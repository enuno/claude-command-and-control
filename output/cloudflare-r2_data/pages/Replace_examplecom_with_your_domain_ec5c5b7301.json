{
  "title": "Replace example.com with your domain",
  "content": "pulumi env set $E --plaintext pulumiConfig.domain example.com\nsh\n  npm install @pulumi/cloudflare\n  sh\n  added 1 package ...\n  sh\n  npm install @pulumi/cloudflare\n  sh\n  added 1 package ...\n  sh\n  echo \"pulumi_cloudflare>=5.38,<6.0.0\" >> requirements.txt\n  source venv/bin/activate\n  pip install -r requirements.txt\n  sh\n  ...Collecting pulumi-cloudflare...\n  sh\n  go get github.com/pulumi/pulumi-cloudflare/sdk/v3/go/cloudflare\n  sh\n  go: downloading github.com/pulumi/pulumi-cloudflare ...\n  xml\n  <dependency>\n      <groupId>com.pulumi</groupId>\n      <artifactId>cloudflare</artifactId>\n      <version>5.38.0</version>\n  </dependency>\n  sh\n  mvn clean install\n  sh\n  ...[INFO] BUILD SUCCESS...\n  sh\n  dotnet add package Pulumi.Cloudflare\n  sh\n  ...\n  info : Adding PackageReference for package 'Pulumi.Cloudflare' into project\n  ...\n  javascript\n  \"use strict\";\n  const pulumi = require(\"@pulumi/pulumi\");\n  const cloudflare = require(\"@pulumi/cloudflare\");\n\nconst config = new pulumi.Config();\n  const accountId = config.require(\"accountId\");\n  const domain = config.require(\"domain\");\n\nconst content = `export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };`;\n\nconst worker = new cloudflare.WorkersScript(\"hello-world-worker\", {\n    accountId: accountId,\n    name: \"hello-world-worker\",\n    content: content,\n    module: true, // ES6 module\n  });\n  typescript\n  import * as pulumi from \"@pulumi/pulumi\";\n  import * as cloudflare from \"@pulumi/cloudflare\";\n\nconst config = new pulumi.Config();\n  const accountId = config.require(\"accountId\");\n  const domain = config.require(\"domain\");\n\nconst content = `export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };`;\n\nconst worker = new cloudflare.WorkersScript(\"hello-world-worker\", {\n    accountId: accountId,\n    name: \"hello-world-worker\",\n    content: content,\n    module: true, // ES6 module\n  });\n  python\n  \"\"\"Pulumi program \"\"\"\n  import pulumi\n  import pulumi_cloudflare as cloudflare\n\nCONFIG = pulumi.Config()\n  ACCOUNT_ID = CONFIG.get(\"accountId\")\n  DOMAIN = CONFIG.require(\"domain\")\n  CONTENT = \"\"\"\n  export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };\n  \"\"\"\n\nworker = cloudflare.WorkersScript(\"hello-world-worker\",\n      account_id=ACCOUNT_ID,\n      name=\"hello-world-worker\",\n      content=CONTENT,\n      module=True  # ES6 module\n  )\n  go\n  package main\n\nimport (\n    \"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n    \"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n    \"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n  )\n\nfunc main() {\n    pulumi.Run(func(ctx *pulumi.Context) error {\n      conf := config.New(ctx, \"\")\n      accountID := conf.Get(\"accountId\")\n      domain := conf.Get(\"domain\")\n      content := `\n      export default {\n        async fetch(request) {\n          const options = { headers: { 'content-type': 'text/plain' } };\n          return new Response(\"Hello World!\", options);\n        },\n      };\n      `\n      worker, err := cloudflare.NewWorkersScript(ctx, \"hello-world-worker\", &cloudflare.WorkersScriptArgs{\n        AccountId: pulumi.String(accountID),\n        Name:      pulumi.String(\"hello-world-worker\"),\n        Content:   pulumi.String(content),\n        Module:    pulumi.Bool(true), // ES6 module\n      })\n      if err != nil {\n        return err\n      }\n\nreturn nil\n    })\n  }\n  java\n  package myproject;\n\nimport com.pulumi.Pulumi;\n  import com.pulumi.cloudflare.WorkersScript;\n  import com.pulumi.cloudflare.WorkersScriptArgs;\n  import com.pulumi.core.Output;\n\npublic class App {\n      public static void main(String[] args) {\n          Pulumi.run(ctx -> {\n              var content = \"\"\"\n                export default {\n                  async fetch(request) {\n                    const options = { headers: { 'content-type': 'text/plain' } };\n                    return new Response(\"Hello World!\", options);\n                  },\n                };\n              \"\"\";\n\nvar accountId = ctx.config().require(\"accountId\");\n              var domain = ctx.config().require(\"domain\");\n              var worker = new WorkersScript(\"hello-world-worker\", WorkersScriptArgs.builder()\n                  .accountId(accountId)\n                  .name(\"hello-world-worker\")\n                  .content(content)\n                  .module(true)\n                  .build());\n\nreturn;\n          });\n      }\n  }\n  csharp\n  using Pulumi;\n  using Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =>\n  {\n      var config = new Config();\n      var accountId = config.Require(\"accountId\");\n      var domain = config.Require(\"domain\");\n      var content = @\"\n              export default {\n                  async fetch(request) {\n                      const options = { headers: { 'content-type': 'text/plain' } };\n                      return new Response(\"\"Hello World!\"\", options);\n                  },\n              };\n          \";\n\nvar worker = new Cloudflare.WorkersScript(\"hello-world-worker\", new()\n      {\n          AccountId = accountId,\n          Name = \"hello-world-worker\",\n          Content = content,\n          Module = true\n      });\n      return;\n  });\n  yaml\n  name: serverless-cloudflare\n  runtime: yaml\n  resources:\n    worker:\n      type: cloudflare:WorkersScript\n      properties:\n        accountId: \"${accountId}\"\n        name: \"hello-world-worker\"\n        content: |\n          export default {\n              async fetch(request) {\n                  const options = { headers: { 'content-type': 'text/plain' } };\n                  return new Response(\"Hello World!\", options);\n              },\n          };\n        module: true\n  javascript\n  const zone = cloudflare.getZone({\n    accountId: accountId,\n    name: domain,\n  });\n\nconst zoneId = zone.then((z) => z.zoneId);\n\nconst route = new cloudflare.WorkersRoute(\"hello-world-route\", {\n    zoneId: zoneId,\n    pattern: \"hello-world.\" + domain,\n    scriptName: worker.name,\n  });\n  typescript\n  const zone = cloudflare.getZone({\n    accountId: accountId,\n    name: domain,\n  });\n\nconst zoneId = zone.then((z) => z.zoneId);\n\nconst route = new cloudflare.WorkersRoute(\"hello-world-route\", {\n    zoneId: zoneId,\n    pattern: \"hello-world.\" + domain,\n    scriptName: worker.name,\n  });\n  python\n  zone = cloudflare.get_zone(account_id=ACCOUNT_ID, name=DOMAIN)\n  zone_id = zone.zone_id\n  route = cloudflare.WorkersRoute(\"hello-world-route\",\n      zone_id=zone_id,\n      pattern=\"hello-world.\" + DOMAIN,\n      script_name=worker.name\n  )\n  go\n  zone, err := cloudflare.LookupZone(ctx, &cloudflare.LookupZoneArgs{\n    AccountId: &accountID,\n    Name:      &domain,\n  }, nil)\n  if err != nil {\n    return err\n  }\n\nroute, err := cloudflare.NewWorkersRoute(ctx, \"hello-world-route\", &cloudflare.WorkersRouteArgs{\n    ZoneId:     pulumi.String(zone.Id),\n    Pattern:    pulumi.String(\"hello-world.\" + domain),\n    ScriptName: worker.Name,\n  })\n  if err != nil {\n    return err\n  }\n  java\n  final var zone = CloudflareFunctions.getZone(GetZoneArgs.builder()\n    .accountId(accountId)\n    .name(domain)\n    .build());\n  var route = new WorkersRoute(\"hello-world-route\", WorkersRouteArgs.builder()\n    .zoneId(zone.applyValue(getZoneResult -> getZoneResult.id()))\n    .pattern(\"hello-world.\" + domain)\n    .scriptName(worker.name())\n    .build());\n  csharp\n  var zone = Output.Create(Cloudflare.GetZone.InvokeAsync(new()\n  {\n      AccountId = accountId,\n      Name = domain,\n  }));\n  var route = new Cloudflare.WorkersRoute(\"hello-world-route\", new()\n  {\n      ZoneId = zone.Apply(z => z.Id),\n      Pattern = \"hello-world.\" + domain,\n      ScriptName = worker.Name,\n  });\n  yaml\n  # new top-level section\n  variables:\n    zone:\n      fn::invoke:\n        function: cloudflare:getZone\n        arguments:\n          accountId: ${accountId}\n          name: ${domain}\n  yaml\n  route:\n    type: cloudflare:WorkersRoute\n    properties:\n      zoneId: ${zone.id}\n      pattern: \"hello-world.${domain}\"\n      scriptName: ${worker.name}\n  javascript\n  const record = new cloudflare.Record(\"hello-world-record\", {\n    name: route.pattern,\n    type: \"A\",\n    content: \"192.0.2.1\",\n    zoneId: zoneId,\n    proxied: true,\n  });\n\nexports.url = pulumi.interpolate`https://${record.hostname}`;\n  typescript\n  const record = new cloudflare.Record(\"hello-world-record\", {\n    name: route.pattern,\n    type: \"A\",\n    content: \"192.0.2.1\",\n    zoneId: zoneId,\n    proxied: true,\n  });\n\nexport const url = pulumi.interpolate`https://${record.hostname}`;\n  python\n  record = cloudflare.Record(\"hello-world-record\",\n      name=route.pattern,\n      type=\"A\",\n      content=\"192.0.2.1\",\n      zone_id=zone_id,\n      proxied=True\n  )\n\nurl = pulumi.Output.concat(\"https://\", record.hostname)\n  pulumi.export('url', url)\n  go\n  record, err := cloudflare.NewRecord(ctx, \"hello-world-record\", &cloudflare.RecordArgs{\n    Name:    route.Pattern,\n    Type:    pulumi.String(\"A\"),\n    Content: pulumi.String(\"192.0.2.1\"),\n    ZoneId:  pulumi.String(zone.Id),\n    Proxied: pulumi.Bool(true),\n  })\n  if err != nil {\n    return err\n  }\n\nctx.Export(\"url\", pulumi.Sprintf(\"https://%s\", record.Hostname))\n  java\n  var record = new Record(\"hello-world-record\", RecordArgs.builder()\n      .name(route.pattern())\n      .type(\"A\")\n      .content(\"192.0.2.1\")\n      .zoneId(zone.applyValue(getZoneResult -> getZoneResult.id()))\n      .proxied(true)\n      .build());\n\nctx.export(\"url\", Output.format(\"https://%s\", record.hostname()));\n  csharp\n  var record = new Cloudflare.Record(\"hello-world-record\", new()\n  {\n      Name = route.Pattern,\n      Type = \"A\",\n      Content = \"192.0.2.1\",\n      ZoneId = zone.Apply(z => z.Id),\n      Proxied = true\n  });\n\nreturn new Dictionary<string, object?>\n  {\n      [\"url\"] = Output.Format($\"https://{record.Hostname}\")\n  };\n  yaml\n    record:\n      type: cloudflare:Record\n      properties:\n        name: ${route.pattern}\n        type: A\n        content: \"192.0.2.1\"\n        zoneId: ${zone.id}\n        proxied: true\n\noutputs:\n    url: \"https://${record.hostname}\"\n  javascript\n  \"use strict\";\n  const pulumi = require(\"@pulumi/pulumi\");\n  const cloudflare = require(\"@pulumi/cloudflare\");\n\nconst config = new pulumi.Config();\n  const accountId = config.require(\"accountId\");\n  const domain = config.require(\"domain\");\n\nconst content = `export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };`;\n\nconst worker = new cloudflare.WorkersScript(\"hello-world-worker\", {\n    accountId: accountId,\n    name: \"hello-world-worker\",\n    content: content,\n    module: true, // ES6 module\n  });\n\nconst zone = cloudflare.getZone({\n    accountId: accountId,\n    name: domain,\n  });\n\nconst zoneId = zone.then((z) => z.zoneId);\n\nconst route = new cloudflare.WorkersRoute(\"hello-world-route\", {\n    zoneId: zoneId,\n    pattern: \"hello-world.\" + domain,\n    scriptName: worker.name,\n  });\n\nconst record = new cloudflare.Record(\"hello-world-record\", {\n    name: route.pattern,\n    type: \"A\",\n    content: \"192.0.2.1\",\n    zoneId: zoneId,\n    proxied: true,\n  });\n\nexports.url = pulumi.interpolate`https://${record.hostname}`;\n  typescript\n  import * as pulumi from \"@pulumi/pulumi\";\n  import * as cloudflare from \"@pulumi/cloudflare\";\n\nconst config = new pulumi.Config();\n  const accountId = config.require(\"accountId\");\n  const domain = config.require(\"domain\");\n\nconst content = `export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };`;\n\nconst worker = new cloudflare.WorkersScript(\"hello-world-worker\", {\n    accountId: accountId,\n    name: \"hello-world-worker\",\n    content: content,\n    module: true, // ES6 module\n  });\n\nconst zone = cloudflare.getZone({\n    accountId: accountId,\n    name: domain,\n  });\n\nconst zoneId = zone.then((z) => z.zoneId);\n\nconst route = new cloudflare.WorkersRoute(\"hello-world-route\", {\n    zoneId: zoneId,\n    pattern: \"hello-world.\" + domain,\n    scriptName: worker.name,\n  });\n\nconst record = new cloudflare.Record(\"hello-world-record\", {\n    name: route.pattern,\n    type: \"A\",\n    content: \"192.0.2.1\",\n    zoneId: zoneId,\n    proxied: true,\n  });\n\nexport const url = pulumi.interpolate`https://${record.hostname}`;\n  python\n  \"\"\"Pulumi program \"\"\"\n  import pulumi\n  import pulumi_cloudflare as cloudflare\n\nCONFIG = pulumi.Config()\n  ACCOUNT_ID = CONFIG.get(\"accountId\")\n  DOMAIN = CONFIG.require(\"domain\")\n  CONTENT = \"\"\"\n  export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };\n  \"\"\"\n\nworker = cloudflare.WorkersScript(\"hello-world-worker\",\n      account_id=ACCOUNT_ID,\n      name=\"hello-world-worker\",\n      content=CONTENT,\n      module=True  # ES6 module\n  )\n\nzone = cloudflare.get_zone(account_id=ACCOUNT_ID, name=DOMAIN)\n  zone_id = zone.zone_id\n  route = cloudflare.WorkersRoute(\"hello-world-route\",\n      zone_id=zone_id,\n      pattern=\"hello-world.\" + DOMAIN,\n      script_name=worker.name\n  )\n\nrecord = cloudflare.Record(\"hello-world-record\",\n      name=route.pattern,\n      type=\"A\",\n      content=\"192.0.2.1\",\n      zone_id=zone_id,\n      proxied=True\n  )\n\nurl = pulumi.Output.concat(\"https://\", record.hostname)\n  pulumi.export('url', url)\n  go\n  package main\n\nimport (\n    \"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n    \"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n    \"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n  )\n\nfunc main() {\n    pulumi.Run(func(ctx *pulumi.Context) error {\n      conf := config.New(ctx, \"\")\n      accountID := conf.Get(\"accountId\")\n      domain := conf.Get(\"domain\")\n      content := `\n      export default {\n        async fetch(request) {\n          const options = { headers: { 'content-type': 'text/plain' } };\n          return new Response(\"Hello World!\", options);\n        },\n      };\n      `\n      worker, err := cloudflare.NewWorkersScript(ctx, \"hello-world-worker\", &cloudflare.WorkersScriptArgs{\n        AccountId: pulumi.String(accountID),\n        Name:      pulumi.String(\"hello-world-worker\"),\n        Content:   pulumi.String(content),\n        Module:    pulumi.Bool(true), // ES6 module\n      })\n      if err != nil {\n        return err\n      }\n      zone, err := cloudflare.LookupZone(ctx, &cloudflare.LookupZoneArgs{\n        AccountId: &accountID,\n        Name:      &domain,\n      }, nil)\n      if err != nil {\n        return err\n      }\n\nroute, err := cloudflare.NewWorkersRoute(ctx, \"hello-world-route\", &cloudflare.WorkersRouteArgs{\n        ZoneId:     pulumi.String(zone.Id),\n        Pattern:    pulumi.String(\"hello-world.\" + domain),\n        ScriptName: worker.Name,\n      })\n      if err != nil {\n        return err\n      }\n\nrecord, err := cloudflare.NewRecord(ctx, \"hello-world-record\", &cloudflare.RecordArgs{\n        Name:    route.Pattern,\n        Type:    pulumi.String(\"A\"),\n        Content: pulumi.String(\"192.0.2.1\"),\n        ZoneId:  pulumi.String(zone.Id),\n        Proxied: pulumi.Bool(true),\n      })\n      if err != nil {\n        return err\n      }\n\nctx.Export(\"url\", pulumi.Sprintf(\"https://%s\", record.Hostname))\n\nreturn nil\n    })\n  }\n  java\n  package myproject;\n\nimport com.pulumi.Pulumi;\n  import com.pulumi.core.Output;\n  import com.pulumi.cloudflare.WorkersScript;\n  import com.pulumi.cloudflare.WorkersScriptArgs;\n  import com.pulumi.cloudflare.CloudflareFunctions;\n  import com.pulumi.cloudflare.inputs.GetZoneArgs;\n  import com.pulumi.cloudflare.WorkersRoute;\n  import com.pulumi.cloudflare.WorkersRouteArgs;\n  import com.pulumi.cloudflare.Record;\n  import com.pulumi.cloudflare.RecordArgs;\n\npublic class App {\n      public static void main(String[] args) {\n          Pulumi.run(ctx -> {\n              var content = \"\"\"\n          export default {\n            async fetch(request) {\n              const options = { headers: { 'content-type': 'text/plain' } };\n              return new Response(\"Hello World!\", options);\n            },\n          };\n        \"\"\";\n\nvar accountId = ctx.config().require(\"accountId\");\n              var domain = ctx.config().require(\"domain\");\n\nvar worker = new WorkersScript(\"hello-world-worker\", WorkersScriptArgs.builder()\n                  .accountId(accountId)\n                  .name(\"hello-world-worker\")\n                  .content(content)\n                  .module(true)\n                  .build());\n              final var zone = CloudflareFunctions.getZone(GetZoneArgs.builder()\n                  .accountId(accountId)\n                  .name(domain)\n                  .build());\n              var route = new WorkersRoute(\"hello-world-route\", WorkersRouteArgs.builder()\n                  .zoneId(zone.applyValue(getZoneResult -> getZoneResult.id()))\n                  .pattern(\"hello-world.\" + domain)\n                  .scriptName(worker.name())\n                  .build());\n              var record = new Record(\"hello-world-record\", RecordArgs.builder()\n                  .name(route.pattern())\n                  .type(\"A\")\n                  .content(\"192.0.2.1\")\n                  .zoneId(zone.applyValue(getZoneResult -> getZoneResult.id()))\n                  .proxied(true)\n                  .build());\n\nctx.export(\"url\", Output.format(\"https://%s\", record.hostname()));\n              return;\n          });\n      }\n  }\n  csharp\n  using System.Collections.Generic;\n  using Pulumi;\n  using Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =>\n  {\n      var config = new Config();\n      var accountId = config.Require(\"accountId\");\n      var domain = config.Require(\"domain\");\n      var content = @\"\n              export default {\n                  async fetch(request) {\n                      const options = { headers: { 'content-type': 'text/plain' } };\n                      return new Response(\"\"Hello World!\"\", options);\n                  },\n              };\n          \";\n\nvar worker = new Cloudflare.WorkersScript(\"hello-world-worker\", new()\n      {\n          AccountId = accountId,\n          Name = \"hello-world-worker\",\n          Content = content,\n          Module = true\n      });\n      var zone = Output.Create(Cloudflare.GetZone.InvokeAsync(new()\n      {\n          AccountId = accountId,\n          Name = domain,\n      }));\n      var route = new Cloudflare.WorkersRoute(\"hello-world-route\", new()\n      {\n          ZoneId = zone.Apply(z => z.Id),\n          Pattern = \"hello-world.\" + domain,\n          ScriptName = worker.Name,\n      });\n\nvar record = new Cloudflare.Record(\"hello-world-record\", new()\n      {\n          Name = route.Pattern,\n          Type = \"A\",\n          Content = \"192.0.2.1\",\n          ZoneId = zone.Apply(z => z.Id),\n          Proxied = true\n      });\n\nreturn new Dictionary<string, object?>\n      {\n          [\"url\"] = Output.Format($\"https://{record.Hostname}\")\n      };\n  });\n  yaml\n  name: serverless-cloudflare\n  runtime: yaml\n  variables:\n    zone:\n      fn::invoke:\n        function: cloudflare:getZone\n        arguments:\n          accountId: ${accountId}\n          name: ${domain}\n\nresources:\n    worker:\n      type: cloudflare:WorkersScript\n      properties:\n        accountId: \"${accountId}\"\n        name: \"hello-world-worker\"\n        content: |\n          export default {\n              async fetch(request) {\n                  const options = { headers: { 'content-type': 'text/plain' } };\n                  return new Response(\"Hello World!\", options);\n              },\n          };\n        module: true\n    route:\n      type: cloudflare:WorkersRoute\n      properties:\n        zoneId: ${zone.id}\n        pattern: \"hello-world.${domain}\"\n        scriptName: ${worker.name}\n    record:\n      type: cloudflare:Record\n      properties:\n        name: ${route.pattern}\n        type: A\n        content: \"192.0.2.1\"\n        zoneId: ${zone.id}\n        proxied: true\n\noutputs:\n    url: \"https://${record.hostname}\"\n  sh\npulumi up --yes\nsh\nwait for the dev stack to become ready\nsh\ncurl $(pulumi stack output url)\nsh\nHello, World!\nsh\npulumi destroy\nsh\npulumi stack rm dev\nsh\nesc login\nsh\nLogged in to pulumi.com as  ....\nsh\nESC_ENV=wrangler/my-dev-environment\nesc env init $ESC_ENV\nsh\nEnvironment created.\nsh\nesc env set $ESC_ENV environmentVariables.CLOUDFLARE_ACCOUNT_ID 123abc\nesc env set $ESC_ENV environmentVariables.CLOUDFLARE_API_TOKEN  123abc --secret\nsh\nnpx wrangler logout\nsh\nNot logged in, exiting...\nsh\nesc run ${ESC_ENV} npx wrangler whoami\nsh\nGetting User settings...\nðŸ‘‹ You are logged in with an API Token.\nsh\nesc env set ${ESC_ENV} environementVariables.TOP_SECRET \"aliens are real\" --secret\nsh\nesc run -i ${ESC_ENV} -- sh -c 'echo \"$TOP_SECRET\" | npx wrangler secret put TOP_SECRET'\nsh\nE=wrangler/my-devvars\nesc env init $E\nsh\nEnvironment created.\nsh\nesc env set $E environmentVariables.TOP_SECRET  \"the moon is made of cheese\" --secret\nsh\nesc env open ${E} --format dotenv > .dev.vars\njs\n  export default {\n    async queue(batch, env, ctx) {\n      for (const msg of batch.messages) {\n        // TODO: do something with the message\n        // Explicitly acknowledge the message as delivered\n        msg.ack();\n      }\n    },\n  };\n  ts\n  export default {\n    async queue(batch: MessageBatch, env: Env, ctx: ExecutionContext) {\n      for (const msg of batch.messages) {\n        // TODO: do something with the message\n        // Explicitly acknowledge the message as delivered\n        msg.ack();\n      }\n    },\n  };\n  python\n  from workers import WorkerEntrypoint\n\nclass Default(WorkerEntrypoint):\n      async def queue(self, batch):\n          for msg in batch.messages:\n              # TODO: do something with the message\n              # Explicitly acknowledge the message as delivered\n              msg.ack()\n  js\n  export default {\n    async queue(batch, env, ctx) {\n      for (const msg of batch.messages) {\n        // TODO: do something with the message that fails\n        msg.retry();\n      }\n    },\n  };\n  ts\n  export default {\n    async queue(batch: MessageBatch, env: Env, ctx: ExecutionContext) {\n      for (const msg of batch.messages) {\n        // TODO: do something with the message that fails\n        msg.retry();\n      }\n    },\n  };\n  python\n  from workers import WorkerEntrypoint\n\nclass Default(WorkerEntrypoint):\n      async def queue(self, batch):\n          for msg in batch.messages:\n              # TODO: do something with the message that fails\n              msg.retry()\n  js\n  // Delay a singular message by 600 seconds (10 minutes)\n  await env.YOUR_QUEUE.send(message, { delaySeconds: 600 });\n\n// Delay a batch of messages by 300 seconds (5 minutes)\n  await env.YOUR_QUEUE.sendBatch(messages, { delaySeconds: 300 });\n\n// Do not delay this message.\n  // If there is a global delay configured on the queue, ignore it.\n  await env.YOUR_QUEUE.sendBatch(messages, { delaySeconds: 0 });\n  ts\n  // Delay a singular message by 600 seconds (10 minutes)\n  await env.YOUR_QUEUE.send(message, { delaySeconds: 600 });\n\n// Delay a batch of messages by 300 seconds (5 minutes)\n  await env.YOUR_QUEUE.sendBatch(messages, { delaySeconds: 300 });\n\n// Do not delay this message.\n  // If there is a global delay configured on the queue, ignore it.\n  await env.YOUR_QUEUE.sendBatch(messages, { delaySeconds: 0 });\n  python\n  # Delay a singular message by 600 seconds (10 minutes)\n  await env.YOUR_QUEUE.send(message, delaySeconds=600)\n\n# Delay a batch of messages by 300 seconds (5 minutes)\n  await env.YOUR_QUEUE.sendBatch(messages, delaySeconds=300)\n\n# Do not delay this message.\n  # If there is a global delay configured on the queue, ignore it.\n  await env.YOUR_QUEUE.sendBatch(messages, delaySeconds=0)\n  sh",
  "code_samples": [
    {
      "code": "### f. Install the Cloudflare package\n\nYou need to install the Cloudflare package for your language of choice in order to define Cloudflare resources in your Pulumi program.\n\nInstall the Cloudflare package by running the following command:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* go",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* Java\n\n  Below are Apache Maven instructions. For other Java project managers such as Gradle, see the official [Maven repository](https://central.sonatype.com/artifact/com.pulumi/cloudflare/overview)\n\n  1. Open your `pom.xml` file.\n  2. Add the Pulumi Cloudflare dependency inside the `<dependencies>` section.",
      "language": "unknown"
    },
    {
      "code": "1. Run:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* .NET",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* YAML\n\n  There are no dependencies to download for YAML. Skip ahead.\n\n## 2. Define Cloudflare resources in code\n\nWith the Cloudflare package installed, you can now define any [supported Cloudflare resource](https://www.pulumi.com/registry/packages/cloudflare/) in your Pulumi program. Next, define a Worker, a Route, and a DNS Record.\n\n### a. Add a Workers script\n\nThe [Workers Script resource](https://www.pulumi.com/registry/packages/cloudflare/api-docs/workersscript/) represents a Cloudflare Worker that can be deployed to the Cloudflare network.\n\nReplace the contents of your entrypoint file with the following:\n\n* JavaScript\n\n  **Filename: `index.js`**",
      "language": "unknown"
    },
    {
      "code": "* TypeScript\n\n  **Filename: `index.ts`**",
      "language": "unknown"
    },
    {
      "code": "* Python\n\n  **Filename: `__main__.py`**",
      "language": "unknown"
    },
    {
      "code": "* go\n\n  **Filename: `main.go`**",
      "language": "unknown"
    },
    {
      "code": "* Java\n\n  **Filename: `src/main/java/myproject/App.java`**",
      "language": "unknown"
    },
    {
      "code": "* .NET\n\n  **Filename: `Program.cs`**",
      "language": "unknown"
    },
    {
      "code": "* YAML\n\n  **Filename: `Pulumi.yaml`**",
      "language": "unknown"
    },
    {
      "code": "### b. Add a Route\n\nYou will now add a [Workers Route resource](https://www.pulumi.com/registry/packages/cloudflare/api-docs/workersroute/) to your Pulumi program so the Workers script can have an endpoint and be active. To properly configure the Route, you will also look up the zone ID for your domain.\n\nAdd the following code snippet to your entrypoint file **after** the Worker script resource:\n\n* JavaScript\n\n  **Filename: `index.js`**",
      "language": "unknown"
    },
    {
      "code": "* TypeScript\n\n  **Filename: `index.ts`**",
      "language": "unknown"
    },
    {
      "code": "* Python\n\n  **Filename: `__main__.py`**",
      "language": "unknown"
    },
    {
      "code": "* go\n\n  **Filename: `main.go`**",
      "language": "unknown"
    },
    {
      "code": "* Java\n\n  **Filename: `src/main/java/myproject/App.java`**",
      "language": "unknown"
    },
    {
      "code": "* .NET\n\n  **Filename: `Program.cs`**",
      "language": "unknown"
    },
    {
      "code": "* YAML\n\n  **Filename: `Pulumi.yaml`**\n\n  Below the `runtime` key, add the following code:",
      "language": "unknown"
    },
    {
      "code": "Below the `worker` resource, add the following code:",
      "language": "unknown"
    },
    {
      "code": "### c. Add a DNS Record\n\nYou will now add a DNS [Record resource](https://www.pulumi.com/registry/packages/cloudflare/api-docs/record/) to resolve the previously configured Route. In the next step, you'll also output the Route URL so it can be easily accessed.\n\nAdd the following code snippet to your entrypoint file **after** the Route resource:\n\n* JavaScript\n\n  **Filename: `index.js`**",
      "language": "unknown"
    },
    {
      "code": "* TypeScript\n\n  **Filename: `index.ts`**",
      "language": "unknown"
    },
    {
      "code": "* Python\n\n  **Filename: `__main__.py`**",
      "language": "unknown"
    },
    {
      "code": "* go\n\n  **Filename: `main.go`**",
      "language": "unknown"
    },
    {
      "code": "* Java\n\n  **Filename: `src/main/java/myproject/App.java`**",
      "language": "unknown"
    },
    {
      "code": "* .NET\n\n  **Filename: `Program.cs`**\n\n  Notice the updated ' return ' statement because you're now exporting a value. Ensure that you also include `using System.Collections.Generic;` in your imports.",
      "language": "unknown"
    },
    {
      "code": "* YAML\n\n  Notice the new top-level `outputs` section.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nYou may need to use `http` instead depending on your domain settings.\n\n### d. (Optional) Verify your code\n\nConfirm all your changes match the full solution below:\n\n* JavaScript\n\n  **Filename: `index.js`**",
      "language": "unknown"
    },
    {
      "code": "* TypeScript\n\n  **Filename: `index.ts`**",
      "language": "unknown"
    },
    {
      "code": "* Python\n\n  **Filename: `__main__.py`**",
      "language": "unknown"
    },
    {
      "code": "* go\n\n  **Filename: `main.go`**",
      "language": "unknown"
    },
    {
      "code": "* Java\n\n  **Filename: `src/main/java/myproject/App.java`**",
      "language": "unknown"
    },
    {
      "code": "* .NET\n\n  **Filename: `Program.cs`**",
      "language": "unknown"
    },
    {
      "code": "* YAML\n\n  **Filename: `Pulumi.yaml`**",
      "language": "unknown"
    },
    {
      "code": "## 3. Deploy your application\n\nNow that you have defined all the Cloudflare resources, you can deploy the Hello World application to your Cloudflare account using the Pulumi CLI.\n\nTo deploy the changes, run:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## 4. Test the Worker\n\nYou incrementally added Cloudflare resources to run and access your Hello World application. You can test your application by curling the `url` output from the Pulumi stack.",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## 5. Clean up\n\nIn this last step, you will clean up the resources and stack used throughout the tutorial.\n\n### a. Delete the Cloudflare resources",
      "language": "unknown"
    },
    {
      "code": "### b. Remove the Pulumi stack",
      "language": "unknown"
    },
    {
      "code": "## Next steps\n\nVisit the [Cloudflare package documentation](https://www.pulumi.com/docs/reference/pkg/cloudflare/) to explore other resources you can define with Pulumi and Cloudflare.\n\n</page>\n\n<page>\n---\ntitle: Manage secrets with Pulumi ESC Â· Pulumi docs\ndescription: Pulumi ESC (Environments, Secrets, and Configuration) is a secure\n  and robust secrets management solution. The tutorial will walk you through how\n  to develop with Wrangler while following security best practices.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/pulumi/tutorial/manage-secrets/\n  md: https://developers.cloudflare.com/pulumi/tutorial/manage-secrets/index.md\n---\n\nIn this tutorial, you will receive step-by-step instructions on using Pulumi ESC (Environments, Secrets, and Configuration), which is a secure and robust secrets management solution.\n\nThe tutorial will walk you through how to develop with Wrangler while following security best practices.\n\nSpecifically, you will learn how to manage your `CLOUDFLARE_API_TOKEN` for logging in to your Cloudflare account, pass ESC-stored secrets to Workers, and programmatically load your `.dev.vars` file.\n\nNote\n\nYou will provision resources that qualify under free tier offerings for both Pulumi Cloud and Cloudflare.\n\n## Before you begin\n\nEnsure you have:\n\n* A Cloudflare account. [Sign up for a Cloudflare account](https://www.cloudflare.com/sign-up).\n* A Pulumi Cloud account. [Sign up for a Pulumi Cloud](https://app.pulumi.com/signup).\n* The [Pulumi ESC CLI](https://www.pulumi.com/docs/install/esc/) installed.\n* A Wrangler project. To create one, follow the [Create a New Worker project step](https://developers.cloudflare.com/workers/get-started/guide/#1-create-a-new-worker-project).\n\n## 1. Set up a new Environment\n\nA [Pulumi ESC Environment](https://www.pulumi.com/docs/esc/environments/), or Environment, is a YAML file containing configurations and secrets for your application and infrastructure. These can be accessed in several ways, including shell commands. All ESC Environments reside in your Pulumi Cloud account.\n\n### a. Log in to Pulumi Cloud\n\nUse the Pulumi ESC CLI to log into your Pulumi Cloud account.",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### b. Create a new Environment\n\nNote\n\nEnvironment names must be unique within a Pulumi organization and may only contain alphanumeric characters, hyphens, underscores, and periods.",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## 2. Log into Cloudflare\n\nNow that the Pulumi ESC Environment has been created, it can be consumed in various ways. For instance, to log into your Cloudflare account without needing to predefine credentials in your shell.\n\n### a. Add your credentials\n\nBy externally and securely storing your `CLOUDFLARE_API_TOKEN`, you can control access and rotate the token value. We will run `wrangler` in non-interactive mode, which requires:\n\n* Your Cloudflare [account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids/)\n* A valid Cloudflare API [token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/)\n\nReplace the placeholder `123abc` with your corresponding values:",
      "language": "unknown"
    },
    {
      "code": "Note\n\nThe API token is declared as a `secret`. Once the Environment is saved, Pulumi will encrypt its value and replace it with ciphertext.\n\n### b. Log out\n\nEnsure you're not currently logged in to your Cloudflare account.",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### c. Log in\n\nPass ESC-stored Cloudflare credentials to Wrangler.",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "When you use the `esc run` command, it opens the Environment and sets the specified Environment variables into a temporary environment. After that, it uses those variables in the context of the `wrangler` command. This is especially helpful when running `wrangler` commands in a CI/CD environment but wanting to avoid storing credentials directly in your pipeline.\n\n## 3. Add Worker secrets\n\nPulumi ESC centralizes secrets, and Wrangler can be used to pass them on to Workers and other Cloudflare resources. You will use the `wrangler secret put` command for this purpose.\n\n### a. Add a secret",
      "language": "unknown"
    },
    {
      "code": "### b. Pass the secret to your Worker",
      "language": "unknown"
    },
    {
      "code": "By using an external secrets management solution, commonly used Worker secrets can be stored in a single shared Environment that is accessed by the relevant Workers. You can use shell commands with `esc` to incorporate scripting and integrate them into deployment pipelines or `make` commands. Use `esc [command] --help` for more information about the various commands available in the CLI.\n\n## 4. Load `.dev.vars`\n\nIn this step, you will configure an Environment to load your `.dev.vars` file programmatically.\n\nNote\n\nThe `.dev.vars` file is located in the root of your Wrangler project to define secrets used when running `wrangler dev`. For more information, refer to [Local Development with Secrets](https://developers.cloudflare.com/workers/configuration/secrets/#local-development-with-secrets).\n\nWith a dedicated ESC Environment to store all the `.dev.vars` secrets, you can use a `dotenv` export flag.\n\n### a. Create an Environment",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### b. Add a secret",
      "language": "unknown"
    },
    {
      "code": "### c. Generate the `.dev.vars` file",
      "language": "unknown"
    },
    {
      "code": "As `.dev.vars` files may often contain secrets, they should not be committed to source control. Keeping these secrets externally ensures you can load them to a new development environment without any loss.\n\n## Next steps\n\nYou have configured Pulumi ESC Environments to load secrets for Wrangler commands, enhancing security during development with Wrangler. The externalized secrets are now reusable across Workers. [Learn more about Pulumi ESC features and integrations](https://www.pulumi.com/docs/esc/) or follow the [Deploy a Worker with Pulumi](https://developers.cloudflare.com/pulumi/tutorial/hello-world/) tutorial.\n\n</page>\n\n<page>\n---\ntitle: Batching, Retries and Delays Â· Cloudflare Queues docs\ndescription: When configuring a consumer Worker for a queue, you can also define\n  how messages are batched as they are delivered.\nlastUpdated: 2025-12-09T12:49:27.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/batching-retries/\n  md: https://developers.cloudflare.com/queues/configuration/batching-retries/index.md\n---\n\n## Batching\n\nWhen configuring a [consumer Worker](https://developers.cloudflare.com/queues/reference/how-queues-works#consumers) for a queue, you can also define how messages are batched as they are delivered.\n\nBatching can:\n\n1. Reduce the total number of times your consumer Worker needs to be invoked (which can reduce costs).\n2. Allow you to batch messages when writing to an external API or service (reducing writes).\n3. Disperse load over time, especially if your producer Workers are associated with user-facing activity.\n\nThere are two ways to configure how messages are batched. You configure batching when connecting your consumer Worker to a queue.\n\n* `max_batch_size` - The maximum size of a batch delivered to a consumer (defaults to 10 messages).\n* `max_batch_timeout` - the *maximum* amount of time the queue will wait before delivering a batch to a consumer (defaults to 5 seconds)\n\nBatch size configuration\n\nBoth `max_batch_size` and `max_batch_timeout` work together. Whichever limit is reached first will trigger the delivery of a batch.\n\nFor example, a `max_batch_size = 30` and a `max_batch_timeout = 10` means that if 30 messages are written to the queue, the consumer will receive a batch of 30 messages. However, if it takes longer than 10 seconds for those 30 messages to be written to the queue, then the consumer will get a batch of messages that contains however many messages were on the queue at the time (somewhere between 1 and 29, in this case).\n\nEmpty queues\n\nWhen a queue is empty, a push-based (Worker) consumer's `queue` handler will not be invoked until there are messages to deliver. A queue does not attempt to push empty batches to a consumer and thus does not invoke unnecessary reads.\n\n[Pull-based consumers](https://developers.cloudflare.com/queues/configuration/pull-consumers/) that attempt to pull from a queue, even when empty, will incur a read operation.\n\nWhen determining what size and timeout settings to configure, you will want to consider latency (how long can you wait to receive messages?), overall batch size (when writing to external systems), and cost (fewer-but-larger batches).\n\n### Batch settings\n\nThe following batch-level settings can be configured to adjust how Queues delivers batches to your configured consumer.\n\n## Explicit acknowledgement and retries\n\nYou can acknowledge individual messages within a batch by explicitly acknowledging each message as it is processed. Messages that are explicitly acknowledged will not be re-delivered, even if your queue consumer fails on a subsequent message and/or fails to return successfully when processing a batch.\n\n* Each message can be acknowledged as you process it within a batch, and avoids the entire batch from being re-delivered if your consumer throws an error during batch processing.\n* Acknowledging individual messages is useful when you are calling external APIs, writing messages to a database, or otherwise performing non-idempotent (state changing) actions on individual messages.\n\nTo explicitly acknowledge a message as delivered, call the `ack()` method on the message.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "You can also call `retry()` to explicitly force a message to be redelivered in a subsequent batch. This is referred to as \"negative acknowledgement\". This can be particularly useful when you want to process the rest of the messages in that batch without throwing an error that would force the entire batch to be redelivered.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "You can also acknowledge or negatively acknowledge messages at a batch level with `ackAll()` and `retryAll()`. Calling `ackAll()` on the batch of messages (`MessageBatch`) delivered to your consumer Worker has the same behaviour as a consumer Worker that successfully returns (does not throw an error).\n\nNote that calls to `ack()`, `retry()` and their `ackAll()` / `retryAll()` equivalents follow the below precedence rules:\n\n* If you call `ack()` on a message, subsequent calls to `ack()` or `retry()` are silently ignored.\n* If you call `retry()` on a message and then call `ack()`: the `ack()` is ignored. The first method call wins in all cases.\n* If you call either `ack()` or `retry()` on a single message, and then either/any of `ackAll()` or `retryAll()` on the batch, the call on the single message takes precedence. That is, the batch-level call does not apply to that message (or messages, if multiple calls were made).\n\n## Delivery failure\n\nWhen a message is failed to be delivered, the default behaviour is to retry delivery three times before marking the delivery as failed. You can set `max_retries` (defaults to 3) when configuring your consumer, but in most cases we recommend leaving this as the default.\n\nMessages that reach the configured maximum retries will be deleted from the queue, or if a [dead-letter queue](https://developers.cloudflare.com/queues/configuration/dead-letter-queues/) (DLQ) is configured, written to the DLQ instead.\n\nNote\n\nEach retry counts as an additional read operation per [Queues pricing](https://developers.cloudflare.com/queues/platform/pricing/).\n\nWhen a single message within a batch fails to be delivered, the entire batch is retried, unless you have [explicitly acknowledged](#explicit-acknowledgement-and-retries) a message (or messages) within that batch. For example, if a batch of 10 messages is delivered, but the 8th message fails to be delivered, all 10 messages will be retried and thus redelivered to your consumer in full.\n\nRetried messages and consumer concurrency\n\nRetrying messages with `retry()` or calling `retryAll()` on a batch will **not** cause the consumer to autoscale down if consumer concurrency is enabled. Refer to [Consumer concurrency](https://developers.cloudflare.com/queues/configuration/consumer-concurrency/) to learn more.\n\n## Delay messages\n\nWhen publishing messages to a queue, or when [marking a message or batch for retry](#explicit-acknowledgement-and-retries), you can choose to delay messages from being processed for a period of time.\n\nDelaying messages allows you to defer tasks until later, and/or respond to backpressure when consuming from a queue. For example, if an upstream API you are calling to returns a `HTTP 429: Too Many Requests`, you can delay messages to slow down how quickly you are consuming them before they are re-processed.\n\nMessages can be delayed by up to 12 hours.\n\nNote\n\nConfiguring delivery and retry delays via the `wrangler` CLI or when [developing locally](https://developers.cloudflare.com/queues/configuration/local-development/) requires `wrangler` version `3.38.0` or greater. Use `npx wrangler@latest` to always use the latest version of `wrangler`.\n\n### Delay on send\n\nTo delay a message or batch of messages when sending to a queue, you can provide a `delaySeconds` parameter when sending a message.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "You can also configure a default, global delay on a per-queue basis by passing `--delivery-delay-secs` when creating a queue via the `wrangler` CLI:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h3",
      "text": "f. Install the Cloudflare package",
      "id": "f.-install-the-cloudflare-package"
    },
    {
      "level": "h2",
      "text": "2. Define Cloudflare resources in code",
      "id": "2.-define-cloudflare-resources-in-code"
    },
    {
      "level": "h3",
      "text": "a. Add a Workers script",
      "id": "a.-add-a-workers-script"
    },
    {
      "level": "h3",
      "text": "b. Add a Route",
      "id": "b.-add-a-route"
    },
    {
      "level": "h3",
      "text": "c. Add a DNS Record",
      "id": "c.-add-a-dns-record"
    },
    {
      "level": "h3",
      "text": "d. (Optional) Verify your code",
      "id": "d.-(optional)-verify-your-code"
    },
    {
      "level": "h2",
      "text": "3. Deploy your application",
      "id": "3.-deploy-your-application"
    },
    {
      "level": "h2",
      "text": "4. Test the Worker",
      "id": "4.-test-the-worker"
    },
    {
      "level": "h2",
      "text": "5. Clean up",
      "id": "5.-clean-up"
    },
    {
      "level": "h3",
      "text": "a. Delete the Cloudflare resources",
      "id": "a.-delete-the-cloudflare-resources"
    },
    {
      "level": "h3",
      "text": "b. Remove the Pulumi stack",
      "id": "b.-remove-the-pulumi-stack"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Before you begin",
      "id": "before-you-begin"
    },
    {
      "level": "h2",
      "text": "1. Set up a new Environment",
      "id": "1.-set-up-a-new-environment"
    },
    {
      "level": "h3",
      "text": "a. Log in to Pulumi Cloud",
      "id": "a.-log-in-to-pulumi-cloud"
    },
    {
      "level": "h3",
      "text": "b. Create a new Environment",
      "id": "b.-create-a-new-environment"
    },
    {
      "level": "h2",
      "text": "2. Log into Cloudflare",
      "id": "2.-log-into-cloudflare"
    },
    {
      "level": "h3",
      "text": "a. Add your credentials",
      "id": "a.-add-your-credentials"
    },
    {
      "level": "h3",
      "text": "b. Log out",
      "id": "b.-log-out"
    },
    {
      "level": "h3",
      "text": "c. Log in",
      "id": "c.-log-in"
    },
    {
      "level": "h2",
      "text": "3. Add Worker secrets",
      "id": "3.-add-worker-secrets"
    },
    {
      "level": "h3",
      "text": "a. Add a secret",
      "id": "a.-add-a-secret"
    },
    {
      "level": "h3",
      "text": "b. Pass the secret to your Worker",
      "id": "b.-pass-the-secret-to-your-worker"
    },
    {
      "level": "h2",
      "text": "4. Load `.dev.vars`",
      "id": "4.-load-`.dev.vars`"
    },
    {
      "level": "h3",
      "text": "a. Create an Environment",
      "id": "a.-create-an-environment"
    },
    {
      "level": "h3",
      "text": "b. Add a secret",
      "id": "b.-add-a-secret"
    },
    {
      "level": "h3",
      "text": "c. Generate the `.dev.vars` file",
      "id": "c.-generate-the-`.dev.vars`-file"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Batching",
      "id": "batching"
    },
    {
      "level": "h3",
      "text": "Batch settings",
      "id": "batch-settings"
    },
    {
      "level": "h2",
      "text": "Explicit acknowledgement and retries",
      "id": "explicit-acknowledgement-and-retries"
    },
    {
      "level": "h2",
      "text": "Delivery failure",
      "id": "delivery-failure"
    },
    {
      "level": "h2",
      "text": "Delay messages",
      "id": "delay-messages"
    },
    {
      "level": "h3",
      "text": "Delay on send",
      "id": "delay-on-send"
    }
  ],
  "url": "llms-txt#replace-example.com-with-your-domain",
  "links": []
}