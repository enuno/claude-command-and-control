{
  "title": "Create a readonly token",
  "content": "npm token create --read-only\n#-> Enter password, if prompted\n#-> Enter 2FA code, if configured\nini\n@foobar:registry=https://npm.pkg.github.com\n//registry.npmjs.org/:_authToken=${TOKEN_FOR_NPM}\n//npm.pkg.github.com/:_authToken=${TOKEN_FOR_GITHUB}\nsh\ncloudflared --version\nsh\ncloudflared version 2021.5.9 (built 2021-05-21-1541 UTC)\nsh\ncloudflared tunnel --url http://localhost:5173\nsh\n2021-07-15T20:11:29Z INF Cannot determine default configuration path. No file [config.yml config.yaml] in [~/.cloudflared ~/.cloudflare-warp ~/cloudflare-warp /etc/cloudflared /usr/local/etc/cloudflared]\n2021-07-15T20:11:29Z INF Version 2021.5.9\n2021-07-15T20:11:29Z INF GOOS: linux, GOVersion: devel +11087322f8 Fri Nov 13 03:04:52 2020 +0100, GoArch: amd64\n2021-07-15T20:11:29Z INF Settings: map[url:http://localhost:5173]\n2021-07-15T20:11:29Z INF cloudflared will not automatically update when run from the shell. To enable auto-updates, run cloudflared as a service: https://developers.cloudflare.com/argo-tunnel/reference/service/\n2021-07-15T20:11:29Z INF Initial protocol h2mux\n2021-07-15T20:11:29Z INF Starting metrics server on 127.0.0.1:42527/metrics\n2021-07-15T20:11:29Z WRN Your version 2021.5.9 is outdated. We recommend upgrading it to 2021.7.0\n2021-07-15T20:11:29Z INF Connection established connIndex=0 location=ATL\n2021-07-15T20:11:32Z INF Each HA connection's tunnel IDs: map[0:cx0nsiqs81fhrfb82pcq075kgs6cybr86v9vdv8vbcgu91y2nthg]\n2021-07-15T20:11:32Z INF +-------------------------------------------------------------+\n2021-07-15T20:11:32Z INF |  Your free tunnel has started! Visit it:                    |\n2021-07-15T20:11:32Z INF |    https://seasonal-deck-organisms-sf.trycloudflare.com     |\n2021-07-15T20:11:32Z INF +-------------------------------------------------------------+\njs\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n\nif (url.pathname === \"/submit\") {\n      return submitHandler(request, env);\n    }\n\nreturn fetch(request.url);\n  },\n};\n\nasync function submitHandler(request, env) {\n  if (request.method !== \"POST\") {\n    return new Response(\"Method not allowed\", {\n      status: 405,\n    });\n  }\n  const body = await request.formData();\n\nconst { first_name, last_name, email, phone, subject, message } =\n    Object.fromEntries(body);\n\nconst reqBody = {\n    fields: {\n      \"First Name\": first_name,\n      \"Last Name\": last_name,\n      Email: email,\n      \"Phone number\": phone,\n      Subject: subject,\n      Message: message,\n    },\n  };\n\nreturn HandleAirtableData(reqBody, env);\n}\n\nconst HandleAirtableData = (body, env) => {\n  return fetch(\n    `https://api.airtable.com/v0/${env.AIRTABLE_BASE_ID}/${encodeURIComponent(\n      env.AIRTABLE_TABLE_NAME,\n    )}`,\n    {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: {\n        Authorization: `Bearer ${env.AIRTABLE_API_KEY}`,\n        \"Content-type\": `application/json`,\n      },\n    },\n  );\n};\njs\nexport async function onRequestPost(context) {\n  return await submitHandler(context);\n}\njs\nexport async function onRequestPost(context) {\n  return await submitHandler(context);\n}\n\nasync function submitHandler(context) {\n  const body = await context.request.formData();\n\nconst { first_name, last_name, email, phone, subject, message } =\n    Object.fromEntries(body);\n\nconst reqBody = {\n    fields: {\n      \"First Name\": first_name,\n      \"Last Name\": last_name,\n      Email: email,\n      \"Phone number\": phone,\n      Subject: subject,\n      Message: message,\n    },\n  };\n\nreturn HandleAirtableData({ body: reqBody, env: env });\n}\njs\n// ..\nconst HandleAirtableData = async function onRequest({ body, env }) {\n  return fetch(\n    `https://api.airtable.com/v0/${env.AIRTABLE_BASE_ID}/${encodeURIComponent(\n      env.AIRTABLE_TABLE_NAME,\n    )}`,\n    {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: {\n        Authorization: `Bearer ${env.AIRTABLE_API_KEY}`,\n        \"Content-type\": `application/json`,\n      },\n    },\n  );\n};\nsh",
  "code_samples": [
    {
      "code": "This will produce a read-only token that looks like a UUID string. Save this value for a later step.\n\n## Private modules on the npm registry\n\nThe following section applies to users with applications that are only using private modules from the npm registry.\n\nIn your Pages project's **Settings** > **Environment variables**, add a new [environment variable](https://developers.cloudflare.com/pages/configuration/build-configuration/#environment-variables) named `NPM_TOKEN` to the **Production** and **Preview** environments and paste the [read-only token you created](#registry-access-token) as its value.\n\nWarning\n\nAdd the `NPM_TOKEN` variable to both the **Production** and **Preview** environments.\n\nBy default, `npm` looks for an environment variable named `NPM_TOKEN` and because you did not define a [custom registry endpoint](#custom-registry-endpoints), the npm registry is assumed. Local development should continue to work as expected, provided that you and your teammates are authenticated with npm accounts (see `npm whoami` and `npm login`) that have been granted access to the private package(s).\n\n## Custom registry endpoints\n\nWhen multiple registries are in use, a project will need to define its own root-level [`.npmrc`](https://docs.npmjs.com/cli/v7/configuring-npm/npmrc) configuration file. An example `.npmrc` file may look like this:",
      "language": "unknown"
    },
    {
      "code": "Here, all packages under the `@foobar` scope are directed towards the GitHub Packages registry. Then the registries are assigned their own access tokens via their respective environment variable names.\n\nNote\n\nYou only need to define an Access Token for the npm registry (refer to `TOKEN_FOR_NPM` in the example) if it is hosting private packages that your application requires.\n\nYour Pages project must then have the matching [environment variables](https://developers.cloudflare.com/pages/configuration/build-configuration/#environment-variables) defined for all environments. In our example, that means `TOKEN_FOR_NPM` must contain [the read-only npm token](#registry-access-token) value and `TOKEN_FOR_GITHUB` must contain its own [personal access token](https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token#creating-a-token).\n\n### Managing multiple environments\n\nIn the event that your local development no longer works with your new `.npmrc` file, you will need to add some additional changes:\n\n1. Rename the Pages-compliant `.npmrc` file to `.npmrc.pages`. This should be referencing environment variables.\n\n2. Restore your previous `.npmrc` file – the version that was previously working for you and your teammates.\n\n3. Go to **Workers & Pages** in the Cloudflare dashboard.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n4. Select your Pages project.\n\n5. Go to **Settings** > **Environment variables**, add a new [environment variable](https://developers.cloudflare.com/pages/configuration/build-configuration/#environment-variables) named [`NPM_CONFIG_USERCONFIG`](https://docs.npmjs.com/cli/v6/using-npm/config#npmrc-files) and set its value to `/opt/buildhome/repo/.npmrc.pages`. If your `.npmrc.pages` file is not in your project's root directory, adjust this path accordingly.\n\n</page>\n\n<page>\n---\ntitle: Preview Local Projects with Cloudflare Tunnel · Cloudflare Pages docs\ndescription: Cloudflare Tunnel runs a lightweight daemon (cloudflared) in your\n  infrastructure that establishes outbound connections (Tunnels) between your\n  origin web server and the Cloudflare global network. In practical terms, you\n  can use Cloudflare Tunnel to allow remote access to services running on your\n  local machine. It is an alternative to popular tools like Ngrok, and provides\n  free, long-running tunnels via the TryCloudflare service.\nlastUpdated: 2025-10-23T20:06:36.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/pages/how-to/preview-with-cloudflare-tunnel/\n  md: https://developers.cloudflare.com/pages/how-to/preview-with-cloudflare-tunnel/index.md\n---\n\n[Cloudflare Tunnel](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/) runs a lightweight daemon (`cloudflared`) in your infrastructure that establishes outbound connections (Tunnels) between your origin web server and the Cloudflare global network. In practical terms, you can use Cloudflare Tunnel to allow remote access to services running on your local machine. It is an alternative to popular tools like [Ngrok](https://ngrok.com), and provides free, long-running tunnels via the [TryCloudflare](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/do-more-with-tunnels/trycloudflare/) service.\n\nWhile Cloudflare Pages provides unique [deploy preview URLs](https://developers.cloudflare.com/pages/configuration/preview-deployments/) for new branches and commits on your projects, Cloudflare Tunnel can be used to provide access to locally running applications and servers during the development process. In this guide, you will install Cloudflare Tunnel, and create a new tunnel to provide access to a locally running application. You will need a Cloudflare account to begin using Cloudflare Tunnel.\n\n## Installing Cloudflare Tunnel\n\nCloudflare Tunnel can be installed on Windows, Linux, and macOS. To learn about installing Cloudflare Tunnel, refer to the [Install cloudflared](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/downloads/) page in the Cloudflare for Teams documentation.\n\nConfirm that `cloudflared` is installed correctly by running `cloudflared --version` in your command line:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## Run a local service\n\nThe easiest way to get up and running with Cloudflare Tunnel is to have an application running locally, such as a [React](https://developers.cloudflare.com/pages/framework-guides/deploy-a-react-site/) or [SvelteKit](https://developers.cloudflare.com/pages/framework-guides/deploy-a-svelte-kit-site/) site. When you are developing an application with these frameworks, they will often make use of a `npm run develop` script, or something similar, which mounts the application and runs it on a `localhost` port. For example, the popular `vite` tool runs your in-development React application on port `5173`, making it accessible at the `http://localhost:5173` address.\n\n## Start a Cloudflare Tunnel\n\nWith a local development server running, a new Cloudflare Tunnel can be instantiated by running `cloudflared tunnel` in a new command line window, passing in the `--url` flag with your `localhost` URL and port. `cloudflared` will output logs to your command line, including a banner with a tunnel URL:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "In this example, the randomly-generated URL `https://seasonal-deck-organisms-sf.trycloudflare.com` has been created and assigned to your tunnel instance. Visiting this URL in a browser will show the application running, with requests being securely forwarded through Cloudflare's global network, through the tunnel running on your machine, to `localhost:5173`:\n\n![Cloudflare Tunnel example rendering a randomly-generated URL](https://developers.cloudflare.com/_astro/tunnel.DK_OjmvC_Z1Wv9CW.webp)\n\n## Next Steps\n\nCloudflare Tunnel can be configured in a variety of ways and can be used beyond providing access to your in-development applications. For example, you can provide `cloudflared` with a [configuration file](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/do-more-with-tunnels/local-management/configuration-file/) to add more complex routing and tunnel setups that go beyond a simple `--url` flag. You can also [attach a Cloudflare DNS record](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/routing-to-tunnel/dns/) to a domain or subdomain for an easily accessible, long-lived tunnel to your local machine.\n\nFinally, by incorporating Cloudflare Access, you can provide [secure access to your tunnels](https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/self-hosted-public-app/) without exposing your entire server, or compromising on security. Refer to the [Cloudflare for Teams documentation](https://developers.cloudflare.com/cloudflare-one/) to learn more about what you can do with Cloudflare's entire suite of Zero Trust tools.\n\n</page>\n\n<page>\n---\ntitle: Redirecting *.pages.dev to a Custom Domain · Cloudflare Pages docs\ndescription: Learn how to use Bulk Redirects to redirect your *.pages.dev\n  subdomain to your custom domain.\nlastUpdated: 2025-09-15T21:45:20.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/pages/how-to/redirect-to-custom-domain/\n  md: https://developers.cloudflare.com/pages/how-to/redirect-to-custom-domain/index.md\n---\n\nLearn how to use [Bulk Redirects](https://developers.cloudflare.com/rules/url-forwarding/bulk-redirects/) to redirect your `*.pages.dev` subdomain to your [custom domain](https://developers.cloudflare.com/pages/configuration/custom-domains/).\n\nYou may want to do this to ensure that your site's content is served only on the custom domain, and not the `<project>.pages.dev` site automatically generated on your first Pages deployment.\n\n## Setup\n\nTo redirect a `<project>.pages.dev` subdomain to your custom domain:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. Select your Pages project.\n\n3. Go to **Custom domains** and make sure that your custom domain is listed. If it is not, add it by clicking **Set up a custom domain**.\n\n4. Go **Bulk Redirects**.\n\n5. [Create a bulk redirect list](https://developers.cloudflare.com/rules/url-forwarding/bulk-redirects/create-dashboard/#1-create-a-bulk-redirect-list) modeled after the following (but replacing the values as appropriate):\n\n| Source URL | Target URL | Status | Parameters |\n| - | - | - | - |\n| `<project>.pages.dev` | `https://example.com` | `301` | * Preserve query string\n* Subpath matching\n* Preserve path suffix\n* Include subdomains |\n\n1. [Create a bulk redirect rule](https://developers.cloudflare.com/rules/url-forwarding/bulk-redirects/create-dashboard/#2-create-a-bulk-redirect-rule) using the list you just created.\n\nTo test that your redirect worked, go to your `<project>.pages.dev` domain. If the URL is now set to your custom domain, then the rule has propagated.\n\n## Related resources\n\n* [Redirect www to domain apex](https://developers.cloudflare.com/pages/how-to/www-redirect/)\n* [Handle redirects with Bulk Redirects](https://developers.cloudflare.com/rules/url-forwarding/bulk-redirects/)\n\n</page>\n\n<page>\n---\ntitle: Refactor a Worker to a Pages Function · Cloudflare Pages docs\ndescription: \"In this guide, you will learn how to refactor a Worker made to\n  intake form submissions to a Pages Function that can be hosted on your\n  Cloudflare Pages application. Pages Functions is a serverless function that\n  lives within the same project directory as your application and is deployed\n  with Cloudflare Pages. It enables you to run server-side code that adds\n  dynamic functionality without running a dedicated server. You may want to\n  refactor a Worker to a Pages Function for one of these reasons:\"\nlastUpdated: 2025-09-15T21:45:20.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/pages/how-to/refactor-a-worker-to-pages-functions/\n  md: https://developers.cloudflare.com/pages/how-to/refactor-a-worker-to-pages-functions/index.md\n---\n\nIn this guide, you will learn how to refactor a Worker made to intake form submissions to a Pages Function that can be hosted on your Cloudflare Pages application. [Pages Functions](https://developers.cloudflare.com/pages/functions/) is a serverless function that lives within the same project directory as your application and is deployed with Cloudflare Pages. It enables you to run server-side code that adds dynamic functionality without running a dedicated server. You may want to refactor a Worker to a Pages Function for one of these reasons:\n\n1. If you manage a serverless function that your Pages application depends on and wish to ship the logic without managing a Worker as a separate service.\n2. If you are migrating your Worker to Pages Functions and want to use the routing and middleware capabilities of Pages Functions.\n\nNote\n\nYou can import your Worker to a Pages project without using Functions by creating a `_worker.js` file in the output directory of your Pages project. This [Advanced mode](https://developers.cloudflare.com/pages/functions/advanced-mode/) requires writing your Worker with [Module syntax](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/).\n\nHowever, when using the `_worker.js` file in Pages, the entire `/functions` directory is ignored – including its routing and middleware characteristics.\n\n## General refactoring steps\n\n1. Remove the fetch handler and replace it with the appropriate `OnRequest` method. Refer to [Functions](https://developers.cloudflare.com/pages/functions/get-started/) to select the appropriate method for your Function.\n2. Pass the `context` object as an argument to your new `OnRequest` method to access the properties of the context parameter: `request`,`env`,`params` and `next`.\n3. Use middleware to handle logic that must be executed before or after route handlers. Learn more about [using Middleware](https://developers.cloudflare.com/pages/functions/middleware/) in the Functions documentation.\n\n## Background\n\nTo explain the process of refactoring, this guide uses a simple form submission example.\n\nForm submissions can be handled by Workers but can also be a good use case for Pages Functions, since forms are most times specific to a particular application.\n\nAssuming you are already using a Worker to handle your form, you would have deployed this Worker and then added the URL to your form action attribute in your HTML form. This means that when you change how the Worker handles your submissions, you must make changes to the Worker script. If the logic in your Worker is used by more than one application, Pages Functions would not be a good use case.\n\nHowever, it can be beneficial to use a [Pages Function](https://developers.cloudflare.com/pages/functions/) when you would like to organize your function logic in the same project directory as your application.\n\nBuilding your application using Pages Functions can help you manage your client and serverless logic from the same place and make it easier to write and debug your code.\n\n## Handle form entries with Airtable and Workers\n\nAn [Airtable](https://airtable.com/) is a low-code platform for building collaborative applications. It helps customize your workflow, collaborate, and handle form submissions. For this example, you will utilize Airtable's form submission feature.\n\n[Airtable](https://airtable.com/) can be used to store entries of information in different tables for the same account. When creating a Worker for handling the submission logic, the first step is to use [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/) to initialize a new Worker within a specific folder or at the root of your application.\n\nThis step creates the boilerplate to write your Airtable submission Worker. After writing your Worker, you can deploy it to Cloudflare's global network after you [configure your project for deployment](https://developers.cloudflare.com/workers/wrangler/configuration/). Refer to the Workers documentation for a full tutorial on how to [handle form submission with Workers](https://developers.cloudflare.com/workers/tutorials/handle-form-submissions-with-airtable/).\n\nThe following code block shows an example of a Worker that handles Airtable form submission.\n\nThe `submitHandler` async function is called if the pathname of the work is `/submit`. This function checks that the request method is a `POST` request and then proceeds to parse and post the form entries to Airtable using your credentials, which you can store using [Wrangler `secret`](https://developers.cloudflare.com/workers/wrangler/commands/#secret).",
      "language": "unknown"
    },
    {
      "code": "### Refactor your Worker\n\nTo refactor the above Worker, go to your Pages project directory and create a `/functions` folder. In `/functions`, create a `form.js` file. This file will handle form submissions.\n\nThen, in the `form.js` file, export a single `onRequestPost`:",
      "language": "unknown"
    },
    {
      "code": "Every Worker has an `addEventListener` to listen for `fetch` events, but you will not need this in a Pages Function. Instead, you will `export` a single `onRequest` function, and depending on the HTTPS request it handles, you will name it accordingly. Refer to [Function documentation](https://developers.cloudflare.com/pages/functions/get-started/) to select the appropriate method for your function.\n\nThe above code takes a `request` and `env` as arguments which pass these properties down to the `submitHandler` function, which remains unchanged from the [original Worker](#handle-form-entries-with-airtable-and-workers). However, because Functions allow you to specify the HTTPS request type, you can remove the `request.method` check in your Worker. This is now handled by Pages Functions by naming the `onRequest` handler.\n\nNow, you will introduce the `submitHandler` function and pass the `env` parameter as a property. This will allow you to access `env` in the `HandleAirtableData` function below. This function does a `POST` request to Airtable using your Airtable credentials:",
      "language": "unknown"
    },
    {
      "code": "Finally, create a `HandleAirtableData` function. This function will send a `fetch` request to Airtable with your Airtable credentials and the body of your request:",
      "language": "unknown"
    },
    {
      "code": "You can test your Function [locally using Wrangler](https://developers.cloudflare.com/pages/functions/local-development/). By completing this guide, you have successfully refactored your form submission Worker to a form submission Pages Function.\n\n## Related resources\n\n* [HTML forms](https://developers.cloudflare.com/pages/tutorials/forms/)\n* [Plugins documentation](https://developers.cloudflare.com/pages/functions/plugins/)\n* [Functions documentation](https://developers.cloudflare.com/pages/functions/)\n\n</page>\n\n<page>\n---\ntitle: Use Direct Upload with continuous integration · Cloudflare Pages docs\ndescription: Cloudflare Pages supports directly uploading prebuilt assets,\n  allowing you to use custom build steps for your applications and deploy to\n  Pages with Wrangler. This guide will teach you how to deploy your application\n  to Pages, using continuous integration.\nlastUpdated: 2025-09-17T11:00:27.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/pages/how-to/use-direct-upload-with-continuous-integration/\n  md: https://developers.cloudflare.com/pages/how-to/use-direct-upload-with-continuous-integration/index.md\n---\n\nCloudflare Pages supports directly uploading prebuilt assets, allowing you to use custom build steps for your applications and deploy to Pages with [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/). This guide will teach you how to deploy your application to Pages, using continuous integration.\n\n## Deploy with Wrangler\n\nIn your project directory, install [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/) so you can deploy a folder of prebuilt assets by running the following command:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Private modules on the npm registry",
      "id": "private-modules-on-the-npm-registry"
    },
    {
      "level": "h2",
      "text": "Custom registry endpoints",
      "id": "custom-registry-endpoints"
    },
    {
      "level": "h3",
      "text": "Managing multiple environments",
      "id": "managing-multiple-environments"
    },
    {
      "level": "h2",
      "text": "Installing Cloudflare Tunnel",
      "id": "installing-cloudflare-tunnel"
    },
    {
      "level": "h2",
      "text": "Run a local service",
      "id": "run-a-local-service"
    },
    {
      "level": "h2",
      "text": "Start a Cloudflare Tunnel",
      "id": "start-a-cloudflare-tunnel"
    },
    {
      "level": "h2",
      "text": "Next Steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Setup",
      "id": "setup"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "General refactoring steps",
      "id": "general-refactoring-steps"
    },
    {
      "level": "h2",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h2",
      "text": "Handle form entries with Airtable and Workers",
      "id": "handle-form-entries-with-airtable-and-workers"
    },
    {
      "level": "h3",
      "text": "Refactor your Worker",
      "id": "refactor-your-worker"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Deploy with Wrangler",
      "id": "deploy-with-wrangler"
    }
  ],
  "url": "llms-txt#create-a-readonly-token",
  "links": []
}