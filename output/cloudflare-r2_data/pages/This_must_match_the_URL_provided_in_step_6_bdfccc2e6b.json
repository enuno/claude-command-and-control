{
  "title": "This must match the URL provided in step 6",
  "content": "curl -s https://workflows-starter.YOUR_WORKERS_SUBDOMAIN.workers.dev/\nsh\n{\"id\":\"16ac31e5-db9d-48ae-a58f-95b95422d0fa\",\"details\":{\"status\":\"queued\",\"error\":null,\"output\":null}}\nts\nimport {\n  WorkflowEntrypoint,\n  WorkflowStep,\n  WorkflowEvent,\n} from \"cloudflare:workers\";\n\n// We are using R2 to store the D1 backup\ntype Env = {\n  BACKUP_WORKFLOW: Workflow;\n  D1_REST_API_TOKEN: string;\n  BACKUP_BUCKET: R2Bucket;\n};\n\n// Workflow parameters: we expect accountId and databaseId\ntype Params = {\n  accountId: string;\n  databaseId: string;\n};\n\n// Workflow logic\nexport class backupWorkflow extends WorkflowEntrypoint<Env, Params> {\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n    const { accountId, databaseId } = event.payload;\n\nconst url = `https://api.cloudflare.com/client/v4/accounts/${accountId}/d1/database/${databaseId}/export`;\n    const method = \"POST\";\n    const headers = new Headers();\n    headers.append(\"Content-Type\", \"application/json\");\n    headers.append(\"Authorization\", `Bearer ${this.env.D1_REST_API_TOKEN}`);\n\nconst bookmark = await step.do(\n      `Starting backup for ${databaseId}`,\n      async () => {\n        const payload = { output_format: \"polling\" };\n\nconst res = await fetch(url, {\n          method,\n          headers,\n          body: JSON.stringify(payload),\n        });\n        const { result } = (await res.json()) as any;\n\n// If we don't get `at_bookmark` we throw to retry the step\n        if (!result?.at_bookmark) throw new Error(\"Missing `at_bookmark`\");\n\nreturn result.at_bookmark;\n      },\n    );\n\nawait step.do(\"Check backup status and store it on R2\", async () => {\n      const payload = { current_bookmark: bookmark };\n\nconst res = await fetch(url, {\n        method,\n        headers,\n        body: JSON.stringify(payload),\n      });\n      const { result } = (await res.json()) as any;\n\n// The endpoint sends `signed_url` when the backup is ready to download.\n      // If we don't get `signed_url` we throw to retry the step.\n      if (!result?.signed_url) throw new Error(\"Missing `signed_url`\");\n\nconst dumpResponse = await fetch(result.signed_url);\n      if (!dumpResponse.ok) throw new Error(\"Failed to fetch dump file\");\n\n// Finally, stream the file directly to R2\n      await this.env.BACKUP_BUCKET.put(result.filename, dumpResponse.body);\n    });\n  }\n}\n\nexport default {\n  async fetch(req: Request, env: Env): Promise<Response> {\n    return new Response(\"Not found\", { status: 404 });\n  },\n  async scheduled(\n    controller: ScheduledController,\n    env: Env,\n    ctx: ExecutionContext,\n  ) {\n    const params: Params = {\n      accountId: \"{accountId}\",\n      databaseId: \"{databaseId}\",\n    };\n    const instance = await env.BACKUP_WORKFLOW.create({ params });\n    console.log(`Started workflow: ${instance.id}`);\n  },\n};\njson\n{\n  \"devDependencies\": {\n    \"wrangler\": \"^3.99.0\"\n  }\n}\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"backup-d1\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2024-12-27\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"workflows\": [\n      {\n        \"name\": \"backup-workflow\",\n        \"binding\": \"BACKUP_WORKFLOW\",\n        \"class_name\": \"backupWorkflow\"\n      }\n    ],\n    \"r2_buckets\": [\n      {\n        \"binding\": \"BACKUP_BUCKET\",\n        \"bucket_name\": \"d1-backups\"\n      }\n    ],\n    \"triggers\": {\n      \"crons\": [\n        \"0 0 * * *\"\n      ]\n    }\n  }\n  toml\n  name = \"backup-d1\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2024-12-27\"\n  compatibility_flags = [ \"nodejs_compat\" ]\n\n[[workflows]]\n  name = \"backup-workflow\"\n  binding = \"BACKUP_WORKFLOW\"\n  class_name = \"backupWorkflow\"\n\n[[r2_buckets]]\n  binding = \"BACKUP_BUCKET\"\n  bucket_name = \"d1-backups\"\n\n[triggers]\n  crons = [ \"0 0 * * *\" ]\n  ts\nimport {\n  WorkflowEntrypoint,\n  WorkflowStep,\n  WorkflowEvent,\n} from \"cloudflare:workers\";\nimport { EmailMessage } from \"cloudflare:email\";\nimport { createMimeMessage } from \"mimetext\";\n\n// We are using Email Routing to send emails out and D1 for our cart database\ntype Env = {\n  CART_WORKFLOW: Workflow;\n  SEND_EMAIL: any;\n  DB: any;\n};\n\n// Workflow parameters: we expect a cartId\ntype Params = {\n  cartId: string;\n};\n\n// Adjust this to your Cloudflare zone using Email Routing\nconst merchantEmail = \"merchant@example.com\";\n\n// Uses mimetext npm to generate Email\nconst genEmail = (email: string, amount: number) => {\n  const msg = createMimeMessage();\n  msg.setSender({ name: \"Pet shop\", addr: merchantEmail });\n  msg.setRecipient(email);\n  msg.setSubject(\"You invoice\");\n  msg.addMessage({\n    contentType: \"text/plain\",\n    data: `Your invoice for ${amount} has been paid. Your products will be shipped shortly.`,\n  });\n\nreturn new EmailMessage(merchantEmail, email, msg.asRaw());\n};\n\n// Workflow logic\nexport class cartInvoicesWorkflow extends WorkflowEntrypoint<Env, Params> {\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n    await step.sleep(\"sleep for a while\", \"10 seconds\");\n\n// Retrieve the cart from the D1 database\n    // if the cart hasn't been checked out yet retry every 2 minutes, 10 times, otherwise give up\n    const cart = await step.do(\n      \"retrieve cart\",\n      {\n        retries: {\n          limit: 10,\n          delay: 2000 * 60,\n          backoff: \"constant\",\n        },\n        timeout: \"30 seconds\",\n      },\n      async () => {\n        const { results } = await this.env.DB.prepare(\n          `SELECT * FROM cart WHERE id = ?`,\n        )\n          .bind(event.payload.cartId)\n          .run();\n        // should return { checkedOut: true, amount: 250 , account: { email: \"celsomartinho@gmail.com\" }};\n        if (results[0].checkedOut === false) {\n          throw new Error(\"cart hasn't been checked out yet\");\n        }\n        return results[0];\n      },\n    );\n\n// Proceed to payment, retry 10 times every minute or give up\n    const payment = await step.do(\n      \"payment\",\n      {\n        retries: {\n          limit: 10,\n          delay: 1000 * 60,\n          backoff: \"constant\",\n        },\n        timeout: \"30 seconds\",\n      },\n      async () => {\n        let resp = await fetch(\"https://payment-processor.example.com/\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\",\n          },\n          body: JSON.stringify({ amount: cart.amount }),\n        });\n\nif (!resp.ok) {\n          throw new Error(\"payment has failed\");\n        }\n\nreturn { success: true, amount: cart.amount };\n      },\n    );\n\n// Send invoice to the customer, retry 10 times every 5 minutes or give up\n    // Requires that cart.account.email has previously been validated in Email Routing,\n    // See https://developers.cloudflare.com/email-routing/email-workers/\n    await step.do(\n      \"send invoice\",\n      {\n        retries: {\n          limit: 10,\n          delay: 5000 * 60,\n          backoff: \"constant\",\n        },\n        timeout: \"30 seconds\",\n      },\n      async () => {\n        const message = genEmail(cart.account.email, payment.amount);\n        try {\n          await this.env.SEND_EMAIL.send(message);\n        } catch (e) {\n          throw new Error(\"failed to send invoice\");\n        }\n      },\n    );\n  }\n}\n\n// Default page for admin\n// Remove in production\n\nexport default {\n  async fetch(req: Request, env: Env): Promise<Response> {\n    let url = new URL(req.url);\n\nlet id = new URL(req.url).searchParams.get(\"instanceId\");\n\n// Get the status of an existing instance, if provided\n    if (id) {\n      let instance = await env.CART_WORKFLOW.get(id);\n      return Response.json({\n        status: await instance.status(),\n      });\n    }\n\nif (url.pathname.startsWith(\"/new\")) {\n      let instance = await env.CART_WORKFLOW.create({\n        params: {\n          cartId: \"123\",\n        },\n      });\n      return Response.json({\n        id: instance.id,\n        details: await instance.status(),\n      });\n    }\n\nreturn new Response(\n      `<html><body><a href=\"/new\">new instance</a> or add ?instanceId=...</body></html>`,\n      {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      },\n    );\n  },\n};\njson\n{\n  \"devDependencies\": {\n    \"wrangler\": \"^3.83.0\"\n  },\n  \"dependencies\": {\n    \"mimetext\": \"^3.0.24\"\n  }\n}\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"cart-invoices\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2024-10-22\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"workflows\": [\n      {\n        \"name\": \"cart-invoices-workflow\",\n        \"binding\": \"CART_WORKFLOW\",\n        \"class_name\": \"cartInvoicesWorkflow\"\n      }\n    ],\n    \"send_email\": [\n      {\n        \"name\": \"SEND_EMAIL\"\n      }\n    ]\n  }\n  toml\n  name = \"cart-invoices\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2024-10-22\"\n  compatibility_flags = [\"nodejs_compat\" ]\n\n[[workflows]]\n  name = \"cart-invoices-workflow\"\n  binding = \"CART_WORKFLOW\"\n  class_name = \"cartInvoicesWorkflow\"\n\n[[send_email]]\n  name = \"SEND_EMAIL\"\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    db;\n\nasync run(event, step) {\n      this.db = new DatabaseService(this.env.DB);\n      const { imageKey } = event.payload;\n\nawait step.do(\"Insert image name into database\", async () => {\n        await this.db.insertImage(imageKey, event.instanceId);\n      });\n\nconst waitForApproval = await step.waitForEvent(\n        \"Wait for AI Image tagging approval\",\n        {\n          type: \"approval-for-ai-tagging\",\n          timeout: \"5 minute\",\n        },\n      );\n\nconst approvalPayload = waitForApproval.payload;\n      if (approvalPayload?.approved) {\n        const aiTags = await step.do(\"Generate AI tags\", async () => {\n          const image = await this.env.workflow_demo_bucket.get(imageKey);\n          if (!image) throw new Error(\"Image not found\");\n\nconst arrayBuffer = await image.arrayBuffer();\n          const uint8Array = new Uint8Array(arrayBuffer);\n\nconst input = {\n            image: Array.from(uint8Array),\n            prompt: AI_CONFIG.PROMPT,\n            max_tokens: AI_CONFIG.MAX_TOKENS,\n          };\n\nconst response = await this.env.AI.run(AI_CONFIG.MODEL, input);\n          return response.description;\n        });\n\nawait step.do(\"Update DB with AI tags\", async () => {\n          await this.db.updateImageTags(event.instanceId, aiTags);\n        });\n      }\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint<Env, WorkflowParams> {\n    private db!: DatabaseService;\n\nasync run(event: WorkflowEvent<WorkflowParams>, step: WorkflowStep) {\n      this.db = new DatabaseService(this.env.DB);\n      const { imageKey } = event.payload;\n\nawait step.do('Insert image name into database', async () => {\n        await this.db.insertImage(imageKey, event.instanceId);\n      });\n\nconst waitForApproval = await step.waitForEvent('Wait for AI Image tagging approval', {\n        type: 'approval-for-ai-tagging',\n        timeout: '5 minute',\n      });\n\nconst approvalPayload = waitForApproval.payload as ApprovalRequest;\n      if (approvalPayload?.approved) {\n        const aiTags = await step.do('Generate AI tags', async () => {\n          const image = await this.env.workflow_demo_bucket.get(imageKey);\n          if (!image) throw new Error('Image not found');\n\nconst arrayBuffer = await image.arrayBuffer();\n          const uint8Array = new Uint8Array(arrayBuffer);\n\nconst input = {\n            image: Array.from(uint8Array),\n            prompt: AI_CONFIG.PROMPT,\n            max_tokens: AI_CONFIG.MAX_TOKENS,\n          };\n\nconst response = await this.env.AI.run(AI_CONFIG.MODEL, input);\n          return response.description;\n        });\n\nawait step.do('Update DB with AI tags', async () => {\n          await this.db.updateImageTags(event.instanceId, aiTags);\n        });\n      }\n    }\n  }\n  jsonc\n  {\n    \"$schema\": \"node_modules/wrangler/config-schema.json\",\n    \"name\": \"workflows-waitforevent\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2025-04-14\",\n    \"observability\": {\n      \"enabled\": true,\n      \"head_sampling_rate\": 1,\n    },\n    \"ai\": {\n      \"binding\": \"AI\"\n    },\n    \"workflows\": [\n      {\n        \"name\": \"workflows-starter\",\n        \"binding\": \"MY_WORKFLOW\",\n        \"class_name\": \"MyWorkflow\"\n      }\n    ],\n    \"r2_buckets\": [\n      {\n        \"bucket_name\": \"workflow-demo\",\n        \"binding\": \"workflow_demo_bucket\"\n      }\n    ],\n    \"d1_databases\": [\n      {\n        \"binding\": \"DB\",\n        \"database_name\": \"workflows-demo-d1\",\n        \"database_id\": \"66e4fbe9-06ac-4548-abba-2dc42088e13a\"\n      }\n    ]\n  }\n  toml\n  \"$schema\" = \"node_modules/wrangler/config-schema.json\"\n  name = \"workflows-waitforevent\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2025-04-14\"\n\n[observability]\n  enabled = true\n  head_sampling_rate = 1\n\n[ai]\n  binding = \"AI\"\n\n[[workflows]]\n  name = \"workflows-starter\"\n  binding = \"MY_WORKFLOW\"\n  class_name = \"MyWorkflow\"\n\n[[r2_buckets]]\n  bucket_name = \"workflow-demo\"\n  binding = \"workflow_demo_bucket\"\n\n[[d1_databases]]\n  binding = \"DB\"\n  database_name = \"workflows-demo-d1\"\n  database_id = \"66e4fbe9-06ac-4548-abba-2dc42088e13a\"\n  graphql\nquery WorkflowInvocationsExample(\n  $accountTag: string!\n  $datetimeStart: Time\n  $datetimeEnd: Time\n  $workflowName: string\n) {\n  viewer {\n    accounts(filter: { accountTag: $accountTag }) {\n      wallTime: workflowsAdaptiveGroups(\n        limit: 10000\n        filter: {\n          datetimeHour_geq: $datetimeStart\n          datetimeHour_leq: $datetimeEnd\n          workflowName: $workflowName\n        }\n        orderBy: [count_DESC]\n      ) {\n        count\n        sum {\n          wallTime\n        }\n        dimensions {\n          date: datetimeHour\n        }\n      }\n    }\n  }\n}\ngraphql\nquery WorkflowInvocationsExample2(\n  $accountTag: string!\n  $datetimeStart: Time\n  $datetimeEnd: Time\n  $workflowName: string\n) {\n  viewer {\n    accounts(filter: { accountTag: $accountTag }) {\n      instanceRuns: workflowsAdaptiveGroups(\n        limit: 10000\n        filter: {\n          datetimeHour_geq: $datetimeStart\n          datetimeHour_leq: $datetimeEnd\n          workflowName: $workflowName\n          eventType: \"WORKFLOW_START\"\n        }\n        orderBy: [count_DESC]\n      ) {\n        count\n        dimensions {\n          date: datetimeHour\n        }\n      }\n      stepCount: workflowsAdaptiveGroups(\n        limit: 10000\n        filter: {\n          datetimeHour_geq: $datetimeStart\n          datetimeHour_leq: $datetimeEnd\n          workflowName: $workflowName\n          eventType: \"WORKFLOW_START\"\n        }\n        orderBy: [count_DESC]\n      ) {\n        count\n        dimensions {\n          date: datetimeHour\n        }\n      }\n      wallTime: workflowsAdaptiveGroups(\n        limit: 10000\n        filter: {\n          datetimeHour_geq: $datetimeStart\n          datetimeHour_leq: $datetimeEnd\n          workflowName: $workflowName\n        }\n        orderBy: [count_DESC]\n      ) {\n        count\n        sum {\n          wallTime\n        }\n        dimensions {\n          date: datetimeHour\n        }\n      }\n    }\n  }\n}\ngraphql\nquery WorkflowsAdaptiveExample(\n  $accountTag: string!\n  $datetimeStart: Time\n  $datetimeEnd: Time\n  $instanceId: string\n) {\n  viewer {\n    accounts(filter: { accountTag: $accountTag }) {\n      workflowsAdaptive(\n        limit: 100\n        filter: {\n          datetime_geq: $datetimeStart\n          datetime_leq: $datetimeEnd\n          instanceId: $instanceId\n        }\n        orderBy: [datetime_ASC]\n      ) {\n        datetime\n        eventType\n        workflowName\n        instanceId\n        stepCount\n        wallTime\n      }\n    }\n  }\n}\njson\n{\n  \"accountTag\": \"fedfa729a5b0ecfd623bca1f9000f0a22\",\n  \"datetimeStart\": \"2024-10-20T00:00:00Z\",\n  \"datetimeEnd\": \"2024-10-29T00:00:00Z\",\n  \"workflowName\": \"shoppingCart\",\n  \"instanceId\": \"ecc48200-11c4-22a3-b05f-88a3c1c1db81\"\n}\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"workflows-starter\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2025-10-24\",\n    \"compatibility_flags\": [\n      \"python_workflows\",\n      \"python_workers\"\n    ],\n    \"workflows\": [\n      {\n        \"name\": \"workflows-starter\",\n        \"binding\": \"MY_WORKFLOW\",\n        \"class_name\": \"MyWorkflow\"\n      }\n    ]\n  }\n  toml\n  #:schema node_modules/wrangler/config-schema.json\n  name = \"workflows-starter\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2025-10-24\"\n  compatibility_flags = [\"python_workflows\", \"python_workers\"]\n\n[[workflows]]\n  # name of your workflow\n  name = \"workflows-starter\"\n  # binding name env.MY_WORKFLOW\n  binding = \"MY_WORKFLOW\"\n  # this is class that extends the Workflow class in src/index.ts\n  class_name = \"MyWorkflow\"\n  python\nfrom pyodide.ffi import to_js\n\nclass DemoWorkflowClass(WorkflowEntrypoint):\n    async def run(self, event, step):\n        @step.do('step-name')\n        async def first_step():\n            payload = event[\"payload\"]\n            return payload\npython\nfrom js import Object\nfrom pyodide.ffi import to_js\nfrom workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n    async def fetch(self, request):\n        event = {\"foo\": \"bar\"}\n        options = to_js({\"params\": event}, dict_converter=Object.fromEntries)\n        await self.env.MY_WORKFLOW.create(options)\n        return Response.json({\"status\": \"success\"})\npython\nfrom pyodide.ffi import to_js\nfrom js import Object",
  "code_samples": [
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "***\n\n## Next steps\n\n* Learn more about [how events are passed to a Workflow](https://developers.cloudflare.com/workflows/build/events-and-parameters/).\n* Learn more about binding to and triggering Workflow instances using the [Workers API](https://developers.cloudflare.com/workflows/build/workers-api/).\n* Learn more about the [Rules of Workflows](https://developers.cloudflare.com/workflows/build/rules-of-workflows/) and best practices for building applications using Workflows.\n\nIf you have any feature requests or notice any bugs, share your feedback directly with the Cloudflare team by joining the [Cloudflare Developers community on Discord](https://discord.cloudflare.com).\n\n</page>\n\n<page>\n---\ntitle: Test Workflows · Cloudflare Workflows docs\nlastUpdated: 2025-09-12T15:23:11.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/build/test-workflows/\n  md: https://developers.cloudflare.com/workflows/build/test-workflows/index.md\n---\n\n\n</page>\n\n<page>\n---\ntitle: Agents · Cloudflare Workflows docs\ndescription: Build AI-powered Agents on Cloudflare\nlastUpdated: 2025-01-29T20:30:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/examples/agents/\n  md: https://developers.cloudflare.com/workflows/examples/agents/index.md\n---\n\n\n</page>\n\n<page>\n---\ntitle: Export and save D1 database · Cloudflare Workflows docs\ndescription: Send invoice when shopping cart is checked out and paid for\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workflows/examples/backup-d1/\n  md: https://developers.cloudflare.com/workflows/examples/backup-d1/index.md\n---\n\nIn this example, we implement a Workflow periodically triggered by a [Cron Trigger](https://developers.cloudflare.com/workers/configuration/cron-triggers). That Workflow initiates a backup for a D1 database using the REST API, and then stores the SQL dump in an [R2](https://developers.cloudflare.com/r2) bucket.\n\nWhen the Workflow is triggered, it fetches the REST API to initiate an export job for a specific database. Then it fetches the same endpoint to check if the backup job is ready and the SQL dump is available to download.\n\nAs shown in this example, Workflows handles both the responses and failures, thereby removing the burden from the developer. Workflows retries the following steps:\n\n* API calls until it gets a successful response\n* Fetching the backup from the URL provided\n* Saving the file to [R2](https://developers.cloudflare.com/r2)\n\nThe Workflow can run until the backup file is ready, handling all of the possible conditions until it is completed.\n\nThis example provides simplified steps for backing up a [D1](https://developers.cloudflare.com/d1) database to help you understand the possibilities of Workflows. In every step, it uses the [default](https://developers.cloudflare.com/workflows/build/sleeping-and-retrying) sleeping and retrying configuration. In a real-world scenario, more steps and additional logic would likely be needed.",
      "language": "unknown"
    },
    {
      "code": "Here is a minimal package.json:",
      "language": "unknown"
    },
    {
      "code": "Here is a [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Pay cart and send invoice · Cloudflare Workflows docs\ndescription: Send invoice when shopping cart is checked out and paid for\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workflows/examples/send-invoices/\n  md: https://developers.cloudflare.com/workflows/examples/send-invoices/index.md\n---\n\nIn this example, we implement a Workflow for an e-commerce website that is triggered every time a shopping cart is created.\n\nOnce a Workflow instance is triggered, it starts polling a [D1](https://developers.cloudflare.com/d1) database for the cart ID until it has been checked out. Once the shopping cart is checked out, we proceed to process the payment with an external provider doing a fetch POST. Finally, assuming everything goes well, we try to send an email using [Email Workers](https://developers.cloudflare.com/email-routing/email-workers/) with the invoice to the customer.\n\nAs you can see, Workflows handles all the different service responses and failures; it will retry D1 until the cart is checked out, retry the payment processor if it fails for some reason, and retry sending the email with the invoice if it can't. The developer doesn't have to care about any of that logic, and the workflow can run for hours, handling all the possible conditions until it is completed.\n\nThis is a simplified example of processing a shopping cart. We would assume more steps and additional logic in a real-life scenario, but this example gives you a good idea of what you can do with Workflows.",
      "language": "unknown"
    },
    {
      "code": "Here's a minimal package.json:",
      "language": "unknown"
    },
    {
      "code": "And finally [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "If you're using TypeScript, run [`wrangler types`](https://developers.cloudflare.com/workers/wrangler/commands/#types) whenever you modify your Wrangler configuration file. This generates types for the `env` object based on your bindings, as well as [runtime types](https://developers.cloudflare.com/workers/languages/typescript/).\n\n</page>\n\n<page>\n---\ntitle: Integrate Workflows with Twilio · Cloudflare Workflows docs\ndescription: Integrate Workflows with Twilio. Learn how to receive and send text\n  messages and phone calls via APIs and Webhooks.\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/examples/twilio/\n  md: https://developers.cloudflare.com/workflows/examples/twilio/index.md\n---\n\nUsing the following [repository](https://github.com/craigsdennis/twilio-cloudflare-workflow), learn how to integrate Cloudflare Workflows with Twilio, a popular cloud communications platform that enables developers to integrate messaging, voice, video, and authentication features into applications via APIs. By the end of the video tutorial, you will become familiarized with the process of setting up Cloudflare Workflows to seamlessly interact with Twilio's APIs, enabling you to build interesting communication features directly into your applications.\n\n</page>\n\n<page>\n---\ntitle: Human-in-the-Loop Image Tagging with waitForEvent · Cloudflare Workflows docs\ndescription: Human-in-the-loop Workflow with waitForEvent API\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workflows/examples/wait-for-event/\n  md: https://developers.cloudflare.com/workflows/examples/wait-for-event/index.md\n---\n\nThis example demonstrates how to use the `waitForEvent()` API in Cloudflare Workflows to introduce a human-in-the-loop step. The Workflow is triggered by an image upload, during which metadata is stored in a D1 database. The Workflow then waits for user approval, and upon approval, it uses Workers AI to generate image tags, which are stored in the database. An accompanying Next.js frontend application facilitates the image upload and approval process.\n\nNote\n\nThe example on this page includes only a subset of the full implementation. For the complete codebase and deployment instructions, please refer to the [GitHub repository](https://github.com/cloudflare/docs-examples/tree/main/workflows/waitForEvent).\n\n## Overview of the Workflow\n\nIn this Workflow, we simulate a scenario where an uploaded image requires human approval before AI-based processing. An image is uploaded to R2, then Workflow performs the following steps:\n\n1. Stores image metadata in a D1 database.\n2. Pauses execution using `waitForEvent()` and waits for an external event sent from the Next.js frontend, indicating approval or rejection.\n3. If approved, the Workflow uses Workers AI to generate image tags and stores the tags in the D1 database.\n4. If rejected, the Workflow ends without further action.\n\nThis pattern is useful in scenarios where certain operations should not proceed without explicit human consent, adding an extra layer of control and safety.\n\n## Frontend Integration\n\nThis example includes a Next.js frontend application that facilitates the image upload and approval process. The frontend provides an interface for uploading images, reviewing them, and approving or rejecting them. Upon image upload, the application triggers the Cloudflare Workflow, which then manages the subsequent steps, including waiting for user approval and performing AI-based image tagging upon approval.\n\nRefer to the `/nextjs-workflow-frontend` folder in the [GitHub repository](https://github.com/cloudflare/docs-examples/tree/main/workflows/waitForEvent) for the complete frontend implementation and deployment details.\n\n## Workflow index.ts\n\nThe `index.ts` file defines the core logic of the Cloudflare Workflow responsible for handling image uploads, awaiting human approval, and performing AI-based image tagging upon approval. It extends the `WorkflowEntrypoint` class and implements the `run()` method.\n\nFor the complete implementation of the `index.ts` file, please refer to the [GitHub repository](https://github.com/cloudflare/docs-examples/blob/main/workflows/waitForEvent/workflow/src/index.ts).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "## Workflow wrangler.jsonc\n\nThe Workflow configuration is defined in the `wrangler.jsonc` file. This file includes bindings for the R2 bucket, D1 database, Workers AI, and the Workflow itself. Ensure that all necessary bindings and environment variables are correctly set up to match your Cloudflare account and services.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "For access to the codebase, deployment instructions, and reference architecture, please visit the [GitHub repository](https://github.com/cloudflare/docs-examples/tree/main/workflows/waitForEvent). This resource provides all the necessary tools and information to effectively implement the Workflow and Next.js frontend application.\n\n</page>\n\n<page>\n---\ntitle: Metrics and analytics · Cloudflare Workflows docs\ndescription: Workflows expose metrics that allow you to inspect and measure\n  Workflow execution, error rates, steps, and total duration across each (and\n  all) of your Workflows.\nlastUpdated: 2025-12-03T22:57:02.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/observability/metrics-analytics/\n  md: https://developers.cloudflare.com/workflows/observability/metrics-analytics/index.md\n---\n\nWorkflows expose metrics that allow you to inspect and measure Workflow execution, error rates, steps, and total duration across each (and all) of your Workflows.\n\nThe metrics displayed in the [Cloudflare dashboard](https://dash.cloudflare.com/) charts are queried from Cloudflare’s [GraphQL Analytics API](https://developers.cloudflare.com/analytics/graphql-api/). You can access the metrics [programmatically](#query-via-the-graphql-api) via GraphQL or HTTP client.\n\n## Metrics\n\nWorkflows currently export the below metrics within the `workflowsAdaptiveGroups` GraphQL dataset.\n\n| Metric | GraphQL Field Name | Description |\n| - | - | - |\n| Read Queries (qps) | `readQueries` | The number of read queries issued against a database. This is the raw number of read queries, and is not used for billing. |\n\nMetrics can be queried (and are retained) for the past 31 days.\n\n### Labels and dimensions\n\nThe `workflowsAdaptiveGroups` dataset provides the following dimensions for filtering and grouping query results:\n\n* `workflowName` - Workflow name - e.g. `my-workflow`\n* `instanceId` - Instance ID\n* `stepName` - Step name\n* `eventType` - Event type (see [event types](#event-types))\n* `stepCount` - Step number within a given instance\n* `date` - The date when the Workflow was triggered\n* `datetimeFifteenMinutes` - The date and time truncated to fifteen minutes\n* `datetimeFiveMinutes` - The date and time truncated to five minutes\n* `datetimeHour` - The date and time truncated to the hour\n* `datetimeMinute` - The date and time truncated to the minute\n\n### Event types\n\nThe `eventType` metric allows you to filter (or groupBy) Workflows and steps based on their last observed status.\n\nThe possible values for `eventType` are documented below:\n\n#### Workflows-level status labels\n\n* `WORKFLOW_QUEUED` - the Workflow is queued, but not currently running. This can happen when you are at the [concurrency limit](https://developers.cloudflare.com/workflows/reference/limits/) and new instances are waiting for currently running instances to complete.\n* `WORKFLOW_START` - the Workflow has started and is running.\n* `WORKFLOW_SUCCESS` - the Workflow finished without errors.\n* `WORKFLOW_FAILURE` - the Workflow failed due to errors (exhausting retries, errors thrown, etc).\n* `WORKFLOW_TERMINATED` - the Workflow was explicitly terminated.\n\n#### Step-level status labels\n\n* `STEP_START` - the step has started and is running.\n* `STEP_SUCCESS` - the step finished without errors.\n* `STEP_FAILURE` - the step failed due to an error.\n* `SLEEP_START` - the step is sleeping.\n* `SLEEP_COMPLETE` - the step last finished sleeping.\n* `ATTEMPT_START` - a step is retrying.\n* `ATTEMPT_SUCCESS` - the retry succeeded.\n* `ATTEMPT_FAILURE` - the retry attempt failed.\n\n## View metrics in the dashboard\n\nPer-Workflow and instance analytics for Workflows are available in the Cloudflare dashboard. To view current and historical metrics for a database:\n\n1. In the Cloudflare dashboard, go to the **Workflows** page.\n\n   [Go to **Workflows**](https://dash.cloudflare.com/?to=/:account/workers/workflows)\n\n2. Select a Workflow to view its metrics.\n\nYou can optionally select a time window to query. This defaults to the last 24 hours.\n\n## Query via the GraphQL API\n\nYou can programmatically query analytics for your Workflows via the [GraphQL Analytics API](https://developers.cloudflare.com/analytics/graphql-api/). This API queries the same datasets as the Cloudflare dashboard, and supports GraphQL [introspection](https://developers.cloudflare.com/analytics/graphql-api/features/discovery/introspection/).\n\nWorkflows GraphQL datasets require an `accountTag` filter with your Cloudflare account ID, and includes the `workflowsAdaptiveGroups` dataset.\n\n### Examples\n\nTo query the count (number of workflow invocations) and sum of `wallTime` for a given `$workflowName` between `$datetimeStart` and `$datetimeEnd`, grouping by `date`:",
      "language": "unknown"
    },
    {
      "code": "[Run in GraphQL API Explorer](https://graphql.cloudflare.com/explorer?query=I4VwpgTgngBA6gewgawGYBsEHcCSA7ANwQGMBDAFwEsE8BnAUQA9SBbAB3TAAoAoGGACSlixBCDzkAKqQDmALhi1yESnhkBCPoIAmFMFRZgAyuVIRyCyZUNaBu8vuth6ebZae2sSNJiwA5VjAFJRU1HgBKGABvLQJKMCxIaK1+YVFxclouVEp0BwgFKJg0sQlpeUESjPKYAF9ImP4mmCxSdHQrQwUvFAxsWgBBXTYqAjAAcQgxNiyU5ph0a0oLGABGAAZN9bnmnLzIQp35+0dDAAkxCAB9GTBgBTs9A2NTcyPmk+eLkGvOe50nk4XNp3k0ej5sAEuoJwX1-IFQbVQUhtJAAEJQBQAbXSEiuABF6EYAMIAXSODVBuPIoNoIBYyXm81a7U6YERoO0Tjo1DojKZTROCk+Tm+EA5TKRzSldR4tSAA\\&variables=N4IghgxhD2CuB2AXAKmA5iAXCAggYTwHkBVAOWQH0BJAERABoQATMRAU0QEsBbNgZURgAToiwgATAAZxAVgC0ARnFyAzJOTjxmNZkkyAWg2asOPNgFF4TMVNmLlKhckkAWbZN0GjAd2hCA1gBmADbQ3qRgvGIASuYACgAy+OYUAOpUyAASFHzI0VSkAOIgAL5AA)\n\nHere we are doing the same for `wallTime`, `instanceRuns` and `stepCount` in the same query:",
      "language": "unknown"
    },
    {
      "code": "[Run in GraphQL API Explorer](https://graphql.cloudflare.com/explorer?query=I4VwpgTgngBA6gewgawGYBsEHcCSA7ANwQGMBDAFwEsE8BnAUQA9SBbAB3TACYAKAKBgwAJKWLEEIPOQAqpAOYAuGLXIRKeOQEIBwgCYUwVFmADK5UhHJLplYzqH7yh22Hp5d1l-axI0mLAByrGBKKmoafACUMADeOgSUYFiQsTqCouKS5LQ8qJToThBKMTAZElKyisJlWZUwAL7RcYItMOoqpHjEYABKkrRKPigY2LQAgvpsVARgAOIQEmw5aa0w6LaUVjAAjAAM+7srrXkFkMVHq47OxgASEhAA+nJgwEoOBkam5pYXrVefdxAj04rz0Hxcbl0vxaQz82CCxjesJGgWC0MEYBmFSgbBCMAARHAAPI9ADSADEADJEuAPEzSMY9aT46H1aFIXSQABCUCUAG1MlIHgARegmADCAF0Lk1oYLyNDdC46NQ6KlVpcDEp-i5ARBWRc2RqVGA2OLyltkf5xpNpnMFiAlvwNYJ1ixNko9gdoSdCucXS0dbd7k8Xm8g18LAqA4II3qHiDw+DjJD0TArfDgkjfCiEWA05iwNjcUpCSSKdTafTGcyDQGOdzeTABRaRWKpTL1S75YrlbRVbQuwGrtrk2A9XXVkbVlhSOh0DZEemc9aJqQppQZvNFssA26PTsDocA76zkOXXGQ89Qe8nJ8zFG05egQmw2C7xD3GmM6il0If3mk4ag2EA8vy8pthK0oarKAY9gGtAgCw54arO86LvmAbThqSrGCqNCDs0MYjjAz76lhhorNObL1EAA\\&variables=N4IghgxhD2CuB2AXAKmA5iAXCAggYTwHkBVAOWQH0BJAERABoQATMRAU0QEsBbNgZURgAToiwgATAAZxAVgC0ARnFyAzJOTjxmNZkkyAWg2asOPNgFF4TMVNmLlKhckkAWbZN0GjAd2hCA1gBmADbQ3qRgvGIASuYACgAy+OYUAOpUyAASFHzI0VSkAOIgAL5AA)\n\nHere lets query `workflowsAdaptive` for raw data about `$instanceId` between `$datetimeStart` and `$datetimeEnd`:",
      "language": "unknown"
    },
    {
      "code": "[Run in GraphQL API Explorer](https://graphql.cloudflare.com/explorer?query=I4VwpgTgngBA6gewgawGYBsEHcDOBBAEwEMAHAFwEsA3MAUQA8iBbE9MACgCgYYASIgMYCEIAHZkAKkQDmALhg4yECqOkBCbn2JkwlJmADKZIhDLyJFfZt7bdluqILn71lYqKiBYAJJOFSlWlOAEoYAG9NKgowLEhwzR5BYTEyHHZUCnQdCHkwmCSRcSk5PgKU4pgAX1CInjqYLCQ0TFxCUkoaLnr69EsKMxgARgAGYYTujKzIXPHumFs9MAB9aTBgeRsiHUWjEzJZ7oX7JbZ1rS27fVpHA-q3Y08fP157jy9fW6rPpAJIACEoPIANpHfRLPAGADCAF0DjVPqCwJ8wDQilASEi5jxGigMNgAHLMTFY16PD5Y-xgEiQwr7ClYIjodAWKxzSrjdk8dmVIA\\&variables=N4IghgxhD2CuB2AXAKmA5iAXCAggYTwHkBVAOWQH0BJAERABoQATMRAU0QEsBbNgZURgAToiwgATAAZxAVgC0ARnFyAzJOTjxmNZkkyAWg2asOPNgFF4TMVNmLlKhckkAWbZN0GjneAGdB8BBsVNbYAErmAAoAMvjmFADqVMgAEtR0AL5AA)\n\n#### GraphQL query variables\n\nExample values for the query variables:",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Interact with a Workflow · Cloudflare Workflows docs\ndescription: The Python Workers platform leverages FFI to access bindings to\n  Cloudflare resources. Refer to the bindings documentation for more\n  information.\nlastUpdated: 2025-11-24T16:55:57.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/workflows/python/bindings/\n  md: https://developers.cloudflare.com/workflows/python/bindings/index.md\n---\n\nPython Workflows are in beta, as well as the underlying platform.\n\nYou must add both `python_workflows` and `python_workers` compatibility flags to your Wrangler config file.\n\nAlso, Python Workflows requires `compatibility_date = \"2025-08-01\"`, or later, to be set in your Wrangler config file.\n\nThe Python Workers platform leverages [FFI](https://en.wikipedia.org/wiki/Foreign_function_interface) to access bindings to Cloudflare resources. Refer to the [bindings](https://developers.cloudflare.com/workers/languages/python/ffi/#using-bindings-from-python-workers) documentation for more information.\n\nFrom the configuration perspective, enabling Python Workflows requires adding the `python_workflows` compatibility flag to your `wrangler.toml` file.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "And this is how you use the payload in your workflow:",
      "language": "unknown"
    },
    {
      "code": "## Workflow\n\nThe `Workflow` binding gives you access to the [Workflow](https://developers.cloudflare.com/workflows/build/workers-api/#workflow) class. All its methods are available on the binding.\n\nUnder the hood, the `Workflow` binding is a Javascript object that is exposed to the Python script via [JsProxy](https://pyodide.org/en/stable/usage/api/python-api/ffi.html#pyodide.ffi.JsProxy). This means that the values returned by its methods are also `JsProxy` objects, and need to be converted back into Python objects using `python_from_rpc`.\n\n### `create`\n\nCreate (trigger) a new instance of a given Workflow.\n\n* `create(options=None)`\\* `options` - an **optional** dictionary of options to pass to the workflow instance. Should contain the same keys as the [WorkflowInstanceCreateOptions](https://developers.cloudflare.com/workflows/build/workers-api/#workflowinstancecreateoptions) type.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nValues returned from steps need to be converted into Javascript objects using `to_js`. This is why we explicitly construct the payload using `Object.fromEntries`.\n\nThe `create` method returns a [`WorkflowInstance`](https://developers.cloudflare.com/workflows/build/workers-api/#workflowinstance) object, which can be used to query the status of the workflow instance. Note that this is a Javascript object, and not a Python object.\n\n### `create_batch`\n\nCreate (trigger) a batch of new workflow instances, up to 100 instances at a time. This is useful if you need to create multiple instances at once within the [instance creation limit](https://developers.cloudflare.com/workflows/reference/limits/).\n\n* `create_batch(batch)`\n  * `batch` - list of `WorkflowInstanceCreateOptions` to pass when creating an instance, including a user-provided ID and payload parameters.\n\nEach element of the `batch` list is expected to include both `id` and `params` properties:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Overview of the Workflow",
      "id": "overview-of-the-workflow"
    },
    {
      "level": "h2",
      "text": "Frontend Integration",
      "id": "frontend-integration"
    },
    {
      "level": "h2",
      "text": "Workflow index.ts",
      "id": "workflow-index.ts"
    },
    {
      "level": "h2",
      "text": "Workflow wrangler.jsonc",
      "id": "workflow-wrangler.jsonc"
    },
    {
      "level": "h2",
      "text": "Metrics",
      "id": "metrics"
    },
    {
      "level": "h3",
      "text": "Labels and dimensions",
      "id": "labels-and-dimensions"
    },
    {
      "level": "h3",
      "text": "Event types",
      "id": "event-types"
    },
    {
      "level": "h2",
      "text": "View metrics in the dashboard",
      "id": "view-metrics-in-the-dashboard"
    },
    {
      "level": "h2",
      "text": "Query via the GraphQL API",
      "id": "query-via-the-graphql-api"
    },
    {
      "level": "h3",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h2",
      "text": "Workflow",
      "id": "workflow"
    },
    {
      "level": "h3",
      "text": "`create`",
      "id": "`create`"
    },
    {
      "level": "h3",
      "text": "`create_batch`",
      "id": "`create_batch`"
    }
  ],
  "url": "llms-txt#this-must-match-the-url-provided-in-step-6",
  "links": []
}