{
  "title": "System packages (requires apt-get update first)",
  "content": "apt-get update && apt-get install -y redis-server\ntypescript\nawait sandbox.writeFile('/workspace/app.py', 'print(\"Hello\")');\nawait sandbox.writeFile('/tmp/cache.json', '{}');\nawait sandbox.exec('ls -la /workspace');\ntypescript\nconst result = await sandbox.exec('npm test');\n// Waits for completion, returns output\ntypescript\nconst process = await sandbox.startProcess('node server.js');\n// Returns immediately, process runs in background\nbash\ncurl https://api.example.com/data\npip install requests\nnpm install express\ntypescript\nconst { hostname } = new URL(request.url);\nawait sandbox.startProcess('python -m http.server 8000');\nconst exposed = await sandbox.exposePort(8000, { hostname });\nconsole.log(exposed.exposedAt); // Public URL\nbash\nredis-server &      # Start server\nredis-cli ping      # Connect locally\ntypescript\nconst sandbox = getSandbox(env.Sandbox, `user-${userId}`);\ntypescript\nconst sandbox = getSandbox(env.Sandbox, \"user-123\");\nawait sandbox.exec('echo \"Hello\"'); // First request creates sandbox\ntypescript\nawait sandbox.destroy();\n// All files, processes, and state deleted permanently\ntypescript\nconst sandbox = getSandbox(env.Sandbox, `user-${userId}`);\ntypescript\nconst sessionId = `session-${Date.now()}-${Math.random()}`;\nconst sandbox = getSandbox(env.Sandbox, sessionId);\n// Later:\nawait sandbox.destroy();\ntypescript\nconst sandbox = getSandbox(env.Sandbox, `build-${repoName}-${commit}`);\ntypescript\ntry {\n  const sandbox = getSandbox(env.Sandbox, sessionId);\n  await sandbox.exec(\"npm run build\");\n} finally {\n  await sandbox.destroy(); // Clean up temporary sandboxes\n}\ntypescript\n// Check if required files exist before using them\nconst files = await sandbox.listFiles(\"/workspace\");\nif (!files.includes(\"data.json\")) {\n  // Reinitialize: container restarted and lost previous state\n  await sandbox.writeFile(\"/workspace/data.json\", initialData);\n}\n\nawait sandbox.exec(\"python process.py\");\ndockerfile\nFROM docker.io/cloudflare/sandbox:0.3.3  # Match your npm version\ntypescript\n// Good - Each user in separate sandbox\nconst userSandbox = getSandbox(env.Sandbox, `user-${userId}`);\n\n// Bad - Users sharing one sandbox\nconst shared = getSandbox(env.Sandbox, 'shared');\n// Users can read each other's files!\ntypescript\n// Dangerous - user input directly in command\nconst filename = userInput;\nawait sandbox.exec(`cat ${filename}`);\n// User could input: \"file.txt; rm -rf /\"\n\n// Safe - validate input\nconst filename = userInput.replace(/[^a-zA-Z0-9._-]/g, '');\nawait sandbox.exec(`cat ${filename}`);\n\n// Better - use file API\nawait sandbox.writeFile('/tmp/input', userInput);\nawait sandbox.exec('cat /tmp/input');\ntypescript\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const userId = await authenticate(request);\n    if (!userId) {\n      return new Response('Unauthorized', { status: 401 });\n    }\n\n// User can only access their sandbox\n    const sandbox = getSandbox(env.Sandbox, userId);\n    return Response.json({ authorized: true });\n  }\n};\ntypescript\nawait sandbox.unexposePort(8080);\npython\nfrom flask import Flask, request, abort\nimport os\n\napp = Flask(__name__)\n\ndef check_auth():\n    token = request.headers.get('Authorization')\n    if token != f\"Bearer {os.environ['AUTH_TOKEN']}\":\n        abort(401)\n\n@app.route('/api/data')\ndef get_data():\n    check_auth()\n    return {'data': 'protected'}\ntypescript\n// Bad - hardcoded in file\nawait sandbox.writeFile('/workspace/config.js', `\n  const API_KEY = 'sk_live_abc123';\n`);\n\n// Good - use environment variables\nawait sandbox.startProcess('node app.js', {\n  env: {\n    API_KEY: env.API_KEY,  // From Worker environment binding\n  }\n});\ntypescript\ntry {\n  await sandbox.writeFile('/tmp/sensitive.txt', secretData);\n  await sandbox.exec('python process.py /tmp/sensitive.txt');\n} finally {\n  await sandbox.deleteFile('/tmp/sensitive.txt');\n}\ntypescript\nconst sandbox = getSandbox(env.Sandbox, `user-${userId}`);\ntypescript\nconst safe = input.replace(/[^a-zA-Z0-9._-]/g, '');\nawait sandbox.exec(`command ${safe}`);\ntypescript\nawait sandbox.startProcess('node app.js', {\n  env: { API_KEY: env.API_KEY }\n});\ntypescript\ntry {\n  const sandbox = getSandbox(env.Sandbox, sessionId);\n  await sandbox.exec('npm test');\n} finally {\n  await sandbox.destroy();\n}\ntypescript\nconst sandbox = getSandbox(env.Sandbox, 'my-sandbox');\n\n// These commands run in the default session\nawait sandbox.exec(\"cd /app\");\nawait sandbox.exec(\"pwd\");  // Output: /app\n\nawait sandbox.exec(\"export MY_VAR=hello\");\nawait sandbox.exec(\"echo $MY_VAR\");  // Output: hello\ntypescript\n// This session doesn't exist yet\nconst result = await sandbox.exec('echo hello', { sessionId: 'new-session' });\n// Container automatically creates 'new-session' with defaults:\n// - cwd: '/workspace'\n// - env: {} (empty)\ntypescript\n// Create and configure a session\nconst session = await sandbox.createSession({\n  id: 'temp',\n  env: { MY_VAR: 'value' }\n});\n\n// Delete the session\nawait sandbox.deleteSession('temp');\n\n// Using the same session ID again works - auto-created with defaults\nconst result = await sandbox.exec('echo $MY_VAR', { sessionId: 'temp' });\n// Output: (empty) - MY_VAR is not set in the freshly created session\ntypescript\nconst buildSession = await sandbox.createSession({\n  id: \"build\",\n  env: { NODE_ENV: \"production\" },\n  cwd: \"/build\"\n});\n\nconst testSession = await sandbox.createSession({\n  id: \"test\",\n  env: { NODE_ENV: \"test\" },\n  cwd: \"/test\"\n});\n\n// Different shell contexts\nawait buildSession.exec(\"npm run build\");\nawait testSession.exec(\"npm test\");\ntypescript\nawait session1.exec(\"export MY_VAR=hello\");\nawait session2.exec(\"echo $MY_VAR\");  // Empty - different shell\ntypescript\nawait session1.exec(\"cd /workspace/project1\");\nawait session2.exec(\"pwd\");  // Different working directory\ntypescript\nconst session1 = await sandbox.createSession({\n  env: { API_KEY: 'key-1' }\n});\nconst session2 = await sandbox.createSession({\n  env: { API_KEY: 'key-2' }\n});\ntypescript\nawait session1.writeFile('/workspace/file.txt', 'data');\nawait session2.readFile('/workspace/file.txt');  // Can read it\ntypescript\nawait session1.startProcess('node server.js');\nawait session2.listProcesses();  // Sees the server\ntypescript\n// Phase 1: AI agent writes code (with API keys)\nconst devSession = await sandbox.createSession({\n  id: \"dev\",\n  env: { ANTHROPIC_API_KEY: env.ANTHROPIC_API_KEY }\n});\nawait devSession.exec('ai-tool \"build a web server\"');\n\n// Phase 2: Run the code (without API keys)\nconst appSession = await sandbox.createSession({\n  id: \"app\",\n  env: { PORT: \"3000\" }\n});\nawait appSession.exec(\"node server.js\");\ntypescript\ntry {\n  const session = await sandbox.createSession({ id: 'temp' });\n  await session.exec('command');\n} finally {\n  await sandbox.deleteSession('temp');\n}\ntypescript\n// This throws an error\nawait sandbox.deleteSession('default');\n// Error: Cannot delete default session. Use sandbox.destroy() instead.\ntypescript\n// Bad - affects all sessions\nawait session.exec('rm -rf /workspace/*');\n\n// For untrusted code isolation, use separate sandboxes\nconst userSandbox = getSandbox(env.Sandbox, userId);\ndockerfile\nFROM docker.io/cloudflare/sandbox:0.3.3\ndockerfile\nFROM docker.io/cloudflare/sandbox:0.3.3",
  "code_samples": [
    {
      "code": "## Filesystem\n\nThe container provides a standard Linux filesystem. You can read and write anywhere you have permissions.\n\n**Standard directories**:\n\n* `/workspace` - Default working directory for user code\n* `/tmp` - Temporary files\n* `/home` - User home directory\n* `/usr/bin`, `/usr/local/bin` - Executable binaries\n\n**Example**:",
      "language": "unknown"
    },
    {
      "code": "## Process management\n\nProcesses run as you'd expect in a regular Linux environment.\n\n**Foreground processes** (`exec()`):",
      "language": "unknown"
    },
    {
      "code": "**Background processes** (`startProcess()`):",
      "language": "unknown"
    },
    {
      "code": "## Network capabilities\n\n**Outbound connections** work:",
      "language": "unknown"
    },
    {
      "code": "**Inbound connections** require port exposure:",
      "language": "unknown"
    },
    {
      "code": "Local development\n\nWhen using `wrangler dev`, you must add `EXPOSE` directives to your Dockerfile for each port. See [Local development with ports](https://developers.cloudflare.com/sandbox/guides/expose-services/#local-development).\n\n**Localhost** works within sandbox:",
      "language": "unknown"
    },
    {
      "code": "## Security\n\n**Between sandboxes** (isolated):\n\n* Each sandbox is a separate container\n* Filesystem, memory and network are all isolated\n\n**Within sandbox** (shared):\n\n* All processes see the same files\n* Processes can communicate with each other\n* Environment variables are session-scoped\n\nTo run untrusted code, use separate sandboxes per user:",
      "language": "unknown"
    },
    {
      "code": "## Limitations\n\n**Cannot**:\n\n* Load kernel modules or access host hardware\n* Run nested containers (no Docker-in-Docker)\n\n## Related resources\n\n* [Architecture](https://developers.cloudflare.com/sandbox/concepts/architecture/) - How containers fit in the system\n* [Security model](https://developers.cloudflare.com/sandbox/concepts/security/) - Container isolation details\n* [Sandbox lifecycle](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) - Container lifecycle management\n\n</page>\n\n<page>\n---\ntitle: Sandbox lifecycle 路 Cloudflare Sandbox SDK docs\ndescription: \"A sandbox is an isolated execution environment where your code\n  runs. Each sandbox:\"\nlastUpdated: 2025-11-18T19:18:00.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/sandbox/concepts/sandboxes/\n  md: https://developers.cloudflare.com/sandbox/concepts/sandboxes/index.md\n---\n\nA sandbox is an isolated execution environment where your code runs. Each sandbox:\n\n* Has a unique identifier (sandbox ID)\n* Contains an isolated filesystem\n* Runs in a dedicated Linux container\n* Maintains state while the container is active\n* Exists as a Cloudflare Durable Object\n\n## Lifecycle states\n\n### Creation\n\nA sandbox is created the first time you reference its ID:",
      "language": "unknown"
    },
    {
      "code": "### Active\n\nThe sandbox container is running and processing requests. All state remains available: files, running processes, shell sessions, and environment variables.\n\n### Idle\n\nAfter a period of inactivity (10 minutes by default, configurable via [`sleepAfter`](https://developers.cloudflare.com/sandbox/configuration/sandbox-options/)), the container stops to free resources. When the next request arrives, a fresh container starts. All previous state is lost and the environment resets to its initial state.\n\n### Destruction\n\nSandboxes are explicitly destroyed or automatically cleaned up:",
      "language": "unknown"
    },
    {
      "code": "## Container lifetime and state\n\nSandbox state exists only while the container is active. Understanding this is critical for building reliable applications.\n\n**While the container is active** (typically minutes to hours of activity):\n\n* Files written to `/workspace`, `/tmp`, `/home` remain available\n* Background processes continue running\n* Shell sessions maintain their working directory and environment\n* Code interpreter contexts retain variables and imports\n\n**When the container stops** (due to inactivity or explicit destruction):\n\n* All files are deleted\n* All processes terminate\n* All shell state resets\n* All code interpreter contexts are cleared\n\nThe next request creates a fresh container with a clean environment.\n\n## Naming strategies\n\n### Per-user sandboxes",
      "language": "unknown"
    },
    {
      "code": "User's work persists while actively using the sandbox. Good for interactive environments, playgrounds, and notebooks where users work continuously.\n\n### Per-session sandboxes",
      "language": "unknown"
    },
    {
      "code": "Fresh environment each time. Good for one-time execution, CI/CD, and isolated tests.\n\n### Per-task sandboxes",
      "language": "unknown"
    },
    {
      "code": "Idempotent operations with clear task-to-sandbox mapping. Good for builds, pipelines, and background jobs.\n\n## Request routing\n\nThe first request to a sandbox determines its geographic location. Subsequent requests route to the same location.\n\n**For global apps**:\n\n* Option 1: Multiple sandboxes per user with region suffix (`user-123-us`, `user-123-eu`)\n* Option 2: Single sandbox per user (simpler, but some users see higher latency)\n\n## Lifecycle management\n\n### When to destroy",
      "language": "unknown"
    },
    {
      "code": "**Destroy when**: Session ends, task completes, resources no longer needed\n\n**Don't destroy**: Personal environments, long-running services\n\n### Handling container restarts\n\nContainers restart after inactivity or failures. Design your application to handle state loss:",
      "language": "unknown"
    },
    {
      "code": "## Version compatibility\n\nThe SDK automatically checks that your npm package version matches the Docker container image version. **Version mismatches can cause features to break or behave unexpectedly.**\n\n**What happens**:\n\n* On sandbox startup, the SDK queries the container's version\n* If versions don't match, a warning is logged\n* Some features may not work correctly if versions are incompatible\n\n**When you might see warnings**:\n\n* You updated the npm package (`npm install @cloudflare/sandbox@latest`) but forgot to update the `FROM` line in your Dockerfile\n\n**How to fix**: Update your Dockerfile to match your npm package version. For example, if using `@cloudflare/sandbox@0.3.3`:",
      "language": "unknown"
    },
    {
      "code": "See [Dockerfile reference](https://developers.cloudflare.com/sandbox/configuration/dockerfile/) for details on extending the base image.\n\n## Best practices\n\n* **Name consistently** - Use clear, predictable naming schemes\n* **Clean up temporary sandboxes** - Always destroy when done\n* **Reuse long-lived sandboxes** - One per user is often sufficient\n* **Batch operations** - Combine commands: `npm install && npm test && npm build`\n* **Design for ephemeral state** - Containers restart after inactivity, losing all state\n\n## Related resources\n\n* [Architecture](https://developers.cloudflare.com/sandbox/concepts/architecture/) - How sandboxes fit in the system\n* [Container runtime](https://developers.cloudflare.com/sandbox/concepts/containers/) - What runs inside sandboxes\n* [Session management](https://developers.cloudflare.com/sandbox/concepts/sessions/) - Advanced state isolation\n* [Lifecycle API](https://developers.cloudflare.com/sandbox/api/lifecycle/) - Create and manage sandboxes\n* [Sessions API](https://developers.cloudflare.com/sandbox/api/sessions/) - Create and manage execution sessions\n\n</page>\n\n<page>\n---\ntitle: Security model 路 Cloudflare Sandbox SDK docs\ndescription: The Sandbox SDK is built on Containers, which run each sandbox in\n  its own VM for strong isolation.\nlastUpdated: 2025-11-08T10:22:38.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/sandbox/concepts/security/\n  md: https://developers.cloudflare.com/sandbox/concepts/security/index.md\n---\n\nThe Sandbox SDK is built on [Containers](https://developers.cloudflare.com/containers/), which run each sandbox in its own VM for strong isolation.\n\n## Container isolation\n\nEach sandbox runs in a separate VM, providing complete isolation:\n\n* **Filesystem isolation** - Sandboxes cannot access other sandboxes' files\n* **Process isolation** - Processes in one sandbox cannot see or affect others\n* **Network isolation** - Sandboxes have separate network stacks\n* **Resource limits** - CPU, memory, and disk quotas are enforced per sandbox\n\nFor complete security details about the underlying container platform, see [Containers architecture](https://developers.cloudflare.com/containers/platform-details/architecture/).\n\n## Within a sandbox\n\nAll code within a single sandbox shares resources:\n\n* **Filesystem** - All processes see the same files\n* **Processes** - All sessions can see all processes\n* **Network** - Processes can communicate via localhost\n\nFor complete isolation, use separate sandboxes per user:",
      "language": "unknown"
    },
    {
      "code": "## Input validation\n\n### Command injection\n\nAlways validate user input before using it in commands:",
      "language": "unknown"
    },
    {
      "code": "## Authentication\n\n### Sandbox access\n\nSandbox IDs provide basic access control but aren't cryptographically secure. Add application-level authentication:",
      "language": "unknown"
    },
    {
      "code": "### Preview URLs\n\nPreview URLs include randomly generated tokens. Anyone with the URL can access the service.\n\nTo revoke access, unexpose the port:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## Secrets management\n\nUse environment variables, not hardcoded secrets:",
      "language": "unknown"
    },
    {
      "code": "Clean up temporary sensitive data:",
      "language": "unknown"
    },
    {
      "code": "## What the SDK protects against\n\n* Sandbox-to-sandbox access (VM isolation)\n* Resource exhaustion (enforced quotas)\n* Container escapes (VM-based isolation)\n\n## What you must implement\n\n* Authentication and authorization\n* Input validation and sanitization\n* Rate limiting\n* Application-level security (SQL injection, XSS, etc.)\n\n## Best practices\n\n**Use separate sandboxes for isolation**:",
      "language": "unknown"
    },
    {
      "code": "**Validate all inputs**:",
      "language": "unknown"
    },
    {
      "code": "**Use environment variables for secrets**:",
      "language": "unknown"
    },
    {
      "code": "**Clean up temporary resources**:",
      "language": "unknown"
    },
    {
      "code": "## Related resources\n\n* [Containers architecture](https://developers.cloudflare.com/containers/platform-details/architecture/) - Underlying platform security\n* [Sandbox lifecycle](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) - Resource management\n\n</page>\n\n<page>\n---\ntitle: Session management 路 Cloudflare Sandbox SDK docs\ndescription: Sessions are bash shell execution contexts within a sandbox. Think\n  of them like terminal tabs or panes in the same container.\nlastUpdated: 2025-11-08T10:22:38.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/sandbox/concepts/sessions/\n  md: https://developers.cloudflare.com/sandbox/concepts/sessions/index.md\n---\n\nSessions are bash shell execution contexts within a sandbox. Think of them like terminal tabs or panes in the same container.\n\n* **Sandbox** = A computer (container)\n* **Session** = A terminal shell session in that computer\n\n## Default session\n\nEvery sandbox has a default session that maintains shell state between commands while the container is active:",
      "language": "unknown"
    },
    {
      "code": "Working directory, environment variables, and exported variables carry over between commands. This state resets if the container restarts due to inactivity.\n\n### Automatic session creation\n\nThe container automatically creates sessions on first use. If you reference a non-existent session ID, the container creates it with default settings:",
      "language": "unknown"
    },
    {
      "code": "This behavior is particularly relevant after deleting a session:",
      "language": "unknown"
    },
    {
      "code": "This auto-creation means you can't \"break\" commands by referencing non-existent sessions. However, custom configuration (environment variables, working directory) is lost after deletion.\n\n## Creating sessions\n\nCreate additional sessions for isolated shell contexts:",
      "language": "unknown"
    },
    {
      "code": "## What's isolated per session\n\nEach session has its own:\n\n**Shell environment**:",
      "language": "unknown"
    },
    {
      "code": "**Working directory**:",
      "language": "unknown"
    },
    {
      "code": "**Environment variables** (set via `createSession` options):",
      "language": "unknown"
    },
    {
      "code": "## What's shared\n\nAll sessions in a sandbox share:\n\n**Filesystem**:",
      "language": "unknown"
    },
    {
      "code": "**Processes**:",
      "language": "unknown"
    },
    {
      "code": "## When to use sessions\n\n**Use sessions when**:\n\n* You need isolated shell state for different tasks\n* Running parallel operations with different environments\n* Keeping AI agent credentials separate from app runtime\n\n**Example - separate dev and runtime environments**:",
      "language": "unknown"
    },
    {
      "code": "**Use separate sandboxes when**:\n\n* You need complete isolation (untrusted code)\n* Different users require fully separated environments\n* Independent resource allocation is needed\n\n## Best practices\n\n### Session cleanup\n\n**Clean up temporary sessions** to free resources while keeping the sandbox running:",
      "language": "unknown"
    },
    {
      "code": "**Default session cannot be deleted**:",
      "language": "unknown"
    },
    {
      "code": "### Filesystem isolation\n\n**Sessions share filesystem** - file operations affect all sessions:",
      "language": "unknown"
    },
    {
      "code": "## Related resources\n\n* [Sandbox lifecycle](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) - Understanding sandbox management\n* [Sessions API](https://developers.cloudflare.com/sandbox/api/sessions/) - Complete session API reference\n\n</page>\n\n<page>\n---\ntitle: Dockerfile reference 路 Cloudflare Sandbox SDK docs\ndescription: Customize the sandbox container image with your own packages,\n  tools, and configurations by extending the base runtime image.\nlastUpdated: 2025-11-18T19:18:00.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/sandbox/configuration/dockerfile/\n  md: https://developers.cloudflare.com/sandbox/configuration/dockerfile/index.md\n---\n\nCustomize the sandbox container image with your own packages, tools, and configurations by extending the base runtime image.\n\n## Base image\n\nThe Sandbox SDK uses a Ubuntu-based Linux container with Python, Node.js (via Bun), and common development tools pre-installed:",
      "language": "unknown"
    },
    {
      "code": "Version synchronization required\n\nAlways match the Docker image version to your npm package version. If you're using `@cloudflare/sandbox@0.3.3`, use `docker.io/cloudflare/sandbox:0.3.3` as your base image.\n\n**Why this matters**: The SDK automatically checks version compatibility on startup. Mismatched versions can cause features to break or behave unexpectedly. If versions don't match, you'll see warnings in your logs.\n\nSee [Version compatibility](https://developers.cloudflare.com/sandbox/concepts/sandboxes/#version-compatibility) for troubleshooting version mismatch warnings.\n\n**What's included:**\n\n* Ubuntu 22.04 LTS base\n* Python 3.11.14 with pip and venv\n* Node.js 20 LTS with npm\n* Bun 1.x (JavaScript/TypeScript runtime)\n* Pre-installed Python packages: matplotlib, numpy, pandas, ipython\n* System utilities: curl, wget, git, jq, zip, unzip, file, procps, ca-certificates\n\n## Creating a custom image\n\nCreate a `Dockerfile` in your project root:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Filesystem",
      "id": "filesystem"
    },
    {
      "level": "h2",
      "text": "Process management",
      "id": "process-management"
    },
    {
      "level": "h2",
      "text": "Network capabilities",
      "id": "network-capabilities"
    },
    {
      "level": "h2",
      "text": "Security",
      "id": "security"
    },
    {
      "level": "h2",
      "text": "Limitations",
      "id": "limitations"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Lifecycle states",
      "id": "lifecycle-states"
    },
    {
      "level": "h3",
      "text": "Creation",
      "id": "creation"
    },
    {
      "level": "h3",
      "text": "Active",
      "id": "active"
    },
    {
      "level": "h3",
      "text": "Idle",
      "id": "idle"
    },
    {
      "level": "h3",
      "text": "Destruction",
      "id": "destruction"
    },
    {
      "level": "h2",
      "text": "Container lifetime and state",
      "id": "container-lifetime-and-state"
    },
    {
      "level": "h2",
      "text": "Naming strategies",
      "id": "naming-strategies"
    },
    {
      "level": "h3",
      "text": "Per-user sandboxes",
      "id": "per-user-sandboxes"
    },
    {
      "level": "h3",
      "text": "Per-session sandboxes",
      "id": "per-session-sandboxes"
    },
    {
      "level": "h3",
      "text": "Per-task sandboxes",
      "id": "per-task-sandboxes"
    },
    {
      "level": "h2",
      "text": "Request routing",
      "id": "request-routing"
    },
    {
      "level": "h2",
      "text": "Lifecycle management",
      "id": "lifecycle-management"
    },
    {
      "level": "h3",
      "text": "When to destroy",
      "id": "when-to-destroy"
    },
    {
      "level": "h3",
      "text": "Handling container restarts",
      "id": "handling-container-restarts"
    },
    {
      "level": "h2",
      "text": "Version compatibility",
      "id": "version-compatibility"
    },
    {
      "level": "h2",
      "text": "Best practices",
      "id": "best-practices"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Container isolation",
      "id": "container-isolation"
    },
    {
      "level": "h2",
      "text": "Within a sandbox",
      "id": "within-a-sandbox"
    },
    {
      "level": "h2",
      "text": "Input validation",
      "id": "input-validation"
    },
    {
      "level": "h3",
      "text": "Command injection",
      "id": "command-injection"
    },
    {
      "level": "h2",
      "text": "Authentication",
      "id": "authentication"
    },
    {
      "level": "h3",
      "text": "Sandbox access",
      "id": "sandbox-access"
    },
    {
      "level": "h3",
      "text": "Preview URLs",
      "id": "preview-urls"
    },
    {
      "level": "h2",
      "text": "Secrets management",
      "id": "secrets-management"
    },
    {
      "level": "h2",
      "text": "What the SDK protects against",
      "id": "what-the-sdk-protects-against"
    },
    {
      "level": "h2",
      "text": "What you must implement",
      "id": "what-you-must-implement"
    },
    {
      "level": "h2",
      "text": "Best practices",
      "id": "best-practices"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Default session",
      "id": "default-session"
    },
    {
      "level": "h3",
      "text": "Automatic session creation",
      "id": "automatic-session-creation"
    },
    {
      "level": "h2",
      "text": "Creating sessions",
      "id": "creating-sessions"
    },
    {
      "level": "h2",
      "text": "What's isolated per session",
      "id": "what's-isolated-per-session"
    },
    {
      "level": "h2",
      "text": "What's shared",
      "id": "what's-shared"
    },
    {
      "level": "h2",
      "text": "When to use sessions",
      "id": "when-to-use-sessions"
    },
    {
      "level": "h2",
      "text": "Best practices",
      "id": "best-practices"
    },
    {
      "level": "h3",
      "text": "Session cleanup",
      "id": "session-cleanup"
    },
    {
      "level": "h3",
      "text": "Filesystem isolation",
      "id": "filesystem-isolation"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Base image",
      "id": "base-image"
    },
    {
      "level": "h2",
      "text": "Creating a custom image",
      "id": "creating-a-custom-image"
    }
  ],
  "url": "llms-txt#system-packages-(requires-apt-get-update-first)",
  "links": []
}