{
  "title": "404",
  "content": "Check the URL, try using our [search](https://developers.cloudflare.com/search/) or try our LLM-friendly [llms.txt directory](https://developers.cloudflare.com/llms.txt).\n\n<page>\n---\ntitle: Advanced options · Cloudflare Zaraz docs\nlastUpdated: 2024-09-24T17:04:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/advanced/\n  md: https://developers.cloudflare.com/zaraz/advanced/index.md\n---\n\n* [Load Zaraz selectively](https://developers.cloudflare.com/zaraz/advanced/load-selectively/)\n* [Blocking Triggers](https://developers.cloudflare.com/zaraz/advanced/blocking-triggers/)\n* [Data layer compatibility mode](https://developers.cloudflare.com/zaraz/advanced/datalayer-compatibility/)\n* [Domains not proxied by Cloudflare](https://developers.cloudflare.com/zaraz/advanced/domains-not-proxied/)\n* [Google Consent Mode](https://developers.cloudflare.com/zaraz/advanced/google-consent-mode/)\n* [Load Zaraz manually](https://developers.cloudflare.com/zaraz/advanced/load-zaraz-manually/)\n* [Configuration Import & Export](https://developers.cloudflare.com/zaraz/advanced/import-export/)\n* [Context Enricher](https://developers.cloudflare.com/zaraz/advanced/context-enricher/)\n* [Using JSONata](https://developers.cloudflare.com/zaraz/advanced/using-jsonata/)\n* [Send Zaraz logs to Logpush](https://developers.cloudflare.com/zaraz/advanced/logpush/)\n* [Custom Managed Components](https://developers.cloudflare.com/zaraz/advanced/load-custom-managed-component/)\n\n<page>\n---\ntitle: Changelog · Cloudflare Zaraz docs\ndescription: Subscribe to RSS\nlastUpdated: 2025-02-13T19:35:19.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/changelog/\n  md: https://developers.cloudflare.com/zaraz/changelog/index.md\n---\n\n[Subscribe to RSS](https://developers.cloudflare.com/zaraz/changelog/index.xml)\n\n* **Logpush**: Add Logpush support for Zaraz\n\n* **Consent Management**: Allow forcing the consent modal language\n\n- **Zaraz Debugger**: Log the response status and body for server-side requests\n\n* **Monitoring**: Introduce \"Advanced Monitoring\" with new reports such as geography, user timeline, funnel, retention and more\n* **Monitoring**: Show information about server-side requests success rate\n\n- **Zaraz Types**: Update the `zaraz-types` package\n- **Custom HTML Managed Component**: Apply syntax highlighting for inlined JavaScript code\n\n* **Facebook Component**: Update to version 21 of the API, and fail gracefully when e-commerce payload doesn't match schema\n\n- **Zaraz Monitoring**: Show all response status codes from the Zaraz server-side requests in the dashboard\n- **Zaraz Debugger**: Fix a bug that broke the display when Custom HTML included backticks\n- **Context Enricher**: It's now possible to programatically edit the Zaraz `config` itself, in addition to the `system` and `client` objects\n- **Rocker Loader**: Issues with using Zaraz next to Rocket Loader were fixed\n- **Automatic Actions**: The tools setup flow now fully supports configuring Automatic Actions\n- **Bing Managed Component**: Issues with setting the currency field were fixed\n- **Improvement**: The allowed size for a Zaraz config was increased by 250x\n- **Improvement**: The Zaraz runtime should run faster due to multiple code optimizations\n- **Bugfix**: Fixed an issue that caused the dashboard to sometimes show \"E-commerce\" option for tools that do not support it\n\n* **Automatic Actions**: E-commerce support is now integrated with Automatic Actions\n* **Consent Management**: Support styling the Consent Modal when CSP is enabled\n* **Consent Management**: Fix an issue that could cause tools to load before consent was granted when TCF is enabled\n* **Zaraz Debugger**: Remove redundant messages related to empty values\n* **Amplitude Managed Component**: Respect the EU endpoint setting\n\n* **Automatic Actions**: Automatic Event Tracking is now fully available\n* **Consent Management**: Fixed issues with rendering the Consent modal on iOS\n* **Zaraz Debugger**: Remove redundant messages related to `__zarazEcommerce`\n* **Zaraz Debugger**: Fixed bug that prevented the debugger to load when certain Custom HTML tools were used\n\n* **Automatic Actions**: Automatic Pageview tracking is now fully available\n* **Google Analytics 4**: Support Google Consent signals when using e-commerce tracking\n* **HTTP Events API**: Ignore bot score detection on the HTTP Events API endpoint\n* **Zaraz Debugger**: Show client-side network requests initiated by Managed Components\n\n* **Automatic Actions**: New tools now support Automatic Pageview tracking\n* **HTTP Events API**: Respect Google consent signals\n\n* **Embeds**: Add support for server-side rendering of X (Twitter) and Instagram embeds\n* **CSP Compliance**: Remove `eval` dependency\n* **Google Analytics 4 Managed Component**: Allow customizing the document title and client ID fields\n* **Custom HTML Managed Component**: Scripts included in a Custom HTML will preserve their running order\n* **Google Ads Managed Component**: Allow linking data with Google Analytics 4 instances\n* **TikTok Managed Component**: Use the new TikTok Events API v2\n* **Reddit Managed Component**: Support custom events\n* **Twitter Managed Component**: Support setting the `event_id`, using custom fields, and improve conversion tracking\n* **Bugfix**: Cookie life-time cannot exceed one year anymore\n* **Bugfix**: Zaraz Debugger UI does not break when presenting really long lines of information\n\n* **Dashboard**: Add an option to disable the automatic `Pageview` event\n\n* **Amplitude Managed Component**: Allow users to choose data center\n* **Bing Managed Component**: Fix e-commerce events handling\n* **Google Analytics 4 Managed Component**: Mark e-commerce events as conversions\n* **Consent Management**: Fix IAB Consent Mode tools not showing with purposes\n\n* **Dashboard**: Add setting for Google Consent mode default\n* **Bugfix**: Cookie values are now decoded\n* **Bugfix**: Ensure context enricher worker can access the `context.system.consent` object\n* **Google Ads Managed Component**: Add conversion linker on pageviews without sending a pageview event\n* **Pinterest Conversion API Managed Component**: Bugfix handling of partial e-commerce event payloads\n\n* **Instagram Managed Component**: Improve performance of Instagram embeds\n* **Mixpanel Managed Component**: Include `gclid` and `fbclid` values in Mixpanel requests if available\n* **Consent Management**: Ensure consent platform is enabled when using IAB TCF compliant mode when there's at least one TCF-approved vendor configured\n* **Bugfix**: Ensure track data payload keys take priority over preset-keys when using enrich-payload feature for custom actions\n\n* **Consent Management**: Add `consent` object to `context.system` for finer control over consent preferences\n* **Consent Management**: Add support for IAB-compliant consent mode\n* **Consent Management**: Add \"zarazConsentChoicesUpdated\" event\n* **Consent Management**: Modal now respects system dark mode prefs when present\n* **Google Analytics 4 Managed Component**: Add support for Google Consent Mode v2\n* **Google Ads Managed Component**: Add support for Google Consent Mode v2\n* **Twitter Managed Component**: Enable tweet embeds\n* **Bing Managed Component**: Support running without setting cookies\n* **Bugfix**: `client.get` for Custom Managed Components fixed\n* **Bugfix**: Prevent duplicate pageviews in monitoring after consent granting\n* **Bugfix**: Prevent Managed Component routes from blocking origin routes unintentionally\n\n* **Single Page Applications**: Introduce `zaraz.spaPageview()` for manually triggering SPA pageviews\n* **Pinterest Managed Component**: Add ecommerce support\n* **Google Ads Managed Component**: Append url and rnd params to pagead/landing endpoint\n* **Bugfix**: Add noindex robots headers for Zaraz GET endpoint responses\n* **Bugfix**: Gracefully handle responses from custom Managed Components without mapped endpoints\n\n* **Dashboard**: rename \"tracks\" to \"events\" for consistency\n* **Pinterest Conversion API Managed Component**: update parameters sent to api\n* **HTTP Managed Component**: update \\_settings prefix usage handling\n* **Bugfix**: better minification of client-side js\n* **Bugfix**: fix bug where anchor link click events were not bubbling when using click listener triggers\n* **API update**: begin migration support from deprecated `tool.neoEvents` array to `tool.actions` object config schema migration\n\n* **Google Analytics 4 Managed Component**: Fix Google Analytics 4 average engagement time metric.\n\n* **HTTP Request Managed Component**: Re-added `__zarazTrack` property.\n\n* **Google Analytics 4 Managed Component**: Remove `debug_mode` key if falsy or `false`.\n\n* **Custom HTML**: Added support for non-JavaScript script tags.\n\n* **Bing Managed Component**: Fixed an issue where some events were not being sent to Bing even after being triggered.\n* **Dashboard**: Improved welcome screen for new Zaraz users.\n\n* **Bugfix**: Fixed an issue that prevented some server-side requests from arriving to their destination\n* **Google Analytics 4 Managed Component**: Add support for `dbg` and `ir` fields.\n\n* **Consent Management**: Add support for custom button translations.\n* **Consent Management**: Modal stays fixed when scrolling.\n* **Google Analytics 4 Managed Component**: `hideOriginalIP` and `ga-audiences` can be set from tool event.\n\n* **Reddit Managed Component**: Support new \"Account ID\" formats (e.g. \"ax\\_xxxxx\").\n\n* **Consent Management**: Consent cookie name can now be customized.\n\n* **Segment Managed Component**: API Endpoint can be customized.\n\n* **TikTok Managed Component**: Support setting `ttp` and `event_id`.\n* **Consent Management**: Accessibility improvements.\n* **Facebook Managed Component**: Support for using \"Limited Data Use\" features.\n\n<page>\n---\ntitle: Zaraz Consent Management platform · Cloudflare Zaraz docs\ndescription: Zaraz provides a Consent Management platform (CMP) to help you\n  address and manage required consents under the European General Data\n  Protection Regulation (GDPR) and the Directive on privacy and electronic\n  communications. This consent platform lets you easily create a consent modal\n  for your website based on the tools you have configured. With Zaraz CMP, you\n  can make sure Zaraz only loads tools under the umbrella of the specific\n  purposes your users have agreed to.\nlastUpdated: 2025-09-23T20:48:09.000Z\nchatbotDeprioritize: false\ntags: Privacy\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/consent-management/\n  md: https://developers.cloudflare.com/zaraz/consent-management/index.md\n---\n\nZaraz provides a Consent Management platform (CMP) to help you address and manage required consents under the European [General Data Protection Regulation (GDPR)](https://gdpr-info.eu/) and the [Directive on privacy and electronic communications](https://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:02002L0058-20091219\\&from=EN#tocId7). This consent platform lets you easily create a consent modal for your website based on the tools you have configured. With Zaraz CMP, you can make sure Zaraz only loads tools under the umbrella of the specific purposes your users have agreed to.\n\nThe consent modal added to your website is concise and gives your users an easy way to opt-in to any purposes of data processing your tools need.\n\n## Crucial vocabulary\n\nThe Zaraz Consent Management platform (CMP) has a **Purposes** section. This is where you will have to create purposes for the third-party tools your website uses. To better understand the terms involved in dealing with personal data, refer to these definitions:\n\n* **Purpose**: The reason you are loading a given tool on your website, such as to track conversions or improve your website’s layout based on behavior tracking. One purpose can be assigned to many tools, but one tool can be assigned only to one purpose.\n* **Consent**: An affirmative action that the user makes, required to store and access cookies (or other persistent data, like `LocalStorage`) on the users’ computer/browser.\n\nAll tools use consent as a legal basis. This is due to the fact that they all use cookies that are not strictly necessary for the website’s correct operation. Due to this, all purposes are opt-in.\n\n## Purposes and tools\n\nWhen you add a new tool to your website, Zaraz does not assign any purpose to it. This means that this tool will skip consent by default. Remember to check the [Consent Management settings](https://developers.cloudflare.com/zaraz/consent-management/enable-consent-management/) every time you set up a new tool. This helps ensure you avoid a situation where your tool is triggered before the user gives consent.\n\nThe user’s consent preferences are stored within a first-party cookie. This cookie is a JSON file that maps the purposes’ ID to a `true`/`false`/missing value:\n\n* `true` value: The user gave consent.\n* `false`value: The user refused consent.\n* Missing value: The user has not made a choice yet.\n\nCloudflare cannot recommend nor assign by default any specific purpose for your tools. It is your responsibility to properly assign tools to purposes if you need to comply with GDPR.\n\n## Important things to note\n\n* Purposes that have no tools assigned will not show up in the CMP modal.\n* If a tool is assigned to a purpose, it will not run unless the user gives consent for the purpose the tool is assigned for.\n* Once your website loads for a given user for the first time, all the triggers you have configured for tools that are waiting for consent are cached in the browser. Then, they will be fired when/if the user gives consent, so they are not lost.\n* If the user visits your website for the first time, the consent modal will automatically show up. This also happens if the user has previously visited your website, but in the meantime you have enabled CMP.\n* On subsequent visits, the modal will not show up. You can make the modal show up by calling the function `zaraz.showConsentModal()` — for example, by binding it to a button.\n\n<page>\n---\ntitle: Create a third-party tool action · Cloudflare Zaraz docs\ndescription: Tools on Zaraz must have actions configured in order to do\n  something. Often, using Automatic Actions is enough for configuring a tool.\n  But you might want to use Custom Actions to create a more customized setup, or\n  perhaps you are using a tool that does not support Automatic Actions. In these\n  cases, you will need to configure Custom Actions manually.\nlastUpdated: 2024-09-24T17:04:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/custom-actions/\n  md: https://developers.cloudflare.com/zaraz/custom-actions/index.md\n---\n\nTools on Zaraz must have actions configured in order to do something. Often, using Automatic Actions is enough for configuring a tool. But you might want to use Custom Actions to create a more customized setup, or perhaps you are using a tool that does not support Automatic Actions. In these cases, you will need to configure Custom Actions manually.\n\nEvery action has firing triggers assigned to it. When the conditions of the firing triggers are met, the action will start. An action can be anything the tool can do - sending analytics information, showing a widget, adding a script and much more.\n\nTo start using actions, first [create a trigger](https://developers.cloudflare.com/zaraz/custom-actions/create-trigger/) to determine when this action will start. If you have already set up a trigger, or if you are using one of the built-in triggers, follow these steps to [create an action](https://developers.cloudflare.com/zaraz/custom-actions/create-action/).\n\n<page>\n---\ntitle: Embeds · Cloudflare Zaraz docs\ndescription: Embeds are tools for incorporating external content, like social\n  media posts, directly onto webpages, enhancing user engagement without\n  compromising site performance and security.\nlastUpdated: 2025-09-05T07:54:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/embeds/\n  md: https://developers.cloudflare.com/zaraz/embeds/index.md\n---\n\nEmbeds are tools for incorporating external content, like social media posts, directly onto webpages, enhancing user engagement without compromising site performance and security.\n\nCloudflare Zaraz introduces server-side rendering for embeds, avoiding third-party JavaScript to improve security, privacy, and page speed. This method processes content on the server side, removing the need for direct communication between the user's browser and third-party servers.\n\nTo add an Embed to Your Website:\n\n1. In the Cloudflare dashboard, go to the **Tag Setup** page.\n\n[Go to **Tag setup**](https://dash.cloudflare.com/?to=/:account/tag-management/zaraz)\n\n2. Go to **Tools Configuration**.\n\n3. Click \"add new tool\" and activate the desired tools on your Cloudflare Zaraz dashboard.\n\n4. Add a placeholder in your HTML, specifying the necessary attributes. For a generic embed, the snippet looks like this:\n\nReplace `componentName`, `embedName` and `attribute=\"value\"` with the specific Managed Component requirements. Zaraz automatically detects placeholders and replaces them with the content in a secure and efficient way.\n\n### X (Twitter) embed\n\nReplace `tweet-id` with the actual tweet ID for the content you wish to embed.\n\nReplace `post-url` with the actual URL for the content you wish to embed. To include posts captions set captions attribute to `true`.\n\n<page>\n---\ntitle: FAQ · Cloudflare Zaraz docs\ndescription: Below you will find answers to our most commonly asked questions.\n  If you cannot find the answer you are looking for, refer to the community page\n  or Discord channel to explore additional resources.\nlastUpdated: 2025-09-05T07:54:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/faq/\n  md: https://developers.cloudflare.com/zaraz/faq/index.md\n---\n\nBelow you will find answers to our most commonly asked questions. If you cannot find the answer you are looking for, refer to the [community page](https://community.cloudflare.com/) or [Discord channel](https://discord.cloudflare.com) to explore additional resources.\n\n* [General](#general)\n* [Tools](#tools)\n* [Consent](#consent)\n\nIf you're looking for information regarding Zaraz Pricing, see the [Zaraz Pricing](https://developers.cloudflare.com/zaraz/pricing-info/) page.\n\n#### Why is Zaraz not working?\n\nIf you are experiencing issues with Zaraz, there could be multiple reasons behind it. First, it's important to verify that the Zaraz script is loading properly on your website.\n\nTo check if the script is loading correctly, follow these steps:\n\n1. Open your website in a web browser.\n2. Open your browser's Developer Tools.\n3. In the Console, type `zaraz`.\n4. If you see an error message saying `zaraz is not defined`, it means that Zaraz failed to load.\n\nIf Zaraz is not loading, please verify the following:\n\n* The domain running Zaraz [is proxied by Cloudflare](https://developers.cloudflare.com/dns/proxy-status/).\n* Auto Injection is enabled in your [Zaraz Settings](https://developers.cloudflare.com/zaraz/reference/settings/#auto-inject-script).\n* Your website's HTML is valid and includes `<head>` and `</head>` tags.\n* You have at least [one enabled tool](https://developers.cloudflare.com/zaraz/get-started/) configured in Zaraz.\n\n#### The browser extension I'm using cannot find the tool I have added. Why?\n\nZaraz is loading tools server-side, which means code running in the browser will not be able to see it. Running tools server-side is better for your website performance and privacy, but it also means you cannot use normal browser extensions to debug your Zaraz tools.\n\n#### I'm seeing some data discrepancies. Is there a way to check what data reaches Zaraz?\n\nYes. You can use the metrics in [Zaraz Monitoring](https://developers.cloudflare.com/zaraz/monitoring/) and [Debug Mode](https://developers.cloudflare.com/zaraz/web-api/debug-mode/) to help you find where in the workflow the problem occurred.\n\n#### Can I use Zaraz with Rocket Loader?\n\nWe recommend disabling [Rocket Loader](https://developers.cloudflare.com/speed/optimization/content/rocket-loader/) when using Zaraz. While Zaraz can be used together with Rocket Loader, there's usually no need to use both. Rocket Loader can sometimes delay data from reaching Zaraz, causing issues.\n\n#### Is Zaraz compatible with Content Security Policies (CSP)?\n\nYes. To learn more about how Zaraz compatibility with [CSP](https://developers.cloudflare.com/fundamentals/reference/policies-compliances/content-security-policies/) configurations works, refer to the [Cloudflare Zaraz supports CSP](https://blog.cloudflare.com/cloudflare-zaraz-supports-csp/) blog post.\n\n#### Does Cloudflare process my HTML, removing existing scripts and then injecting Zaraz?\n\nCloudflare Zaraz does not remove other third-party scripts from the page. Zaraz [can be auto-injected or not](https://developers.cloudflare.com/zaraz/reference/settings/#auto-inject-script), depending on your configuration, but if you have existing scripts that you intend to load with Zaraz, you should remove them.\n\n#### Does Zaraz work with Cloudflare Page Shield?\n\nYes. Refer to [Page Shield](https://developers.cloudflare.com/page-shield/) for more information related to this product.\n\n#### Is there a way to prevent Zaraz from loading on specific pages, like under `/wp-admin`?\n\nTo prevent Zaraz from loading on specific pages, refer to [Load Zaraz selectively](https://developers.cloudflare.com/zaraz/advanced/load-selectively/).\n\n#### How can I remove my Zaraz configuration?\n\nResetting your Zaraz configuration will erase all of your configuration settings, including any tools, triggers, and variables you've set up. This action will disable Zaraz immediately. If you want to start over with a clean slate, you can always reset your configuration.\n\n1. In the Cloudflare dashboard, go to the **Settings** page.\n\n[Go to **Settings**](https://dash.cloudflare.com/?to=/:account/tag-management/settings)\n\n2. Go to **Advanced**.\n\n3. Click \"Reset\" and follow the instructions.\n\n#### Why would the `zaraz.ecommerce()` method returns an undefined error?\n\nE-commerce tracking needs to be enabled in [the Zaraz Settings page](https://developers.cloudflare.com/zaraz/reference/settings/#e-commerce-tracking) before you can start using the E-commerce Web API.\n\n#### How would I trigger pageviews manually on a Single Page Application (SPA)?\n\nZaraz comes with built-in [Single Page Application (SPA) support](https://developers.cloudflare.com/zaraz/reference/settings/#single-page-application-support) that automatically sends pageview events when navigating through the pages of your SPA. However, if you have advanced use cases, you might want to build your own system to trigger pageviews. In such cases, you can use the internal SPA pageview event by calling `zaraz.spaPageview()`.\n\n#### After moving from Google Analytics 4 to Zaraz, I can no longer see demographics data. Why?\n\nYou probably have enabled **Hide Originating IP Address** in the [Settings option](https://developers.cloudflare.com/zaraz/custom-actions/edit-tools-and-actions/) for Google Analytics 4. This tells Zaraz to not send the IP address to Google. To have access to demographics data and anonymize your visitor's IP, you should use [**Anonymize Originating IP Address**](#i-see-two-ways-of-anonymizing-ip-address-information-on-the-third-party-tool-google-analytics-one-in-privacy-and-one-in-additional-fields-which-is-the-correct-one) instead.\n\n#### I see two ways of anonymizing IP address information on the third-party tool Google Analytics: one in Privacy, and one in Additional fields. Which is the correct one?\n\nThere is not a correct option, as the two options available in Google Analytics (GA) do different things.\n\nThe \"Hide Originating IP Address\" option in [Tool Settings](https://developers.cloudflare.com/zaraz/custom-actions/edit-tools-and-actions/) prevents Zaraz from sending the IP address from a visitor to Google. This means that GA treats Zaraz's Worker's IP address as the visitor's IP address. This is often close in terms of location, but it might not be.\n\nWith the **Anonymize Originating IP Address** available in the [Add field](https://developers.cloudflare.com/zaraz/custom-actions/additional-fields/) option, Cloudflare sends the visitor's IP address to Google as is, and passes the 'aip' parameter to GA. This asks GA to anonymize the data.\n\n#### If I set up Event Reporting (enhanced measurements) for Google Analytics, why does Zaraz only report Page View, Session Start, and First Visit?\n\nThis is not a bug. Zaraz does not offer all the automatic events the normal GA4 JavaScript snippets offer out of the box. You will need to build [triggers](https://developers.cloudflare.com/zaraz/custom-actions/create-trigger/) and [actions](https://developers.cloudflare.com/zaraz/custom-actions/) to capture those events. Refer to [Get started](https://developers.cloudflare.com/zaraz/get-started/) to learn more about how Zaraz works.\n\n#### Can I set up custom dimensions for Google Analytics with Zaraz?\n\nYes. Refer to [Additional fields](https://developers.cloudflare.com/zaraz/custom-actions/additional-fields/) to learn how to send additional data to tools.\n\n#### How do I attach a User Property to my events?\n\nIn your Google Analytics 4 action, select **Add field** > **Add custom field...** and enter a field name that starts with `up.` — for example, `up.name`. This will make Zaraz send the field as a User Property and not as an Event Property.\n\n#### How can I enable Google Consent Mode signals?\n\nZaraz has built-in support for Google Consent Mode v2. Learn more on how to use it in [Google Consent Mode page](https://developers.cloudflare.com/zaraz/advanced/google-consent-mode/).\n\n#### If I set up Facebook Pixel on my Zaraz account, why am I not seeing data coming through?\n\nIt can take between 15 minutes to several hours for data to appear on Facebook's interface, due the way Facebook Pixel works. You can also use [debug mode](https://developers.cloudflare.com/zaraz/web-api/debug-mode/) to confirm that data is being properly sent from your Zaraz account.\n\n#### What is the expected format for Conversion ID and Conversion Label\n\nConversion ID and Conversion Label are usually provided by Google Ads as a \"gtag script\". Here's an example for a $1 USD conversion:\n\nThe Conversion ID is the first part of `send_to` parameter, without the `AW-`. In the above example it would be `123456789`. The Conversion Label is the second part of the `send_to` parameter, therefore `AbC-D_efG-h12_34-567` in the above example. When setting up your Google Ads conversions through Zaraz, take the information from the original scripts you were asked to implement.\n\n#### Can I use Google Tag Manager together with Zaraz?\n\nYou can load Google Tag Manager using Zaraz, but it is not recommended. Tools configured inside Google Tag Manager cannot be optimized by Zaraz, and cannot be restricted by the Zaraz privacy controls. In addition, Google Tag Manager could slow down your website because it requires additional JavaScript, and its rules are evaluated client-side. If you are currently using Google Tag Manager, we recommend replacing it with Zaraz by configuring your tags directly as Zaraz tools.\n\n#### Why should I prefer a native tool integration instead of an HTML snippet?\n\nAdding a tool to your website via a native Zaraz integration is always better than using an HTML snippet. HTML snippets usually depends on additional client-side requests, and require client-side code execution, which can slow down your website. They are often a security risk, as they can be hacked. Moreover, it can be very difficult to control their affect on the privacy of your visitors. Tools included in the Zaraz library are not suffering from these issues - they are fast, executed at the edge, and be controlled and restricted because they are sandboxed.\n\n#### How can I set my Custom HTML to be injected just once in my Single Page App (SPA) website?\n\nIf you have enabled \"Single Page Application support\" in Zaraz Settings, your Custom HTML code may be unnecessarily injected every time a new SPA page is loaded. This can result in duplicates. To avoid this, go to your Custom HTML action and select the \"Add Field\" option. Then, add the \"Ignore SPA\" field and enable the toggle switch. Doing so will prevent your code from firing on every SPA pageview and ensure that it is injected only once.\n\n#### What if I want to use a tool that is not supported by Zaraz?\n\nThe Zaraz engineering team is adding support to new tools all the time. You can also refer to the [community space](https://community.cloudflare.com/c/developers/integrationrequest/68) to ask for new integrations.\n\n#### I cannot get a tool to load when the website is loaded. Do I have to add code to my website?\n\nIf you proxy your domain through Cloudflare, you do not need to add any code to your website. By default, Zaraz includes an automated `Pageview` trigger. Some tools, like Google Analytics, automatically add a `Pageview` action that uses this trigger. With other tools, you will need to add it manually. Refer to [Get started](https://developers.cloudflare.com/zaraz/get-started/) for more information.\n\n#### I am a vendor. How can I integrate my tool with Zaraz?\n\nThe Zaraz team is working with third-party vendors to build their own Zaraz integrations using the Zaraz SDK. To request a new tool integration, or to collaborate on our SDK, contact us at <zaraz@cloudflare.com>.\n\n### How do I show the consent modal again to all users?\n\nIn such a case, you can change the cookie name in the *Consent cookie name* field in the Zaraz Consent configuration. This will cause the consent modal to reappear for all users. Make sure to use a cookie name that has not been used for Zaraz on your site.\n\n<page>\n---\ntitle: Get started · Cloudflare Zaraz docs\ndescription: Before being able to use Zaraz, it is recommended that you proxy\n  your website through Cloudflare. Refer to Set up Cloudflare for more\n  information. If you do not want to proxy your website through Cloudflare,\n  refer to Use Zaraz on domains not proxied by Cloudflare.\nlastUpdated: 2025-09-05T07:54:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/get-started/\n  md: https://developers.cloudflare.com/zaraz/get-started/index.md\n---\n\nBefore being able to use Zaraz, it is recommended that you proxy your website through Cloudflare. Refer to [Set up Cloudflare](https://developers.cloudflare.com/fundamentals/account/) for more information. If you do not want to proxy your website through Cloudflare, refer to [Use Zaraz on domains not proxied by Cloudflare](https://developers.cloudflare.com/zaraz/advanced/domains-not-proxied/).\n\n## Add a third-party tool to your website\n\nYou can add new third-party tools and load them into your website through the Cloudflare dashboard.\n\n1. In the Cloudflare dashboard, go to the **Tag Setup** page.\n\n[Go to **Tag setup**](https://dash.cloudflare.com/?to=/:account/tag-management/zaraz)\n\n2. If you have already added a tool before, select **Third-party tools** and click on **Add new tool**.\n\n3. Choose a tool from the tools catalog. Select **Continue** to confirm your selection.\n\n4. In **Set up**, configure the settings for your new tool. The information you need to enter will depend on the tool you choose. If you want to use any dynamic properties or variables, select the `+` sign in the drop-down menu next to the relevant field.\n\n5. In **Actions** setup the actions for your new tool. You should be able to select Pageviews, Events or E-Commerce [1](#user-content-fn-1).\n\n## Events, triggers and actions\n\nZaraz relies on events, triggers and actions to determine when to load the tools you need in your website, and what action they need to perform. The way you configure Zaraz and where you start largely depend on the tool you wish to use. When using a tool that supports Automatic Actions, this process is largely done for you. If the tool you are adding doesn't support Automatic Actions, read more about configuring [Custom Actions](https://developers.cloudflare.com/zaraz/custom-actions).\n\nWhen using Automatic Actions, the available actions are as follows:\n\n* **Pageviews** - for tracking every pageview on your website\n* **Events** - For tracking calls using the [`zaraz.track` Web API](https://developers.cloudflare.com/zaraz/web-api/track)\n* **E-commerce** - For tracking calls to [`zaraz.ecommerce` Web API](https://developers.cloudflare.com/zaraz/web-api/ecommerce)\n\nIf you need to programmatically start actions in your tools, Cloudflare Zaraz provides a unified Web API to send events to Zaraz, and from there, to third-party tools. This Web API includes the `zaraz.track()`, `zaraz.set()` and `zaraz.ecommerce()` methods.\n\n[The Track method](https://developers.cloudflare.com/zaraz/web-api/track/) allows you to track custom events and actions on your website that might happen in real time. [The Set method](https://developers.cloudflare.com/zaraz/web-api/set/) is an easy shortcut to define a variable once and have it sent with every future Track call. [E-commerce](https://developers.cloudflare.com/zaraz/web-api/ecommerce/) is a unified method for sending e-commerce related data to multiple tools without needing to configure triggers and events. Refer to [Web API](https://developers.cloudflare.com/zaraz/web-api/) for more information.\n\nIf you suspect that something is not working the way it should, or if you want to verify the operation of tools on your website, read more about [Debug Mode](https://developers.cloudflare.com/zaraz/web-api/debug-mode/) and [Zaraz Monitoring](https://developers.cloudflare.com/zaraz/monitoring/). Also, check the [FAQ](https://developers.cloudflare.com/zaraz/faq/) page to see if your question was already answered there.\n\nUsers and companies have developed plugins that make using Zaraz easier on specific platforms. We recommend checking out these plugins if you are using one of these platforms.\n\n* [Beetle Tracking](https://beetle-tracking.com/) - Integrate Zaraz with your WordPress WooCommerce website to track e-commerce events with zero configuration. Beetle Tracking also supports consent management and other advanced features.\n\n1. Some tools do not supported Automatic Actions, see the section about [Custom Actions](https://developers.cloudflare.com/zaraz/custom-actions) if the tool you are adding doesn't present Automatic Actions. [↩](#user-content-fnref-1)\n\n<page>\n---\ntitle: Versions & History · Cloudflare Zaraz docs\ndescription: Zaraz can work in real-time. In this mode, every change you make is\n  instantly published. You can also enable Preview & Publish mode, which allows\n  you to test your changes before you commit to them.\nlastUpdated: 2024-09-24T17:04:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/history/\n  md: https://developers.cloudflare.com/zaraz/history/index.md\n---\n\nZaraz can work in real-time. In this mode, every change you make is instantly published. You can also enable [Preview & Publish mode](https://developers.cloudflare.com/zaraz/history/preview-mode/), which allows you to test your changes before you commit to them.\n\nWhen enabling Preview & Publish mode, you will also have access to [Zaraz History](https://developers.cloudflare.com/zaraz/history/versions/). Zaraz History shows you a list of all the changes made to your settings, and allows you to revert to any previous settings.\n\n* [Preview mode](https://developers.cloudflare.com/zaraz/history/preview-mode/)\n* [Versions](https://developers.cloudflare.com/zaraz/history/versions/)\n\n<page>\n---\ntitle: HTTP Events API · Cloudflare Zaraz docs\ndescription: The Zaraz HTTP Events API allows you to send information to Zaraz\n  from places that cannot run the Web API, such as your server or your mobile\n  app. It is useful for tracking events that are happening outside the browser,\n  like successful transactions, sign-ups and more. The API also allows sending\n  multiple events in batches.\nlastUpdated: 2025-09-05T07:54:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/http-events-api/\n  md: https://developers.cloudflare.com/zaraz/http-events-api/index.md\n---\n\nThe Zaraz HTTP Events API allows you to send information to Zaraz from places that cannot run the [Web API](https://developers.cloudflare.com/zaraz/web-api/), such as your server or your mobile app. It is useful for tracking events that are happening outside the browser, like successful transactions, sign-ups and more. The API also allows sending multiple events in batches.\n\n## Configure the API endpoint\n\nThe API is disabled unless you configure an endpoint for it. The endpoint determines under what URL the API will be accessible. For example, if you set the endpoint to be `/zaraz/api`, and your domain is `example.com`, requests to the API will go to `https://example.com/zaraz/api`.\n\nTo enable the API endpoint:\n\n1. In the Cloudflare dashboard, go to the **Settings** page.\n\n[Go to **Settings**](https://dash.cloudflare.com/?to=/:account/tag-management/settings)\n\n2. Under **Endpoints** > **HTTP Events API**, set your desired path. Remember the path is relative to your domain, and it must start with a `/`.\n\nTo avoid getting the API used by unwanted actors, Cloudflare recommends choosing a unique path.\n\nThe endpoint you have configured for the API will receive `POST` requests with a JSON payload. Below, there is an example payload:\n\nThe payload must contain an `events` array. Each Event Object in this array corresponds to one event you want Zaraz to process. The above example is similar to calling `zaraz.track('transaction successful', { value: \"200\" })` using the Web API.\n\nThe Event Object holds the `client` object, in which you can pass information about the event itself. Every key you include in the Event Object will be available as a *Track Property* in the Zaraz dashboard.\n\nThere are two reserved keys:\n\n* `__zarazTrack`: The value of this key will be available as *Event Name*. This is what you will usually build your triggers around. In the above example, setting this to `transaction successful` is the same as [using the Web API](https://developers.cloudflare.com/zaraz/web-api/track/) and calling `zaraz.track(\"transaction successful\")`.\n* `__zarazEcommerce`: This key needs to be set to `true` if you want Zaraz to process the event as an e-commerce event.\n\nIn addition to the `client` key, you can use the `system` key to include information about the device from which the event originated. For example, you can submit the `User-Agent` string, the cookies and the screen resolution. Zaraz will use this information when connecting to different third-party tools. Since some tools depend on certain fields, it is often useful to include all the information you can.\n\nThe same payload from before will resemble the following example, when we add the `system` information:\n\nFor all available system keys, refer to the table below:\n\n| Property | Type | Description |\n| - | - | - |\n| `system.cookies` | Object | A key-value object holding cookies from the device associated with the event. |\n| `system.device.ip` | String | The IP address of the device associated with the event. |\n| `system.device.resolution` | String | The screen resolution of the device associated with the event, in a `WIDTHxHEIGHT` format. |\n| `system.device.viewport` | String | The viewport of the device associated with the event, in a `WIDTHxHEIGHT` format. |\n| `system.device.language` | String | The language code used by the device associated with the event. |\n| `system.device.user-agent` | String | The `User-Agent` string of the device associated with the event. |\n| `system.page.title` | String | The title of the page associated with the event. |\n| `system.page.url` | String | The URL of the page associated with the event. |\n| `system.page.referrer` | String | The URL of the referrer page in the time the event took place. |\n| `system.page.encoding` | String | The encoding of the page associated with the event. |\n\nIt is currently not possible to override location related properties, such as City, Country, and Continent.\n\n## Process API responses\n\nFor each Event Object in your payload, Zaraz will respond with a Result Object. The Result Objects order matches the order of your Event Objects.\n\nDepending on what tools you are loading using Zaraz, the body of the response coming from the API might include information you will want to process. This is because some tools do not have a complete server-side implementation and still depend on cookies, client-side JavaScript or similar mechanisms. Each Result Object can include the following information:\n\n| Result key | Description |\n| - | - |\n| `fetch` | Fetch requests that tools want to send from the user browser. |\n| `execute` | JavaScript code that tools want to execute in the user browser. |\n| `return` | Information that tools return. |\n| `cookies` | Cookies that tools want to set for the user. |\n\nYou do not have to process the information above, but some tools might depend on this to work properly. You can start using the HTTP Events API without processing the information in the table above, and adjust accordingly later.\n\n<page>\n---\ntitle: Monitoring · Cloudflare Zaraz docs\ndescription: Zaraz Monitoring shows you different metrics regarding Zaraz. This\n  helps you to detect issues when they occur. For example, if a third-party\n  analytics provider stops collecting data, you can use the information\n  presented by Zaraz Monitoring to find where in the workflow the problem\n  occurred.\nlastUpdated: 2025-09-05T07:54:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/monitoring/\n  md: https://developers.cloudflare.com/zaraz/monitoring/index.md\n---\n\nZaraz Monitoring shows you different metrics regarding Zaraz. This helps you to detect issues when they occur. For example, if a third-party analytics provider stops collecting data, you can use the information presented by Zaraz Monitoring to find where in the workflow the problem occurred.\n\nYou can also check activity data in the **Activity last 24hr** section, when you access [tools](https://developers.cloudflare.com/zaraz/get-started/), [actions](https://developers.cloudflare.com/zaraz/custom-actions/) and [triggers](https://developers.cloudflare.com/zaraz/custom-actions/create-trigger/) in the dashboard.\n\nTo use Zaraz Monitoring:\n\n1. In the Cloudflare dashboard, go to the **Monitoring** page.\n\n[Go to **Monitoring**](https://dash.cloudflare.com/?to=/:account/tag-management/monitoring)\n\n2. Select one of the options (Loads, Events, Triggers, Actions). Zaraz Monitoring will show you how the traffic for that section evolved for the time period selected.\n\n## Zaraz Monitoring options\n\n* **Loads**: Counts how many times Zaraz was loaded on pages of your website. When [Single Page Application support](https://developers.cloudflare.com/zaraz/reference/settings/#single-page-application-support) is enabled, Loads will count every change of navigation as well.\n* **Events**: Counts how many times a specific event was tracked by Zaraz. It includes the [Pageview event](https://developers.cloudflare.com/zaraz/get-started/), [Track events](https://developers.cloudflare.com/zaraz/web-api/track/), and [E-commerce events](https://developers.cloudflare.com/zaraz/web-api/ecommerce/).\n* **Triggers**: Counts how many times a specific trigger was activated. It includes the built-in [Pageview trigger](https://developers.cloudflare.com/zaraz/custom-actions/create-trigger/) and any other trigger you set in Zaraz.\n* **Actions**: Counts how many times a [specific action](https://developers.cloudflare.com/zaraz/custom-actions/) was activated. It includes the pre-configured Pageview action, and any other actions you set in Zaraz.\n* **Server-side requests**: tracks the status codes returned from server-side requests that Zaraz makes to your third-party tools.\n\n<page>\n---\ntitle: Pricing · Cloudflare Zaraz docs\ndescription: Zaraz is available to all Cloudflare users, across all tiers. Each\n  month, every Cloudflare account gets 1,000,000 free Zaraz Events. For\n  additional usage, the Zaraz Paid plan costs $5 per month for each additional\n  1,000,000 Zaraz Events.\nlastUpdated: 2025-09-23T13:15:19.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/pricing-info/\n  md: https://developers.cloudflare.com/zaraz/pricing-info/index.md\n---\n\nZaraz is available to all Cloudflare users, across all tiers. Each month, every Cloudflare account gets 1,000,000 free Zaraz Events. For additional usage, the Zaraz Paid plan costs $5 per month for each additional 1,000,000 Zaraz Events.\n\nAll Zaraz features and tools are always available on all accounts. Learn more about our pricing in [the following pricing announcement](https://blog.cloudflare.com/zaraz-announces-new-pricing)\n\n## The Zaraz Event unit\n\nOne Zaraz Event is an event you are sending to Zaraz, whether that is a page view, a `zaraz.track` event, or similar. You can easily see the total number of Zaraz Events you are currently using on the **Monitoring** page of the Cloudflare dashboard:\n\n[Go to **Monitoring**](https://dash.cloudflare.com/?to=/:account/tag-management/monitoring)\n\n## Enabling Zaraz Paid\n\n1. In the Cloudflare dashboard, go to the **Zaraz plans** page.\n\n[Go to **Zaraz plans**](https://dash.cloudflare.com/?to=/:account/tag-management/plans)\n\n2. Click the **Enable Zaraz usage billing** button and follow the instructions.\n\nIf you don't enable Zaraz Paid, you'll receive email notifications when you reach 50%, 80%, and 90% of your free allocation. Zaraz will be disabled until the next billing cycle if you exceed 1,000,000 events without enabling Zaraz Paid.\n\n<page>\n---\ntitle: Reference · Cloudflare Zaraz docs\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/reference/\n  md: https://developers.cloudflare.com/zaraz/reference/index.md\n---\n\n* [Zaraz Context](https://developers.cloudflare.com/zaraz/reference/context/)\n* [Properties reference](https://developers.cloudflare.com/zaraz/reference/properties-reference/)\n* [Settings](https://developers.cloudflare.com/zaraz/reference/settings/)\n* [Third-party tools](https://developers.cloudflare.com/zaraz/reference/supported-tools/)\n* [Triggers and rules](https://developers.cloudflare.com/zaraz/reference/triggers/)\n\n<page>\n---\ntitle: Web API · Cloudflare Zaraz docs\ndescription: Zaraz provides a client-side web API that you can use anywhere\n  inside the <body> tag of a page.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/web-api/\n  md: https://developers.cloudflare.com/zaraz/web-api/index.md\n---\n\nZaraz provides a client-side web API that you can use anywhere inside the `<body>` tag of a page.\n\nThis API allows you to send events and data to Zaraz, that you can later use when creating your triggers. Using the API lets you tailor the behavior of Zaraz to your needs: You can launch tools only when you need them, or send information you care about that is not otherwise automatically collected from your site.\n\n* [Track](https://developers.cloudflare.com/zaraz/web-api/track/)\n* [Set](https://developers.cloudflare.com/zaraz/web-api/set/)\n* [E-commerce](https://developers.cloudflare.com/zaraz/web-api/ecommerce/)\n* [Debug mode](https://developers.cloudflare.com/zaraz/web-api/debug-mode/)\n\n<page>\n---\ntitle: Variables · Cloudflare Zaraz docs\nlastUpdated: 2024-09-24T17:04:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/variables/\n  md: https://developers.cloudflare.com/zaraz/variables/index.md\n---\n\n* [Create a variable](https://developers.cloudflare.com/zaraz/variables/create-variables/)\n* [Edit variables](https://developers.cloudflare.com/zaraz/variables/edit-variables/)\n* [Worker Variables](https://developers.cloudflare.com/zaraz/variables/worker-variables/)\n\n<page>\n---\ntitle: DNS in Google Sheets · Cloudflare 1.1.1.1 docs\ndescription: Cloudflare 1.1.1 works directly inside Google Sheets. To get\n  started, create a Google Function with the following code.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-in-google-sheets/\n  md: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-in-google-sheets/index.md\n---\n\n1.1.1.1 works directly inside Google Sheets. To get started, create a [Google Function](https://developers.google.com/apps-script/guides/sheets/functions) with the following code:\n\nWhen you feed the function `NSLookup` a record type and a domain, you will get a DNS record value in the cell you called `NSLookup`.\n\nTo limit the number of DNS lookups and speed up the results (especially in larger Google Sheets), you can cache the returned DNS record value. Both the cache usage and the cache TTL can be controlled in arguments 3 and 4, respectively.\n\nSupported DNS record types\n\n* `A`\n* `AAAA`\n* `CAA`\n* `CNAME`\n* `DS`\n* `DNSKEY`\n* `MX`\n* `NS`\n* `NSEC`\n* `NSEC3`\n* `RRSIG`\n* `SOA`\n* `TXT`\n\nOr - depending on your regional settings - you may have to use this formula:\n\n![Google sheets function](https://developers.cloudflare.com/_astro/google-sheet-function.B_K9dB4i_B0eSL.webp)\n\n![Google sheets function](https://developers.cloudflare.com/_astro/google-sheet-result.qjsyQyZU_ZuvlJi.webp)\n\n<page>\n---\ntitle: DNS over Discord · Cloudflare 1.1.1.1 docs\ndescription: 1.1. 1.1 works from a Discord server. Invite the bot to your\n  Discord server to start using DNS over Discord. Or, add it to your account to\n  use it anywhere in Discord.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-over-discord/\n  md: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-over-discord/index.md\n---\n\n1.1.1.1 works from a Discord server, thanks to the 1.1.1.1 bot. [Invite the bot to your Discord server](https://cfl.re/3nM6VfQ) to start using DNS over Discord. Or, [add the bot to your Discord account](https://dns-over-discord.v4.wtf/invite/user) to use it anywhere in Discord.\n\n## Perform DNS lookups\n\nOnce the bot is in your server, type `/dig` to start performing DNS lookups. This will provide a native interface within Discord that allows you to specify the domain to lookup, an optional DNS record type and an optional flag for a short result.\n\nIf only a domain is given for the command, the bot will default to looking for `A` DNS records, and will return the full format result, not the short form.\n\n### Supported record types\n\nDiscord has a limit of 25 options in slash commands, so DNS over Discord offers the 25 most common DNS record types to choose from.\n\nSupported DNS record types\n\n* `A`\n* `AAAA`\n* `CAA`\n* `CDNSKEY`\n* `CDS`\n* `CERT`\n* `CNAME`\n* `DNSKEY`\n* `DS`\n* `HINFO`\n* `HTTPS`\n* `LOC`\n* `MX`\n* `NAPTR`\n* `NS`\n* `PTR`\n* `SMIMEA`\n* `SOA`\n* `SPF`\n* `SRV`\n* `SSHFP`\n* `SVCB`\n* `TLSA`\n* `TXT`\n* `URI`\n\nTo query other DNS record types, or multiple record types at once, use the `/multi-dig` command.\n\n### Short form response\n\nDNS over Discord has an optional flag in the `/dig` command that allows the user to request a response in the short form.\n\nWhen you request a response in the short form, the name and TTL columns will be excluded. The command only returns the data column without formatting, similar to the equivalent `dig` command-line interface response.\n\n### Disable DNSSEC checking\n\nYou can disable DNSSEC checking in the `dig` command by passing `cdflag` as true. This will return the DNS records even if the DNSSEC validation fails.\n\n### Refreshing existing results\n\nYou can refresh the DNS lookup results by clicking the Refresh button. Clicking it will trigger the bot to re-request the DNS query in the message, and update the results in the message. Any user can click this button.\n\nThe refresh button is available on all responses to the `/dig` command, including those that resulted in an error, such as an unknown domain or no records found.\n\n### Changing DNS provider\n\nBy default, the DNS over Discord bot uses Cloudflare's 1.1.1.1 DNS service. You can run the DNS lookup with alternate DNS providers by selecting the dropdown below the result. This shows you a list of available providers. Selecting a new provider updates the results in the message. Any user can change the DNS provider.\n\n## `multi-dig` command\n\nIf you want to look up multiple DNS record types at once, use the `/multi-dig` command. This allows you to specify any supported DNS record type, and multiple types separated by a space.\n\n### Supported record types\n\nWhen providing DNS record types for the `/multi-dig` command, Discord will not prompt you with options. You have to provide a space-separated list of valid DNS record types to lookup, as any invalid options will be silently dropped. `A` records will be used as the default if no valid types are given.\n\nDNS record types supported and considered valid by the bot\n\nUse a `*` (asterisk) in place of a record type to get DNS results for all supported types.\n\n* `A`\n* `AAAA`\n* `AFSDB`\n* `APL`\n* `CAA`\n* `CDNSKEY`\n* `CDS`\n* `CERT`\n* `CNAME`\n* `CSYNC`\n* `DHCID`\n* `DLV`\n* `DNAME`\n* `DNSKEY`\n* `DS`\n* `EUI48`\n* `EUI64`\n* `HINFO`\n* `HIP`\n* `HTTPS`\n* `IPSECKEY`\n* `KEY`\n* `KX`\n* `LOC`\n* `MX`\n* `NAPTR`\n* `NS`\n* `NSEC`\n* `NSEC3`\n* `NSEC3PARAM`\n* `OPENPGPKEY`\n* `PTR`\n* `RP`\n* `SMIMEA`\n* `SOA`\n* `SPF`\n* `SRV`\n* `SSHFP`\n* `SVCB`\n* `TA`\n* `TKEY`\n* `TLSA`\n* `TXT`\n* `URI`\n* `ZONEMD`\n\n### Short form response\n\nLike the main `/dig` command, the `/multi-dig` command also supports the optional short flag after the types have been specified in the slash command.\n\n### Disable DNSSEC checking\n\nAs with the `dig` command, you can disable DNSSEC checking by passing `cdflag` as true. This will return the DNS records even if the DNSSEC validation fails.\n\n### Refreshing existing results\n\nThe `/multi-dig` command also provides a refresh button below each set of DNS results requested (or after each block of 10 DNS record types, if you requested more than 10).\n\nAs with the `/dig` command, any user can press the refresh button to refresh the displayed DNS results, including for DNS queries that had previously failed.\n\n### Changing DNS provider\n\nLike the `/dig` command, you can change the DNS provider when using the `/multi-dig` command. The menu appears after each set of DNS results (or after each block of results if more than 10 record types are requested).\n\nThis menu can be used by any user to change the DNS provider used for the lookup.\n\nThe `/whois` command allows you to perform a RDAP/WHOIS lookup right in Discord for a given domain, IP or ASN.\n\nThe bot also has a set of helper commands available to get more information about the bot and quick links.\n\nThe `/help` command provides in-Discord documentation about all the commands available in the 1.1.1.1 DNS over Discord bot.\n\n### `privacy` command\n\nThe `/privacy` command displays the Privacy Policy notice for using the 1.1.1.1 DNS over Discord bot. You can also [refer to the Privacy Policy page](https://dns-over-discord.v4.wtf/privacy) to access it.\n\nThe `/terms` command displays the Terms of Service notice for using the 1.1.1.1 DNS over Discord bot. You can also [refer to the Terms of Service page](https://dns-over-discord.v4.wtf/terms) to access it.\n\nThe DNS over Discord bot is open-source, and the `/github` command provides a quick link to access the GitHub repository. The GitHub repository can be accessed at <https://github.com/MattIPv4/DNS-over-Discord/>.\n\nThe `/invite` command provides the user with a quick link to invite the 1.1.1.1 DNS over Discord bot to another Discord server, or to add it to a Discord account. The bot can be invited at any time with <https://cfl.re/3nM6VfQ>. The bot can also be added to accounts with <https://dns-over-discord.v4.wtf/invite/user>.\n\nThe DNS over Discord bot is deployed on [Cloudflare Workers](https://workers.cloudflare.com/).\n\nYou can find the source code for the bot on GitHub, as well as information on getting started with contributing to the project, at <https://github.com/MattIPv4/DNS-over-Discord/>.\n\n<page>\n---\ntitle: DNS over Tor · Cloudflare 1.1.1.1 docs\ndescription: If you do not want to disclose your IP address to the resolver, you\n  can use our Tor onion service. Resolving DNS queries through the Tor network\n  guarantees a significantly higher level of anonymity than making the requests\n  directly.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-over-tor/\n  md: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-over-tor/index.md\n---\n\nThe hidden resolver is still an experimental service and should not be used in production or for other critical uses.\n\nIf you do not want to disclose your IP address to the resolver, you can use our Tor onion service. Resolving DNS queries through the Tor network guarantees a significantly higher level of anonymity than making the requests directly. Not only does doing so prevent the resolver from ever seeing your IP address, but it also prevents your ISP from knowing that you attempted to resolve a domain name.\n\nRead more about this service in [this blog post](https://blog.cloudflare.com/welcome-hidden-resolver/).\n\n## Setting up a Tor client\n\nThe important difference between using all other modes of DNS and this one is that packet routing no longer uses IP addresses, and therefore all connections must be routed through a Tor client.\n\nBefore you start, head to the [Tor Project website](https://www.torproject.org/download/download.html.en) to download and install a Tor client. If you use the Tor Browser, it will automatically start a [SOCKS proxy](https://en.wikipedia.org/wiki/SOCKS) at `127.0.0.1:9150`.\n\nIf you use Tor from the command line, create the following configuration file:\n\nThen you can run tor with:\n\nAlso, if you use the Tor Browser, you can head to the resolver's address to see the usual 1.1.1.1 page:\n\nThe HTTPS certificate indicator should say \"Cloudflare, Inc. (US).\"\n\nIf you ever forget 1.1.1.1's address, use cURL to retrieve it:\n\n## Setting up a local DNS proxy using socat\n\nOf course, not all DNS clients support connecting to the Tor client, so the easiest way to connect any DNS-speaking software to the hidden resolver is by forwarding ports locally, for instance [using `socat`](http://www.dest-unreach.org/socat/).\n\n### DNS over TCP, TLS, and HTTPS\n\nThe hidden resolver is set up to listen on TCP ports 53 and 853 for DNS over TCP and TLS. After setting up a Tor proxy, run the following `socat` command as a privileged user, replacing the port number appropriately:\n\nFrom here, you can follow the regular guide for [setting up 1.1.1.1](https://developers.cloudflare.com/1.1.1.1/setup/), except you should always use `127.0.0.1` instead of `1.1.1.1`. If you need to access the proxy from another device, simply replace `127.0.0.1` in `socat` commands with your local IP address.\n\n[As explained in the blog post](https://blog.cloudflare.com/welcome-hidden-resolver/), our favorite way of using the hidden resolver is using DNS over HTTPS (DoH). To set it up:\n\n1. Download `cloudflared` by following the guide for [connecting to 1.1.1.1 using DNS over HTTPS clients](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/dns-over-https-client/).\n\n2. Start a Tor SOCKS proxy and use `socat` to forward port TCP:443 to localhost:\n\n1. Instruct your machine to treat the `.onion` address as localhost:\n\n1. Finally, start a local DNS over UDP daemon:\n\n<page>\n---\ntitle: DNS over HTTPS · Cloudflare 1.1.1.1 docs\ndescription: With DNS over HTTPS (DoH), DNS queries and responses are encrypted\n  and sent via the HTTP, HTTP/2 and HTTP/3 protocols. DoH ensures that attackers\n  cannot forge or alter DNS traffic. DoH uses port 443, which is the standard\n  HTTPS traffic port, to wrap the DNS query in an HTTPS request. DNS queries and\n  responses are camouflaged within other HTTPS traffic, since it all comes and\n  goes from the same port.\nlastUpdated: 2025-10-09T12:44:04.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/\n  md: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/index.md\n---\n\nWith DNS over HTTPS (DoH), DNS queries and responses are encrypted and sent via the HTTP, HTTP/2 and HTTP/3 protocols. DoH ensures that attackers cannot forge or alter DNS traffic. DoH uses port 443, which is the standard HTTPS traffic port, to wrap the DNS query in an HTTPS request. DNS queries and responses are camouflaged within other HTTPS traffic, since it all comes and goes from the same port.\n\n* [Configure DoH on your browser](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/encrypted-dns-browsers/)\n* [Connect to 1.1.1.1 using DoH clients](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/dns-over-https-client/)\n* [Make API requests to 1.1.1.1](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/)\n\n<page>\n---\ntitle: DNS over TLS · Cloudflare 1.1.1.1 docs\ndescription: By default, DNS is sent over a plaintext connection. DNS over TLS\n  (DoT) is one way to send DNS queries over an encrypted connection. Cloudflare\n  supports DNS over TLS on standard port 853 and is compliant with RFC 7858.\n  With DoT, the encryption happens at the transport layer, where it adds TLS\n  encryption on top of a TCP connection.\nlastUpdated: 2024-11-19T17:02:12.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-tls/\n  md: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-tls/index.md\n---\n\nBy default, DNS is sent over a plaintext connection. DNS over TLS (DoT) is one way to send DNS queries over an encrypted connection. Cloudflare supports DNS over TLS on standard port 853 and is compliant with [RFC 7858](https://tools.ietf.org/html/rfc7858). With DoT, the encryption happens at the transport layer, where it adds TLS encryption on top of a TCP connection.\n\nCloudflare supports DNS over TLS (DoT) on `1.1.1.1`, `1.0.0.1`, and the corresponding IPv6 addresses (`2606:4700:4700::1111` and `2606:4700:4700::1001`) on port `853`. If your DoT client does not support IP addresses, Cloudflare's DoT endpoint can also be reached by hostname on `one.one.one.one`. A stub resolver (the DNS client on a device that talks to the DNS resolver) connects to the resolver over a TLS connection:\n\n1. Before the connection, the DNS stub resolver has stored a base64 encoded SHA256 hash of the TLS certificate from 1.1.1.1 (called SPKI).\n2. DNS stub resolver establishes a TCP connection with `1.1.1.1:853`.\n3. DNS stub resolver initiates a TLS handshake.\n4. In the TLS handshake, 1.1.1.1 presents its TLS certificate.\n5. Once the TLS connection is established, the DNS stub resolver can send DNS over an encrypted connection, preventing eavesdropping and tampering.\n6. All DNS queries sent over the TLS connection must comply with specifications of [sending DNS over TCP](https://tools.ietf.org/html/rfc1035#section-4.2.2).\n\n## Supported TLS versions\n\nCloudflare's DNS over TLS supports TLS 1.3 and TLS 1.2.\n\n<page>\n---\ntitle: Supported DNSKEY signature algorithms · Cloudflare 1.1.1.1 docs\ndescription: \"DNSSEC is a protocol that adds a layer of security to the domain\n  name system (DNS). DNSSEC does this by providing authentication through public\n  signing keys using two DNS records: DNSKEY and DS. They can be used to verify\n  DNSSEC signatures in RRSIG records.\"\nlastUpdated: 2024-11-19T17:02:12.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/encryption/dnskey/\n  md: https://developers.cloudflare.com/1.1.1.1/encryption/dnskey/index.md\n---\n\n[DNSSEC is a protocol](https://www.cloudflare.com/learning/dns/dns-records/dnskey-ds-records/) that adds a layer of security to the domain name system (DNS). DNSSEC does this by providing authentication through public signing keys using two DNS records: DNSKEY and DS. They can be used to verify DNSSEC signatures in [RRSIG records](https://www.cloudflare.com/dns/dnssec/how-dnssec-works/).\n\n1.1.1.1 supports the following signature algorithms:\n\n* RSA/SHA-1\n* RSA/SHA-256\n* RSA/SHA-512\n* RSASHA1-NSEC3-SHA1\n* ECDSA Curve P-256 with SHA-256 (ECDSAP256SHA256)\n* ECDSA Curve P-384 with SHA-384 (ECDSAP384SHA384)\n* ED25519\n\n<page>\n---\ntitle: Oblivious DNS over HTTPS · Cloudflare 1.1.1.1 docs\ndescription: Learn how Cloudflare 1.1.1.1 supports Oblivious DNS over HTTPS\n  (ODoH) to enhance privacy by separating HTTP request contents from requester\n  IP addresses.\nlastUpdated: 2025-03-03T17:17:36.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/encryption/oblivious-dns-over-https/\n  md: https://developers.cloudflare.com/1.1.1.1/encryption/oblivious-dns-over-https/index.md\n---\n\nAs announced on [our blog](https://blog.cloudflare.com/oblivious-dns/), since late 2020, Cloudflare 1.1.1.1 supports Oblivious DNS over HTTPS (ODoH).\n\nODoH is defined in [RFC 9230](https://www.rfc-editor.org/rfc/rfc9230.html). This RFC is experimental and is not endorsed by the IETF.\n\nODoH improves privacy by separating the contents of an HTTP request (and response) from its requester IP address. To achieve this, a proxy and a target are introduced between the client and the upstream DNS resolver:\n\n* The proxy has no visibility into the DNS messages, with no ability to identify, read, or modify either the query being sent by the client or the answer being returned by the target.\n\n* The target only has access to the encrypted query and the proxy's IP address, while not having visibility over the client's IP address.\n\n* Only the intended target can read the content of the query and produce a response, which is also encrypted.\n\nThis means that, as long as the proxy and the target do not collude, no single entity can have access to both the DNS messages and the client IP address at the same time. Also, clients are in complete control of proxy and target selection.\n\nAdditionally, clients encrypt their query for the target using Hybrid Public Key Encryption (HPKE). A target's public key is obtained via DNS, where it is bundled into an HTTPS resource record and protected by DNSSEC.\n\n## Cloudflare and third-party products\n\nCloudflare 1.1.1.1 supports ODoH by acting as a target that can be reached at `odoh.cloudflare-dns.com`.\n\nTo make ODoH queries you can use open source clients such as [dnscrypt-proxy](https://github.com/DNSCrypt/dnscrypt-proxy).\n\nAlso, [iCloud Private Relay](https://support.apple.com/102602) is based on ODoH and uses [Cloudflare as one of their partners](https://blog.cloudflare.com/icloud-private-relay/).\n\n* [HPKE: Standardizing public-key encryption](https://blog.cloudflare.com/hybrid-public-key-encryption/) blog post\n* [Privacy Gateway](https://developers.cloudflare.com/privacy-gateway/)\n\n<page>\n---\ntitle: Extended DNS error codes · Cloudflare 1.1.1.1 docs\ndescription: Extended DNS Error Codes is a method to return additional\n  information about the cause of DNS errors. As there are many reasons why a DNS\n  query might fail, it became necessary to provide additional information on the\n  exact cause of an error.\nlastUpdated: 2024-12-05T10:44:03.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/infrastructure/extended-dns-error-codes/\n  md: https://developers.cloudflare.com/1.1.1.1/infrastructure/extended-dns-error-codes/index.md\n---\n\n[Extended DNS Error Codes](https://www.rfc-editor.org/rfc/rfc8914.html) is a method to return additional information about the cause of DNS errors. As there are many reasons why a DNS query might fail, it became necessary to provide additional information on the exact cause of an error.\n\n1.1.1.1 supports Extended DNS Error Codes. Below is a list of error codes 1.1.1.1 returns, what they mean, and steps you may want to take to resolve the issue.\n\n| Code number | Code name | Example output | Next steps |\n| - | - | - | - |\n| 1 | Unsupported DNSKEY Algorithm | `EDE: 1 (Unsupported DNSKEY Algorithm): (failed to verify example.com. A: unsupported key size, DNSKEY example.com., id = 12345)` | The domain did not pass DNSSEC validation. Check which [signature key algorithm](https://developers.cloudflare.com/1.1.1.1/encryption/dnskey/) your website uses and confirm it is supported by 1.1.1.1. |\n| 2 | Unsupported DS Digest Type | `EDE: 2 (Unsupported DS Digest Type): (no supported DS digest type for example.com.)` | The domain did not pass DNSSEC validation due to an unsupported digest type on the DS record. If none of the provided DS records are supported, the domain will fail to resolve. Make sure to [add a supported DS record](https://developers.cloudflare.com/dns/dnssec/) with your registrar. |\n| 3 | Stale Answer | `EDE: 3 (Stale Answer)` | This is a silent error. It notifies that the DNS resolver could only return stale data. If the issue persists reach out on the 1.1.1.1 [community forum](https://community.cloudflare.com/c/reliability/dns-1111/47). |\n| 6 | DNSSEC Bogus | `EDE: 6 (DNSSEC Bogus): (proof of non-existence of example.com. A)` `EDE: 6 (DNSSEC Bogus): (found duplicate CNAME records for example.com. (1 duplicate RRs))` | This domain did not pass DNSSEC validation. The signatures for the target record, or the proof of non-existence of the target records, are invalid. Check your [DNS configuration](https://developers.cloudflare.com/dns/). |\n| 7 | Signature Expired | `EDE: 7 (Signature Expired): (for DNSKEY example.com., id = 12345: RRSIG example.com., expiration = 123456)` | This domain did not pass DNSSEC validation due to an expired signature. Make sure your zone is signed with valid [DNSSEC signatures](https://developers.cloudflare.com/dns/dnssec/troubleshooting/). |\n| 8 | Signature Not Yet Valid | `EDE: 8 (Signature Not Yet Valid): (for DNSKEY example.com., id = 12345: RRSIG example.com., inception = 12345)` | This domain did not pass DNSSEC validation. Make sure your zone is signed with valid [DNSSEC signatures](https://developers.cloudflare.com/dns/dnssec/troubleshooting/). |\n| 9 | DNSKEY Missing | `EDE: 9 (DNSKEY Missing): (no SEP matching the DS found for example.com.)` | This domain did not pass DNSSEC validation. It does not have a SEP DNSKEY that matches the set of DS records at the registry. Make sure to either sign the zone using keys that match the current DS set, or [add the missing DS records](https://developers.cloudflare.com/dns/dnssec/) with your registrar. |\n| 10 | RRSIGs Missing | `EDE: 10 (RRSIGs Missing): (for DNSKEY example.com., id = 12345)` | 1.1.1.1 was unable to retrieve Resource Record Signatures (RRSigs) to verify the authenticity of the records. Check your [DNS configuration](https://developers.cloudflare.com/dns/) and the response code. If the response code is not `SERVFAIL`, this error indicates that there is a non-operational key issue somewhere along the path, but the resolver found at least one successful path for validation. Examples of non-operational key issues include but are not limited to key rollover in-progress, stand-by key, and attacker stripping signatures made by a certain key. |\n| 11 | No Zone Key Bit Set | `EDE: 11 (No Zone Key Bit Set): (for DNSKEY example.com., id = 12345)` | This domain did not pass DNSSEC validation. The zone's SEP DNSKEY must [set a Zone Key flag](https://datatracker.ietf.org/doc/html/rfc4035#section-5.3.1). Check your [DNSSEC configuration](https://developers.cloudflare.com/dns/dnssec/) or DNSSEC's [troubleshooting guide](https://developers.cloudflare.com/dns/dnssec/troubleshooting/). |\n| 12 | NSEC Missing | `EDE: 12 (NSEC Missing): failed to verify an insecure referral proof for example.com` | This domain did not pass DNSSEC validation. The upstream nameserver did not include a valid proof of non-existence for the target name. Make sure the zone is [signed with DNSSEC](https://developers.cloudflare.com/dns/dnssec/troubleshooting/) and has valid [NSEC/NSEC3 records](https://www.cloudflare.com/dns/dnssec/dnssec-complexities-and-considerations/). |\n| 13 | Cached Error | `EDE: 13 (Cached Error)` | 1.1.1.1 returned a cached error. If this issue persists, reach out to the [community forum](https://community.cloudflare.com/c/reliability/dns-1111/47). |\n| 22 | No Reachable Authority | `EDE: 22 (No Reachable Authority): (at delegation example.com.)` | 1.1.1.1 could not reach some or all of the authoritative nameservers (or they potentially refused to resolve). This can occur if the authoritative nameservers are overloaded or temporarily unavailable. If this issue persists, reach out to the [community forum](https://community.cloudflare.com/c/reliability/dns-1111/47). |\n| 23 | Network Error | `EDE: 23 (Network Error): (1.1.1.1:53 rcode=SERVFAIL for example.com. A)` | 1.1.1.1 could not determine a network path to the upstream nameservers, or the nameserver did not respond. If this issue persists, reach out to the [community forum](https://community.cloudflare.com/c/reliability/dns-1111/47). |\n| 30 | Invalid Query Type | `EDE: 30 (Invalid Query Type): Invalid Query Type` | The record type in the request cannot give a valid answer. If this is returned for standard query types, such as A or AAAA records, please reach out to the [community forum](https://community.cloudflare.com/c/reliability/dns-1111/47). |\n\n<page>\n---\ntitle: Support for IPv6-only networks · Cloudflare 1.1.1.1 docs\ndescription: While network infrastructure is shifting towards IPv6-only\n  networks, providers still need to support IPv4 addresses. Dual-stack networks\n  are networks in which all nodes have both IPv4 and IPv6 connectivity\n  capabilities, and can therefore understand both IPv4 and IPv6 packets.\nlastUpdated: 2025-08-15T20:11:52.000Z\nchatbotDeprioritize: false\ntags: IPv6\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/infrastructure/ipv6-networks/\n  md: https://developers.cloudflare.com/1.1.1.1/infrastructure/ipv6-networks/index.md\n---\n\nWhile network infrastructure is shifting towards IPv6-only networks, providers still need to support IPv4 addresses. Dual-stack networks are networks in which all nodes have both IPv4 and IPv6 connectivity capabilities, and can therefore understand both IPv4 and IPv6 packets.\n\n1.1.1.1 supports DNS64, a mechanism that synthesizes AAAA records from A records when no AAAA records exist. DNS64 allows configuring a DNS resolver to synthesize IPv6 addresses from IPv4 answers.\n\nYou should only enable DNS64 if you are managing or using an IPv6-only network. While the resolver can synthesize IPv6 addresses, it cannot synthesize their record signatures for domains using DNSSEC, so a DNS client that is able to revalidate signatures would reject these extra records without signatures.\n\nA good tradeoff is to use a secure protocol such as DNS over TLS, or DNS over HTTPS between the client and the resolver to prevent tampering.\n\nDNS64 is specifically for networks that already have NAT64 support. If you are a network operator who has NAT64, you can test our DNS64 support by updating it to the following IP addresses:\n\nSome devices use separate fields for all eight parts of IPv6 addresses and cannot accept the `::` IPv6 abbreviation syntax. For such fields enter:\n\nAfter your configuration, visit an IPv4 only address to check if you can reach it. For example, you can visit <https://ipv4.google.com>.\n\nVisit <http://test-ipv6.com/> to test if it can detect your IPv6 address. If you receive a `10/10`, your IPv6 is configured correctly.\n\n<page>\n---\ntitle: Network operators · Cloudflare 1.1.1.1 docs\ndescription: Network operators, including Internet Service Providers (ISPs),\n  device manufacturers, public Wi-Fi networks, municipal broadband providers,\n  and security scanning services can use 1.1.1.1 in place of operating their own\n  recursive DNS infrastructure.\nlastUpdated: 2025-12-18T10:25:22.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/infrastructure/network-operators/\n  md: https://developers.cloudflare.com/1.1.1.1/infrastructure/network-operators/index.md\n---\n\nNetwork operators, including Internet Service Providers (ISPs), device manufacturers, public Wi-Fi networks, municipal broadband providers, and security scanning services can use [1.1.1.1](https://developers.cloudflare.com/1.1.1.1/setup/) in place of operating their own recursive DNS infrastructure.\n\nCloudflare also partners with ISPs and network equipment providers to make [1.1.1.1 for Families](https://developers.cloudflare.com/1.1.1.1/setup/#1111-for-families) available within their offerings. Refer to our [blog post](https://blog.cloudflare.com/safer-resolver/) for details.\n\nUsing 1.1.1.1 can improve performance for end-users due to Cloudflare's extensive [global network](https://www.cloudflare.com/network/), as well as provide higher overall cache hit rates due to our regional caches.\n\nThe 1.1.1.1 resolver was designed with a privacy-first approach. Refer to our [data and privacy policies](https://developers.cloudflare.com/1.1.1.1/privacy/public-dns-resolver/) for what is logged and retained by 1.1.1.1.\n\n## Configuring 1.1.1.1\n\nThere are multiple ways to use 1.1.1.1 as an operator:\n\n* Including a [DNS over HTTPS](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/) or [DNS over TLS](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-tls/) proxy on end-user routers or devices (best for privacy).\n* Pushing 1.1.1.1 to devices via DHCP/PPP within an operator network (recommended; most practical).\n* Having a DNS proxy on a edge router make requests to 1.1.1.1 on behalf of all connected devices.\n\nWhere possible, we recommend using encrypted transports (DNS over HTTPS or TLS) for queries, as this provides the highest degree of privacy for users over last-mile networks.\n\n## Available Endpoints\n\n[Cloudflare Zero Trust](https://www.cloudflare.com/products/zero-trust/) supports customizable [DNS policies](https://developers.cloudflare.com/cloudflare-one/traffic-policies/dns-policies/), analytics, additional built-in filtering categories, and custom rate limiting capabilities.\n\nIf you require additional controls over our public 1.1.1.1 resolver, [contact us](https://www.cloudflare.com/products/zero-trust/).\n\nThe publicly available endpoints for 1.1.1.1 are detailed in the following table:\n\n| Resolver | IPv4 address | IPv6 address | DNS over HTTPS endpoint | DNS over TLS endpoint |\n| - | - | - | - | - |\n| 1.1.1.1 (unfiltered) | `1.1.1.1` `1.0.0.1` | `2606:4700:4700::1111` `2606:4700:4700::1001` | `https://cloudflare-dns.com/dns-query` | `one.one.one.one` |\n| Families (Malware) | `1.1.1.2` `1.0.0.2` | `2606:4700:4700::1112` `2606:4700:4700::1002` | `https://security.cloudflare-dns.com/dns-query` | `security.cloudflare-dns.com` |\n| Families (Adult Content + Malware) | `1.1.1.3` `1.0.0.3` | `2606:4700:4700::1113` `2606:4700:4700::1003` | `https://family.cloudflare-dns.com/dns-query` | `family.cloudflare-dns.com` |\n\nYou may wish to provide end users with options to change from the default 1.1.1.1 resolver to one of the [1.1.1.1 for Families](https://developers.cloudflare.com/1.1.1.1/setup/#1111-for-families) endpoints.\n\nOperators using 1.1.1.1 for typical Internet-facing applications and/or users should not encounter any rate limiting for their users. In some rare cases, security scanning use-cases or proxied traffic may be rate limited to protect our infrastructure as well as upstream DNS infrastructure from potential abuse.\n\nBest practices include:\n\n* Avoiding tunneling or proxying all queries from a single IP address at high rates. Distributing queries across multiple public IPs will improve this without impacting cache hit rates (caches are regional).\n* A high rate of \"uncacheable\" responses (such as `SERVFAIL`) against the same domain may be rate limited to protect upstream, authoritative nameservers. Many authoritative nameservers enforce their own rate limits, and we strive to avoid overloading third party infrastructure where possible.\n\nIf you are a network operator and still have outstanding questions, contact `resolver@cloudflare.com` with your use case, so it can be discussed further. Make sure to visit [1.1.1.1/help](https://one.one.one.one/help) from within your network and share the resulting report when contacting Cloudflare.\n\n<page>\n---\ntitle: SLA and technical support · Cloudflare 1.1.1.1 docs\ndescription: As you use 1.1.1.1 in your infrastructure or service, note that\n  dedicated technical support is limited.\nlastUpdated: 2025-10-22T21:11:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/infrastructure/sla-and-support/\n  md: https://developers.cloudflare.com/1.1.1.1/infrastructure/sla-and-support/index.md\n---\n\nAs you use 1.1.1.1 in your infrastructure or service, note that dedicated technical support is limited.\n\nYou are subject to the [Cloudflare Website and Online Services Terms of Use](https://www.cloudflare.com/website-terms/) and no service level agreements (SLAs) are provided.\n\nIf you need SLAs and dedicated support, consider using [Cloudflare Gateway](https://developers.cloudflare.com/cloudflare-one/traffic-policies/) instead.\n\nGateway includes other advanced options such as domain categories, customized filtering, and scheduling capabilities. For example, if you are a device manufacturer or network operator, you can use a multi-tenant environment to allow your customers to configure their own individual filters.\n\n<page>\n---\ntitle: 1.1.1.1 Public DNS Resolver · Cloudflare 1.1.1.1 docs\ndescription: Learn more about Cloudflare's commitment to privacy with the\n  1.1.1.1 Public DNS Resolver.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/privacy/public-dns-resolver/\n  md: https://developers.cloudflare.com/1.1.1.1/privacy/public-dns-resolver/index.md\n---\n\n*Last updated March 27, 2024*\n\n## Cloudflare’s commitment to privacy: 1.1.1.1 Public DNS Resolver\n\nThe 1.1.1.1 public DNS resolver is governed by our [Privacy Policy](https://www.cloudflare.com/privacypolicy/). This document provides additional details on our collection, use, and disclosure of the information collected from the 1.1.1.1 public DNS resolver.\n\nNearly everything on the Internet starts with a DNS request. DNS is the Internet’s directory. Select a link, open an app, send an email, and the first thing your phone or computer does is ask its directory: where can I find this?\n\nUnfortunately, by default, DNS is usually slow and insecure. Your ISP, and anyone else listening in on the Internet, can see every site you visit and every app you use — even if their content is encrypted. Creepily, some DNS providers sell data about your Internet activity or use it to target you with ads.\n\nGiven the current state of affairs, Cloudflare created a DNS resolver with your privacy and security in mind. Cloudflare, in partnership with APNIC, runs the 1.1.1.1 public resolver, a recursive DNS service that values user privacy and security. DNS requests sent to our public resolver can be sent over a secure channel, significantly decreasing the odds of any unwanted spying or man in the middle attacks.\n\nThe 1.1.1.1 public DNS resolver was designed for privacy first, and Cloudflare commits to the following:\n\n1. Cloudflare will not sell or share Public Resolver users’ personal data with third parties or use personal data from the Public Resolver to target any user with advertisements.\n2. Cloudflare will only retain or use what is being asked, not information that will identify who is asking it. Except for randomly sampled network packets captured from at most 0.05% of all traffic sent to Cloudflare’s network infrastructure, Cloudflare will not retain the source IP from DNS queries to the Public Resolver in non-volatile storage. These randomly sampled packets are solely used for network troubleshooting and DoS mitigation purposes.\n3. A Public Resolver user’s IP address (referred to as the client or source IP address) will not be stored in non-volatile storage. Cloudflare will anonymize source IP addresses via IP truncation methods (last octet for IPv4 and last 80 bits for IPv6). Cloudflare will delete the truncated IP address within 25 hours.\n4. Cloudflare will retain only the limited transaction and debug log data (“Public Resolver Logs”) set forth below, for the legitimate operation of our Public Resolver and research purposes, and Cloudflare will delete the Public Resolver Logs within 25 hours.\n5. Cloudflare will not share the Public Resolver Logs with any third parties except for APNIC pursuant to a Research Cooperative Agreement. APNIC will only have limited access to query the anonymized data in the Public Resolver Logs and conduct research related to the operation of the DNS system.\n\nCloudflare has taken technical steps to ensure that we cannot retain our user’s information.\n\nWe have also retained one of the top four accounting firms to audit our practices and publish a public report confirming we are doing what we said we would. The report is available in the [Certifications and compliance resources](https://www.cloudflare.com/trust-hub/compliance-resources/) page.\n\n## Limited data sharing with APNIC\n\nCloudflare has partnered with [APNIC Labs](https://labs.apnic.net/?p=1127), the regional Internet registry for the Asia-Pacific region to make the 1.1.1.1 IP address the home of the Cloudflare Public DNS Resolver. As part of its mission to ensure a global, open and secure Internet, APNIC conducts research about the functioning and governance of the Internet, which it makes available on its website, located at [www.apnic.net](http://www.apnic.net).\n\nCloudflare has agreed to provide APNIC with access to some of the anonymized data that Cloudflare collects through the Cloudflare Public DNS Resolver. Specifically, APNIC will be permitted to access query names, query types, resolver location and other metadata via a Cloudflare API that will allow APNIC to study topics like the volume of DDoS attacks launched on the Internet and adoption of IPv6.\n\nAPNIC Labs will use such data for non-profit operational research. As part of Cloudflare’s commitment to privacy, Cloudflare will not provide APNIC with any access to the IP address associated with a client.\n\nAside from APNIC, Cloudflare will not share the Public Resolver Logs with any third party.\n\n## Data in public resolver logs\n\nThe Public Resolver Logs we store consist entirely of the following fields:\n\n* answerData type\n* answerData\n* coloID (unique Cloudflare data center ID)\n* date\n* dateTime\n* dstIPVersion\n* dstIPv6\n* dstIPv4\n* dstPort\n* ede\n* ednsVersion\n* ednsPayload\n* ednsNsid\n* feature.uid\n* feature.value\n* metalId (unique Cloudflare data center ID)\n* ns ip\n* ns name\n* protocol\n* queryName\n* queryType\n* queryClass\n* queryRd\n* queryDo\n* querySize\n* queryEdns\n* queryCd\n* responseType\n* responseCode\n* responseSize\n* responseCount\n* responseTimeMs\n* responseCached\n* responseMinTTL\n* reused\n* srcAsNum\n* srcCountry\n* srcIPVersion\n* validationState\n\nAdditionally, recursive resolvers perform outgoing queries to various authoritative nameservers in the DNS hierarchy that are logged in subrequest fields. These logs are used for the operation and debugging of our public DNS resolver service.\n\nThe following subrequest data is included in the Public Resolver Logs:\n\n* subrequest.ipv6 (authoritative nameserver)\n* subrequest.ipv4 (authoritative nameserver)\n* subrequest.protocol\n* subrequest.durationMs\n* subrequest.queryName\n* subrequest.queryType\n* subrequest.responseCode\n* subrequest.responseCount\n* subrequest.recordType\n* subrequest.recordData\n* subrequest.error\n\nExcept for the limited sampled data from the Public Resolver Logs (which do not include truncated IP addresses) used to generate the aggregated data described below, all of the Public Resolver Logs are deleted within 25 hours of Cloudflare’s receipt of such information.\n\nCloudflare may make the following aggregations:\n\n* Total number of queries with different protocol settings (for example, tcp/udp/dnssec) by Cloudflare data centers.\n* Response code/time quantiles with different protocol settings by Cloudflare data centers.\n* Total Number of Requests Processed by Cloudflare data centers.\n* Aggregate List of All Domain Names Requested and aggregate number of requests and timestamp of first time requested by region.\n* Number of unique clients, queries over IPv4, queries over IPv6, queries with the RD bit set, queries asking for DNSSEC, number of bogus, valid, and invalid DNSSEC answers, queries by type, number of answers with each response code, response time quantiles (e.g. 50 percentile), response TTL, and number of cached answers per minute, per day, per protocol (HTTPS/UDP/TCP/TLS), per region, per Cloudflare data center, and per Autonomous System Number.\n* Number of queries, number of queries with EDNS, number of bytes and time in answers quantiles (e.g. 50 percentile) by day, month, Cloudflare data center, and by IPv4 vs IPv6.\n* Number of queries, response codes and response code quantiles (e.g. 50 percentile) by day, region, name and type.\n\nCloudflare may store the data described above indefinitely in order to power Cloudflare Radar and assist Cloudflare in improving Cloudflare services, such as, enhancing the overall performance of the Cloudflare Resolver and identifying security threats.\n\n## What about requests for content blocking?\n\nCloudflare does not block or filter any content through the 1.1.1.1 Public DNS Resolver, which is designed for direct, fast DNS resolution, not for blocking or filtering content. Cloudflare does block and filter malware and adult content through 1.1.1.1 for Families, which is designed to help individuals protect their home networks.\n\nIn general, Cloudflare views government or civil requests to block content at the DNS level as ineffective, inefficient, and overboard. Because such a block would apply globally to all users of the resolver, regardless of where they are located, it would affect end users outside of the blocking government’s jurisdiction. A government request to block content through a globally available public recursive resolver like the 1.1.1.1 Public DNS Resolver and 1.1.1.1 for Families should therefore be evaluated as a request to block content globally.\n\nGiven the broad extraterritorial effect, if Cloudflare were to receive written requests from law enforcement and government agencies to block access to domains or content through the 1.1.1.1 Public DNS Resolver or to block access to domains or content through 1.1.1.1 for Families that is outside the scope of the filtering in that product, Cloudflare would pursue its legal remedies before complying with such a request. We also commit to documenting any government request to block access in our semi-annual transparency report, unless legally prohibited from doing so.\n\n<page>\n---\ntitle: Cloudflare Resolver for Firefox · Cloudflare 1.1.1.1 docs\ndescription: Every time you type a web address, such as www.mozilla.org or\n  www.firefox.com, into a web browser, the web browser sends a query to a DNS\n  resolver. If DNS is like the card catalog of the Internet, then a DNS resolver\n  is like a helpful librarian that knows how to use the information from that\n  catalog to track down the exact location of a website. Whenever a resolver\n  receives your query it looks up the IP address associated with the web address\n  that you entered and relays that information to your web browser. “DNS\n  resolution” as this process is referred to, is a crucial component of your\n  Internet experience because without it your web browser would be unable to\n  communicate with the servers that host your favorite websites, since\n  communication requires knowing the IP addresses of those websites.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/privacy/cloudflare-resolver-firefox/\n  md: https://developers.cloudflare.com/1.1.1.1/privacy/cloudflare-resolver-firefox/index.md\n---\n\n## Frequently asked questions about the Cloudflare resolver for Firefox\n\n### What is the Cloudflare resolver for Firefox?\n\nEvery time you type a web address, such as [www.mozilla.org](http://www.mozilla.org) or [www.firefox.com](http://www.firefox.com), into a web browser, the web browser sends a query to a DNS resolver. If DNS is like the card catalog of the Internet, then a DNS resolver is like a helpful librarian that knows how to use the information from that catalog to track down the exact location of a website. Whenever a resolver receives your query it looks up the IP address associated with the web address that you entered and relays that information to your web browser. “DNS resolution” as this process is referred to, is a crucial component of your Internet experience because without it your web browser would be unable to communicate with the servers that host your favorite websites, since communication requires knowing the IP addresses of those websites.\n\nFor most Internet users, the DNS resolver that they use is either the one that comes with the operating system running on their machines or the one that is set by their network provider. In some cases, these resolvers leave a lot to be desired because of their susceptibility to unwanted spying and other security threats.\n\nTo counter such threats, Mozilla has partnered with Cloudflare to provide direct DNS resolution from within the Firefox browser using the Cloudflare Resolver for Firefox. What this means is that whenever you select or type a web address in the Firefox browser your DNS lookup request will be sent over a secure channel to the Cloudflare Resolver for Firefox rather than to an unknown DNS resolver, significantly decreasing the odds of any unwanted spying or man in the middle attacks.\n\n### What information does the Cloudflare resolver for Firefox collect?\n\nAny data Cloudflare handles as a result of its resolver for Firefox is as a data processor acting pursuant to Firefox’s data processing instructions. Therefore, the data Cloudflare collects and processes pursuant to its agreement with Firefox is not covered by the [Cloudflare Privacy Policy](https://www.cloudflare.com/privacypolicy/). As part of its agreement with Firefox, Cloudflare has agreed to collect only a limited amount of data about the DNS requests that are sent to the Cloudflare Resolver for Firefox via the Firefox browser. Cloudflare will collect only the following information from Firefox users:\n\n* date\n* dateTime\n* srcAsNum\n* srcIPVersion\n* dstIPVersion\n* dstIPv6\n* dstIPv4\n* dstPort\n* protocol\n* queryName\n* queryType\n* queryClass\n* queryRd\n* queryDo\n* querySize\n* queryEdns\n* ednsVersion\n* ednsPayload\n* ednsNsid\n* responseType\n* responseCode\n* responseSize\n* responseCount\n* responseTimeMs\n* responseCached\n* responseMinTTL\n* answerData type\n* answerData\n* validationState\n* coloID (unique Cloudflare data center ID)\n* metalId (unique Cloudflare data center ID)\n\nAll of the above information will be stored briefly as part of Cloudflare’s temporary logs, and then permanently deleted within 24 hours of Cloudflare’s receipt of such information. In addition to the above information, Cloudflare will also collect and store the following information as part of its permanent logs.\n\n* Total number of requests processed by each Cloudflare co-location facility.\n* Aggregate list of all domain names requested.\n* Samples of domain names queried along with the times of such queries.\n\nInformation stored in Cloudflare’s permanent logs will be anonymized and may be held indefinitely by Cloudflare for its own internal research and development purposes.\n\n### What is the Cloudflare promise?\n\nCloudflare understands how important your data is to you, which is why we promise to use the information that we collect from the Cloudflare Resolver for Firefox solely to improve the performance of Cloudflare Resolver for Firefox and to assist us in debugging efforts if an issue arises. In addition to limiting our collection and use of your data, Cloudflare also promises:\n\n* Cloudflare will not retain or sell or transfer to any third party (except as may be required by law) any personal information, IP addresses or other user identifiers from the DNS queries sent from the Firefox browser to the Cloudflare Resolver for Firefox;\n\n* Cloudflare will not combine the data that it collects from such queries, with any other Cloudflare or third party data in any way that can be used to identify individual end users;\n\n* Cloudflare will not sell, license, sublicense, or grant any rights to your data to any other person or entity without Mozilla’s explicit written permission.\n\n### What about government requests for content blocking?\n\nCloudflare does not block or filter content through the Cloudflare Resolver for Firefox. As part of its agreement with Mozilla, Cloudflare is providing only direct DNS resolution. If Cloudflare were to receive written requests from law enforcement and government agencies to block access to domains or content through the Cloudflare resolver for Firefox, Cloudflare would, in consultation with Mozilla, exhaust our legal remedies before complying with such a request. We also commit to documenting any government request to block access in our semi-annual transparency report, unless legally prohibited from doing so.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on Azure · Cloudflare 1.1.1.1 docs\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/azure/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/azure/index.md\n---\n\n1. Log in to your Azure portal.\n\n2. From the Azure portal side menu, select **Virtual Networks**.\n\n3. Navigate to the virtual network associated with your virtual machine (VM).\n\n4. Select **DNS Servers** > **Custom**, and add two entries:\n\n<page>\n---\ntitle: Set up 1.1.1.1 on Android · Cloudflare 1.1.1.1 docs\ndescription: Learn how to set up Cloudflare's 1.1.1.1 DNS resolver on Android\n  devices. Encrypt DNS queries with DoT or DoH, and enable 1.1.1.1 for Families.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/android/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/android/index.md\n---\n\n[1.1.1.1: Faster Internet](https://play.google.com/store/apps/details?id=com.cloudflare.onedotonedotonedotone) is the preferred method of setting up 1.1.1.1 DNS resolver and 1.1.1.1 for Families. It allows you to automatically configure your phone to use 1.1.1.1 on any network you connect to.\n\nThe app also allows you to enable encryption for DNS queries or enable [WARP mode](https://developers.cloudflare.com/warp-client/), which keeps all your HTTP traffic private and secure, including your DNS queries to 1.1.1.1.\n\nYou can select between the options available in the app settings. By default, 1.1.1.1: Faster Internet is configured to WARP mode.\n\n## Set up 1.1.1.1: Faster Internet\n\n1. Download [1.1.1.1: Faster Internet from Google Play](https://play.google.com/store/apps/details?id=com.cloudflare.onedotonedotonedotone) for free.\n2. Launch 1.1.1.1: Faster Internet and accept the Terms of Service.\n3. Toggle the **WARP** button to **Connected**.\n4. Install the VPN profile that allows your phone to connect securely to 1.1.1.1.\n\nYour connection to the Internet and your DNS queries are now protected.\n\n### Enable 1.1.1.1 for Families\n\n1. Open 1.1.1.1: Faster Internet.\n2. Tap the **menu button**.\n3. Select **Advanced** > **Connection options**.\n4. In **DNS settings** > **1.1.1.1 for Families**, select the option you want to use.\n\n## Configure 1.1.1.1 manually\n\n### Android 11 or later\n\nAndroid 11 or later versions support both DNS over TLS (DoT) and DNS over HTTPS (DoH).\n\n1. Go to **Settings** > **Network & internet**.\n2. Select **Advanced** > **Private DNS**.\n3. Select the **Private DNS provider hostname** option.\n4. Depending on what you want to configure, use one of the following DNS hostnames or [IP addresses](https://developers.cloudflare.com/1.1.1.1/ip-addresses/) and select **Save**.\n\nOr the corresponding IP address if your device requires it:\n\n* **IPv4**: `1.1.1.1` or `1.0.0.1`\n* **IPv6**: `2606:4700:4700::1111` or `2606:4700:4700::1001`\n\nBlock malware with 1.1.1.1 for Families\n\n* `security.cloudflare-dns.com`\n\nOr the corresponding IP address if your device requires it:\n\n* **IPv4**: `1.1.1.2` or `1.0.0.2`\n* **IPv6**: `2606:4700:4700::1112` or `2606:4700:4700::1002`\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n* `family.cloudflare-dns.com`\n\nOr the corresponding IP address if your device requires it:\n\n* **IPv4**: `1.1.1.3` or `1.0.0.3`\n* **IPv6**: `2606:4700:4700::1113` or `2606:4700:4700::1003`\n\nAndroid 9 and Android 10 support DNS over TLS to secure your queries through encryption. In Android, this option is called Private DNS. It prevents your queries from being tracked, modified or surveilled by third-parties. Unlike previous versions of Android, this method also ensures 1.1.1.1 does not need to be configured for each new Wi-Fi network your smartphone joins.\n\n1. Go to **Settings** > **Network & internet**.\n2. Select **Advanced** > **Private DNS**.\n3. Select the **Private DNS provider hostname** option.\n4. Enter `one.one.one.one` and select **Save**. Or consider the following options if you want to use 1.1.1.1 for Families.\n\nBlock malware with 1.1.1.1 for Families\n\n* `security.cloudflare-dns.com`\n\nOr the corresponding IP address if your device requires it:\n\n* **IPv4**: `1.1.1.2` or `1.0.0.2`\n* **IPv6**: `2606:4700:4700::1112` or `2606:4700:4700::1002`\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n* `family.cloudflare-dns.com`\n\nOr the corresponding IP address if your device requires it:\n\n* **IPv4**: `1.1.1.3` or `1.0.0.3`\n* **IPv6**: `2606:4700:4700::1113` or `2606:4700:4700::1003`\n\n### Previous Android versions\n\nBefore making changes, take note of any DNS addresses you might have and save them in a safe place in case you need to use them later.\n\n1. Open **Settings** > **Wi-Fi**.\n\n2. Press down and hold the name of the network you are currently connected to.\n\n3. Select **Modify Network**.\n\n4. Select the checkbox **Show Advanced Options**.\n\n5. Change the IP Settings to **Static**.\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n7. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n8. Select **Save**. You may need to disconnect from the Wi-Fi and reconnect for the changes to take place.\n\nSetting up a static IP address to configure a DNS server may prevent you from connecting to some public Wi-Fi networks that use captive portals — these are the web pages some wireless networks employ to let users log in and use their services.\n\nIf you are experiencing connectivity issues related to captive portals:\n\n1. Remove the static IP addresses from the device or disable the 1.1.1.1 app.\n2. Connect to the Wi-Fi network.\n3. Once the connection has been established, re-add the static IP addresses or enable the 1.1.1.1 app.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on gaming consoles · Cloudflare 1.1.1.1 docs\ndescription: The following instructions work on New Nintendo 3DS, New Nintendo\n  3DS XL, New Nintendo 2DS XL, Nintendo 3DS, Nintendo 3DS XL, and Nintendo 2DS.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/gaming-consoles/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/gaming-consoles/index.md\n---\n\n1. Go to **Settings** > **Network** > **Set Up Internet Connection**.\n\n2. Select **Wi-Fi** or **LAN** depending on your Internet connection.\n\n3. Select **Custom**.\n\n4. Set **IP Address Settings** to **Automatic**.\n\n5. Change **DHCP Host Name** to **Do Not Specify**.\n\n6. Set **DNS Settings** to **Manual**.\n\n7. Change **Primary DNS** and **Secondary DNS** to:\n\n8. If you are able to add more DNS servers, you can add the IPv6 addresses as well:\n\n9. Set **MTU Settings** to **Automatic**.\n\n10. Set **Proxy Server** to **Do Not Use**.\n\n1. Open the Network screen by pressing the Xbox button on your controller.\n\n2. Go to **Settings** > **Network** > **Network Settings**.\n\n3. Next, go to **Advanced Settings** > **DNS Settings**.\n\n4. Select **Manual**.\n\n5. Set **Primary DNS** and **Secondary DNS** to:\n\n6. If you have the option to add more DNS servers, you can add the IPv6 addresses as well:\n\n7. When you are done, you will be shown a confirmation screen. Press **B** to save.\n\nThe following instructions work on New Nintendo 3DS, New Nintendo 3DS XL, New Nintendo 2DS XL, Nintendo 3DS, Nintendo 3DS XL, and Nintendo 2DS.\n\n1. Go to the home menu and choose **System Settings** (the wrench icon).\n\n2. Select **Internet Settings** > **Connection Settings**.\n\n3. Select your Internet connection and then select **Change Settings**.\n\n4. Select **Change DNS**.\n\n5. Set **Auto-Obtain DNS** to **No**.\n\n6. Select **Detailed Setup**.\n\n7. Set **Primary DNS** and **Secondary DNS** to:\n\n8. If you are able to add more DNS servers, you can add the IPv6 addresses as well:\n\n9. Select **Save** > **OK**.\n\n1. Press the home button and select **System Settings**.\n\n2. Scroll down and select **Internet** > **Internet Settings**.\n\n3. Select your Internet connection and then select **Change Settings**.\n\n4. Select **DNS Settings** > **Manual**.\n\n5. Set **Primary DNS** and **Secondary DNS** to:\n\n6. Select **Save** > **OK**.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on Google Cloud · Cloudflare 1.1.1.1 docs\ndescription: Google Cloud supports configuring outbound server policy within\n  Cloud DNS. Policies are applied per Virtual Private Cloud (VPC) network, and\n  will affect all resources within that VPC network, including any existing\n  virtual machines.\nlastUpdated: 2025-11-21T18:29:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/google-cloud/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/google-cloud/index.md\n---\n\nGoogle Cloud supports configuring [outbound server policy](https://cloud.google.com/dns/docs/server-policies-overview#dns-server-policy-out) within Cloud DNS. Policies are applied per Virtual Private Cloud (VPC) network, and will affect all resources within that VPC network, including any existing virtual machines.\n\nIf you are using [Cloudflare Zero Trust](https://developers.cloudflare.com/cloudflare-one/), you can choose assigned [locations](https://developers.cloudflare.com/cloudflare-one/networks/resolvers-and-proxies/dns/locations/) to apply custom [DNS policies](https://developers.cloudflare.com/cloudflare-one/traffic-policies/dns-policies/) via Gateway.\n\nTo configure 1.1.1.1 for your Google Cloud VPC network(s):\n\n1. Open the [Google Cloud Console](https://console.cloud.google.com).\n\n2. Navigate to **Network Services** > **Cloud DNS** and select [**DNS Server Policies**](https://console.cloud.google.com/net-services/dns/policies).\n\n3. Select **Create Policy**.\n\n4. Provide a name for your Policy (such as `cloudflare-1-1-1-1`) and select associated VPC network or networks.\n\n5. Under **Alternate DNS servers**, select **Add Item** and type:\n\n6. Select **Create**.\n\nDNS requests within the configured VPC network(s) will now use 1.1.1.1.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on iOS · Cloudflare 1.1.1.1 docs\ndescription: \"1.1.1.1: Faster Internet is the preferred method of setting up\n  1.1.1.1 DNS resolver and 1.1.1.1 for Families in iOS devices. It allows you to\n  automatically configure your phone to use 1.1.1.1 on any network you connect\n  to, and solves iOS inability of using an alternative DNS resolver in cellular\n  connections.\"\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/ios/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/ios/index.md\n---\n\n[1.1.1.1: Faster Internet](https://apps.apple.com/us/app/1-1-1-1-faster-internet/id1423538627) is the preferred method of setting up 1.1.1.1 DNS resolver and 1.1.1.1 for Families in iOS devices. It allows you to automatically configure your phone to use 1.1.1.1 on any network you connect to, and solves iOS inability of using an alternative DNS resolver in cellular connections.\n\nThe app also allows you to enable encryption for DNS queries or enable [WARP mode](https://developers.cloudflare.com/warp-client/), which keeps all your HTTP traffic private and secure, including your DNS queries to 1.1.1.1.\n\nYou can select between the options available in the app's settings. By default, 1.1.1.1: Faster Internet is configured to WARP mode.\n\n## Set up 1.1.1.1: Faster Internet\n\n1. Download [1.1.1.1: Faster Internet from the App Store](https://apps.apple.com/us/app/1-1-1-1-faster-internet/id1423538627) for free.\n2. Launch 1.1.1.1: Faster Internet and accept the Terms of Service.\n3. Install the VPN profile that allows your phone to connect securely to 1.1.1.1.\n4. Toggle the **WARP** button to **Connected**.\n\n### Enable 1.1.1.1 for Families\n\n1. Open 1.1.1.1: Faster Internet.\n2. Tap the **menu button**.\n3. Select **Advanced** > **Connection options**.\n4. In **DNS settings** > **1.1.1.1 for Families**, select the option you want to use.\n\n## Configure 1.1.1.1 manually\n\nIf you configure 1.1.1.1 manually, you will have to do it for every Wi-Fi network your device connects to. This method does not work for cellular connections.\n\nTake note of any DNS addresses you might have set up, and save them in a safe place in case you need to use them later.\n\n1. Go to **Settings** > **Wi-Fi**.\n\n2. Select the **'i'** icon next to the Wi-Fi network you are connected to.\n\n3. Scroll down and select **Configure DNS**.\n\n4. Change the configuration from **Automatic** to **Manual**.\n\n5. Select **Add Server**.\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n7. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\nSetting up a static IP address to configure a DNS server may prevent you from connecting to some public Wi-Fi networks that use captive portals — these are the web pages some wireless networks employ to let users log in and use their services.\n\nIf you are experiencing connectivity issues related to captive portals:\n\n1. Remove the static IP addresses from the device or disable the 1.1.1.1 app.\n2. Connect to the Wi-Fi network.\n3. Once the connection has been established, re-add the static IP addresses or enable the 1.1.1.1 app.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on Linux · Cloudflare 1.1.1.1 docs\ndescription: Learn how to set up 1.1.1.1 as your DNS resolver on a Linux system.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/linux/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/linux/index.md\n---\n\nBefore you begin, take note of any DNS addresses you might have set up, and save them in a safe place in case you need to use them later.\n\nConsider the sections below to set up 1.1.1.1 using either the [command line interface (CLI)](#use-command-line-interface-cli) or a [graphical user interface (GUI)](#use-graphical-user-interface-gui) of your preference.\n\n## Use command line interface (CLI)\n\nChoose whether you want to use 1.1.1.1 or 1.1.1.1 For Families, and replace `1.1.1.1` with the corresponding [IPv4 or IPv6 address](https://developers.cloudflare.com/1.1.1.1/ip-addresses/) accordingly.\n\nUsually, `/etc/resolv.conf` is where you can configure the resolver IPs that your system is using.\n\nIn that case, you can use the following one-line command to specify `1.1.1.1` as your DNS resolver and `1.0.0.1` as backup:\n\nNote that other systems, such as dynamic host configuration protocol (DHCP), may automatically write to `/etc/resolv.conf` and change that configuration. In those cases, consider changing your network settings or DHCP to use `1.1.1.1`.\n\nAlternatively, you can use an editor (`nano` or `vim`, for example) to manually edit the file.\n\n### `systemd-resolved`\n\nIf you use `systemd-resolved` utility and the resolver IPs configuration is in `/etc/systemd/resolved.conf`, consider the steps below:\n\n1. Run the following command, replacing `<EDITOR>` with your preferred editor.\n\n1. In the editor, add or edit the following lines:\n\nTo use DNS over TLS, add `#one.one.one.one` and set `DNSOverTLS` to `yes`, as in the following example:\n\n## Use graphical user interface (GUI)\n\n1. Go to **Show Applications** > **Settings** > **Network**.\n\n2. Select the adapter you want to configure — like your Ethernet adapter or Wi-Fi card — and select the **Settings** button.\n\n3. On the **IPv4** tab > **DNS** section, disable the **Automatic** toggle.\n\n4. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n1. Go to **System Settings** > **Wi-Fi & Internet** > **Wi-Fi & Networking**. (or **Connections**, if on Plasma 5)\n\n2. Select the connection you want to configure - like your current connected network.\n\n3. On the **IPv4** tab, select the **Method** drop-down menu > *Automatic (Only addresses)*.\n\n4. Select the text box next to **DNS servers**.\n\n5. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n6. On the **IPv6** tab, select the **Method** drop-down menu > *Automatic (Only addresses)*.\n\n7. Select the text box next to **DNS servers**.\n\n8. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\nSetting up a static IP address to configure a DNS server may prevent you from connecting to some public Wi-Fi networks that use captive portals — these are the web pages some wireless networks employ to let users log in and use their services.\n\nIf you are experiencing connectivity issues related to captive portals:\n\n1. Remove the static IP addresses from the device or disable the 1.1.1.1 app.\n2. Connect to the Wi-Fi network.\n3. Once the connection has been established, re-add the static IP addresses or enable the 1.1.1.1 app.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on macOS · Cloudflare 1.1.1.1 docs\ndescription: Take note of any DNS addresses you might have set up, and save them\n  in a safe place in case you need to use them later.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/macos/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/macos/index.md\n---\n\nTake note of any DNS addresses you might have set up, and save them in a safe place in case you need to use them later.\n\n1. Go to **System Settings**. You can find it by pressing `CMD + Space` on your keyboard and typing `System Settings`.\n\n2. Go to **Network**.\n\n3. Select a network service.\n\n4. Select **Details**.\n\n6. Under **DNS Servers**, select **Add**.\n\n7. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n8. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\nSetting up a static IP address to configure a DNS server may prevent you from connecting to some public Wi-Fi networks that use captive portals — these are the web pages some wireless networks employ to let users log in and use their services.\n\nIf you are experiencing connectivity issues related to captive portals:\n\n1. Remove the static IP addresses from the device or disable the 1.1.1.1 app.\n2. Connect to the Wi-Fi network.\n3. Once the connection has been established, re-add the static IP addresses or enable the 1.1.1.1 app.\n\n## Encrypt your DNS queries\n\n1.1.1.1 supports DNS over TLS (DoT) and DNS over HTTPS (DoH), two standards developed for encrypting plaintext DNS traffic. This prevents untrustworthy entities from interpreting and manipulating your queries. For more information on how to encrypt your DNS queries, please refer to the [Encrypted DNS documentation](https://developers.cloudflare.com/1.1.1.1/encryption/).\n\n<page>\n---\ntitle: Set up 1.1.1.1 on a router · Cloudflare 1.1.1.1 docs\ndescription: \"It is possible to encrypt DNS traffic out from your router using\n  DNS-over-TLS if it is running OpenWrt. For more details, see our blog post on\n  the topic: Adding DNS-Over-TLS support to OpenWrt (LEDE) with Unbound.\"\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/router/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/router/index.md\n---\n\n1. Go to the **IP address** used to access your router's admin console in your browser.\n\n* Linksys and Asus routers typically use `http://192.168.1.1` or `http://router.asus.com` (for ASUS).\n   * Netgear routers typically use `http://192.168.1.1` or `http://routerlogin.net`.\n   * D-Link routers typically use `http://192.168.0.1`.\n   * Ubiquiti routers typically use `http://unifi.ubnt.com`.\n\n2. Enter the router credentials. For consumer routers, the default credentials for the admin console are often found under or behind the device.\n\n3. In the admin console, find the place where **DNS settings** are set. This may be contained within categories such as **WAN** and **IPv6** (Asus Routers) or **Internet** (Netgear Routers). Consult your router's documentation for details.\n\n4. Take note of any DNS addresses that are currently set and save them in a safe place in case you need to use them later.\n\n5. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n7. Save the updated settings.\n\n## Using DNS-Over-TLS on OpenWrt\n\nIt is possible to encrypt DNS traffic out from your router using DNS-over-TLS if it is running OpenWrt. For more details, see our blog post on the topic: [Adding DNS-Over-TLS support to OpenWrt (LEDE) with Unbound](https://blog.cloudflare.com/dns-over-tls-for-openwrt/).\n\nStarting with [FRITZ!OS 7.20](https://en.avm.de/press/press-releases/2020/07/fritzos-720-more-performance-convenience-security/), DNS over TLS is supported, see [Configuring different DNS servers in the FRITZ!Box](https://en.avm.de/service/knowledge-base/dok/FRITZ-Box-7590/165_Configuring-different-DNS-servers-in-the-FRITZ-Box/).\n\n<page>\n---\ntitle: Set up 1.1.1.1 on Windows · Cloudflare 1.1.1.1 docs\ndescription: Take note of any DNS addresses you might have set up, and save them\n  in a safe place in case you need to use them later.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/windows/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/windows/index.md\n---\n\nTake note of any DNS addresses you might have set up, and save them in a safe place in case you need to use them later.\n\n1. Select the **Start menu** > **Settings**.\n\n2. On **Network and Internet**, select **Change Adapter Options**.\n\n3. Right-click on the Ethernet or Wi-Fi network you are connected to and select **Properties**.\n\n4. Choose **Internet Protocol Version 4**.\n\n5. Select **Properties** > **Use the following DNS server addresses**.\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n8. Go to **Internet Protocol Version 6**.\n\n9. Select **Properties** > **Use the following DNS server addresses**.\n\n10. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\nTake note of any DNS addresses you might have set up, and save them in a safe place in case you need to use them later.\n\n1. Select the **Start menu** > **Settings**.\n\n2. On **Network and Internet**, choose the adapter you want to configure - like your Ethernet adapter or Wi-Fi card.\n\n3. Scroll to **DNS server assignment** and select **Edit**.\n\n4. Select the **Automatic (DHCP)** drop-down menu > **Manual**.\n\n5. Select the **IPv4** toggle to turn it on.\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n7. Select the **IPv6** toggle.\n\n8. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\nSetting up a static IP address to configure a DNS server may prevent you from connecting to some public Wi-Fi networks that use captive portals — these are the web pages some wireless networks employ to let users log in and use their services.\n\nIf you are experiencing connectivity issues related to captive portals:\n\n1. Remove the static IP addresses from the device or disable the 1.1.1.1 app.\n2. Connect to the Wi-Fi network.\n3. Once the connection has been established, re-add the static IP addresses or enable the 1.1.1.1 app.\n\n## Encrypt your DNS queries\n\n1.1.1.1 supports DNS over TLS (DoT) and DNS over HTTPS (DoH), two standards developed for encrypting plaintext DNS traffic. This prevents untrustworthy entities from interpreting and manipulating your queries. For more information on how to encrypt your DNS queries, please refer to the [Encrypted DNS documentation](https://developers.cloudflare.com/1.1.1.1/encryption/).\n\n<page>\n---\ntitle: Agents API · Cloudflare Agents docs\ndescription: This page provides an overview of the Agent SDK API, including the\n  Agent class, methods and properties built-in to the Agents SDK.\nlastUpdated: 2025-12-12T16:34:43.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/agents-api/\n  md: https://developers.cloudflare.com/agents/api-reference/agents-api/index.md\n---\n\nThis page provides an overview of the Agent SDK API, including the `Agent` class, methods and properties built-in to the Agents SDK.\n\nThe Agents SDK exposes two main APIs:\n\n* The server-side `Agent` class. An Agent encapsulates all of the logic for an Agent, including how clients can connect to it, how it stores state, the methods it exposes, how to call AI models, and any error handling.\n* The client-side `AgentClient` class, which allows you to connect to an Agent instance from a client-side application. The client APIs also include React hooks, including `useAgent` and `useAgentChat`, and allow you to automatically synchronize state between each unique Agent (running server-side) and your client applications.\n\nAgents require [Cloudflare Durable Objects](https://developers.cloudflare.com/durable-objects/), see [Configuration](https://developers.cloudflare.com/agents/getting-started/testing-your-agent/#add-the-agent-configuration) to learn how to add the required bindings to your project.\n\nYou can also find more specific usage examples for each API in the [Agents API Reference](https://developers.cloudflare.com/agents/api-reference/).\n\nAn Agent can have many (millions of) instances: each instance is a separate micro-server that runs independently of the others. This allows Agents to scale horizontally: an Agent can be associated with a single user, or many thousands of users, depending on the agent you're building.\n\nInstances of an Agent are addressed by a unique identifier: that identifier (ID) can be the user ID, an email address, GitHub username, a flight ticket number, an invoice ID, or any other identifier that helps to uniquely identify the instance and for whom it is acting on behalf of.\n\nAn instance of an Agent is globally unique: given the same name (or ID), you will always get the same instance of an agent.\n\nThis allows you to avoid synchronizing state across requests: if an Agent instance represents a specific user, team, channel or other entity, you can use the Agent instance to store state for that entity. No need to set up a centralized session store.\n\nIf the client disconnects, you can always route the client back to the exact same Agent and pick up where they left off.\n\nWriting an Agent requires you to define a class that extends the `Agent` class from the Agents SDK package. An Agent encapsulates all of the logic for an Agent, including how clients can connect to it, how it stores state, the methods it exposes, and any error handling.\n\nYou can also define your own methods on an Agent: it's technically valid to publish an Agent that only has your own methods exposed, and create/get Agents directly from a Worker.\n\nYour own methods can access the Agent's environment variables and bindings on `this.env`, state on `this.setState`, and call other methods on the Agent via `this.yourMethodName`.\n\nThe WebSocket API allows you to accept and manage WebSocket connections made to an Agent.\n\nRepresents a WebSocket connection to an Agent.\n\nTypes of messages that can be received from a WebSocket.\n\n#### ConnectionContext\n\nContext information for a WebSocket connection.\n\n### State synchronization API\n\nTo learn more about how to manage state within an Agent, refer to the documentation on [managing and syncing state](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/).\n\nMethods and types for managing Agent state.\n\n#### Scheduling tasks\n\nSchedule tasks to run at a specified time in the future.\n\nRepresents a scheduled task.\n\nEach Agent instance has an embedded SQLite database that can be accessed using the `this.sql` method within any method on your `Agent` class.\n\nExecute SQL queries against the Agent's built-in SQLite database using the `this.sql` method within any method on your `Agent` class.\n\nVisit the [state management API documentation](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) within the Agents SDK, including the native `state` APIs and the built-in `this.sql` API for storing and querying data within your Agents.\n\nThe Agents SDK allows your Agent to act as an MCP (Model Context Protocol) client, connecting to remote MCP servers and using their tools, resources, and prompts.\n\nWhen your Agent connects to MCP servers, it can dynamically discover and use tools provided by those servers, enabling powerful integrations with external services.\n\nFor complete MCP client API documentation, including OAuth configuration and advanced usage, refer to the [Agent — MCP Client API](https://developers.cloudflare.com/agents/model-context-protocol/mcp-client-api/).\n\nThe Agents SDK provides a set of client APIs for interacting with Agents from client-side JavaScript code, including:\n\n* React hooks, including `useAgent` and `useAgentChat`, for connecting to Agents from client applications.\n* Client-side [state syncing](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) that allows you to subscribe to state updates between the Agent and any connected client(s) when calling `this.setState` within your Agent's code.\n* The ability to call remote methods (Remote Procedure Calls; RPC) on the Agent from client-side JavaScript code using the `@callable` method decorator.\n\nClient for connecting to an Agent from the browser.\n\nMake an HTTP request to an Agent.\n\nThe Agents SDK provides a React API for simplifying connection and routing to Agents from front-end frameworks, including React Router (Remix), Next.js, and Astro.\n\nReact hook for connecting to an Agent.\n\nThe Agents SDK exposes an `AIChatAgent` class that extends the `Agent` class and exposes an `onChatMessage` method that simplifies building interactive chat agents.\n\nYou can combine this with the `useAgentChat` React hook from the `agents/ai-react` package to manage chat state and messages between a user and your Agent(s).\n\nExtension of the `Agent` class with built-in chat capabilities.\n\n#### Resumable streaming\n\nThe `AIChatAgent` class provides **automatic resumable streaming** out of the box. When a client disconnects and reconnects during an active stream, the response automatically resumes from where it left off. This works across browser tabs and devices.\n\nWhen you use `AIChatAgent` with `useAgentChat`:\n\n1. **During streaming**: All chunks are automatically persisted to SQLite\n2. **On disconnect**: The stream continues server-side, buffering chunks\n3. **On reconnect**: Client receives all buffered chunks and continues streaming\n\n##### Disabling resume\n\nIf you don't want automatic resume (for example, for short responses), disable it:\n\n### Chat Agent React API\n\nReact hook for building AI chat interfaces using an Agent.\n\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n<page>\n---\ntitle: Browse the web · Cloudflare Agents docs\ndescription: Agents can browse the web using the Browser Rendering API or your\n  preferred headless browser service.\nlastUpdated: 2025-05-16T16:37:37.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/browse-the-web/\n  md: https://developers.cloudflare.com/agents/api-reference/browse-the-web/index.md\n---\n\nAgents can browse the web using the [Browser Rendering](https://developers.cloudflare.com/browser-rendering/) API or your preferred headless browser service.\n\n### Browser Rendering API\n\nThe [Browser Rendering](https://developers.cloudflare.com/browser-rendering/) allows you to spin up headless browser instances, render web pages, and interact with websites through your Agent.\n\nYou can define a method that uses Puppeteer to pull the content of a web page, parse the DOM, and extract relevant information by calling the OpenAI model:\n\nYou'll also need to add install the `@cloudflare/puppeteer` package and add the following to the wrangler configuration of your Agent:\n\nYou can also use [Browserbase](https://docs.browserbase.com/integrations/cloudflare/typescript) by using the Browserbase API directly from within your Agent.\n\nOnce you have your [Browserbase API key](https://docs.browserbase.com/integrations/cloudflare/typescript), you can add it to your Agent by creating a [secret](https://developers.cloudflare.com/workers/configuration/secrets/):\n\nInstall the `@cloudflare/puppeteer` package and use it from within your Agent to call the Browserbase API:\n\n<page>\n---\ntitle: Calling Agents · Cloudflare Agents docs\ndescription: Learn how to call your Agents from Workers, including how to create\n  Agents on-the-fly, address them, and route requests to specific instances of\n  an Agent.\nlastUpdated: 2025-08-27T15:01:29.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/calling-agents/\n  md: https://developers.cloudflare.com/agents/api-reference/calling-agents/index.md\n---\n\nLearn how to call your Agents from Workers, including how to create Agents on-the-fly, address them, and route requests to specific instances of an Agent.\n\n### Calling your Agent\n\nAgents are created on-the-fly and can serve multiple requests concurrently. Each Agent instance is isolated from other instances, can maintain its own state, and has a unique address.\n\nAn instance of an Agent is globally unique: given the same name (or ID), you will always get the same instance of an agent.\n\nThis allows you to avoid synchronizing state across requests: if an Agent instance represents a specific user, team, channel or other entity, you can use the Agent instance to store state for that entity. No need to set up a centralized session store.\n\nIf the client disconnects, you can always route the client back to the exact same Agent and pick up where they left off.\n\nYou can create and run an instance of an Agent directly from a Worker using either:\n\n* The `routeAgentRequest` helper: this will automatically map requests to an individual Agent based on the `/agents/:agent/:name` URL pattern. The value of `:agent` will be the name of your Agent class converted to `kebab-case`, and the value of `:name` will be the name of the Agent instance you want to create or retrieve.\n* `getAgentByName`, which will create a new Agent instance if none exists by that name, or retrieve a handle to an existing instance.\n\nSee the usage patterns in the following example:\n\nYou can also call other Agents from within an Agent and build multi-Agent systems.\n\nCalling other Agents uses the same APIs as calling into an Agent directly.\n\n### Calling methods on Agents\n\nWhen using `getAgentByName`, you can pass both requests (including WebSocket) connections and call methods defined directly on the Agent itself using the native [JavaScript RPC](https://developers.cloudflare.com/workers/runtime-apis/rpc/) (JSRPC) API.\n\nFor example, once you have a handle (or \"stub\") to an unique instance of your Agent, you can call methods on it:\n\nWhen using TypeScript, ensure you pass your Agent class as a TypeScript type parameter to the AgentNamespace type so that types are correctly inferred:\n\n### Naming your Agents\n\nWhen creating names for your Agents, think about what the Agent represents. A unique user? A team or company? A room or channel for collaboration?\n\nA consistent approach to naming allows you to:\n\n* direct incoming requests directly to the right Agent\n* deterministically route new requests back to that Agent, no matter where the client is in the world.\n* avoid having to rely on centralized session storage or external services for state management, since each Agent instance can maintain its own state.\n\nFor a given Agent definition (or 'namespace' in the code below), there can be millions (or tens of millions) of instances of that Agent, each handling their own requests, making calls to LLMs, and maintaining their own state.\n\nFor example, you might have an Agent for every user using your new AI-based code editor. In that case, you'd want to create Agents based on the user ID from your system, which would then allow that Agent to handle all requests for that user.\n\nIt also ensures that [state within the Agent](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/), including chat history, language preferences, model configuration and other context can associated specifically with that user, making it easier to manage state.\n\nThe example below shows how to create a unique agent Agent for each `userId` in a request:\n\nReplace `userId` with `teamName`, `channel`, `companyName` as fits your Agents goals - and/or configure authentication to ensure Agents are only created for known, authenticated users.\n\n### Authenticating Agents\n\nWhen building and deploying Agents using the Agents SDK, you will often want to authenticate clients before passing requests to an Agent in order to restrict who the Agent will call, authorize specific users for specific Agents, and/or to limit who can access administrative or debug APIs exposed by an Agent.\n\n* Handle authentication in your Workers code, before you invoke your Agent.\n* Use the built-in hooks when using the `routeAgentRequest` helper - `onBeforeConnect` and `onBeforeRequest`\n* Use your preferred router (such as Hono) and authentication middleware or provider to apply custom authentication schemes before calling an Agent using other methods.\n\nThe `routeAgentRequest` helper documented earlier in this guide exposes two useful hooks (`onBeforeConnect`, `onBeforeRequest`) that allow you to apply custom logic before creating or retrieving an Agent:\n\nIf you are using `getAgentByName` or the underlying Durable Objects routing API, you should authenticate incoming requests or WebSocket connections before calling `getAgentByName`.\n\nFor example, if you are using [Hono](https://hono.dev/), you can authenticate in the middleware before calling an Agent and passing a request (or a WebSocket connection) to it:\n\nThis ensures we only create Agents for authenticated users, and allows you to validate whether Agent names conform to your preferred naming scheme before instances are created.\n\n* Review the [API documentation](https://developers.cloudflare.com/agents/api-reference/agents-api/) for the Agents class to learn how to define\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n<page>\n---\ntitle: Configuration · Cloudflare Agents docs\ndescription: An Agent is configured like any other Cloudflare Workers project,\n  and uses a wrangler configuration file to define where your code is and what\n  services (bindings) it will use.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/configuration/\n  md: https://developers.cloudflare.com/agents/api-reference/configuration/index.md\n---\n\nAn Agent is configured like any other Cloudflare Workers project, and uses [a wrangler configuration](https://developers.cloudflare.com/workers/wrangler/configuration/) file to define where your code is and what services (bindings) it will use.\n\n### Project structure\n\nThe typical file structure for an Agent project created from `npm create cloudflare@latest agents-starter -- --template cloudflare/agents-starter` follows:\n\n### Example configuration\n\nBelow is a minimal `wrangler.jsonc` file that defines the configuration for an Agent, including the entry point, `durable_object` namespace, and code `migrations`:\n\nThe configuration includes:\n\n* A `main` field that points to the entry point of your Agent, which is typically a TypeScript (or JavaScript) file.\n* A `durable_objects` field that defines the [Durable Object namespace](https://developers.cloudflare.com/durable-objects/reference/glossary/) that your Agents will run within.\n* A `migrations` field that defines the code migrations that your Agent will use. This field is mandatory and must contain at least one migration. The `new_sqlite_classes` field is mandatory for the Agent to store state.\n\nAgents must define these fields in their `wrangler.jsonc` (or `wrangler.toml`) config file.\n\n<page>\n---\ntitle: HTTP and Server-Sent Events · Cloudflare Agents docs\ndescription: The Agents SDK allows you to handle HTTP requests and has native\n  support for Server-Sent Events (SSE). This allows you build applications that\n  can push data to clients and avoid buffering.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/http-sse/\n  md: https://developers.cloudflare.com/agents/api-reference/http-sse/index.md\n---\n\nThe Agents SDK allows you to handle HTTP requests and has native support for [Server-Sent Events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) (SSE). This allows you build applications that can push data to clients and avoid buffering.\n\n### Handling HTTP requests\n\nAgents can handle HTTP requests using the `onRequest` method, which is called whenever an HTTP request is received by the Agent instance. The method takes a `Request` object as a parameter and returns a `Response` object.\n\nReview the [Agents API reference](https://developers.cloudflare.com/agents/api-reference/agents-api/) to learn more about the `Agent` class and its methods.\n\n### Implementing Server-Sent Events\n\nThe Agents SDK support Server-Sent Events directly: you can use SSE to stream data back to the client over a long running connection. This avoids buffering large responses, which can both make your Agent feel slow, and forces you to buffer the entire response in memory.\n\nWhen an Agent is deployed to Cloudflare Workers, there is no effective limit on the total time it takes to stream the response back: large AI model responses that take several minutes to reason and then respond will not be prematurely terminated.\n\nNote that this does not mean the client can't potentially disconnect during the streaming process: you can account for this by either [writing to the Agent's stateful storage](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) and/or [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/). Because you can always [route to the same Agent](https://developers.cloudflare.com/agents/api-reference/calling-agents/), you do not need to use a centralized session store to pick back up where you left off when a client disconnects.\n\nThe following example uses the AI SDK to generate text and stream it back to the client. It will automatically stream the response back to the client as the model generates it:\n\n### WebSockets vs. Server-Sent Events\n\nBoth WebSockets and Server-Sent Events (SSE) enable real-time communication between clients and Agents. Agents built on the Agents SDK can expose both WebSocket and SSE endpoints directly.\n\n* WebSockets provide full-duplex communication, allowing data to flow in both directions simultaneously. SSE only supports server-to-client communication, requiring additional HTTP requests if the client needs to send data back.\n* WebSockets establish a single persistent connection that stays open for the duration of the session. SSE, being built on HTTP, may experience more overhead due to reconnection attempts and header transmission with each reconnection, especially when there is a lot of client-server communication.\n* While SSE works well for simple streaming scenarios, WebSockets are better suited for applications requiring minutes or hours of connection time, as they maintain a more stable connection with built-in ping/pong mechanisms to keep connections alive.\n* WebSockets use their own protocol (ws\\:// or wss\\://), separating them from HTTP after the initial handshake. This separation allows WebSockets to better handle binary data transmission and implement custom subprotocols for specialized use cases.\n\nIf you're unsure of which is better for your use-case, we recommend WebSockets. The [WebSockets API documentation](https://developers.cloudflare.com/agents/api-reference/websockets/) provides detailed information on how to use WebSockets with the Agents SDK.\n\n* Review the [API documentation](https://developers.cloudflare.com/agents/api-reference/agents-api/) for the Agents class to learn how to define them.\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n<page>\n---\ntitle: Retrieval Augmented Generation · Cloudflare Agents docs\ndescription: Agents can use Retrieval Augmented Generation (RAG) to retrieve\n  relevant information and use it augment calls to AI models. Store a user's\n  chat history to use as context for future conversations, summarize documents\n  to bootstrap an Agent's knowledge base, and/or use data from your Agent's web\n  browsing tasks to enhance your Agent's capabilities.\nlastUpdated: 2025-05-14T14:20:47.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/rag/\n  md: https://developers.cloudflare.com/agents/api-reference/rag/index.md\n---\n\nAgents can use Retrieval Augmented Generation (RAG) to retrieve relevant information and use it augment [calls to AI models](https://developers.cloudflare.com/agents/api-reference/using-ai-models/). Store a user's chat history to use as context for future conversations, summarize documents to bootstrap an Agent's knowledge base, and/or use data from your Agent's [web browsing](https://developers.cloudflare.com/agents/api-reference/browse-the-web/) tasks to enhance your Agent's capabilities.\n\nYou can use the Agent's own [SQL database](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state) as the source of truth for your data and store embeddings in [Vectorize](https://developers.cloudflare.com/vectorize/) (or any other vector-enabled database) to allow your Agent to retrieve relevant information.\n\nIf you're brand-new to vector databases and Vectorize, visit the [Vectorize tutorial](https://developers.cloudflare.com/vectorize/get-started/intro/) to learn the basics, including how to create an index, insert data, and generate embeddings.\n\nYou can query a vector index (or indexes) from any method on your Agent: any Vectorize index you attach is available on `this.env` within your Agent. If you've [associated metadata](https://developers.cloudflare.com/vectorize/best-practices/insert-vectors/#metadata) with your vectors that maps back to data stored in your Agent, you can then look up the data directly within your Agent using `this.sql`.\n\nHere's an example of how to give an Agent retrieval capabilities:\n\nYou'll also need to connect your Agent to your vector indexes:\n\nIf you have multiple indexes you want to make available, you can provide an array of `vectorize` bindings.\n\n* Learn more on how to [combine Vectorize and Workers AI](https://developers.cloudflare.com/vectorize/get-started/embeddings/)\n* Review the [Vectorize query API](https://developers.cloudflare.com/vectorize/reference/client-api/)\n* Use [metadata filtering](https://developers.cloudflare.com/vectorize/reference/metadata-filtering/) to add context to your results\n\n<page>\n---\ntitle: Run Workflows · Cloudflare Agents docs\ndescription: Agents can trigger asynchronous Workflows, allowing your Agent to\n  run complex, multi-step tasks in the background. This can include\n  post-processing files that a user has uploaded, updating the embeddings in a\n  vector database, and/or managing long-running user-lifecycle email or SMS\n  notification workflows.\nlastUpdated: 2025-05-14T14:20:47.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/run-workflows/\n  md: https://developers.cloudflare.com/agents/api-reference/run-workflows/index.md\n---\n\nAgents can trigger asynchronous [Workflows](https://developers.cloudflare.com/workflows/), allowing your Agent to run complex, multi-step tasks in the background. This can include post-processing files that a user has uploaded, updating the embeddings in a [vector database](https://developers.cloudflare.com/vectorize/), and/or managing long-running user-lifecycle email or SMS notification workflows.\n\nBecause an Agent is just like a Worker script, it can create Workflows defined in the same project (script) as the Agent *or* in a different project.\n\nAgents and Workflows have some similarities: they can both run tasks asynchronously. For straightforward tasks that are linear or need to run to completion, a Workflow can be ideal: steps can be retried, they can be cancelled, and can act on events.\n\nAgents do not have to run to completion: they can loop, branch and run forever, and they can also interact directly with users (over HTTP or WebSockets). An Agent can be used to trigger multiple Workflows as it runs, and can thus be used to co-ordinate and manage Workflows to achieve its goals.\n\n## Trigger a Workflow\n\nAn Agent can trigger one or more Workflows from within any method, whether from an incoming HTTP request, a WebSocket connection, on a delay or schedule, and/or from any other action the Agent takes.\n\nTriggering a Workflow from an Agent is no different from [triggering a Workflow from a Worker script](https://developers.cloudflare.com/workflows/build/trigger-workflows/):\n\nYou'll also need to make sure your Agent [has a binding to your Workflow](https://developers.cloudflare.com/workflows/build/trigger-workflows/#workers-api-bindings) so that it can call it:\n\n## Trigger a Workflow from another project\n\nYou can also call a Workflow that is defined in a different Workers script from your Agent by setting the `script_name` property in the `workflows` binding of your Agent:\n\nRefer to the [cross-script calls](https://developers.cloudflare.com/workflows/build/workers-api/#cross-script-calls) section of the Workflows documentation for more examples.\n\n<page>\n---\ntitle: Schedule tasks · Cloudflare Agents docs\ndescription: An Agent can schedule tasks to be run in the future by calling\n  this.schedule(when, callback, data), where when can be a delay, a Date, or a\n  cron string; callback the function name to call, and data is an object of data\n  to pass to the function.\nlastUpdated: 2025-09-24T13:21:38.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/schedule-tasks/\n  md: https://developers.cloudflare.com/agents/api-reference/schedule-tasks/index.md\n---\n\nAn Agent can schedule tasks to be run in the future by calling `this.schedule(when, callback, data)`, where `when` can be a delay, a `Date`, or a cron string; `callback` the function name to call, and `data` is an object of data to pass to the function.\n\nScheduled tasks can do anything a request or message from a user can: make requests, query databases, send emails, read+write state: scheduled tasks can invoke any regular method on your Agent.\n\nYou can call `this.schedule` within any method on an Agent, and schedule tens-of-thousands of tasks per individual Agent:\n\nTasks that set a callback for a method that does not exist will throw an exception: ensure that the method named in the `callback` argument of `this.schedule` exists on your `Agent` class.\n\nYou can schedule tasks in multiple ways:\n\nCalling `await this.schedule` returns a `Schedule`, which includes the task's randomly generated `id`. You can use this `id` to retrieve or cancel the task in the future. It also provides a `type` property that indicates the type of schedule, for example, one of `\"scheduled\" | \"delayed\" | \"cron\"`.\n\nMaximum scheduled tasks\n\nEach task is mapped to a row in the Agent's underlying [SQLite database](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/), which means that each task can be up to 2 MB in size. The maximum number of tasks must be `(task_size * tasks) + all_other_state < maximum_database_size` (currently 1GB per Agent).\n\n### Managing scheduled tasks\n\nYou can get, cancel and filter across scheduled tasks within an Agent using the scheduling API:\n\n<page>\n---\ntitle: Store and sync state · Cloudflare Agents docs\ndescription: Every Agent has built-in state management capabilities, including\n  built-in storage and synchronization between the Agent and frontend\n  applications.\nlastUpdated: 2025-10-23T15:22:15.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/\n  md: https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/index.md\n---\n\nEvery Agent has built-in state management capabilities, including built-in storage and synchronization between the Agent and frontend applications.\n\nState within an Agent is:\n\n* Persisted across Agent restarts: data is permanently stored within an Agent.\n* Automatically serialized/deserialized: you can store any JSON-serializable data.\n* Immediately consistent within the Agent: read your own writes.\n* Thread-safe for concurrent updates\n* Fast: state is colocated wherever the Agent is running. Reads and writes do not need to traverse the network.\n\nAgent state is stored in a SQL database that is embedded within each individual Agent instance: you can interact with it using the higher-level `this.setState` API (recommended), which allows you to sync state and trigger events on state changes, or by directly querying the database with `this.sql`.\n\nEvery Agent has built-in state management capabilities. You can set and update the Agent's state directly using `this.setState`:\n\nIf you're using TypeScript, you can also provide a type for your Agent's state by passing in a type as a [type parameter](https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints) as the *second* type parameter to the `Agent` class definition.\n\n### Set the initial state for an Agent\n\nYou can also set the initial state for an Agent via the `initialState` property on the `Agent` class:\n\nAny initial state is synced to clients connecting via [the `useAgent` hook](#synchronizing-state).\n\n### Synchronizing state\n\nClients can connect to an Agent and stay synchronized with its state using the React hooks provided as part of `agents/react`.\n\nA React application can call `useAgent` to connect to a named Agent over WebSockets at\n\nThe state synchronization system:\n\n* Automatically syncs the Agent's state to all connected clients\n* Handles client disconnections and reconnections gracefully\n* Provides immediate local updates\n* Supports multiple simultaneous client connections\n\n* Real-time collaborative features\n* Multi-window/tab synchronization\n* Live updates across multiple devices\n* Maintaining consistent UI state across clients\n* When new clients connect, they automatically receive the current state from the Agent, ensuring all clients start with the latest data.\n\nEvery individual Agent instance has its own SQL (SQLite) database that runs *within the same context* as the Agent itself. This means that inserting or querying data within your Agent is effectively zero-latency: the Agent doesn't have to round-trip across a continent or the world to access its own data.\n\nYou can access the SQL API within any method on an Agent via `this.sql`. The SQL API accepts template literals, and\n\nYou can also supply a [TypeScript type argument](https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints) to the query, which will be used to infer the type of the result:\n\nYou do not need to specify an array type (`User[]` or `Array<User>`) as `this.sql` will always return an array of the specified type.\n\nProviding a type parameter does not validate that the result matches your type definition. In TypeScript, properties (fields) that do not exist or conform to the type you provided will be dropped. If you need to validate incoming events, we recommend a library such as [zod](https://zod.dev/) or your own validator logic.\n\nLearn more about the zero-latency SQL storage that powers both Agents and Durable Objects [on our blog](https://blog.cloudflare.com/sqlite-in-durable-objects/).\n\nThe SQL API exposed to an Agent is similar to the one [within Durable Objects](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/#sql-api): Durable Object SQL methods available on `this.ctx.storage.sql`. You can use the same SQL queries with the Agent's database, create tables, and query data, just as you would with Durable Objects or [D1](https://developers.cloudflare.com/d1/).\n\n### Use Agent state as model context\n\nYou can combine the state and SQL APIs in your Agent with its ability to [call AI models](https://developers.cloudflare.com/agents/api-reference/using-ai-models/) to include historical context within your prompts to a model. Modern Large Language Models (LLMs) often have very large context windows (up to millions of tokens), which allows you to pull relevant context into your prompt directly.\n\nFor example, you can use an Agent's built-in SQL database to pull history, query a model with it, and append to that history ahead of the next call to the model:\n\nThis works because each instance of an Agent has its *own* database, the state stored in that database is private to that Agent: whether it's acting on behalf of a single user, a room or channel, or a deep research tool. By default, you don't have to manage contention or reach out over the network to a centralized database to retrieve and store state.\n\n* Review the [API documentation](https://developers.cloudflare.com/agents/api-reference/agents-api/) for the Agents class to learn how to define them.\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n<page>\n---\ntitle: Using AI Models · Cloudflare Agents docs\ndescription: \"Agents can communicate with AI models hosted on any provider, including:\"\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\ntags: AI\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/using-ai-models/\n  md: https://developers.cloudflare.com/agents/api-reference/using-ai-models/index.md\n---\n\nAgents can communicate with AI models hosted on any provider, including:\n\n* [Workers AI](https://developers.cloudflare.com/workers-ai/)\n* The [AI SDK](https://sdk.vercel.ai/docs/ai-sdk-core/overview)\n* [OpenAI](https://platform.openai.com/docs/quickstart?language=javascript)\n* [Anthropic](https://docs.anthropic.com/en/api/client-sdks#typescript)\n* [Google's Gemini](https://ai.google.dev/gemini-api/docs/openai)\n\nYou can also use the model routing features in [AI Gateway](https://developers.cloudflare.com/ai-gateway/) to route across providers, eval responses, and manage AI provider rate limits.\n\nBecause Agents are built on top of [Durable Objects](https://developers.cloudflare.com/durable-objects/), each Agent or chat session is associated with a stateful compute instance. Traditional serverless architectures often present challenges for persistent connections needed in real-time applications like chat.\n\nA user can disconnect during a long-running response from a modern reasoning model (such as `o3-mini` or DeepSeek R1), or lose conversational context when refreshing the browser. Instead of relying on request-response patterns and managing an external database to track & store conversation state, state can be stored directly within the Agent. If a client disconnects, the Agent can write to its own distributed storage, and catch the client up as soon as it reconnects: even if it's hours or days later.\n\nYou can call models from any method within an Agent, including from HTTP requests using the [`onRequest`](https://developers.cloudflare.com/agents/api-reference/agents-api/) handler, when a [scheduled task](https://developers.cloudflare.com/agents/api-reference/schedule-tasks/) runs, when handling a WebSocket message in the [`onMessage`](https://developers.cloudflare.com/agents/api-reference/websockets/) handler, or from any of your own methods.\n\nImportantly, Agents can call AI models on their own — autonomously — and can handle long-running responses that can take minutes (or longer) to respond in full.\n\n### Long-running model requests\n\nModern [reasoning models](https://platform.openai.com/docs/guides/reasoning) or \"thinking\" model can take some time to both generate a response *and* stream the response back to the client.\n\nInstead of buffering the entire response, or risking the client disconnecting, you can stream the response back to the client by using the [WebSocket API](https://developers.cloudflare.com/agents/api-reference/websockets/).\n\nYou can also persist AI model responses back to [Agent's internal state](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) by using the `this.setState` method. For example, if you run a [scheduled task](https://developers.cloudflare.com/agents/api-reference/schedule-tasks/), you can store the output of the task and read it later. Or, if a user disconnects, read the message history back and send it to the user when they reconnect.\n\nYou can use [any of the models available in Workers AI](https://developers.cloudflare.com/workers-ai/models/) within your Agent by [configuring a binding](https://developers.cloudflare.com/workers-ai/configuration/bindings/).\n\nWorkers AI supports streaming responses out-of-the-box by setting `stream: true`, and we strongly recommend using them to avoid buffering and delaying responses, especially for larger models or reasoning models that require more time to generate a response.\n\nYour Wrangler configuration will need an `ai` binding added:\n\nYou can also use the model routing features in [AI Gateway](https://developers.cloudflare.com/ai-gateway/) directly from an Agent by specifying a [`gateway` configuration](https://developers.cloudflare.com/ai-gateway/usage/providers/workersai/) when calling the AI binding.\n\nModel routing allows you to route requests to different AI models based on whether they are reachable, rate-limiting your client, and/or if you've exceeded your cost budget for a specific provider.\n\nYour Wrangler configuration will need an `ai` binding added. This is shared across both Workers AI and AI Gateway.\n\nVisit the [AI Gateway documentation](https://developers.cloudflare.com/ai-gateway/) to learn how to configure a gateway and retrieve a gateway ID.\n\nThe [AI SDK](https://sdk.vercel.ai/docs/introduction) provides a unified API for using AI models, including for text generation, tool calling, structured responses, image generation, and more.\n\nTo use the AI SDK, install the `ai` package and use it within your Agent. The example below shows how it use it to generate text on request, but you can use it from any method within your Agent, including WebSocket handlers, as part of a scheduled task, or even when the Agent is initialized.\n\n### OpenAI compatible endpoints\n\nAgents can call models across any service, including those that support the OpenAI API. For example, you can use the OpenAI SDK to use one of [Google's Gemini models](https://ai.google.dev/gemini-api/docs/openai#node.js) directly from your Agent.\n\nAgents can stream responses back over HTTP using Server Sent Events (SSE) from within an `onRequest` handler, or by using the native [WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) API in your Agent to responses back to a client, which is especially useful for larger models that can take over 30+ seconds to reply.\n\n<page>\n---\ntitle: Using WebSockets · Cloudflare Agents docs\ndescription: Users and clients can connect to an Agent directly over WebSockets,\n  allowing long-running, bi-directional communication with your Agent as it\n  operates.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/websockets/\n  md: https://developers.cloudflare.com/agents/api-reference/websockets/index.md\n---\n\nUsers and clients can connect to an Agent directly over WebSockets, allowing long-running, bi-directional communication with your Agent as it operates.\n\nTo enable an Agent to accept WebSockets, define `onConnect` and `onMessage` methods on your Agent.\n\n* `onConnect(connection: Connection, ctx: ConnectionContext)` is called when a client establishes a new WebSocket connection. The original HTTP request, including request headers, cookies, and the URL itself, are available on `ctx.request`.\n* `onMessage(connection: Connection, message: WSMessage)` is called for each incoming WebSocket message. Messages are one of `ArrayBuffer | ArrayBufferView | string`, and you can send messages back to a client using `connection.send()`. You can distinguish between client connections by checking `connection.id`, which is unique for each connected client.\n\nHere's an example of an Agent that echoes back any message it receives:\n\n### Connecting clients\n\nThe Agent framework includes a useful helper package for connecting directly to your Agent (or other Agents) from a client application. Import `agents/client`, create an instance of `AgentClient` and use it to connect to an instance of your Agent:\n\nReact-based applications can import `agents/react` and use the `useAgent` hook to connect to an instance of an Agent directly:\n\nThe `useAgent` hook automatically handles the lifecycle of the connection, ensuring that it is properly initialized and cleaned up when the component mounts and unmounts. You can also [combine `useAgent` with `useState`](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) to automatically synchronize state across all clients connected to your Agent.\n\n### Handling WebSocket events\n\nDefine `onError` and `onClose` methods on your Agent to explicitly handle WebSocket client errors and close events. Log errors, clean up state, and/or emit metrics:\n\n<page>\n---\ntitle: Agent class internals · Cloudflare Agents docs\ndescription: The core of the agents library is the exported Agent class.\n  Following the pattern from Durable Objects, the main API for developers is to\n  extend the Agent class to inherit all the built-in features. While this\n  effectively is a supercharged primitive that allows developers to only write\n  the logic they need in their agents, it obscures the inner workings.\nlastUpdated: 2025-11-07T18:37:32.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/agent-class/\n  md: https://developers.cloudflare.com/agents/concepts/agent-class/index.md\n---\n\nThe core of the `agents` library is the exported `Agent` class. Following the pattern from [Durable Objects](https://developers.cloudflare.com/durable-objects/api/), the main API for developers is to extend the `Agent` class to inherit all the built-in features. While this effectively is a supercharged primitive that allows developers to only write the logic they need in their agents, it obscures the inner workings.\n\nThis document tries to bridge that gap, empowering any developer aiming to get started writing agents to get the full picture and avoid common pitfalls. The snippets shown here are primarily illustrative, and do not necessarily represent best practices. For a more in-depth look at the inner workings of the `Agent` class, check out the [API reference](https://developers.cloudflare.com/agents/api-reference/) and the [source code](https://github.com/cloudflare/agents/blob/main/packages/agents/src/index.ts).\n\n## What is the Agent?\n\nThe `Agent` class is an extension of `DurableObject`. That is to say, they *are* Durable Objects. If you are not familiar with Durable Objects, it is highly recommended that you read [What are Durable Objects](https://developers.cloudflare.com/durable-objects/), but at their core, Durable Objects are globally addressable (each instance has a unique ID) single-threaded compute instances with long term storage (key-value/SQLite).\n\nNote that `Agent` does not extend `DurableObject` directly, but instead extends `Server`. `Server` is a class provided by [PartyKit](https://github.com/cloudflare/partykit/tree/main/packages/partyserver).\n\nYou can visualize the logic as a Matryoshka doll: **DurableObject** > **Server** > **Agent**.\n\n## Layer 0: Durable Object\n\nLet's briefly consider which primitives are exposed by Durable Objects so we understand how the outer layers make use of them. The Durable Object class comes with:\n\nThe Workers runtime always calls the constructor to handle things internally. This means two things:\n\n1. While the constructor is called every time the Durable Object is initialized, the signature is fixed. Developers cannot add or update parameters from the constructor.\n2. Instead of instantiating the class manually, developers must use the binding APIs and do it through the [DurableObjectNamespace](https://developers.cloudflare.com/durable-objects/api/namespace/).\n\nBy writing a Durable Object class which inherits from the built-in type `DurableObject`, public methods are exposed as RPC methods, which developers can call using a [DurableObjectStub from a Worker](https://developers.cloudflare.com/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/#invoking-methods-on-a-durable-object).\n\nDurable Objects can take a `Request` from a Worker and send a `Response` back. This can only be done through the [`fetch`](https://developers.cloudflare.com/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/#invoking-the-fetch-handler) method (which the developer must implement).\n\nDurable Objects include first-class support for [WebSockets](https://developers.cloudflare.com/durable-objects/best-practices/websockets/). A Durable Object can accept a WebSocket it receives from a `Request` in `fetch` and forget about it. The base class provides methods that developers can implement that are called as callbacks. They effectively replace the need for event listeners.\n\nThe base class provides `webSocketMessage(ws, message)`, `webSocketClose(ws, code, reason, wasClean)` and `webSocketError(ws , error)` ([API](https://developers.cloudflare.com/workers/runtime-apis/websockets)).\n\nHTTP and RPC requests are not the only entrypoints for a Durable Object. Alarms allow developers to schedule an event to trigger at a later time. Whenever the next alarm is due, the runtime will call the `alarm()` method, which is left to the developer to implement.\n\nTo schedule an alarm, you can use the `this.ctx.storage.setAlarm()` method. For more information, refer to [Alarms](https://developers.cloudflare.com/durable-objects/api/alarms/).\n\nThe base `DurableObject` class sets the [DurableObjectState](https://developers.cloudflare.com/durable-objects/api/state/) into `this.ctx`. There are a lot of interesting methods and properties, but we will focus on `this.ctx.storage`.\n\n### `this.ctx.storage`\n\n[DurableObjectStorage](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/) is the main interface with the Durable Object's persistence mechanisms, which include both a KV and SQLITE **synchronous** APIs.\n\nLastly, it is worth mentioning that the Durable Object also has the Worker `Env` in `this.env`. Learn more in [Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings).\n\n## Layer 1: Partykit `Server`\n\nNow that you have seen what Durable Objects come with out-of-the-box, what [PartyKit](https://github.com/cloudflare/partykit)'s `Server` (package `partyserver`) implements will be clearer. It is an opinionated `DurableObject` wrapper that improves DX by hiding away Durable Object primitives in favor of more developer friendly callbacks.\n\nAn important note is that `Server` does NOT persist to the Durable Object storage, so you will not see extra storage operations by using it.\n\n`partyserver` exposes helper to address your Durable Objects instead of manually through your bindings. This allows `partyserver` to implement several improvements, including a unique URL routing scheme for your Durable Objects (e.g. `<your-worker>/servers/:durableClass/:durableName`).\n\nCompare this to the Durable Object addressing [example above](#rpc).\n\nSince we have a URL addressing scheme, we also get access to `routePartykitRequest()`.\n\nYou can also refer to [the implementation](https://github.com/cloudflare/partykit/blob/main/packages/partyserver/src/index.ts#L122) to learn more.\n\nThe extra plumbing that `Server` includes on addressing allows it to expose an `onStart` callback that is executed every time the Durable Object starts up (the Durable Object was evicted, hibernated or never created at all) and before any `fetch` or RPC.\n\n### `onRequest` and `onConnect`\n\n`Server` already implements `fetch` for the underlying Durable Object and exposes two different callbacks that developers can make use of, `onRequest` and `onConnect` for HTTP requests and incoming WS connections, respectively (WebSocket connections are accepted by default).\n\nJust as `onConnect` is the callback for every new connection, `Server` also provides wrappers on top of the default callbacks from the `DurableObject` class: `onMessage`, `onClose` and `onError`.\n\nThere's also `this.broadcast` that sends a WS message to all connected clients (no magic, just a loop over `this.getConnections()`!).\n\nIt is hard to get a Durable Object's `name` from within it. `partyserver` tries to make it available in `this.name` but it is not a perfect solution. Learn more about it in [this GitHub issue](https://github.com/cloudflare/workerd/issues/2240).\n\nNow finally, the `Agent` class. `Agent` extends `Server` and provides opinionated primitives for stateful, schedulable, and observable agents that can communicate via RPC, WebSockets, and (even!) email.\n\n### `this.state` and `this.setState()`\n\nOne of the core features of `Agent` is **automatic state persistence**. Developers define the shape of their state via the generic parameter and `initialState` (which is only used if no state exists in storage), and the Agent handles loading, saving, and broadcasting state changes (check `Server`'s `this.broadcast()` above).\n\n`this.state` is a getter that lazily loads state from storage (SQL). State is persisted across Durable Object evictions when it is updated with `this.setState()`, which automatically serializes the state and writes it back to storage.\n\nThere's also `this.onStateUpdate` that you can override to react to state changes.\n\nState is stored in the `cf_agents_state` SQL table. State messages are sent with `type: \"cf_agent_state\"` (both from the client and the server). Since the `agents` provides [JS and React clients](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/#synchronizing-state), real-time state updates are available out of the box.\n\nThe Agent provides a convenient `sql` template tag for executing queries against the Durable Object's SQL storage. It constructs parameterized queries and executes them. This uses the **synchronous** SQL API from `this.ctx.storage.sql`.\n\n### RPC and Callable Methods\n\n`agents` take Durable Objects RPC one step forward by implementing RPC through WebSockets, so clients can also call methods on the Agent directly. To make a method callable through WS, developers can use the `@callable` decorator. Methods can return a serializable value or a stream (when using `@callable({ stream: true })`).\n\nClients can invoke this method by sending a WebSocket message:\n\nFor example, with the provided `React` client, it is as easy as:\n\n### `this.queue` and friends\n\nAgents include a built-in task queue for deferred execution. This is useful for offloading work or retrying operations. The available methods are `this.queue`, `this.dequeue`, `this.dequeueAll`, `this.dequeueAllByCallback`, `this.getQueue`, and `this.getQueues`.\n\nTasks are stored in the `cf_agents_queues` SQL table and are automatically flushed in sequence. If a task succeeds, it is automatically dequeued.\n\n### `this.schedule` and friends\n\nAgents support scheduled execution of methods by wrapping the Durable Object's `alarm()`. The available methods are `this.schedule`, `this.getSchedule`, `this.getSchedules`, `this.cancelSchedule`. Schedules can be one-time, delayed, or recurring (using cron expressions).\n\nSince Durable Objects only allow one alarm at a time, the `Agent` class works around this by managing multiple schedules in SQL and using a single alarm.\n\nSchedules are stored in the `cf_agents_schedules` SQL table. Cron schedules automatically reschedule themselves after execution, while one-time schedules are deleted.\n\n### `this.mcp` and friends\n\n`Agent` includes a multi-server MCP client. This enables your Agent to interact with external services that expose MCP interfaces. The MCP client is properly documented in [MCP client API](https://developers.cloudflare.com/agents/model-context-protocol/mcp-client-api/).\n\nAgents can receive and reply to emails using Cloudflare's [Email Routing](https://developers.cloudflare.com/email-routing/email-workers/).\n\nTo route emails to your Agent, use `routeAgentEmail` in your Worker's email handler:\n\n### Context Management\n\n`agents` wraps all your methods with an `AsyncLocalStorage` to maintain context throughout the request lifecycle. This allows you to access the current agent, connection, request, or email (depending of what event is being handled) from anywhere in your code:\n\n`Agent` extends `Server`'s `onError` so it can be used to handle errors that are not necessarily WebSocket errors. It is called with a `Connection` or `unknown` error.\n\n`this.destroy()` drops all tables, deletes alarms, clears storage, and aborts the context. To ensure that the Durable Object is fully evicted, `this.ctx.abort()` is called, which throws an uncatchable error that will show up in your logs (read more about it in [abort()](https://developers.cloudflare.com/durable-objects/api/state/#abort)).\n\nThe `Agent` class re-exports PartyKit's [addressing helpers](#addressing) as `getAgentByName` and `routeAgentRequest`.\n\n<page>\n---\ntitle: Calling LLMs · Cloudflare Agents docs\ndescription: Different LLM providers offer models optimized for specific types\n  of tasks. When building AI systems, choosing the right model is crucial for\n  both performance and cost efficiency.\nlastUpdated: 2025-08-15T20:11:52.000Z\nchatbotDeprioritize: false\ntags: LLM\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/calling-llms/\n  md: https://developers.cloudflare.com/agents/concepts/calling-llms/index.md\n---\n\n### Understanding LLM providers and model types\n\nDifferent LLM providers offer models optimized for specific types of tasks. When building AI systems, choosing the right model is crucial for both performance and cost efficiency.\n\n#### Reasoning Models\n\nModels like OpenAI's o1, Anthropic's Claude, and DeepSeek's R1 are particularly well-suited for complex reasoning tasks. These models excel at:\n\n* Breaking down problems into steps\n* Following complex instructions\n* Maintaining context across long conversations\n* Generating code and technical content\n\nFor example, when implementing a travel booking system, you might use a reasoning model to analyze travel requirements and generate appropriate booking strategies.\n\n#### Instruction Models\n\nModels like GPT-4 and Claude Instant are optimized for following straightforward instructions efficiently. They work well for:\n\n* Content generation\n* Simple classification tasks\n* Basic question answering\n* Text transformation\n\nThese models are often more cost-effective for straightforward tasks that do not require complex reasoning.\n\n<page>\n---\ntitle: Human in the Loop · Cloudflare Agents docs\ndescription: Human-in-the-Loop (HITL) workflows integrate human judgment and\n  oversight into automated processes. These workflows pause at critical points\n  for human review, validation, or decision-making before proceeding. This\n  approach combines the efficiency of automation with human expertise and\n  oversight where it matters most.\nlastUpdated: 2025-04-30T09:59:18.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/human-in-the-loop/\n  md: https://developers.cloudflare.com/agents/concepts/human-in-the-loop/index.md\n---\n\n### What is Human-in-the-Loop?\n\nHuman-in-the-Loop (HITL) workflows integrate human judgment and oversight into automated processes. These workflows pause at critical points for human review, validation, or decision-making before proceeding. This approach combines the efficiency of automation with human expertise and oversight where it matters most.\n\n![A human-in-the-loop diagram](https://developers.cloudflare.com/_astro/human-in-the-loop.C2xls7fV_1vt7N8.svg)\n\n#### Understanding Human-in-the-Loop workflows\n\nIn a Human-in-the-Loop workflow, processes are not fully automated. Instead, they include designated checkpoints where human intervention is required. For example, in a travel booking system, a human may want to confirm the travel before an agent follows through with a transaction. The workflow manages this interaction, ensuring that:\n\n1. The process pauses at appropriate review points\n2. Human reviewers receive necessary context\n3. The system maintains state during the review period\n4. Review decisions are properly incorporated\n5. The process continues once approval is received\n\n### Best practices for Human-in-the-Loop workflows\n\n#### Long-Term State Persistence\n\nHuman review processes do not operate on predictable timelines. A reviewer might need days or weeks to make a decision, especially for complex cases requiring additional investigation or multiple approvals. Your system needs to maintain perfect state consistency throughout this period, including:\n\n* The original request and context\n* All intermediate decisions and actions\n* Any partial progress or temporary states\n* Review history and feedback\n\n[Durable Objects](https://developers.cloudflare.com/durable-objects/) provide an ideal solution for managing state in Human-in-the-Loop workflows, offering persistent compute instances that maintain state for hours, weeks, or months.\n\n#### Continuous Improvement Through Evals\n\nHuman reviewers play a crucial role in evaluating and improving LLM performance. Implement a systematic evaluation process where human feedback is collected not just on the final output, but on the LLM's decision-making process. This can include:\n\n* Decision Quality Assessment: Have reviewers evaluate the LLM's reasoning process and decision points, not just the final output.\n* Edge Case Identification: Use human expertise to identify scenarios where the LLM's performance could be improved.\n* Feedback Collection: Gather structured feedback that can be used to fine-tune the LLM or adjust the workflow. [AI Gateway](https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback/) can be a useful tool for setting up an LLM feedback loop.\n\n#### Error handling and recovery\n\nRobust error handling is essential for maintaining workflow integrity. Your system should gracefully handle various failure scenarios, including reviewer unavailability, system outages, or conflicting reviews. Implement clear escalation paths for handling exceptional cases that fall outside normal parameters.\n\nThe system should maintain stability during paused states, ensuring that no work is lost even during extended review periods. Consider implementing automatic checkpointing that allows workflows to be resumed from the last stable state after any interruption.\n\n<page>\n---\ntitle: Tools · Cloudflare Agents docs\ndescription: Tools enable AI systems to interact with external services and\n  perform actions. They provide a structured way for agents and workflows to\n  invoke APIs, manipulate data, and integrate with external systems. Tools form\n  the bridge between AI decision-making capabilities and real-world actions.\nlastUpdated: 2025-02-28T20:23:07.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/tools/\n  md: https://developers.cloudflare.com/agents/concepts/tools/index.md\n---\n\nTools enable AI systems to interact with external services and perform actions. They provide a structured way for agents and workflows to invoke APIs, manipulate data, and integrate with external systems. Tools form the bridge between AI decision-making capabilities and real-world actions.\n\n### Understanding tools\n\nIn an AI system, tools are typically implemented as function calls that the AI can use to accomplish specific tasks. For example, a travel booking agent might have tools for:\n\n* Searching flight availability\n* Checking hotel rates\n* Processing payments\n* Sending confirmation emails\n\nEach tool has a defined interface specifying its inputs, outputs, and expected behavior. This allows the AI system to understand when and how to use each tool appropriately.\n\n### Common tool patterns\n\n#### API integration tools\n\nThe most common type of tools are those that wrap external APIs. These tools handle the complexity of API authentication, request formatting, and response parsing, presenting a clean interface to the AI system.\n\n#### Model Context Protocol (MCP)\n\nThe [Model Context Protocol](https://modelcontextprotocol.io/introduction) provides a standardized way to define and interact with tools. Think of it as an abstraction on top of APIs designed for LLMs to interact with external resources. MCP defines a consistent interface for:\n\n* **Tool Discovery**: Systems can dynamically discover available tools\n* **Parameter Validation**: Tools specify their input requirements using JSON Schema\n* **Error Handling**: Standardized error reporting and recovery\n* **State Management**: Tools can maintain state across invocations\n\n#### Data processing tools\n\nTools that handle data transformation and analysis are essential for many AI workflows. These might include:\n\n* CSV parsing and analysis\n* Image processing\n* Text extraction\n* Data validation\n\n<page>\n---\ntitle: Agents · Cloudflare Agents docs\ndescription: An agent is an AI system that can autonomously execute tasks by\n  making decisions about tool usage and process flow. Unlike traditional\n  automation that follows predefined paths, agents can dynamically adapt their\n  approach based on context and intermediate results. Agents are also distinct\n  from co-pilots (e.g. traditional chat applications) in that they can fully\n  automate a task, as opposed to simply augmenting and extending human input.\nlastUpdated: 2025-08-15T20:11:52.000Z\nchatbotDeprioritize: false\ntags: AI,LLM\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/what-are-agents/\n  md: https://developers.cloudflare.com/agents/concepts/what-are-agents/index.md\n---\n\nAn agent is an AI system that can autonomously execute tasks by making decisions about tool usage and process flow. Unlike traditional automation that follows predefined paths, agents can dynamically adapt their approach based on context and intermediate results. Agents are also distinct from co-pilots (e.g. traditional chat applications) in that they can fully automate a task, as opposed to simply augmenting and extending human input.\n\n* **Agents** → non-linear, non-deterministic (can change from run to run)\n* **Workflows** → linear, deterministic execution paths\n* **Co-pilots** → augmentative AI assistance requiring human intervention\n\n### Example: Booking vacations\n\nIf this is your first time working with, or interacting with agents, this example will illustrate how an agent works within a context like booking a vacation. If you are already familiar with the topic, read on.\n\nImagine you're trying to book a vacation. You need to research flights, find hotels, check restaurant reviews, and keep track of your budget.\n\n#### Traditional workflow automation\n\nA traditional automation system follows a predetermined sequence:\n\n* Takes specific inputs (dates, location, budget)\n* Calls predefined API endpoints in a fixed order\n* Returns results based on hardcoded criteria\n* Cannot adapt if unexpected situations arise\n\n![Traditional workflow automation diagram](https://developers.cloudflare.com/_astro/workflow-automation.D1rsykgR_15theP.svg)\n\nA co-pilot acts as an intelligent assistant that:\n\n* Provides hotel and itinerary recommendations based on your preferences\n* Can understand and respond to natural language queries\n* Offers guidance and suggestions\n* Requires human decision-making and action for execution\n\n![A co-pilot diagram](https://developers.cloudflare.com/_astro/co-pilot.BZ_kRuK6_Z9KfL9.svg)\n\nAn agent combines AI's ability to make judgements and call the relevant tools to execute the task. An agent's output will be nondeterministic given:\n\n* Real-time availability and pricing changes\n* Dynamic prioritization of constraints\n* Ability to recover from failures\n* Adaptive decision-making based on intermediate results\n\n![An agent diagram](https://developers.cloudflare.com/_astro/agent-workflow.5VDKtHdO_ALLGh.svg)\n\nAn agents can dynamically generate an itinerary and execute on booking reservations, similarly to what you would expect from a travel agent.\n\n### Three primary components of agent systems:\n\n* **Decision Engine**: Usually an LLM (Large Language Model) that determines action steps\n* **Tool Integration**: APIs, functions, and services the agent can utilize\n* **Memory System**: Maintains context and tracks task progress\n\nAgents operate in a continuous loop of:\n\n1. **Observing** the current state or task\n2. **Planning** what actions to take, using AI for reasoning\n3. **Executing** those actions using available tools (often APIs or [MCPs](https://modelcontextprotocol.io/introduction))\n4. **Learning** from the results (storing results in memory, updating task progress, and preparing for next iteration)\n\n<page>\n---\ntitle: Workflows · Cloudflare Agents docs\ndescription: A workflow is the orchestration layer that coordinates how an\n  agent's components work together. It defines the structured paths through\n  which tasks are processed, tools are called, and results are managed. While\n  agents make dynamic decisions about what to do, workflows provide the\n  underlying framework that governs how those decisions are executed.\nlastUpdated: 2025-02-25T13:55:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/workflows/\n  md: https://developers.cloudflare.com/agents/concepts/workflows/index.md\n---\n\n## What are workflows?\n\nA workflow is the orchestration layer that coordinates how an agent's components work together. It defines the structured paths through which tasks are processed, tools are called, and results are managed. While agents make dynamic decisions about what to do, workflows provide the underlying framework that governs how those decisions are executed.\n\n### Understanding workflows in agent systems\n\nThink of a workflow like the operating procedures of a company. The company (agent) can make various decisions, but how those decisions get implemented follows established processes (workflows). For example, when you book a flight through a travel agent, they might make different decisions about which flights to recommend, but the process of actually booking the flight follows a fixed sequence of steps.\n\nLet's examine a basic agent workflow:\n\n### Core components of a workflow\n\nA workflow typically consists of several key elements:\n\n1. **Input Processing** The workflow defines how inputs are received and validated before being processed by the agent. This includes standardizing formats, checking permissions, and ensuring all required information is present.\n2. **Tool Integration** Workflows manage how external tools and services are accessed. They handle authentication, rate limiting, error recovery, and ensuring tools are used in the correct sequence.\n3. **State Management** The workflow maintains the state of ongoing processes, tracking progress through multiple steps and ensuring consistency across operations.\n4. **Output Handling** Results from the agent's actions are processed according to defined rules, whether that means storing data, triggering notifications, or formatting responses.\n\n<page>\n---\ntitle: Build a Chat Agent · Cloudflare Agents docs\ndescription: A starter template for building AI-powered chat agents using\n  Cloudflare's Agent platform, powered by the Agents SDK. This project provides\n  a foundation for creating interactive chat experiences with AI, complete with\n  a modern UI and tool integration capabilities.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/\n  md: https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/index.md\n---\n\n<page>\n---\ntitle: Prompt an AI model · Cloudflare Agents docs\ndescription: Use the Workers \"mega prompt\" to build a Agents using your\n  preferred AI tools and/or IDEs. The prompt understands the Agents SDK APIs,\n  best practices and guidelines, and makes it easier to build valid Agents and\n  Workers.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/getting-started/prompting/\n  md: https://developers.cloudflare.com/agents/getting-started/prompting/index.md\n---\n\n<page>\n---\ntitle: Testing your Agents · Cloudflare Agents docs\ndescription: Because Agents run on Cloudflare Workers and Durable Objects, they\n  can be tested using the same tools and techniques as Workers and Durable\n  Objects.\nlastUpdated: 2025-05-16T16:37:37.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/getting-started/testing-your-agent/\n  md: https://developers.cloudflare.com/agents/getting-started/testing-your-agent/index.md\n---\n\nBecause Agents run on Cloudflare Workers and Durable Objects, they can be tested using the same tools and techniques as Workers and Durable Objects.\n\n## Writing and running tests\n\nThe `agents-starter` template and new Cloudflare Workers projects already include the relevant `vitest` and `@cloudflare/vitest-pool-workers` packages, as well as a valid `vitest.config.js` file.\n\nBefore you write your first test, install the necessary packages:\n\nEnsure that your `vitest.config.js` file is identical to the following:\n\n### Add the Agent configuration\n\nAdd a `durableObjects` configuration to `vitest.config.js` with the name of your Agent class:\n\nReview the [Vitest documentation](https://vitest.dev/) for more information on testing, including the test API reference and advanced testing techniques.\n\nTests use the `vitest` framework. A basic test suite for your Agent can validate how your Agent responds to requests, but can also unit test your Agent's methods and state.\n\nRunning tests is done using the `vitest` CLI:",
  "code_samples": [
    {
      "code": "<componentName-embedName attribute=\"value\"></componentName-embedName>",
      "language": "html"
    },
    {
      "code": "<twitter-post tweet-id=\"12345\"></twitter-post>",
      "language": "html"
    },
    {
      "code": "<instagram-post post-url=\"https://www.instagram.com/p/ABC/\" captions=\"true\"></instagram-post>",
      "language": "html"
    },
    {
      "code": "gtag(\"event\", \"conversion\", {\n  send_to: \"AW-123456789/AbC-D_efG-h12_34-567\",\n  value: 1.0,\n  currency: \"USD\",\n});",
      "language": "js"
    },
    {
      "code": "{\n  \"events\": [\n    {\n      \"client\": {\n        \"__zarazTrack\": \"transaction successful\",\n        \"value\": \"200\"\n      }\n    }\n  ]\n}",
      "language": "json"
    },
    {
      "code": "{\n  \"events\": [\n    {\n      \"client\": {\n        \"__zarazTrack\": \"transaction successful\",\n        \"value\": \"200\"\n      },\n      \"system\": {\n        \"page\": {\n          \"url\": \"https://example.com\",\n          \"title\": \"My website\"\n        },\n        \"device\": {\n          \"language\": \"en-US\",\n          \"ip\": \"192.168.0.1\"\n        }\n      }\n    }\n  ]\n}",
      "language": "json"
    },
    {
      "code": "function NSLookup(type, domain, useCache = false, minCacheTTL = 30) {\n\n\n  if (typeof type == 'undefined') {\n    throw new Error('Missing parameter 1 dns type');\n  }\n\n\n  if (typeof domain == 'undefined') {\n    throw new Error('Missing parameter 2 domain name');\n  }\n\n\n  if (typeof useCache != \"boolean\") {\n    throw new Error('Only boolean values allowed in 3 use cache');\n  }\n\n\n  if (typeof minCacheTTL != \"number\") {\n    throw new Error('Only numeric values allowed in 4 min cache ttl');\n  }\n\n\n  type = type.toUpperCase();\n  domain = domain.toLowerCase();\n\n\n  let cache = null;\n  if (useCache) {\n    // Cache key and hash\n    cacheKey = domain + \"@\" + type;\n    cacheHash = Utilities.base64Encode(cacheKey);\n    cacheBinKey = \"nslookup-result-\" + cacheHash;\n\n\n    cache = CacheService.getScriptCache();\n    const cachedResult = cache.get(cacheBinKey);\n    if (cachedResult != null) {\n      return cachedResult;\n    }\n  }\n\n\n  const url = 'https://cloudflare-dns.com/dns-query?name=' + encodeURIComponent(domain) + '&type=' + encodeURIComponent(type);\n  const options = {\n    muteHttpExceptions: true,\n    headers: {\n      accept: \"application/dns-json\"\n    }\n  };\n\n\n  const result = UrlFetchApp.fetch(url, options);\n  const rc = result.getResponseCode();\n  const resultText = result.getContentText();\n\n\n  if (rc !== 200) {\n    throw new Error(rc);\n  }\n\n\n  const errors = [\n    { name: \"NoError\", description: \"No Error\"}, // 0\n    { name: \"FormErr\", description: \"Format Error\"}, // 1\n    { name: \"ServFail\", description: \"Server Failure\"}, // 2\n    { name: \"NXDomain\", description: \"Non-Existent Domain\"}, // 3\n    { name: \"NotImp\", description: \"Not Implemented\"}, // 4\n    { name: \"Refused\", description: \"Query Refused\"}, // 5\n    { name: \"YXDomain\", description: \"Name Exists when it should not\"}, // 6\n    { name: \"YXRRSet\", description: \"RR Set Exists when it should not\"}, // 7\n    { name: \"NXRRSet\", description: \"RR Set that should exist does not\"}, // 8\n    { name: \"NotAuth\", description: \"Not Authorized\"} // 9\n  ];\n\n\n  const response = JSON.parse(resultText);\n\n\n  if (response.Status !== 0) {\n    return errors[response.Status].name;\n  }\n\n\n  const outputData = [];\n  let cacheTTL = 0;\n\n\n  for (const i in response.Answer) {\n    outputData.push(response.Answer[i].data);\n    const ttl = response.Answer[i].TTL;\n    cacheTTL = Math.min(cacheTTL || ttl, ttl);\n  }\n\n\n  const outputString = outputData.join(',');\n\n\n  if (useCache) {\n    cache.put(cacheBinKey, outputString, Math.max(cacheTTL, minCacheTTL));\n  }\n\n\n  return outputString;\n}",
      "language": "js"
    },
    {
      "code": "NSLookup(B1, B2)",
      "language": "txt"
    },
    {
      "code": "NSLookup(B1; B2)",
      "language": "txt"
    },
    {
      "code": "198.41.214.162, 198.41.215.162",
      "language": "txt"
    },
    {
      "code": "/dig domain: cloudflare.com",
      "language": "txt"
    },
    {
      "code": "/dig domain: cloudflare.com type: AAAA records short: True",
      "language": "txt"
    },
    {
      "code": "/dig domain: cloudflare.com type: AAAA records cdflag: True",
      "language": "txt"
    },
    {
      "code": "/multi-dig domain: cloudflare.com types: A AAAA",
      "language": "txt"
    },
    {
      "code": "/multi-dig domain: cloudflare.com types: CDS CDNSKEY short: True",
      "language": "txt"
    },
    {
      "code": "/multi-dig domain: cloudflare.com type: AAAA records cdflag: True",
      "language": "txt"
    },
    {
      "code": "/whois query: cloudflare.com\n/whois query: 104.16.132.229\n/whois query: 2606:4700::6810:84e5\n/whois query: 13335",
      "language": "txt"
    },
    {
      "code": "/help",
      "language": "txt"
    },
    {
      "code": "/privacy",
      "language": "txt"
    },
    {
      "code": "/terms",
      "language": "txt"
    },
    {
      "code": "/github",
      "language": "txt"
    },
    {
      "code": "/invite",
      "language": "txt"
    },
    {
      "code": "SOCKSPort 9150",
      "language": "txt"
    },
    {
      "code": "tor -f tor.conf",
      "language": "sh"
    },
    {
      "code": "https://dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion/",
      "language": "txt"
    },
    {
      "code": "curl -sI https://tor.cloudflare-dns.com | grep -i alt-svc",
      "language": "sh"
    },
    {
      "code": "alt-svc: h2=\"dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion:443\"; ma=315360000; persist=1",
      "language": "sh"
    },
    {
      "code": "PORT=853; socat TCP4-LISTEN:${PORT},reuseaddr,fork SOCKS4A:127.0.0.1:dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion:${PORT},socksport=9150",
      "language": "sh"
    },
    {
      "code": "socat TCP4-LISTEN:443,reuseaddr,fork SOCKS4A:127.0.0.1:dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion:443,socksport=9150",
      "language": "sh"
    },
    {
      "code": "cat << EOF >> /etc/hosts\n127.0.0.1 dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion\nEOF",
      "language": "bash"
    },
    {
      "code": "cloudflared proxy-dns --upstream \"https://dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion/dns-query\"",
      "language": "sh"
    },
    {
      "code": "INFO[0000] Adding DNS upstream                           url=\"https://dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion/dns-query\"\nINFO[0000] Starting DNS over HTTPS proxy server          addr=\"dns://localhost:53\"\nINFO[0000] Starting metrics server                       addr=\"127.0.0.1:35659\"",
      "language": "sh"
    },
    {
      "code": "kdig -d @1.1.1.1 +tls-ca +tls-host=one.one.one.one example.com",
      "language": "sh"
    },
    {
      "code": ";; DEBUG: Querying for owner(example.com.), class(1), type(1), server(1.1.1.1), port(853), protocol(TCP)\n;; DEBUG: TLS, imported 138 system certificates\n;; DEBUG: TLS, received certificate hierarchy:\n;; DEBUG:  #1, C=US,ST=California,L=San Francisco,O=Cloudflare\\, Inc.,CN=cloudflare-dns.com\n;; DEBUG:      SHA-256 PIN: GP8Knf7qBae+aIfythytMbYnL+yowaWVeD6MoLHkVRg=\n;; DEBUG:  #2, C=US,O=DigiCert Inc,CN=DigiCert TLS Hybrid ECC SHA384 2020 CA1\n;; DEBUG:      SHA-256 PIN: e0IRz5Tio3GA1Xs4fUVWmH1xHDiH2dMbVtCBSkOIdqM=\n;; DEBUG: TLS, skipping certificate PIN check\n;; DEBUG: TLS, The certificate is trusted.\n;; TLS session (TLS1.3)-(ECDHE-X25519)-(ECDSA-SECP256R1-SHA256)-(AES-256-GCM)\n;; ->>HEADER<<- opcode: QUERY; status: NOERROR; id: 3395\n;; Flags: qr rd ra; QUERY: 1; ANSWER: 1; AUTHORITY: 0; ADDITIONAL: 1\n\n\n;; EDNS PSEUDOSECTION:\n;; Version: 0; flags: ; UDP size: 1232 B; ext-rcode: NOERROR\n;; PADDING: 408 B\n\n\n;; QUESTION SECTION:\n;; example.com.            IN  A\n\n\n;; ANSWER SECTION:\nexample.com.          75897  IN  A  93.184.216.34\n\n\n;; Received 468 B\n;; Time 2023-06-23 18:05:42 PDT\n;; From 1.1.1.1@853(TCP) in 12.1 ms",
      "language": "sh"
    },
    {
      "code": "2606:4700:4700::64\n2606:4700:4700::6400",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700:0:0:0:0:64\n2606:4700:4700:0:0:0:0:6400",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "echo -e \"nameserver 1.1.1.1\\nnameserver 1.0.0.1\" | sudo tee /etc/resolv.conf",
      "language": "sh"
    },
    {
      "code": "sudo <EDITOR> /etc/systemd/resolved.conf",
      "language": "sh"
    },
    {
      "code": "[Resolve]\nDNS=1.1.1.1",
      "language": "txt"
    },
    {
      "code": "[Resolve]\nDNS=1.1.1.1#one.one.one.one\nDNSOverTLS=yes",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n    2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n    2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n    2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  class MyAgent extends Agent {\n    // Define methods on the Agent\n  }\n\n\n  export default MyAgent;",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  class MyAgent extends Agent {\n    // Define methods on the Agent\n  }\n\n\n  export default MyAgent;",
      "language": "ts"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  // Pass the Env as a TypeScript type argument\n  // Any services connected to your Agent or Worker as Bindings\n  // are then available on this.env.<BINDING_NAME>\n\n\n  // The core class for creating Agents that can maintain state, orchestrate\n  // complex AI workflows, schedule tasks, and interact with users and other\n  // Agents.\n  class MyAgent extends Agent {\n    // Optional initial state definition\n    initialState = {\n      counter: 0,\n      messages: [],\n      lastUpdated: null,\n    };\n\n\n    // Called when a new Agent instance starts or wakes from hibernation\n    async onStart() {\n      console.log(\"Agent started with state:\", this.state);\n    }\n\n\n    // Handle HTTP requests coming to this Agent instance\n    // Returns a Response object\n    async onRequest(request) {\n      return new Response(\"Hello from Agent!\");\n    }\n\n\n    // Called when a WebSocket connection is established\n    // Access the original request via ctx.request for auth etc.\n    async onConnect(connection, ctx) {\n      // Connections are automatically accepted by the SDK.\n      // You can also explicitly close a connection here with connection.close()\n      // Access the Request on ctx.request to inspect headers, cookies and the URL\n    }\n\n\n    // Called for each message received on a WebSocket connection\n    // Message can be string, ArrayBuffer, or ArrayBufferView\n    async onMessage(connection, message) {\n      // Handle incoming messages\n      connection.send(\"Received your message\");\n    }\n\n\n    // Handle WebSocket connection errors\n    async onError(connection, error) {\n      console.error(`Connection error:`, error);\n    }\n\n\n    // Handle WebSocket connection close events\n    async onClose(connection, code, reason, wasClean) {\n      console.log(`Connection closed: ${code} - ${reason}`);\n    }\n\n\n    // Called when the Agent's state is updated from any source\n    // source can be \"server\" or a client Connection\n    onStateUpdate(state, source) {\n      console.log(\"State updated:\", state, \"Source:\", source);\n    }\n\n\n    // You can define your own custom methods to be called by requests,\n    // WebSocket messages, or scheduled tasks\n    async customProcessingMethod(data) {\n      // Process data, update state, schedule tasks, etc.\n      this.setState({ ...this.state, lastUpdated: new Date() });\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  interface Env {\n    // Define environment variables & bindings here\n  }\n\n\n  // Pass the Env as a TypeScript type argument\n  // Any services connected to your Agent or Worker as Bindings\n  // are then available on this.env.<BINDING_NAME>\n\n\n  // The core class for creating Agents that can maintain state, orchestrate\n  // complex AI workflows, schedule tasks, and interact with users and other\n  // Agents.\n  class MyAgent extends Agent<Env, State> {\n    // Optional initial state definition\n    initialState = {\n      counter: 0,\n      messages: [],\n      lastUpdated: null,\n    };\n\n\n    // Called when a new Agent instance starts or wakes from hibernation\n    async onStart() {\n      console.log(\"Agent started with state:\", this.state);\n    }\n\n\n    // Handle HTTP requests coming to this Agent instance\n    // Returns a Response object\n    async onRequest(request: Request): Promise<Response> {\n      return new Response(\"Hello from Agent!\");\n    }\n\n\n    // Called when a WebSocket connection is established\n    // Access the original request via ctx.request for auth etc.\n    async onConnect(connection: Connection, ctx: ConnectionContext) {\n      // Connections are automatically accepted by the SDK.\n      // You can also explicitly close a connection here with connection.close()\n      // Access the Request on ctx.request to inspect headers, cookies and the URL\n    }\n\n\n    // Called for each message received on a WebSocket connection\n    // Message can be string, ArrayBuffer, or ArrayBufferView\n    async onMessage(connection: Connection, message: WSMessage) {\n      // Handle incoming messages\n      connection.send(\"Received your message\");\n    }\n\n\n    // Handle WebSocket connection errors\n    async onError(connection: Connection, error: unknown): Promise<void> {\n      console.error(`Connection error:`, error);\n    }\n\n\n    // Handle WebSocket connection close events\n    async onClose(\n      connection: Connection,\n      code: number,\n      reason: string,\n      wasClean: boolean,\n    ): Promise<void> {\n      console.log(`Connection closed: ${code} - ${reason}`);\n    }\n\n\n    // Called when the Agent's state is updated from any source\n    // source can be \"server\" or a client Connection\n    onStateUpdate(state: State, source: \"server\" | Connection) {\n      console.log(\"State updated:\", state, \"Source:\", source);\n    }\n\n\n    // You can define your own custom methods to be called by requests,\n    // WebSocket messages, or scheduled tasks\n    async customProcessingMethod(data: any) {\n      // Process data, update state, schedule tasks, etc.\n      this.setState({ ...this.state, lastUpdated: new Date() });\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "// Basic Agent implementation with custom methods\n  import { Agent } from \"agents\";\n\n\n  class MyAgent extends Agent {\n    initialState = {\n      counter: 0,\n      lastUpdated: null,\n    };\n\n\n    async onRequest(request) {\n      if (request.method === \"POST\") {\n        await this.incrementCounter();\n        return new Response(JSON.stringify(this.state), {\n          headers: { \"Content-Type\": \"application/json\" },\n        });\n      }\n      return new Response(JSON.stringify(this.state), {\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n\n\n    async incrementCounter() {\n      this.setState({\n        counter: this.state.counter + 1,\n        lastUpdated: new Date(),\n      });\n    }\n  }",
      "language": "js"
    },
    {
      "code": "// Basic Agent implementation with custom methods\n  import { Agent } from \"agents\";\n\n\n  interface MyState {\n    counter: number;\n    lastUpdated: Date | null;\n  }\n\n\n  class MyAgent extends Agent<Env, MyState> {\n    initialState = {\n      counter: 0,\n      lastUpdated: null,\n    };\n\n\n    async onRequest(request: Request) {\n      if (request.method === \"POST\") {\n        await this.incrementCounter();\n        return new Response(JSON.stringify(this.state), {\n          headers: { \"Content-Type\": \"application/json\" },\n        });\n      }\n      return new Response(JSON.stringify(this.state), {\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    }\n\n\n    async incrementCounter() {\n      this.setState({\n        counter: this.state.counter + 1,\n        lastUpdated: new Date(),\n      });\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "// WebSocket connection interface\ninterface Connection<State = unknown> {\n  // Unique ID for this connection\n  id: string;\n\n\n  // Client-specific state attached to this connection\n  state: State;\n\n\n  // Update the connection's state\n  setState(state: State): void;\n\n\n  // Accept an incoming WebSocket connection\n  accept(): void;\n\n\n  // Close the WebSocket connection with optional code and reason\n  close(code?: number, reason?: string): void;\n\n\n  // Send a message to the client\n  // Can be string, ArrayBuffer, or ArrayBufferView\n  send(message: string | ArrayBuffer | ArrayBufferView): void;\n}",
      "language": "ts"
    },
    {
      "code": "// Example of handling WebSocket messages\n  export class YourAgent extends Agent {\n    async onMessage(connection, message) {\n      if (typeof message === \"string\") {\n        try {\n          // Parse JSON message\n          const data = JSON.parse(message);\n\n\n          if (data.type === \"update\") {\n            // Update connection-specific state\n            connection.setState({ ...connection.state, lastActive: Date.now() });\n\n\n            // Update global Agent state\n            this.setState({\n              ...this.state,\n              connections: this.state.connections + 1,\n            });\n\n\n            // Send response back to this client only\n            connection.send(\n              JSON.stringify({\n                type: \"updated\",\n                status: \"success\",\n              }),\n            );\n          }\n        } catch (e) {\n          connection.send(JSON.stringify({ error: \"Invalid message format\" }));\n        }\n      }\n    }\n  }",
      "language": "js"
    },
    {
      "code": "// Example of handling WebSocket messages\n  export class YourAgent extends Agent {\n    async onMessage(connection: Connection, message: WSMessage) {\n      if (typeof message === \"string\") {\n        try {\n          // Parse JSON message\n          const data = JSON.parse(message);\n\n\n          if (data.type === \"update\") {\n            // Update connection-specific state\n            connection.setState({ ...connection.state, lastActive: Date.now() });\n\n\n            // Update global Agent state\n            this.setState({\n              ...this.state,\n              connections: this.state.connections + 1,\n            });\n\n\n            // Send response back to this client only\n            connection.send(\n              JSON.stringify({\n                type: \"updated\",\n                status: \"success\",\n              }),\n            );\n          }\n        } catch (e) {\n          connection.send(JSON.stringify({ error: \"Invalid message format\" }));\n        }\n      }\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "// Types of messages that can be received from WebSockets\ntype WSMessage = string | ArrayBuffer | ArrayBufferView;",
      "language": "ts"
    },
    {
      "code": "// Context available during WebSocket connection\ninterface ConnectionContext {\n  // The original HTTP request that initiated the WebSocket connection\n  request: Request;\n}",
      "language": "ts"
    },
    {
      "code": "// State management in the Agent class\nclass Agent<Env, State = unknown> {\n  // Initial state that will be set if no state exists yet\n  initialState: State = {} as unknown as State;\n\n\n  // Current state of the Agent, persisted across restarts\n  get state(): State;\n\n\n  // Update the Agent's state\n  // Persists to storage and notifies all connected clients\n  setState(state: State): void;\n\n\n  // Called when state is updated from any source\n  // Override to react to state changes\n  onStateUpdate(state: State, source: \"server\" | Connection): void;\n}",
      "language": "ts"
    },
    {
      "code": "// Example of state management in an Agent\n\n\n  // Inside your Agent class\n  export class YourAgent extends Agent {\n    async addMessage(sender, text) {\n      // Update state with new message\n      this.setState({\n        ...this.state,\n        messages: [\n          ...this.state.messages,\n          { sender, text, timestamp: Date.now() },\n        ].slice(-this.state.settings.maxHistoryLength), // Maintain max history\n      });\n\n\n      // The onStateUpdate method will automatically be called\n      // and all connected clients will receive the update\n    }\n\n\n    // Override onStateUpdate to add custom behavior when state changes\n    onStateUpdate(state, source) {\n      console.log(\n        `State updated by ${source === \"server\" ? \"server\" : \"client\"}`,\n      );\n\n\n      // You could trigger additional actions based on state changes\n      if (state.messages.length > 0) {\n        const lastMessage = state.messages[state.messages.length - 1];\n        if (lastMessage.text.includes(\"@everyone\")) {\n          this.notifyAllParticipants(lastMessage);\n        }\n      }\n    }\n  }",
      "language": "js"
    },
    {
      "code": "// Example of state management in an Agent\n  interface ChatState {\n    messages: Array<{ sender: string; text: string; timestamp: number }>;\n    participants: string[];\n    settings: {\n      allowAnonymous: boolean;\n      maxHistoryLength: number;\n    };\n  }\n\n\n  interface Env {\n    // Your bindings and environment variables\n  }\n\n\n  // Inside your Agent class\n  export class YourAgent extends Agent<Env, ChatState> {\n    async addMessage(sender: string, text: string) {\n      // Update state with new message\n      this.setState({\n        ...this.state,\n        messages: [\n          ...this.state.messages,\n          { sender, text, timestamp: Date.now() },\n        ].slice(-this.state.settings.maxHistoryLength), // Maintain max history\n      });\n\n\n      // The onStateUpdate method will automatically be called\n      // and all connected clients will receive the update\n    }\n\n\n    // Override onStateUpdate to add custom behavior when state changes\n    onStateUpdate(state: ChatState, source: \"server\" | Connection) {\n      console.log(\n        `State updated by ${source === \"server\" ? \"server\" : \"client\"}`,\n      );\n\n\n      // You could trigger additional actions based on state changes\n      if (state.messages.length > 0) {\n        const lastMessage = state.messages[state.messages.length - 1];\n        if (lastMessage.text.includes(\"@everyone\")) {\n          this.notifyAllParticipants(lastMessage);\n        }\n      }\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "// Scheduling API for running tasks in the future\nclass Agent<Env, State = unknown> {\n  // Schedule a task to run in the future\n  // when: seconds from now, specific Date, or cron expression\n  // callback: method name on the Agent to call\n  // payload: data to pass to the callback\n  // Returns a Schedule object with the task ID\n  async schedule<T = any>(\n    when: Date | string | number,\n    callback: keyof this,\n    payload?: T,\n  ): Promise<Schedule<T>>;\n\n\n  // Get a scheduled task by ID\n  // Returns undefined if the task doesn't exist\n  async getSchedule<T = any>(id: string): Promise<Schedule<T> | undefined>;\n\n\n  // Get all scheduled tasks matching the criteria\n  // Returns an array of Schedule objects\n  getSchedules<T = any>(criteria?: {\n    description?: string;\n    id?: string;\n    type?: \"scheduled\" | \"delayed\" | \"cron\";\n    timeRange?: { start?: Date; end?: Date };\n  }): Schedule<T>[];\n\n\n  // Cancel a scheduled task by ID\n  // Returns true if the task was cancelled, false otherwise\n  async cancelSchedule(id: string): Promise<boolean>;\n}",
      "language": "ts"
    },
    {
      "code": "// Example of scheduling in an Agent\n\n\n  export class YourAgent extends Agent {\n    // Schedule a one-time reminder in 2 hours\n    async scheduleReminder(userId, message) {\n      const twoHoursFromNow = new Date(Date.now() + 2 * 60 * 60 * 1000);\n\n\n      const schedule = await this.schedule(twoHoursFromNow, \"sendReminder\", {\n        userId,\n        message,\n        channel: \"email\",\n      });\n\n\n      console.log(`Scheduled reminder with ID: ${schedule.id}`);\n      return schedule.id;\n    }\n\n\n    // Schedule a recurring daily task using cron\n    async scheduleDailyReport() {\n      // Run at 08:00 AM every day\n      const schedule = await this.schedule(\n        \"0 8 * * *\", // Cron expression: minute hour day month weekday\n        \"generateDailyReport\",\n        { reportType: \"daily-summary\" },\n      );\n\n\n      console.log(`Scheduled daily report with ID: ${schedule.id}`);\n      return schedule.id;\n    }\n\n\n    // Method that will be called when the scheduled task runs\n    async sendReminder(data) {\n      console.log(`Sending reminder to ${data.userId}: ${data.message}`);\n      // Add code to send the actual notification\n    }\n  }",
      "language": "js"
    },
    {
      "code": "// Example of scheduling in an Agent\n  interface ReminderData {\n    userId: string;\n    message: string;\n    channel: string;\n  }\n\n\n  export class YourAgent extends Agent {\n    // Schedule a one-time reminder in 2 hours\n    async scheduleReminder(userId: string, message: string) {\n      const twoHoursFromNow = new Date(Date.now() + 2 * 60 * 60 * 1000);\n\n\n      const schedule = await this.schedule<ReminderData>(\n        twoHoursFromNow,\n        \"sendReminder\",\n        { userId, message, channel: \"email\" },\n      );\n\n\n      console.log(`Scheduled reminder with ID: ${schedule.id}`);\n      return schedule.id;\n    }\n\n\n    // Schedule a recurring daily task using cron\n    async scheduleDailyReport() {\n      // Run at 08:00 AM every day\n      const schedule = await this.schedule(\n        \"0 8 * * *\", // Cron expression: minute hour day month weekday\n        \"generateDailyReport\",\n        { reportType: \"daily-summary\" },\n      );\n\n\n      console.log(`Scheduled daily report with ID: ${schedule.id}`);\n      return schedule.id;\n    }\n\n\n    // Method that will be called when the scheduled task runs\n    async sendReminder(data: ReminderData) {\n      console.log(`Sending reminder to ${data.userId}: ${data.message}`);\n      // Add code to send the actual notification\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "// Represents a scheduled task\ntype Schedule<T = any> = {\n  // Unique identifier for the schedule\n  id: string;\n  // Name of the method to be called\n  callback: string;\n  // Data to be passed to the callback\n  payload: T;\n} & (\n  | {\n      // One-time execution at a specific time\n      type: \"scheduled\";\n      // Timestamp when the task should execute\n      time: number;\n    }\n  | {\n      // Delayed execution after a certain time\n      type: \"delayed\";\n      // Timestamp when the task should execute\n      time: number;\n      // Number of seconds to delay execution\n      delayInSeconds: number;\n    }\n  | {\n      // Recurring execution based on cron expression\n      type: \"cron\";\n      // Timestamp for the next execution\n      time: number;\n      // Cron expression defining the schedule\n      cron: string;\n    }\n);",
      "language": "ts"
    },
    {
      "code": "export class YourAgent extends Agent {\n    // Example of managing scheduled tasks\n    async viewAndManageSchedules() {\n      // Get all scheduled tasks\n      const allSchedules = this.getSchedules();\n      console.log(`Total scheduled tasks: ${allSchedules.length}`);\n\n\n      // Get tasks scheduled for a specific time range\n      const upcomingSchedules = this.getSchedules({\n        timeRange: {\n          start: new Date(),\n          end: new Date(Date.now() + 24 * 60 * 60 * 1000), // Next 24 hours\n        },\n      });\n\n\n      // Get a specific task by ID\n      const taskId = \"task-123\";\n      const specificTask = await this.getSchedule(taskId);\n\n\n      if (specificTask) {\n        console.log(\n          `Found task: ${specificTask.callback} at ${new Date(specificTask.time)}`,\n        );\n\n\n        // Cancel a scheduled task\n        const cancelled = await this.cancelSchedule(taskId);\n        console.log(`Task cancelled: ${cancelled}`);\n      }\n    }\n  }",
      "language": "js"
    },
    {
      "code": "export class YourAgent extends Agent {\n    // Example of managing scheduled tasks\n    async viewAndManageSchedules() {\n      // Get all scheduled tasks\n      const allSchedules = this.getSchedules();\n      console.log(`Total scheduled tasks: ${allSchedules.length}`);\n\n\n      // Get tasks scheduled for a specific time range\n      const upcomingSchedules = this.getSchedules({\n        timeRange: {\n          start: new Date(),\n          end: new Date(Date.now() + 24 * 60 * 60 * 1000), // Next 24 hours\n        },\n      });\n\n\n      // Get a specific task by ID\n      const taskId = \"task-123\";\n      const specificTask = await this.getSchedule(taskId);\n\n\n      if (specificTask) {\n        console.log(\n          `Found task: ${specificTask.callback} at ${new Date(specificTask.time)}`,\n        );\n\n\n        // Cancel a scheduled task\n        const cancelled = await this.cancelSchedule(taskId);\n        console.log(`Task cancelled: ${cancelled}`);\n      }\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "// SQL query API for the Agent's embedded database\nclass Agent<Env, State = unknown> {\n  // Execute a SQL query with tagged template literals\n  // Returns an array of rows matching the query\n  sql<T = Record<string, string | number | boolean | null>>(\n    strings: TemplateStringsArray,\n    ...values: (string | number | boolean | null)[]\n  ): T[];\n}",
      "language": "ts"
    },
    {
      "code": "// Example of using SQL in an Agent\n\n\n  export class YourAgent extends Agent {\n    async setupDatabase() {\n      // Create a table if it doesn't exist\n      this.sql`\n        CREATE TABLE IF NOT EXISTS users (\n          id TEXT PRIMARY KEY,\n          name TEXT NOT NULL,\n          email TEXT UNIQUE,\n          created_at INTEGER\n        )\n      `;\n    }\n\n\n    async createUser(id, name, email) {\n      // Insert a new user\n      this.sql`\n        INSERT INTO users (id, name, email, created_at)\n        VALUES (${id}, ${name}, ${email}, ${Date.now()})\n      `;\n    }\n\n\n    async getUserById(id) {\n      // Query a user by ID\n      const users = this.sql`\n        SELECT * FROM users WHERE id = ${id}\n      `;\n\n\n      return users.length ? users[0] : null;\n    }\n\n\n    async searchUsers(term) {\n      // Search users with a wildcard\n      return this.sql`\n        SELECT * FROM users\n        WHERE name LIKE ${\"%\" + term + \"%\"} OR email LIKE ${\"%\" + term + \"%\"}\n        ORDER BY created_at DESC\n      `;\n    }\n  }",
      "language": "js"
    },
    {
      "code": "// Example of using SQL in an Agent\n  interface User {\n    id: string;\n    name: string;\n    email: string;\n    created_at: number;\n  }\n\n\n  export class YourAgent extends Agent {\n    async setupDatabase() {\n      // Create a table if it doesn't exist\n      this.sql`\n        CREATE TABLE IF NOT EXISTS users (\n          id TEXT PRIMARY KEY,\n          name TEXT NOT NULL,\n          email TEXT UNIQUE,\n          created_at INTEGER\n        )\n      `;\n    }\n\n\n    async createUser(id: string, name: string, email: string) {\n      // Insert a new user\n      this.sql`\n        INSERT INTO users (id, name, email, created_at)\n        VALUES (${id}, ${name}, ${email}, ${Date.now()})\n      `;\n    }\n\n\n    async getUserById(id: string): Promise<User | null> {\n      // Query a user by ID\n      const users = this.sql<User>`\n        SELECT * FROM users WHERE id = ${id}\n      `;\n\n\n      return users.length ? users[0] : null;\n    }\n\n\n    async searchUsers(term: string): Promise<User[]> {\n      // Search users with a wildcard\n      return this.sql<User>`\n        SELECT * FROM users\n        WHERE name LIKE ${\"%\" + term + \"%\"} OR email LIKE ${\"%\" + term + \"%\"}\n        ORDER BY created_at DESC\n      `;\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "class Agent {\n    // Connect to an MCP server\n    // Disconnect from an MCP server\n    // Get state of all connected MCP servers\n  }",
      "language": "js"
    },
    {
      "code": "class Agent<Env, State = unknown> {\n    // Connect to an MCP server\n    async addMcpServer(\n      serverName: string,\n      url: string,\n      callbackHost?: string,\n      agentsPrefix?: string,\n      options?: MCPClientOptions,\n    ): Promise<{ id: string; authUrl: string | undefined }>;\n\n\n    // Disconnect from an MCP server\n    async removeMcpServer(id: string): Promise<void>;\n\n\n    // Get state of all connected MCP servers\n    getMcpServers(): MCPServersState;\n  }",
      "language": "ts"
    },
    {
      "code": "import { AgentClient } from \"agents/client\";\n\n\n// Options for creating an AgentClient\ntype AgentClientOptions = Omit<PartySocketOptions, \"party\" | \"room\"> & {\n  // Name of the agent to connect to (class name in kebab-case)\n  agent: string;\n  // Name of the specific Agent instance (optional, defaults to \"default\")\n  name?: string;\n  // Other WebSocket options like host, protocol, etc.\n};\n\n\n// WebSocket client for connecting to an Agent\nclass AgentClient extends PartySocket {\n  static fetch(opts: PartyFetchOptions): Promise<Response>;\n  constructor(opts: AgentClientOptions);\n}",
      "language": "ts"
    },
    {
      "code": "// Example of using AgentClient in the browser\n  import { AgentClient } from \"agents/client\";\n\n\n  // Connect to an Agent instance\n  const client = new AgentClient({\n    agent: \"chat-agent\", // Name of your Agent class in kebab-case\n    name: \"support-room-123\", // Specific instance name\n    host: window.location.host, // Using same host\n  });\n\n\n  client.onopen = () => {\n    console.log(\"Connected to agent\");\n    // Send an initial message\n    client.send(JSON.stringify({ type: \"join\", user: \"user123\" }));\n  };\n\n\n  client.onmessage = (event) => {\n    // Handle incoming messages\n    const data = JSON.parse(event.data);\n    console.log(\"Received:\", data);\n\n\n    if (data.type === \"state_update\") {\n      // Update local UI with new state\n      updateUI(data.state);\n    }\n  };\n\n\n  client.onclose = () => console.log(\"Disconnected from agent\");\n\n\n  // Send messages to the Agent\n  function sendMessage(text) {\n    client.send(\n      JSON.stringify({\n        type: \"message\",\n        text,\n        timestamp: Date.now(),\n      }),\n    );\n  }",
      "language": "js"
    },
    {
      "code": "// Example of using AgentClient in the browser\n  import { AgentClient } from \"agents/client\";\n\n\n  // Connect to an Agent instance\n  const client = new AgentClient({\n    agent: \"chat-agent\", // Name of your Agent class in kebab-case\n    name: \"support-room-123\", // Specific instance name\n    host: window.location.host, // Using same host\n  });\n\n\n  client.onopen = () => {\n    console.log(\"Connected to agent\");\n    // Send an initial message\n    client.send(JSON.stringify({ type: \"join\", user: \"user123\" }));\n  };\n\n\n  client.onmessage = (event) => {\n    // Handle incoming messages\n    const data = JSON.parse(event.data);\n    console.log(\"Received:\", data);\n\n\n    if (data.type === \"state_update\") {\n      // Update local UI with new state\n      updateUI(data.state);\n    }\n  };\n\n\n  client.onclose = () => console.log(\"Disconnected from agent\");\n\n\n  // Send messages to the Agent\n  function sendMessage(text) {\n    client.send(\n      JSON.stringify({\n        type: \"message\",\n        text,\n        timestamp: Date.now(),\n      }),\n    );\n  }",
      "language": "ts"
    },
    {
      "code": "import { agentFetch } from \"agents/client\";\n\n\n// Options for the agentFetch function\ntype AgentClientFetchOptions = Omit<PartyFetchOptions, \"party\" | \"room\"> & {\n  // Name of the agent to connect to\n  agent: string;\n  // Name of the specific Agent instance (optional)\n  name?: string;\n};\n\n\n// Make an HTTP request to an Agent\nfunction agentFetch(\n  opts: AgentClientFetchOptions,\n  init?: RequestInit,\n): Promise<Response>;",
      "language": "ts"
    },
    {
      "code": "// Example of using agentFetch in the browser\n  import { agentFetch } from \"agents/client\";\n\n\n  // Function to get data from an Agent\n  async function fetchAgentData() {\n    try {\n      const response = await agentFetch(\n        {\n          agent: \"task-manager\",\n          name: \"user-123-tasks\",\n        },\n        {\n          method: \"GET\",\n          headers: {\n            Authorization: `Bearer ${userToken}`,\n          },\n        },\n      );\n\n\n      if (!response.ok) {\n        throw new Error(`Error: ${response.status}`);\n      }\n\n\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.error(\"Failed to fetch from agent:\", error);\n    }\n  }",
      "language": "js"
    },
    {
      "code": "// Example of using agentFetch in the browser\n  import { agentFetch } from \"agents/client\";\n\n\n  // Function to get data from an Agent\n  async function fetchAgentData() {\n    try {\n      const response = await agentFetch(\n        {\n          agent: \"task-manager\",\n          name: \"user-123-tasks\",\n        },\n        {\n          method: \"GET\",\n          headers: {\n            Authorization: `Bearer ${userToken}`,\n          },\n        },\n      );\n\n\n      if (!response.ok) {\n        throw new Error(`Error: ${response.status}`);\n      }\n\n\n      const data = await response.json();\n      return data;\n    } catch (error) {\n      console.error(\"Failed to fetch from agent:\", error);\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import { useAgent } from \"agents/react\";\n\n\n// Options for the useAgent hook\ntype UseAgentOptions<State = unknown> = Omit<\n  Parameters<typeof usePartySocket>[0],\n  \"party\" | \"room\"\n> & {\n  // Name of the agent to connect to\n  agent: string;\n  // Name of the specific Agent instance (optional)\n  name?: string;\n  // Called when the Agent's state is updated\n  onStateUpdate?: (state: State, source: \"server\" | \"client\") => void;\n};\n\n\n// React hook for connecting to an Agent\n// Returns a WebSocket connection with setState method\nfunction useAgent<State = unknown>(\n  options: UseAgentOptions<State>,\n): PartySocket & {\n  // Update the Agent's state\n  setState: (state: State) => void;\n};",
      "language": "ts"
    },
    {
      "code": "import { AIChatAgent } from \"agents/ai-chat-agent\";\nimport { Message, StreamTextOnFinishCallback, ToolSet } from \"ai\";\n\n\n// Base class for chat-specific agents\nclass AIChatAgent<Env = unknown, State = unknown> extends Agent<Env, State> {\n  // Array of chat messages for the current conversation\n  messages: Message[];\n\n\n  // Handle incoming chat messages and generate a response\n  // onFinish is called when the response is complete\n  async onChatMessage(\n    onFinish: StreamTextOnFinishCallback<ToolSet>,\n  ): Promise<Response | undefined>;\n\n\n  // Persist messages within the Agent's local storage.\n  async saveMessages(messages: Message[]): Promise<void>;\n}",
      "language": "ts"
    },
    {
      "code": "// Example of extending AIChatAgent\n  import { AIChatAgent } from \"agents/ai-chat-agent\";\n  import { Message } from \"ai\";\n\n\n  class CustomerSupportAgent extends AIChatAgent {\n    // Override the onChatMessage method to customize behavior\n    async onChatMessage(onFinish) {\n      // Access the AI models using environment bindings\n      const { openai } = this.env.AI;\n\n\n      // Get the current conversation history\n      const chatHistory = this.messages;\n\n\n      // Generate a system prompt based on knowledge base\n      const systemPrompt = await this.generateSystemPrompt();\n\n\n      // Generate a response stream\n      const stream = await openai.chat({\n        model: \"gpt-4o\",\n        messages: [{ role: \"system\", content: systemPrompt }, ...chatHistory],\n        stream: true,\n      });\n\n\n      // Return the streaming response\n      return new Response(stream, {\n        headers: { \"Content-Type\": \"text/event-stream\" },\n      });\n    }\n\n\n    // Helper method to generate a system prompt\n    async generateSystemPrompt() {\n      // Query knowledge base or use static prompt\n      return `You are a helpful customer support agent.\n              Respond to customer inquiries based on the following guidelines:\n              - Be friendly and professional\n              - If you don't know an answer, say so\n              - Current company policies: ...`;\n    }\n  }",
      "language": "js"
    },
    {
      "code": "// Example of extending AIChatAgent\n  import { AIChatAgent } from \"agents/ai-chat-agent\";\n  import { Message } from \"ai\";\n\n\n  interface Env {\n    AI: any; // Your AI binding\n  }\n\n\n  class CustomerSupportAgent extends AIChatAgent<Env> {\n    // Override the onChatMessage method to customize behavior\n    async onChatMessage(onFinish) {\n      // Access the AI models using environment bindings\n      const { openai } = this.env.AI;\n\n\n      // Get the current conversation history\n      const chatHistory = this.messages;\n\n\n      // Generate a system prompt based on knowledge base\n      const systemPrompt = await this.generateSystemPrompt();\n\n\n      // Generate a response stream\n      const stream = await openai.chat({\n        model: \"gpt-4o\",\n        messages: [{ role: \"system\", content: systemPrompt }, ...chatHistory],\n        stream: true,\n      });\n\n\n      // Return the streaming response\n      return new Response(stream, {\n        headers: { \"Content-Type\": \"text/event-stream\" },\n      });\n    }\n\n\n    // Helper method to generate a system prompt\n    async generateSystemPrompt() {\n      // Query knowledge base or use static prompt\n      return `You are a helpful customer support agent.\n              Respond to customer inquiries based on the following guidelines:\n              - Be friendly and professional\n              - If you don't know an answer, say so\n              - Current company policies: ...`;\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import { AIChatAgent } from \"agents/ai-chat-agent\";\n  import { streamText } from \"ai\";\n  import { openai } from \"@ai-sdk/openai\";\n\n\n  export class ChatAgent extends AIChatAgent {\n    async onChatMessage() {\n      const result = streamText({\n        model: openai(\"gpt-4o\"),\n        messages: this.messages,\n      });\n\n\n      // Automatic resumable streaming - no extra code needed!\n      return result.toUIMessageStreamResponse();\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { AIChatAgent } from \"agents/ai-chat-agent\";\n  import { streamText } from \"ai\";\n  import { openai } from \"@ai-sdk/openai\";\n\n\n  export class ChatAgent extends AIChatAgent<Env> {\n    async onChatMessage() {\n      const result = streamText({\n        model: openai(\"gpt-4o\"),\n        messages: this.messages,\n      });\n\n\n      // Automatic resumable streaming - no extra code needed!\n      return result.toUIMessageStreamResponse();\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "const { messages } = useAgentChat({\n    agent,\n    resume: false, // Disable automatic stream resumption\n  });",
      "language": "js"
    },
    {
      "code": "const { messages } = useAgentChat({\n    agent,\n    resume: false, // Disable automatic stream resumption\n  });",
      "language": "ts"
    },
    {
      "code": "import { useAgentChat } from \"agents/ai-react\";\nimport { useAgent } from \"agents/react\";\nimport type { Message } from \"ai\";\n\n\n// Options for the useAgentChat hook\ntype UseAgentChatOptions = Omit<\n  Parameters<typeof useChat>[0] & {\n    // Agent connection from useAgent\n    agent: ReturnType<typeof useAgent>;\n  },\n  \"fetch\"\n>;\n\n\n// React hook for building AI chat interfaces using an Agent\nfunction useAgentChat(options: UseAgentChatOptions): {\n  // Current chat messages\n  messages: Message[];\n  // Set messages and synchronize with the Agent\n  setMessages: (messages: Message[]) => void;\n  // Clear chat history on both client and Agent\n  clearHistory: () => void;\n  // Append a new message to the conversation\n  append: (\n    message: Message,\n    chatRequestOptions?: any,\n  ) => Promise<string | null | undefined>;\n  // Reload the last user message\n  reload: (chatRequestOptions?: any) => Promise<string | null | undefined>;\n  // Stop the AI response generation\n  stop: () => void;\n  // Current input text\n  input: string;\n  // Set the input text\n  setInput: React.Dispatch<React.SetStateAction<string>>;\n  // Handle input changes\n  handleInputChange: (\n    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>,\n  ) => void;\n  // Submit the current input\n  handleSubmit: (\n    event?: { preventDefault?: () => void },\n    chatRequestOptions?: any,\n  ) => void;\n  // Additional metadata\n  metadata?: Object;\n  // Whether a response is currently being generated\n  isLoading: boolean;\n  // Current status of the chat\n  status: \"submitted\" | \"streaming\" | \"ready\" | \"error\";\n  // Tool data from the AI response\n  data?: any[];\n  // Set tool data\n  setData: (\n    data: any[] | undefined | ((data: any[] | undefined) => any[] | undefined),\n  ) => void;\n  // Unique ID for the chat\n  id: string;\n  // Add a tool result for a specific tool call\n  addToolResult: ({\n    toolCallId,\n    result,\n  }: {\n    toolCallId: string;\n    result: any;\n  }) => void;\n  // Current error if any\n  error: Error | undefined;\n};",
      "language": "ts"
    },
    {
      "code": "// Example of using useAgentChat in a React component\n  import { useAgentChat } from \"agents/ai-react\";\n  import { useAgent } from \"agents/react\";\n  import { useState } from \"react\";\n\n\n  function ChatInterface() {\n    // Connect to the chat agent\n    const agentConnection = useAgent({\n      agent: \"customer-support\",\n      name: \"session-12345\",\n    });\n\n\n    // Use the useAgentChat hook with the agent connection\n    const {\n      messages,\n      input,\n      handleInputChange,\n      handleSubmit,\n      isLoading,\n      error,\n      clearHistory,\n    } = useAgentChat({\n      agent: agentConnection,\n      initialMessages: [\n        { role: \"system\", content: \"You're chatting with our AI assistant.\" },\n        { role: \"assistant\", content: \"Hello! How can I help you today?\" },\n      ],\n    });\n\n\n    return (\n      <div className=\"chat-container\">\n        <div className=\"message-history\">\n          {messages.map((message, i) => (\n            <div key={i} className={`message ${message.role}`}>\n              {message.role === \"user\" ? \"👤\" : \"🤖\"} {message.content}\n            </div>\n          ))}\n\n\n          {isLoading && <div className=\"loading\">AI is typing...</div>}\n          {error && <div className=\"error\">Error: {error.message}</div>}\n        </div>\n\n\n        <form onSubmit={handleSubmit} className=\"message-input\">\n          <input\n            value={input}\n            onChange={handleInputChange}\n            placeholder=\"Type your message...\"\n            disabled={isLoading}\n          />\n          <button type=\"submit\" disabled={isLoading || !input.trim()}>\n            Send\n          </button>\n          <button type=\"button\" onClick={clearHistory}>\n            Clear Chat\n          </button>\n        </form>\n      </div>\n    );\n  }",
      "language": "js"
    },
    {
      "code": "// Example of using useAgentChat in a React component\n  import { useAgentChat } from \"agents/ai-react\";\n  import { useAgent } from \"agents/react\";\n  import { useState } from \"react\";\n\n\n  function ChatInterface() {\n    // Connect to the chat agent\n    const agentConnection = useAgent({\n      agent: \"customer-support\",\n      name: \"session-12345\",\n    });\n\n\n    // Use the useAgentChat hook with the agent connection\n    const {\n      messages,\n      input,\n      handleInputChange,\n      handleSubmit,\n      isLoading,\n      error,\n      clearHistory,\n    } = useAgentChat({\n      agent: agentConnection,\n      initialMessages: [\n        { role: \"system\", content: \"You're chatting with our AI assistant.\" },\n        { role: \"assistant\", content: \"Hello! How can I help you today?\" },\n      ],\n    });\n\n\n    return (\n      <div className=\"chat-container\">\n        <div className=\"message-history\">\n          {messages.map((message, i) => (\n            <div key={i} className={`message ${message.role}`}>\n              {message.role === \"user\" ? \"👤\" : \"🤖\"} {message.content}\n            </div>\n          ))}\n\n\n          {isLoading && <div className=\"loading\">AI is typing...</div>}\n          {error && <div className=\"error\">Error: {error.message}</div>}\n        </div>\n\n\n        <form onSubmit={handleSubmit} className=\"message-input\">\n          <input\n            value={input}\n            onChange={handleInputChange}\n            placeholder=\"Type your message...\"\n            disabled={isLoading}\n          />\n          <button type=\"submit\" disabled={isLoading || !input.trim()}>\n            Send\n          </button>\n          <button type=\"button\" onClick={clearHistory}>\n            Clear Chat\n          </button>\n        </form>\n      </div>\n    );\n  }",
      "language": "ts"
    },
    {
      "code": "export class MyAgent extends Agent {\n    async browse(browserInstance, urls) {\n      let responses = [];\n      for (const url of urls) {\n        const browser = await puppeteer.launch(browserInstance);\n        const page = await browser.newPage();\n        await page.goto(url);\n\n\n        await page.waitForSelector(\"body\");\n        const bodyContent = await page.$eval(\n          \"body\",\n          (element) => element.innerHTML,\n        );\n        const client = new OpenAI({\n          apiKey: this.env.OPENAI_API_KEY,\n        });\n\n\n        let resp = await client.chat.completions.create({\n          model: this.env.MODEL,\n          messages: [\n            {\n              role: \"user\",\n              content: `Return a JSON object with the product names, prices and URLs with the following format: { \"name\": \"Product Name\", \"price\": \"Price\", \"url\": \"URL\" } from the website content below. <content>${bodyContent}</content>`,\n            },\n          ],\n          response_format: {\n            type: \"json_object\",\n          },\n        });\n\n\n        responses.push(resp);\n        await browser.close();\n      }\n\n\n      return responses;\n    }\n  }",
      "language": "js"
    },
    {
      "code": "interface Env {\n    BROWSER: Fetcher;\n  }\n\n\n  export class MyAgent extends Agent<Env> {\n    async browse(browserInstance: Fetcher, urls: string[]) {\n      let responses = [];\n      for (const url of urls) {\n        const browser = await puppeteer.launch(browserInstance);\n        const page = await browser.newPage();\n        await page.goto(url);\n\n\n        await page.waitForSelector(\"body\");\n        const bodyContent = await page.$eval(\n          \"body\",\n          (element) => element.innerHTML,\n        );\n        const client = new OpenAI({\n          apiKey: this.env.OPENAI_API_KEY,\n        });\n\n\n        let resp = await client.chat.completions.create({\n          model: this.env.MODEL,\n          messages: [\n            {\n              role: \"user\",\n              content: `Return a JSON object with the product names, prices and URLs with the following format: { \"name\": \"Product Name\", \"price\": \"Price\", \"url\": \"URL\" } from the website content below. <content>${bodyContent}</content>`,\n            },\n          ],\n          response_format: {\n            type: \"json_object\",\n          },\n        });\n\n\n        responses.push(resp);\n        await browser.close();\n      }\n\n\n      return responses;\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "npm i -D @cloudflare/puppeteer",
      "language": "sh"
    },
    {
      "code": "yarn add -D @cloudflare/puppeteer",
      "language": "sh"
    },
    {
      "code": "pnpm add -D @cloudflare/puppeteer",
      "language": "sh"
    },
    {
      "code": "{\n    // ...\n    \"browser\": {\n      \"binding\": \"MYBROWSER\",\n    },\n    // ...\n  }",
      "language": "jsonc"
    },
    {
      "code": "[browser]\n  binding = \"MYBROWSER\"",
      "language": "toml"
    },
    {
      "code": "cd your-agent-project-folder\nnpx wrangler@latest secret put BROWSERBASE_API_KEY",
      "language": "sh"
    },
    {
      "code": "Enter a secret value: ******\nCreating the secret for the Worker \"agents-example\"\nSuccess! Uploaded secret BROWSERBASE_API_KEY",
      "language": "sh"
    },
    {
      "code": "npm i @cloudflare/puppeteer",
      "language": "sh"
    },
    {
      "code": "yarn add @cloudflare/puppeteer",
      "language": "sh"
    },
    {
      "code": "pnpm add @cloudflare/puppeteer",
      "language": "sh"
    },
    {
      "code": "export class MyAgent extends Agent {\n    constructor(env) {\n      super(env);\n    }\n  }",
      "language": "js"
    },
    {
      "code": "interface Env {\n    BROWSERBASE_API_KEY: string;\n  }\n\n\n  export class MyAgent extends Agent<Env> {\n    constructor(env: Env) {\n      super(env);\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import {\n    Agent,\n    AgentNamespace,\n    getAgentByName,\n    routeAgentRequest,\n  } from \"agents\";\n\n\n  export default {\n    async fetch(request, env, ctx) {\n      // Routed addressing\n      // Automatically routes HTTP requests and/or WebSocket connections to /agents/:agent/:name\n      // Best for: connecting React apps directly to Agents using useAgent from agents/react\n      return (\n        (await routeAgentRequest(request, env)) ||\n        Response.json({ msg: \"no agent here\" }, { status: 404 })\n      );\n\n\n      // Named addressing\n      // Best for: convenience method for creating or retrieving an agent by name/ID.\n      // Bringing your own routing, middleware and/or plugging into an existing\n      // application or framework.\n      let namedAgent = getAgentByName(env.MyAgent, \"my-unique-agent-id\");\n      // Pass the incoming request straight to your Agent\n      let namedResp = (await namedAgent).fetch(request);\n      return namedResp;\n    },\n  };\n\n\n  export class MyAgent extends Agent {\n    // Your Agent implementation goes here\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent, AgentNamespace, getAgentByName, routeAgentRequest } from 'agents';\n\n\n  interface Env {\n    // Define your Agent on the environment here\n    // Passing your Agent class as a TypeScript type parameter allows you to call\n    // methods defined on your Agent.\n    MyAgent: AgentNamespace<MyAgent>;\n  }\n\n\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      // Routed addressing\n      // Automatically routes HTTP requests and/or WebSocket connections to /agents/:agent/:name\n      // Best for: connecting React apps directly to Agents using useAgent from agents/react\n      return (await routeAgentRequest(request, env)) || Response.json({ msg: 'no agent here' }, { status: 404 });\n\n\n      // Named addressing\n      // Best for: convenience method for creating or retrieving an agent by name/ID.\n      // Bringing your own routing, middleware and/or plugging into an existing\n      // application or framework.\n      let namedAgent = getAgentByName<Env, MyAgent>(env.MyAgent, 'my-unique-agent-id');\n      // Pass the incoming request straight to your Agent\n      let namedResp = (await namedAgent).fetch(request);\n      return namedResp\n    },\n  } satisfies ExportedHandler<Env>;\n\n\n  export class MyAgent extends Agent<Env> {\n    // Your Agent implementation goes here\n  }",
      "language": "ts"
    },
    {
      "code": "import { Agent, AgentNamespace, getAgentByName } from \"agents\";\n\n\n  export default {\n    async fetch(request, env, ctx) {\n      let namedAgent = getAgentByName(env.MyAgent, \"my-unique-agent-id\");\n      // Call methods directly on the Agent, and pass native JavaScript objects\n      let chatResponse = namedAgent.chat(\"Hello!\");\n      // No need to serialize/deserialize it from a HTTP request or WebSocket\n      // message and back again\n      let agentState = namedAgent.getState(); // agentState is of type UserHistory\n      return namedResp;\n    },\n  };\n\n\n  export class MyAgent extends Agent {\n    // Your Agent implementation goes here\n    async chat(prompt) {\n      // call your favorite LLM\n      return \"result\";\n    }\n\n\n    async getState() {\n      // Return the Agent's state directly\n      return this.state;\n    }\n\n\n    // Other methods as you see fit!\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent, AgentNamespace, getAgentByName } from 'agents';\n\n\n  interface Env {\n    // Define your Agent on the environment here\n    // Passing your Agent class as a TypeScript type parameter allows you to call\n    // methods defined on your Agent.\n    MyAgent: AgentNamespace<MyAgent>;\n  }\n\n\n  interface UserHistory {\n    history: string[];\n    lastUpdated: Date;\n  }\n\n\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      let namedAgent = getAgentByName<Env, MyAgent>(env.MyAgent, 'my-unique-agent-id');\n      // Call methods directly on the Agent, and pass native JavaScript objects\n      let chatResponse = namedAgent.chat('Hello!');\n      // No need to serialize/deserialize it from a HTTP request or WebSocket\n      // message and back again\n      let agentState = namedAgent.getState() // agentState is of type UserHistory\n      return namedResp\n    },\n  } satisfies ExportedHandler<Env>;\n\n\n  export class MyAgent extends Agent<Env, UserHistory> {\n    // Your Agent implementation goes here\n    async chat(prompt: string) {\n      // call your favorite LLM\n      return \"result\"\n    }\n\n\n    async getState() {\n      // Return the Agent's state directly\n      return this.state;\n    }\n\n\n    // Other methods as you see fit!\n  }",
      "language": "ts"
    },
    {
      "code": "interface Env {\n  // Passing your Agent class as a TypeScript type parameter allows you to call\n  // methods defined on your Agent.\n  MyAgent: AgentNamespace<CodeReviewAgent>;\n}\n\n\nexport class CodeReviewAgent extends Agent<Env, AgentState> {\n  // Agent methods here\n}",
      "language": "ts"
    },
    {
      "code": "import {\n    Agent,\n    AgentNamespace,\n    getAgentByName,\n    routeAgentRequest,\n  } from \"agents\";\n\n\n  export default {\n    async fetch(request, env, ctx) {\n      let userId = new URL(request.url).searchParams.get(\"userId\") || \"anonymous\";\n      // Use an identifier that allows you to route to requests, WebSockets or call methods on the Agent\n      // You can also put authentication logic here - e.g. to only create or retrieve Agents for known users.\n      let namedAgent = getAgentByName(env.MyAgent, \"my-unique-agent-id\");\n      return (await namedAgent).fetch(request);\n    },\n  };\n\n\n  export class MyAgent extends Agent {\n    // You can access the name of the agent via this.name in any method within\n    // the Agent\n    async onStartup() {\n      console.log(`agent ${this.name} ready!`);\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent, AgentNamespace, getAgentByName, routeAgentRequest } from 'agents';\n\n\n  interface Env {\n    MyAgent: AgentNamespace<MyAgent>;\n  }\n\n\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      let userId = new URL(request.url).searchParams.get('userId') || 'anonymous';\n      // Use an identifier that allows you to route to requests, WebSockets or call methods on the Agent\n      // You can also put authentication logic here - e.g. to only create or retrieve Agents for known users.\n      let namedAgent = getAgentByName<Env, MyAgent>(env.MyAgent, 'my-unique-agent-id');\n      return (await namedAgent).fetch(request);\n    },\n  } satisfies ExportedHandler<Env>;\n\n\n  export class MyAgent extends Agent<Env> {\n    // You can access the name of the agent via this.name in any method within\n    // the Agent\n    async onStartup() { console.log(`agent ${this.name} ready!`)}\n  }",
      "language": "ts"
    },
    {
      "code": "import { Agent, AgentNamespace, routeAgentRequest } from \"agents\";\n\n\n  export default {\n    async fetch(request, env, ctx) {\n      // Use the onBeforeConnect and onBeforeRequest hooks to authenticate clients\n      // or run logic before handling a HTTP request or WebSocket.\n      return (\n        (await routeAgentRequest(request, env, {\n          // Run logic before a WebSocket client connects\n          onBeforeConnect: (request) => {\n            // Your code/auth code here\n            // You can return a Response here - e.g. a HTTP 403 Not Authorized -\n            // which will stop further request processing and will NOT invoke the\n            // Agent.\n            // return Response.json({\"error\": \"not authorized\"}, { status: 403 })\n          },\n          // Run logic before a HTTP client clients\n          onBeforeRequest: (request) => {\n            // Your code/auth code here\n            // Returning nothing will result in the call to the Agent continuing\n          },\n          // Prepend a prefix for how your Agents are named here\n          prefix: \"name-prefix-here\",\n        })) || Response.json({ msg: \"no agent here\" }, { status: 404 })\n      );\n    },\n  };",
      "language": "js"
    },
    {
      "code": "import { Agent, AgentNamespace, routeAgentRequest } from 'agents';\n\n\n  interface Env {\n    MyAgent: AgentNamespace<MyAgent>;\n  }\n\n\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      // Use the onBeforeConnect and onBeforeRequest hooks to authenticate clients\n      // or run logic before handling a HTTP request or WebSocket.\n      return (\n        (await routeAgentRequest(request, env, {\n          // Run logic before a WebSocket client connects\n          onBeforeConnect: (request) => {\n            // Your code/auth code here\n            // You can return a Response here - e.g. a HTTP 403 Not Authorized -\n            // which will stop further request processing and will NOT invoke the\n            // Agent.\n            // return Response.json({\"error\": \"not authorized\"}, { status: 403 })\n          },\n          // Run logic before a HTTP client clients\n          onBeforeRequest: (request) => {\n            // Your code/auth code here\n            // Returning nothing will result in the call to the Agent continuing\n          },\n          // Prepend a prefix for how your Agents are named here\n          prefix: 'name-prefix-here',\n        })) || Response.json({ msg: 'no agent here' }, { status: 404 })\n      );\n\n\n    },\n  } satisfies ExportedHandler<Env>;",
      "language": "ts"
    },
    {
      "code": "import { Agent, AgentNamespace, getAgentByName } from \"agents\";\n  import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  app.use(\"/code-review/*\", async (c, next) => {\n    // Perform auth here\n    // e.g. validate a Bearer token, a JWT, use your preferred auth library\n    // return Response.json({ msg: 'unauthorized' }, { status: 401 });\n    await next(); // continue on if valid\n  });\n\n\n  app.get(\"/code-review/:id\", async (c) => {\n    const id = c.req.param(\"teamId\");\n    if (!id) return Response.json({ msg: \"missing id\" }, { status: 400 });\n\n\n    // Call the Agent, creating it with the name/identifier from the \":id\" segment\n    // of our URL\n    const agent = await getAgentByName(c.env.MyAgent, id);\n\n\n    // Pass the request to our Agent instance\n    return await agent.fetch(c.req.raw);\n  });",
      "language": "js"
    },
    {
      "code": "import { Agent, AgentNamespace, getAgentByName } from 'agents';\n  import { Hono } from 'hono';\n\n\n  const app = new Hono<{ Bindings: Env }>();\n\n\n  app.use('/code-review/*', async (c, next) => {\n    // Perform auth here\n    // e.g. validate a Bearer token, a JWT, use your preferred auth library\n    // return Response.json({ msg: 'unauthorized' }, { status: 401 });\n    await next(); // continue on if valid\n  });\n\n\n  app.get('/code-review/:id', async (c) => {\n    const id = c.req.param('teamId');\n    if (!id) return Response.json({ msg: 'missing id' }, { status: 400 });\n\n\n    // Call the Agent, creating it with the name/identifier from the \":id\" segment\n    // of our URL\n    const agent = await getAgentByName<Env, MyAgent>(c.env.MyAgent, id);\n\n\n    // Pass the request to our Agent instance\n    return await agent.fetch(c.req.raw);\n  });",
      "language": "ts"
    },
    {
      "code": ".\n|-- package-lock.json\n|-- package.json\n|-- public\n|   `-- index.html\n|-- src\n|   `-- index.ts // your Agent definition\n|-- test\n|   |-- index.spec.ts // your tests\n|   `-- tsconfig.json\n|-- tsconfig.json\n|-- vitest.config.mts\n|-- worker-configuration.d.ts\n`-- wrangler.jsonc // your Workers & Agent configuration",
      "language": "sh"
    },
    {
      "code": "{\n    \"$schema\": \"node_modules/wrangler/config-schema.json\",\n    \"name\": \"agents-example\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2025-02-23\",\n    \"compatibility_flags\": [\"nodejs_compat\"],\n    \"durable_objects\": {\n      \"bindings\": [\n        {\n          // Required:\n          \"name\": \"MyAgent\", // How your Agent is called from your Worker\n          \"class_name\": \"MyAgent\", // Must match the class name of the Agent in your code\n          // Optional: set this if the Agent is defined in another Worker script\n          \"script_name\": \"the-other-worker\"\n        },\n      ],\n    },\n    \"migrations\": [\n      {\n        \"tag\": \"v1\",\n        // Mandatory for the Agent to store state\n        \"new_sqlite_classes\": [\"MyAgent\"],\n      },\n    ],\n    \"observability\": {\n      \"enabled\": true,\n    },\n  }",
      "language": "jsonc"
    },
    {
      "code": "\"$schema\" = \"node_modules/wrangler/config-schema.json\"\n  name = \"agents-example\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2025-02-23\"\n  compatibility_flags = [ \"nodejs_compat\" ]\n\n\n  [[durable_objects.bindings]]\n  name = \"MyAgent\"\n  class_name = \"MyAgent\"\n  script_name = \"the-other-worker\"\n\n\n  [[migrations]]\n  tag = \"v1\"\n  new_sqlite_classes = [ \"MyAgent\" ]\n\n\n  [observability]\n  enabled = true",
      "language": "toml"
    },
    {
      "code": "class MyAgent extends Agent {\n    // Handle HTTP requests coming to this Agent instance\n    // Returns a Response object\n    async onRequest(request) {\n      return new Response(\"Hello from Agent!\");\n    }\n\n\n    async callAIModel(prompt) {\n      // Implement AI model call here\n    }\n  }",
      "language": "js"
    },
    {
      "code": "class MyAgent extends Agent<Env, State> {\n    // Handle HTTP requests coming to this Agent instance\n    // Returns a Response object\n    async onRequest(request: Request) {\n      return new Response(\"Hello from Agent!\");\n    }\n\n\n    async callAIModel(prompt: string) {\n      // Implement AI model call here\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import {\n    Agent,\n    AgentNamespace,\n    getAgentByName,\n    routeAgentRequest,\n  } from \"agents\";\n  import { streamText } from \"ai\";\n  import { createOpenAI, openai } from \"@ai-sdk/openai\";\n\n\n  export class MyAgent extends Agent {\n    async onRequest(request) {\n      // Test it via:\n      // curl -d '{\"prompt\": \"Write me a Cloudflare Worker\"}' <url>\n      let data = await request.json();\n      let stream = await this.callAIModel(data.prompt);\n      // This uses Server-Sent Events (SSE)\n      return stream.toTextStreamResponse({\n        headers: {\n          \"Content-Type\": \"text/x-unknown\",\n          \"content-encoding\": \"identity\",\n          \"transfer-encoding\": \"chunked\",\n        },\n      });\n    }\n\n\n    async callAIModel(prompt) {\n      const openai = createOpenAI({\n        apiKey: this.env.OPENAI_API_KEY,\n      });\n\n\n      return streamText({\n        model: openai(\"gpt-4o\"),\n        prompt: prompt,\n      });\n    }\n  }\n\n\n  export default {\n    async fetch(request, env) {\n      let agentId = new URL(request.url).searchParams.get(\"agent-id\") || \"\";\n      const agent = await getAgentByName(env.MyAgent, agentId);\n      return agent.fetch(request);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "import { Agent, AgentNamespace, getAgentByName, routeAgentRequest } from 'agents';\n  import { streamText } from 'ai';\n  import { createOpenAI, openai } from '@ai-sdk/openai';\n\n\n  interface Env {\n    MyAgent: AgentNamespace<MyAgent>;\n    OPENAI_API_KEY: string;\n  }\n\n\n  export class MyAgent extends Agent<Env> {\n    async onRequest(request: Request) {\n      // Test it via:\n      // curl -d '{\"prompt\": \"Write me a Cloudflare Worker\"}' <url>\n      let data = await request.json<{ prompt: string }>();\n      let stream = await this.callAIModel(data.prompt);\n      // This uses Server-Sent Events (SSE)\n      return stream.toTextStreamResponse({\n        headers: {\n          'Content-Type': 'text/x-unknown',\n          'content-encoding': 'identity',\n          'transfer-encoding': 'chunked',\n        },\n      });\n    }\n\n\n    async callAIModel(prompt: string) {\n      const openai = createOpenAI({\n        apiKey: this.env.OPENAI_API_KEY,\n      });\n\n\n      return streamText({\n        model: openai('gpt-4o'),\n        prompt: prompt,\n      });\n    }\n  }\n\n\n  export default {\n    async fetch(request: Request, env: Env) {\n      let agentId = new URL(request.url).searchParams.get('agent-id') || '';\n      const agent = await getAgentByName<Env, MyAgent>(env.MyAgent, agentId);\n      return agent.fetch(request);\n    },\n  };",
      "language": "ts"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  export class RAGAgent extends Agent {\n    // Other methods on our Agent\n    // ...\n    //\n    async queryKnowledge(userQuery) {\n      // Turn a query into an embedding\n      const queryVector = await this.env.AI.run(\"@cf/baai/bge-base-en-v1.5\", {\n        text: [userQuery],\n      });\n\n\n      // Retrieve results from our vector index\n      let searchResults = await this.env.VECTOR_DB.query(queryVector.data[0], {\n        topK: 10,\n        returnMetadata: \"all\",\n      });\n\n\n      let knowledge = [];\n      for (const match of searchResults.matches) {\n        console.log(match.metadata);\n        knowledge.push(match.metadata);\n      }\n\n\n      // Use the metadata to re-associate the vector search results\n      // with data in our Agent's SQL database\n      let results = this\n        .sql`SELECT * FROM knowledge WHERE id IN (${knowledge.map((k) => k.id)})`;\n\n\n      // Return them\n      return results;\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  interface Env {\n    AI: Ai;\n    VECTOR_DB: Vectorize;\n  }\n\n\n  export class RAGAgent extends Agent<Env> {\n    // Other methods on our Agent\n    // ...\n    //\n    async queryKnowledge(userQuery: string) {\n      // Turn a query into an embedding\n      const queryVector = await this.env.AI.run('@cf/baai/bge-base-en-v1.5', {\n        text: [userQuery],\n      });\n\n\n      // Retrieve results from our vector index\n      let searchResults = await this.env.VECTOR_DB.query(queryVector.data[0], {\n        topK: 10,\n        returnMetadata: 'all',\n      });\n\n\n      let knowledge = [];\n      for (const match of searchResults.matches) {\n        console.log(match.metadata);\n        knowledge.push(match.metadata);\n      }\n\n\n      // Use the metadata to re-associate the vector search results\n      // with data in our Agent's SQL database\n      let results = this.sql`SELECT * FROM knowledge WHERE id IN (${knowledge.map((k) => k.id)})`;\n\n\n      // Return them\n      return results;\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "{\n    // ...\n    \"vectorize\": [\n      {\n        \"binding\": \"VECTOR_DB\",\n        \"index_name\": \"your-vectorize-index-name\"\n      }\n    ]\n    // ...\n  }",
      "language": "jsonc"
    },
    {
      "code": "[[vectorize]]\n  binding = \"VECTOR_DB\"\n  index_name = \"your-vectorize-index-name\"",
      "language": "toml"
    },
    {
      "code": "export class MyAgent extends Agent {\n    async onRequest(request) {\n      let userId = request.headers.get(\"user-id\");\n      // Trigger a schedule that runs a Workflow\n      // Pass it a payload\n      let { taskId } = await this.schedule(300, \"runWorkflow\", {\n        id: userId,\n        flight: \"DL264\",\n        date: \"2025-02-23\",\n      });\n    }\n\n\n    async runWorkflow(data) {\n      let instance = await env.MY_WORKFLOW.create({\n        id: data.id,\n        params: data,\n      });\n\n\n      // Schedule another task that checks the Workflow status every 5 minutes...\n      await this.schedule(\"*/5 * * * *\", \"checkWorkflowStatus\", {\n        id: instance.id,\n      });\n    }\n  }\n\n\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // Your Workflow code here\n    }\n  }",
      "language": "js"
    },
    {
      "code": "interface Env {\n    MY_WORKFLOW: Workflow;\n    MyAgent: AgentNamespace<MyAgent>;\n  }\n\n\n  export class MyAgent extends Agent<Env> {\n    async onRequest(request: Request) {\n      let userId = request.headers.get(\"user-id\");\n      // Trigger a schedule that runs a Workflow\n      // Pass it a payload\n      let { taskId } = await this.schedule(300, \"runWorkflow\", { id: userId, flight: \"DL264\", date: \"2025-02-23\" });\n    }\n\n\n    async runWorkflow(data) {\n      let instance = await env.MY_WORKFLOW.create({\n        id: data.id,\n        params: data,\n      })\n\n\n      // Schedule another task that checks the Workflow status every 5 minutes...\n      await this.schedule(\"*/5 * * * *\", \"checkWorkflowStatus\", { id: instance.id });\n    }\n  }\n\n\n  export class MyWorkflow extends WorkflowEntrypoint<Env> {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // Your Workflow code here\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "{\n    // ...\n    // Create a binding between your Agent and your Workflow\n    \"workflows\": [\n      {\n        // Required:\n        \"name\": \"EMAIL_WORKFLOW\",\n        \"class_name\": \"MyWorkflow\",\n        // Optional: set the script_name field if your Workflow is defined in a\n        // different project from your Agent\n        \"script_name\": \"email-workflows\"\n      }\n     ],\n    // ...\n  }",
      "language": "jsonc"
    },
    {
      "code": "[[workflows]]\n  name = \"EMAIL_WORKFLOW\"\n  class_name = \"MyWorkflow\"\n  script_name = \"email-workflows\"",
      "language": "toml"
    },
    {
      "code": "{\n      // Required:\n      \"name\": \"EMAIL_WORKFLOW\",\n      \"class_name\": \"MyWorkflow\",\n      // Optional: set the script_name field if your Workflow is defined in a\n      // different project from your Agent\n      \"script_name\": \"email-workflows\"\n  }",
      "language": "jsonc"
    },
    {
      "code": "name = \"EMAIL_WORKFLOW\"\n  class_name = \"MyWorkflow\"\n  script_name = \"email-workflows\"",
      "language": "toml"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  export class SchedulingAgent extends Agent {\n    async onRequest(request) {\n      // Handle an incoming request\n      // Schedule a task 10 minutes from now\n      // Calls the \"checkFlights\" method\n      let { taskId } = await this.schedule(600, \"checkFlights\", {\n        flight: \"DL264\",\n        date: \"2025-02-23\",\n      });\n      return Response.json({ taskId });\n    }\n\n\n    async checkFlights(data) {\n      // Invoked when our scheduled task runs\n      // We can also call this.schedule here to schedule another task\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\"\n\n\n  export class SchedulingAgent extends Agent {\n    async onRequest(request) {\n      // Handle an incoming request\n      // Schedule a task 10 minutes from now\n      // Calls the \"checkFlights\" method\n      let { taskId } = await this.schedule(600, \"checkFlights\", { flight: \"DL264\", date: \"2025-02-23\" });\n      return Response.json({ taskId });\n    }\n\n\n    async checkFlights(data) {\n      // Invoked when our scheduled task runs\n      // We can also call this.schedule here to schedule another task\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "// schedule a task to run in 10 seconds\n  let task = await this.schedule(10, \"someTask\", { message: \"hello\" });\n\n\n  // schedule a task to run at a specific date\n  let task = await this.schedule(new Date(\"2025-01-01\"), \"someTask\", {});\n\n\n  // schedule a task to run every 10 minutes\n  let { id } = await this.schedule(\"*/10 * * * *\", \"someTask\", {\n    message: \"hello\",\n  });\n\n\n  // schedule a task to run every 10 minutes, but only on Mondays\n  let task = await this.schedule(\"*/10 * * * 1\", \"someTask\", {\n    message: \"hello\",\n  });\n\n\n  // cancel a scheduled task\n  this.cancelSchedule(task.id);",
      "language": "js"
    },
    {
      "code": "// schedule a task to run in 10 seconds\n  let task = await this.schedule(10, \"someTask\", { message: \"hello\" });\n\n\n  // schedule a task to run at a specific date\n  let task = await this.schedule(new Date(\"2025-01-01\"), \"someTask\", {});\n\n\n  // schedule a task to run every 10 minutes\n  let { id } = await this.schedule(\"*/10 * * * *\", \"someTask\", { message: \"hello\" });\n\n\n  // schedule a task to run every 10 minutes, but only on Mondays\n  let task = await this.schedule(\"*/10 * * * 1\", \"someTask\", { message: \"hello\" });\n\n\n  // cancel a scheduled task\n  this.cancelSchedule(task.id);",
      "language": "ts"
    },
    {
      "code": "// Get a specific schedule by ID\n  // Returns undefined if the task does not exist\n  let task = await this.getSchedule(task.id);\n\n\n  // Get all scheduled tasks\n  // Returns an array of Schedule objects\n  let tasks = this.getSchedules();\n\n\n  // Cancel a task by its ID\n  // Returns true if the task was cancelled, false if it did not exist\n  await this.cancelSchedule(task.id);\n\n\n  // Filter for specific tasks\n  // e.g. all tasks starting in the next hour\n  let tasks = this.getSchedules({\n    timeRange: {\n      start: new Date(Date.now()),\n      end: new Date(Date.now() + 60 * 60 * 1000),\n    },\n  });",
      "language": "js"
    },
    {
      "code": "// Get a specific schedule by ID\n  // Returns undefined if the task does not exist\n  let task = await this.getSchedule(task.id)\n\n\n  // Get all scheduled tasks\n  // Returns an array of Schedule objects\n  let tasks = this.getSchedules();\n\n\n  // Cancel a task by its ID\n  // Returns true if the task was cancelled, false if it did not exist\n  await this.cancelSchedule(task.id);\n\n\n  // Filter for specific tasks\n  // e.g. all tasks starting in the next hour\n  let tasks = this.getSchedules({\n    timeRange: {\n      start: new Date(Date.now()),\n      end: new Date(Date.now() + 60 * 60 * 1000),\n    }\n  });",
      "language": "ts"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  export class MyAgent extends Agent {\n    // Update state in response to events\n    async incrementCounter() {\n      this.setState({\n        ...this.state,\n        counter: this.state.counter + 1,\n      });\n    }\n\n\n    // Handle incoming messages\n    async onMessage(message) {\n      if (message.type === \"update\") {\n        this.setState({\n          ...this.state,\n          ...message.data,\n        });\n      }\n    }\n\n\n    // Handle state updates\n    onStateUpdate(state, source) {\n      console.log(\"state updated\", state);\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  export class MyAgent extends Agent {\n    // Update state in response to events\n    async incrementCounter() {\n      this.setState({\n        ...this.state,\n        counter: this.state.counter + 1,\n      });\n    }\n\n\n    // Handle incoming messages\n    async onMessage(message) {\n      if (message.type === \"update\") {\n        this.setState({\n          ...this.state,\n          ...message.data,\n        });\n      }\n    }\n\n\n    // Handle state updates\n    onStateUpdate(state, source: \"server\" | Connection) {\n      console.log(\"state updated\", state);\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  // Define a type for your Agent's state\n  // Pass in the type of your Agent's state\n  export class MyAgent extends Agent {\n    // This allows this.setState and the onStateUpdate method to\n    // be typed:\n    async onStateUpdate(state) {\n      console.log(\"state updated\", state);\n    }\n\n\n    async someOtherMethod() {\n      this.setState({\n        ...this.state,\n        price: this.state.price + 10,\n      });\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  interface Env {}\n\n\n  // Define a type for your Agent's state\n  interface FlightRecord {\n    id: string;\n    departureIata: string;\n    arrival: Date;\n    arrivalIata: string;\n    price: number;\n  }\n\n\n  // Pass in the type of your Agent's state\n  export class MyAgent extends Agent<Env, FlightRecord> {\n    // This allows this.setState and the onStateUpdate method to\n    // be typed:\n     async onStateUpdate(state: FlightRecord) {\n      console.log(\"state updated\", state);\n    }\n\n\n    async someOtherMethod() {\n      this.setState({\n        ...this.state,\n        price: this.state.price + 10,\n      });\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "class MyAgent extends Agent {\n    // Set a default, initial state\n    initialState = {\n      counter: 0,\n      text: \"\",\n      color: \"#3B82F6\",\n    };\n\n\n    doSomething() {\n      console.log(this.state); // {counter: 0, text: \"\", color: \"#3B82F6\"}, if you haven't set the state yet\n    }\n  }",
      "language": "js"
    },
    {
      "code": "type State = {\n    counter: number;\n    text: string;\n    color: string;\n  };\n\n\n  class MyAgent extends Agent<Env, State> {\n    // Set a default, initial state\n    initialState = {\n      counter: 0,\n      text: \"\",\n      color: \"#3B82F6\",\n    };\n\n\n    doSomething() {\n      console.log(this.state); // {counter: 0, text: \"\", color: \"#3B82F6\"}, if you haven't set the state yet\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import { useState } from \"react\";\n  import { useAgent } from \"agents/react\";\n\n\n  function StateInterface() {\n    const [state, setState] = useState({ counter: 0 });\n\n\n    const agent = useAgent({\n      agent: \"thinking-agent\",\n      name: \"my-agent\",\n      onStateUpdate: (newState) => setState(newState),\n    });\n\n\n    const increment = () => {\n      agent.setState({ counter: state.counter + 1 });\n    };\n\n\n    return (\n      <div>\n        <div>Count: {state.counter}</div>\n        <button onClick={increment}>Increment</button>\n      </div>\n    );\n  }",
      "language": "js"
    },
    {
      "code": "import { useState } from \"react\";\n  import { useAgent } from \"agents/react\";\n\n\n  function StateInterface() {\n    const [state, setState] = useState({ counter: 0 });\n\n\n    const agent = useAgent({\n      agent: \"thinking-agent\",\n      name: \"my-agent\",\n      onStateUpdate: (newState) => setState(newState),\n    });\n\n\n    const increment = () => {\n      agent.setState({ counter: state.counter + 1 });\n    };\n\n\n    return (\n      <div>\n        <div>Count: {state.counter}</div>\n        <button onClick={increment}>Increment</button>\n      </div>\n    );\n  }",
      "language": "ts"
    },
    {
      "code": "export class MyAgent extends Agent {\n    async onRequest(request) {\n      let userId = new URL(request.url).searchParams.get(\"userId\");\n\n\n      // 'users' is just an example here: you can create arbitrary tables and define your own schemas\n      // within each Agent's database using SQL (SQLite syntax).\n      let [user] = this.sql`SELECT * FROM users WHERE id = ${userId}`;\n      return Response.json(user);\n    }\n  }",
      "language": "js"
    },
    {
      "code": "export class MyAgent extends Agent<Env> {\n    async onRequest(request: Request) {\n      let userId = new URL(request.url).searchParams.get('userId');\n\n\n      // 'users' is just an example here: you can create arbitrary tables and define your own schemas\n      // within each Agent's database using SQL (SQLite syntax).\n      let [user] = this.sql`SELECT * FROM users WHERE id = ${userId}`\n      return Response.json(user)\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "type User = {\n  id: string;\n  name: string;\n  email: string;\n};\n\n\nexport class MyAgent extends Agent<Env> {\n  async onRequest(request: Request) {\n    let userId = new URL(request.url).searchParams.get('userId');\n    // Supply the type parameter to the query when calling this.sql\n    // This assumes the results returns one or more User rows with \"id\", \"name\", and \"email\" columns\n    const [user] = this.sql<User>`SELECT * FROM users WHERE id = ${userId}`;\n    return Response.json(user)\n  }\n}",
      "language": "ts"
    },
    {
      "code": "export class ReasoningAgent extends Agent {\n    async callReasoningModel(prompt) {\n      let result = this\n        .sql`SELECT * FROM history WHERE user = ${prompt.userId} ORDER BY timestamp DESC LIMIT 1000`;\n      let context = [];\n      for (const row of result) {\n        context.push(row.entry);\n      }\n\n\n      const client = new OpenAI({\n        apiKey: this.env.OPENAI_API_KEY,\n      });\n\n\n      // Combine user history with the current prompt\n      const systemPrompt = prompt.system || \"You are a helpful assistant.\";\n      const userPrompt = `${prompt.user}\\n\\nUser history:\\n${context.join(\"\\n\")}`;\n\n\n      try {\n        const completion = await client.chat.completions.create({\n          model: this.env.MODEL || \"o3-mini\",\n          messages: [\n            { role: \"system\", content: systemPrompt },\n            { role: \"user\", content: userPrompt },\n          ],\n          temperature: 0.7,\n          max_tokens: 1000,\n        });\n\n\n        // Store the response in history\n        this\n          .sql`INSERT INTO history (timestamp, user, entry) VALUES (${new Date()}, ${prompt.userId}, ${completion.choices[0].message.content})`;\n\n\n        return completion.choices[0].message.content;\n      } catch (error) {\n        console.error(\"Error calling reasoning model:\", error);\n        throw error;\n      }\n    }\n  }",
      "language": "js"
    },
    {
      "code": "export class ReasoningAgent extends Agent<Env> {\n    async callReasoningModel(prompt: Prompt) {\n      let result = this.sql<History>`SELECT * FROM history WHERE user = ${prompt.userId} ORDER BY timestamp DESC LIMIT 1000`;\n      let context = [];\n      for (const row of result) {\n        context.push(row.entry);\n      }\n\n\n      const client = new OpenAI({\n        apiKey: this.env.OPENAI_API_KEY,\n      });\n\n\n      // Combine user history with the current prompt\n      const systemPrompt = prompt.system || 'You are a helpful assistant.';\n      const userPrompt = `${prompt.user}\\n\\nUser history:\\n${context.join('\\n')}`;\n\n\n      try {\n        const completion = await client.chat.completions.create({\n          model: this.env.MODEL || 'o3-mini',\n          messages: [\n            { role: 'system', content: systemPrompt },\n            { role: 'user', content: userPrompt },\n          ],\n          temperature: 0.7,\n          max_tokens: 1000,\n        });\n\n\n        // Store the response in history\n        this\n          .sql`INSERT INTO history (timestamp, user, entry) VALUES (${new Date()}, ${prompt.userId}, ${completion.choices[0].message.content})`;\n\n\n        return completion.choices[0].message.content;\n      } catch (error) {\n        console.error('Error calling reasoning model:', error);\n        throw error;\n      }\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import { Agent } from \"agents\";\n  import { OpenAI } from \"openai\";\n\n\n  export class MyAgent extends Agent {\n    async onConnect(connection, ctx) {\n      //\n    }\n\n\n    async onMessage(connection, message) {\n      let msg = JSON.parse(message);\n      // This can run as long as it needs to, and return as many messages as it needs to!\n      await queryReasoningModel(connection, msg.prompt);\n    }\n\n\n    async queryReasoningModel(connection, userPrompt) {\n      const client = new OpenAI({\n        apiKey: this.env.OPENAI_API_KEY,\n      });\n\n\n      try {\n        const stream = await client.chat.completions.create({\n          model: this.env.MODEL || \"o3-mini\",\n          messages: [{ role: \"user\", content: userPrompt }],\n          stream: true,\n        });\n\n\n        // Stream responses back as WebSocket messages\n        for await (const chunk of stream) {\n          const content = chunk.choices[0]?.delta?.content || \"\";\n          if (content) {\n            connection.send(JSON.stringify({ type: \"chunk\", content }));\n          }\n        }\n\n\n        // Send completion message\n        connection.send(JSON.stringify({ type: \"done\" }));\n      } catch (error) {\n        connection.send(JSON.stringify({ type: \"error\", error: error }));\n      }\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\";\n  import { OpenAI } from \"openai\";\n\n\n  export class MyAgent extends Agent<Env> {\n    async onConnect(connection: Connection, ctx: ConnectionContext) {\n      //\n    }\n\n\n    async onMessage(connection: Connection, message: WSMessage) {\n      let msg = JSON.parse(message);\n      // This can run as long as it needs to, and return as many messages as it needs to!\n      await queryReasoningModel(connection, msg.prompt);\n    }\n\n\n    async queryReasoningModel(connection: Connection, userPrompt: string) {\n      const client = new OpenAI({\n        apiKey: this.env.OPENAI_API_KEY,\n      });\n\n\n      try {\n        const stream = await client.chat.completions.create({\n          model: this.env.MODEL || \"o3-mini\",\n          messages: [{ role: \"user\", content: userPrompt }],\n          stream: true,\n        });\n\n\n        // Stream responses back as WebSocket messages\n        for await (const chunk of stream) {\n          const content = chunk.choices[0]?.delta?.content || \"\";\n          if (content) {\n            connection.send(JSON.stringify({ type: \"chunk\", content }));\n          }\n        }\n\n\n        // Send completion message\n        connection.send(JSON.stringify({ type: \"done\" }));\n      } catch (error) {\n        connection.send(JSON.stringify({ type: \"error\", error: error }));\n      }\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  export class MyAgent extends Agent {\n    async onRequest(request) {\n      const response = await env.AI.run(\n        \"@cf/deepseek-ai/deepseek-r1-distill-qwen-32b\",\n        {\n          prompt: \"Build me a Cloudflare Worker that returns JSON.\",\n          stream: true, // Stream a response and don't block the client!\n        },\n      );\n\n\n      // Return the stream\n      return new Response(answer, {\n        headers: { \"content-type\": \"text/event-stream\" },\n      });\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  interface Env {\n    AI: Ai;\n  }\n\n\n  export class MyAgent extends Agent<Env> {\n    async onRequest(request: Request) {\n      const response = await env.AI.run(\n        \"@cf/deepseek-ai/deepseek-r1-distill-qwen-32b\",\n        {\n          prompt: \"Build me a Cloudflare Worker that returns JSON.\",\n          stream: true, // Stream a response and don't block the client!\n        },\n      );\n\n\n      // Return the stream\n      return new Response(answer, {\n        headers: { \"content-type\": \"text/event-stream\" },\n      });\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "{\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"ai\": {\n      \"binding\": \"AI\"\n    }\n  }",
      "language": "jsonc"
    },
    {
      "code": "[ai]\n  binding = \"AI\"",
      "language": "toml"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  export class MyAgent extends Agent {\n    async onRequest(request) {\n      const response = await env.AI.run(\n        \"@cf/deepseek-ai/deepseek-r1-distill-qwen-32b\",\n        {\n          prompt: \"Build me a Cloudflare Worker that returns JSON.\",\n        },\n        {\n          gateway: {\n            id: \"{gateway_id}\", // Specify your AI Gateway ID here\n            skipCache: false,\n            cacheTtl: 3360,\n          },\n        },\n      );\n\n\n      return Response.json(response);\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\";\n\n\n  interface Env {\n    AI: Ai;\n  }\n\n\n  export class MyAgent extends Agent<Env> {\n    async onRequest(request: Request) {\n      const response = await env.AI.run(\n        \"@cf/deepseek-ai/deepseek-r1-distill-qwen-32b\",\n        {\n          prompt: \"Build me a Cloudflare Worker that returns JSON.\",\n        },\n        {\n          gateway: {\n            id: \"{gateway_id}\", // Specify your AI Gateway ID here\n            skipCache: false,\n            cacheTtl: 3360,\n          },\n        },\n      );\n\n\n      return Response.json(response);\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "{\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"ai\": {\n      \"binding\": \"AI\"\n    }\n  }",
      "language": "jsonc"
    },
    {
      "code": "[ai]\n  binding = \"AI\"",
      "language": "toml"
    },
    {
      "code": "npm i ai @ai-sdk/openai",
      "language": "sh"
    },
    {
      "code": "yarn add ai @ai-sdk/openai",
      "language": "sh"
    },
    {
      "code": "pnpm add ai @ai-sdk/openai",
      "language": "sh"
    },
    {
      "code": "import { Agent } from \"agents\";\n  import { generateText } from \"ai\";\n  import { openai } from \"@ai-sdk/openai\";\n\n\n  export class MyAgent extends Agent {\n    async onRequest(request) {\n      const { text } = await generateText({\n        model: openai(\"o3-mini\"),\n        prompt: \"Build me an AI agent on Cloudflare Workers\",\n      });\n\n\n      return Response.json({ modelResponse: text });\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\";\n  import { generateText } from \"ai\";\n  import { openai } from \"@ai-sdk/openai\";\n\n\n  export class MyAgent extends Agent<Env> {\n    async onRequest(request: Request): Promise<Response> {\n      const { text } = await generateText({\n        model: openai(\"o3-mini\"),\n        prompt: \"Build me an AI agent on Cloudflare Workers\",\n      });\n\n\n      return Response.json({ modelResponse: text });\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import { Agent } from \"agents\";\n  import { OpenAI } from \"openai\";\n\n\n  export class MyAgent extends Agent {\n    async onRequest(request) {\n      const openai = new OpenAI({\n        apiKey: this.env.GEMINI_API_KEY,\n        baseURL: \"https://generativelanguage.googleapis.com/v1beta/openai/\",\n      });\n\n\n      // Create a TransformStream to handle streaming data\n      let { readable, writable } = new TransformStream();\n      let writer = writable.getWriter();\n      const textEncoder = new TextEncoder();\n\n\n      // Use ctx.waitUntil to run the async function in the background\n      // so that it doesn't block the streaming response\n      ctx.waitUntil(\n        (async () => {\n          const stream = await openai.chat.completions.create({\n            model: \"4o\",\n            messages: [\n              { role: \"user\", content: \"Write me a Cloudflare Worker.\" },\n            ],\n            stream: true,\n          });\n\n\n          // loop over the data as it is streamed and write to the writeable\n          for await (const part of stream) {\n            writer.write(\n              textEncoder.encode(part.choices[0]?.delta?.content || \"\"),\n            );\n          }\n          writer.close();\n        })(),\n      );\n\n\n      // Return the readable stream back to the client\n      return new Response(readable);\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent } from \"agents\";\n  import { OpenAI } from \"openai\";\n\n\n  export class MyAgent extends Agent<Env> {\n    async onRequest(request: Request): Promise<Response> {\n      const openai = new OpenAI({\n        apiKey: this.env.GEMINI_API_KEY,\n        baseURL: \"https://generativelanguage.googleapis.com/v1beta/openai/\",\n      });\n\n\n      // Create a TransformStream to handle streaming data\n      let { readable, writable } = new TransformStream();\n      let writer = writable.getWriter();\n      const textEncoder = new TextEncoder();\n\n\n      // Use ctx.waitUntil to run the async function in the background\n      // so that it doesn't block the streaming response\n      ctx.waitUntil(\n        (async () => {\n          const stream = await openai.chat.completions.create({\n            model: \"4o\",\n            messages: [\n              { role: \"user\", content: \"Write me a Cloudflare Worker.\" },\n            ],\n            stream: true,\n          });\n\n\n          // loop over the data as it is streamed and write to the writeable\n          for await (const part of stream) {\n            writer.write(\n              textEncoder.encode(part.choices[0]?.delta?.content || \"\"),\n            );\n          }\n          writer.close();\n        })(),\n      );\n\n\n      // Return the readable stream back to the client\n      return new Response(readable);\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import { Agent, Connection } from \"agents\";\n\n\n  export class ChatAgent extends Agent {\n    async onConnect(connection, ctx) {\n      // Connections are automatically accepted by the SDK.\n      // You can also explicitly close a connection here with connection.close()\n      // Access the Request on ctx.request to inspect headers, cookies and the URL\n    }\n\n\n    async onMessage(connection, message) {\n      // const response = await longRunningAITask(message)\n      await connection.send(message);\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent, Connection } from \"agents\";\n\n\n  export class ChatAgent extends Agent {\n    async onConnect(connection: Connection, ctx: ConnectionContext) {\n      // Connections are automatically accepted by the SDK.\n      // You can also explicitly close a connection here with connection.close()\n      // Access the Request on ctx.request to inspect headers, cookies and the URL\n    }\n\n\n    async onMessage(connection: Connection, message: WSMessage) {\n      // const response = await longRunningAITask(message)\n      await connection.send(message)\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "import { AgentClient } from \"agents/client\";\n\n\n  const connection = new AgentClient({\n    agent: \"dialogue-agent\",\n    name: \"insight-seeker\",\n  });\n\n\n  connection.addEventListener(\"message\", (event) => {\n    console.log(\"Received:\", event.data);\n  });\n\n\n  connection.send(\n    JSON.stringify({\n      type: \"inquiry\",\n      content: \"What patterns do you see?\",\n    }),\n  );",
      "language": "js"
    },
    {
      "code": "import { AgentClient } from \"agents/client\";\n\n\n  const connection = new AgentClient({\n    agent: \"dialogue-agent\",\n    name: \"insight-seeker\",\n  });\n\n\n  connection.addEventListener(\"message\", (event) => {\n    console.log(\"Received:\", event.data);\n  });\n\n\n  connection.send(\n    JSON.stringify({\n      type: \"inquiry\",\n      content: \"What patterns do you see?\",\n    })\n  );",
      "language": "ts"
    },
    {
      "code": "import { useAgent } from \"agents/react\";\n\n\n  function AgentInterface() {\n    const connection = useAgent({\n      agent: \"dialogue-agent\",\n      name: \"insight-seeker\",\n      onMessage: (message) => {\n        console.log(\"Understanding received:\", message.data);\n      },\n      onOpen: () => console.log(\"Connection established\"),\n      onClose: () => console.log(\"Connection closed\"),\n    });\n\n\n    const inquire = () => {\n      connection.send(\n        JSON.stringify({\n          type: \"inquiry\",\n          content: \"What insights have you gathered?\",\n        }),\n      );\n    };\n\n\n    return (\n      <div className=\"agent-interface\">\n        <button onClick={inquire}>Seek Understanding</button>\n      </div>\n    );\n  }",
      "language": "js"
    },
    {
      "code": "import { useAgent } from \"agents/react\";\n\n\n  function AgentInterface() {\n    const connection = useAgent({\n      agent: \"dialogue-agent\",\n      name: \"insight-seeker\",\n      onMessage: (message) => {\n        console.log(\"Understanding received:\", message.data);\n      },\n      onOpen: () => console.log(\"Connection established\"),\n      onClose: () => console.log(\"Connection closed\"),\n    });\n\n\n    const inquire = () => {\n      connection.send(\n        JSON.stringify({\n          type: \"inquiry\",\n          content: \"What insights have you gathered?\",\n        })\n      );\n    };\n\n\n    return (\n      <div className=\"agent-interface\">\n        <button onClick={inquire}>Seek Understanding</button>\n      </div>\n    );\n  }",
      "language": "ts"
    },
    {
      "code": "import { Agent, Connection } from \"agents\";\n\n\n  export class ChatAgent extends Agent {\n    // onConnect and onMessage methods\n    // ...\n\n\n    // WebSocket error and disconnection (close) handling.\n    async onError(connection, error) {\n      console.error(`WS error: ${error}`);\n    }\n    async onClose(connection, code, reason, wasClean) {\n      console.log(`WS closed: ${code} - ${reason} - wasClean: ${wasClean}`);\n      connection.close();\n    }\n  }",
      "language": "js"
    },
    {
      "code": "import { Agent, Connection } from \"agents\";\n\n\n  export class ChatAgent extends Agent {\n     // onConnect and onMessage methods\n    // ...\n\n\n    // WebSocket error and disconnection (close) handling.\n    async onError(connection: Connection, error: unknown): Promise<void> {\n      console.error(`WS error: ${error}`);\n    }\n    async onClose(connection: Connection, code: number, reason: string, wasClean: boolean): Promise<void> {\n      console.log(`WS closed: ${code} - ${reason} - wasClean: ${wasClean}`);\n      connection.close();\n    }\n  }",
      "language": "ts"
    },
    {
      "code": "constructor(ctx: DurableObjectState, env: Env) {}",
      "language": "ts"
    },
    {
      "code": "// This instance could've been active, hibernated,\n// not initialized or maybe had never even been created!\nconst stub = env.MY_DO.getByName(\"foo\");\n\n\n// We can call any public method of the class since. The runtime\n// **ensures** the constructor is called for us if the instance wasn't active.\nawait stub.bar();",
      "language": "ts"
    },
    {
      "code": "export class MyDurableObject extends DurableObject {\n  async fetch(request) {\n    // Creates two ends of a WebSocket connection.\n    const webSocketPair = new WebSocketPair();\n    const [client, server] = Object.values(webSocketPair);\n\n\n    // Calling `acceptWebSocket()` connects the WebSocket to the Durable Object, allowing the WebSocket to send and receive messages.\n    this.ctx.acceptWebSocket(server);\n\n\n    return new Response(null, {\n      status: 101,\n      webSocket: client\n    });\n  }\n\n\n  async webSocketMessage(ws, message) {\n    // echo back the messages\n    ws.send(msg);\n  }\n}",
      "language": "ts"
    },
    {
      "code": "const sql = this.ctx.storage.sql;\nconst kv = this.ctx.storage.kv;\n\n\n// An example of a synchronous SQL query\nconst rows = sql.exec(\"SELECT * FROM contacts WHERE country = ?\", \"US\");\n\n\n// And an example of the synchronous KV\nconst token = kv.get(\"someToken\");",
      "language": "ts"
    },
    {
      "code": "// Note the await here!\nconst stub = await getServerByName(env.MY_DO, \"foo\");\n\n\n// We can still call RPC methods.\nawait stub.bar();",
      "language": "ts"
    },
    {
      "code": "async fetch(request: Request, env: Env, ctx: ExecutionContext) {\n    // Behind the scenes, PartyKit normalizes your DO binding names\n    // and tries to do some pattern matching.\n    const res = await routePartykitRequest(request, env);\n\n\n    if (res) return res;\n\n\n    return Response(\"Not found\", { status: 404 });\n  }",
      "language": "ts"
    },
    {
      "code": "class MyServer extends Server {\n  onStart() {\n    // Some initialization logic that you wish\n    // to run every time the DO is started up.\n    const sql = this.ctx.storage.sql;\n    sql.exec(`...`);\n  }\n}",
      "language": "ts"
    },
    {
      "code": "class MyServer extends Server {\n  async onRequest(request: Request) {\n    const url = new URL(request.url);\n\n\n    return new Response(`Hello from ${url.origin}!`);\n  }\n\n\n  async onConnect(conn, ctx) {\n    const { request } = ctx;\n    const url = new URL(request.url);\n\n\n    // Connections are a WebSocket wrapper\n    conn.send(`Hello from ${url.origin}!`);\n  }\n}",
      "language": "ts"
    },
    {
      "code": "class MyAgent extends Agent<Env, { count: number }> {\n  initialState = { count: 0 };\n\n\n  increment() {\n    this.setState({ count: this.state.count + 1 });\n  }\n\n\n  onStateUpdate(state, source) {\n    console.log(\"State updated:\", state);\n  }\n}",
      "language": "ts"
    },
    {
      "code": "class MyAgent extends Agent {\n  onStart() {\n    this.sql`\n      CREATE TABLE IF NOT EXISTS users (\n        id TEXT PRIMARY KEY,\n        name TEXT\n      )\n    `;\n\n\n    const userId = \"1\";\n    const userName = \"Alice\";\n    this.sql`INSERT INTO users (id, name) VALUES (${userId}, ${userName})`;\n\n\n    const users = this.sql<{ id: string; name: string }>`\n      SELECT * FROM users WHERE id = ${userId}\n    `;\n    console.log(users); // [{ id: \"1\", name: \"Alice\" }]\n  }\n}",
      "language": "ts"
    },
    {
      "code": "class MyAgent extends Agent {\n  @callable({ description: \"Add two numbers\" })\n  async add(a: number, b: number) {\n    return a + b;\n  }\n}",
      "language": "ts"
    },
    {
      "code": "{\n  \"type\": \"rpc\",\n  \"id\": \"unique-request-id\",\n  \"method\": \"add\",\n  \"args\": [2, 3]\n}",
      "language": "json"
    },
    {
      "code": "const { stub } = useAgent({ name: \"my-agent\" });\nconst result = await stub.add(2, 3);\nconsole.log(result); // 5",
      "language": "ts"
    },
    {
      "code": "class MyAgent extends Agent {\n  async onConnect() {\n    // Queue a task to be executed later\n    await this.queue(\"processTask\", { userId: \"123\" });\n  }\n\n\n  async processTask(payload: { userId: string }, queueItem: QueueItem) {\n    console.log(\"Processing task for user:\", payload.userId);\n  }\n}",
      "language": "ts"
    },
    {
      "code": "class MyAgent extends Agent {\n  async foo() {\n    // Schedule at a specific time\n    await this.schedule(new Date(\"2025-12-25T00:00:00Z\"), \"sendGreeting\", {\n      message: \"Merry Christmas!\"\n    });\n\n\n    // Schedule with a delay (in seconds)\n    await this.schedule(60, \"checkStatus\", { check: \"health\" });\n\n\n    // Schedule with a cron expression\n    await this.schedule(\"0 0 * * *\", \"dailyTask\", { type: \"cleanup\" });\n  }\n\n\n  async sendGreeting(payload: { message: string }) {\n    console.log(payload.message);\n  }\n\n\n  async checkStatus(payload: { check: string }) {\n    console.log(\"Running check:\", payload.check);\n  }\n\n\n  async dailyTask(payload: { type: string }) {\n    console.log(\"Daily task:\", payload.type);\n  }\n}",
      "language": "ts"
    },
    {
      "code": "class MyAgent extends Agent {\n  async onConnect() {\n    // Add an MCP server\n    await this.addMcpServer(\n      \"GitHub\",\n      \"https://mcp.example.com/sse\",\n      \"https://my-worker.example.workers.dev\", // callback host for OAuth\n      \"agents\" // routing prefix\n    );\n  }\n}",
      "language": "ts"
    },
    {
      "code": "class MyAgent extends Agent {\n  async onEmail(email: AgentEmail) {\n    console.log(\"Received email from:\", email.from);\n    console.log(\"Subject:\", email.headers.get(\"subject\"));\n\n\n    const raw = await email.getRaw();\n    console.log(\"Raw email size:\", raw.length);\n\n\n    // Reply to the email\n    await this.replyToEmail(email, {\n      fromName: \"My Agent\",\n      subject: \"Re: \" + email.headers.get(\"subject\"),\n      body: \"Thanks for your email!\",\n      contentType: \"text/plain\"\n    });\n  }\n}",
      "language": "ts"
    },
    {
      "code": "export default {\n  async email(message, env, ctx) {\n    await routeAgentEmail(message, env, {\n      resolver: createAddressBasedEmailResolver(\"my-agent\")\n    });\n  }\n};",
      "language": "ts"
    },
    {
      "code": "import { getCurrentAgent } from \"agents\";\n\n\nfunction someUtilityFunction() {\n  const { agent, connection, request, email } = getCurrentAgent();\n\n\n  if (agent) {\n    console.log(\"Current agent:\", agent.name);\n  }\n\n\n  if (connection) {\n    console.log(\"WebSocket connection ID:\", connection.id);\n  }\n}",
      "language": "ts"
    },
    {
      "code": "class MyAgent extends Agent {\n  onError(connectionOrError: Connection | unknown, error?: unknown) {\n    if (error) {\n      // WebSocket connection error\n      console.error(\"Connection error:\", error);\n    } else {\n      // Server error\n      console.error(\"Server error:\", connectionOrError);\n    }\n\n\n    // Optionally throw to propagate the error\n    throw connectionOrError;\n  }\n}",
      "language": "ts"
    },
    {
      "code": "class MyAgent extends Agent {\n  async onStart() {\n    console.log(\"Agent is starting up...\");\n    // Initialize your agent\n  }\n\n\n  async cleanup() {\n    // This wipes everything!\n    await this.destroy();\n  }\n}",
      "language": "ts"
    },
    {
      "code": "// Same API as getServerByName\nconst stub = await getAgentByName(env.MY_DO, \"foo\");\n// ...\n\n\n// Same API as routeServerRequest\nconst res = await routeAgentRequest(request, env);\n\n\nif (res) return res;\n\n\nreturn Response(\"Not found\", { status: 404 });",
      "language": "ts"
    },
    {
      "code": "npm install vitest@~3.0.0 --save-dev --save-exact\nnpm install @cloudflare/vitest-pool-workers --save-dev",
      "language": "sh"
    },
    {
      "code": "import { defineWorkersConfig } from \"@cloudflare/vitest-pool-workers/config\";\n\n\nexport default defineWorkersConfig({\n  test: {\n    poolOptions: {\n      workers: {\n        wrangler: { configPath: \"./wrangler.toml\" },\n      },\n    },\n  },\n});",
      "language": "js"
    },
    {
      "code": "import { defineWorkersConfig } from \"@cloudflare/vitest-pool-workers/config\";\n\n\nexport default defineWorkersConfig({\n  test: {\n    poolOptions: {\n      workers: {\n        main: \"./src/index.ts\",\n        miniflare: {\n          durableObjects: {\n            NAME: \"MyAgent\",\n          },\n        },\n      },\n    },\n  },\n});",
      "language": "js"
    },
    {
      "code": "import {\n  env,\n  createExecutionContext,\n  waitOnExecutionContext,\n  SELF,\n} from \"cloudflare:test\";\nimport { describe, it, expect } from \"vitest\";\nimport worker from \"../src\";\nimport { Env } from \"../src\";\n\n\ninterface ProvidedEnv extends Env {}\n\n\ndescribe(\"make a request to my Agent\", () => {\n  // Unit testing approach\n  it(\"responds with state\", async () => {\n    // Provide a valid URL that your Worker can use to route to your Agent\n    // If you are using routeAgentRequest, this will be /agent/:agent/:name\n    const request = new Request<unknown, IncomingRequestCfProperties>(\n      \"http://example.com/agent/my-agent/agent-123\",\n    );\n    const ctx = createExecutionContext();\n    const response = await worker.fetch(request, env, ctx);\n    await waitOnExecutionContext(ctx);\n    expect(await response.text()).toMatchObject({ hello: \"from your agent\" });\n  });\n\n\n  it(\"also responds with state\", async () => {\n    const request = new Request(\"http://example.com/agent/my-agent/agent-123\");\n    const response = await SELF.fetch(request);\n    expect(await response.text()).toMatchObject({ hello: \"from your agent\" });\n  });\n});",
      "language": "ts"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "2025-02-11",
      "id": "2025-02-11"
    },
    {
      "level": "h2",
      "text": "2024-12-16",
      "id": "2024-12-16"
    },
    {
      "level": "h2",
      "text": "2024-11-12",
      "id": "2024-11-12"
    },
    {
      "level": "h2",
      "text": "2024-09-17",
      "id": "2024-09-17"
    },
    {
      "level": "h2",
      "text": "2024-08-23",
      "id": "2024-08-23"
    },
    {
      "level": "h2",
      "text": "2024-08-15",
      "id": "2024-08-15"
    },
    {
      "level": "h2",
      "text": "2024-08-12",
      "id": "2024-08-12"
    },
    {
      "level": "h2",
      "text": "2024-07-23",
      "id": "2024-07-23"
    },
    {
      "level": "h2",
      "text": "2024-06-21",
      "id": "2024-06-21"
    },
    {
      "level": "h2",
      "text": "2024-06-18",
      "id": "2024-06-18"
    },
    {
      "level": "h2",
      "text": "2024-05-03",
      "id": "2024-05-03"
    },
    {
      "level": "h2",
      "text": "2024-04-19",
      "id": "2024-04-19"
    },
    {
      "level": "h2",
      "text": "2024-04-08",
      "id": "2024-04-08"
    },
    {
      "level": "h2",
      "text": "2024-02-15",
      "id": "2024-02-15"
    },
    {
      "level": "h2",
      "text": "2024-02-05",
      "id": "2024-02-05"
    },
    {
      "level": "h2",
      "text": "2023-12-19",
      "id": "2023-12-19"
    },
    {
      "level": "h2",
      "text": "2023-11-13",
      "id": "2023-11-13"
    },
    {
      "level": "h2",
      "text": "2023-10-31",
      "id": "2023-10-31"
    },
    {
      "level": "h2",
      "text": "2023-10-26",
      "id": "2023-10-26"
    },
    {
      "level": "h2",
      "text": "2023-10-20",
      "id": "2023-10-20"
    },
    {
      "level": "h2",
      "text": "2023-10-03",
      "id": "2023-10-03"
    },
    {
      "level": "h2",
      "text": "2023-09-13",
      "id": "2023-09-13"
    },
    {
      "level": "h2",
      "text": "2023-09-11",
      "id": "2023-09-11"
    },
    {
      "level": "h2",
      "text": "2023-09-06",
      "id": "2023-09-06"
    },
    {
      "level": "h2",
      "text": "2023-09-05",
      "id": "2023-09-05"
    },
    {
      "level": "h2",
      "text": "2023-08-21",
      "id": "2023-08-21"
    },
    {
      "level": "h2",
      "text": "Crucial vocabulary",
      "id": "crucial-vocabulary"
    },
    {
      "level": "h2",
      "text": "Purposes and tools",
      "id": "purposes-and-tools"
    },
    {
      "level": "h2",
      "text": "Important things to note",
      "id": "important-things-to-note"
    },
    {
      "level": "h2",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h3",
      "text": "X (Twitter) embed",
      "id": "x-(twitter)-embed"
    },
    {
      "level": "h3",
      "text": "Instagram embed",
      "id": "instagram-embed"
    },
    {
      "level": "h2",
      "text": "General",
      "id": "general"
    },
    {
      "level": "h3",
      "text": "Setting up Zaraz",
      "id": "setting-up-zaraz"
    },
    {
      "level": "h3",
      "text": "Zaraz Web API",
      "id": "zaraz-web-api"
    },
    {
      "level": "h2",
      "text": "Tools",
      "id": "tools"
    },
    {
      "level": "h3",
      "text": "Google Analytics",
      "id": "google-analytics"
    },
    {
      "level": "h3",
      "text": "Facebook Pixel",
      "id": "facebook-pixel"
    },
    {
      "level": "h3",
      "text": "Google Ads",
      "id": "google-ads"
    },
    {
      "level": "h3",
      "text": "Custom HTML",
      "id": "custom-html"
    },
    {
      "level": "h3",
      "text": "Other tools",
      "id": "other-tools"
    },
    {
      "level": "h2",
      "text": "Consent",
      "id": "consent"
    },
    {
      "level": "h3",
      "text": "How do I show the consent modal again to all users?",
      "id": "how-do-i-show-the-consent-modal-again-to-all-users?"
    },
    {
      "level": "h2",
      "text": "Add a third-party tool to your website",
      "id": "add-a-third-party-tool-to-your-website"
    },
    {
      "level": "h2",
      "text": "Events, triggers and actions",
      "id": "events,-triggers-and-actions"
    },
    {
      "level": "h2",
      "text": "Web API",
      "id": "web-api"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h2",
      "text": "Platform plugins",
      "id": "platform-plugins"
    },
    {
      "level": "h3",
      "text": "WooCommerce",
      "id": "woocommerce"
    },
    {
      "level": "h2",
      "text": "Footnotes",
      "id": "footnotes"
    },
    {
      "level": "h2",
      "text": "Configure the API endpoint",
      "id": "configure-the-api-endpoint"
    },
    {
      "level": "h2",
      "text": "Send events",
      "id": "send-events"
    },
    {
      "level": "h3",
      "text": "The `system` key",
      "id": "the-`system`-key"
    },
    {
      "level": "h2",
      "text": "Process API responses",
      "id": "process-api-responses"
    },
    {
      "level": "h2",
      "text": "Zaraz Monitoring options",
      "id": "zaraz-monitoring-options"
    },
    {
      "level": "h2",
      "text": "The Zaraz Event unit",
      "id": "the-zaraz-event-unit"
    },
    {
      "level": "h2",
      "text": "Enabling Zaraz Paid",
      "id": "enabling-zaraz-paid"
    },
    {
      "level": "h2",
      "text": "Using Zaraz Free",
      "id": "using-zaraz-free"
    },
    {
      "level": "h2",
      "text": "Create a function",
      "id": "create-a-function"
    },
    {
      "level": "h2",
      "text": "Using 1.1.1.1",
      "id": "using-1.1.1.1"
    },
    {
      "level": "h2",
      "text": "Perform DNS lookups",
      "id": "perform-dns-lookups"
    },
    {
      "level": "h3",
      "text": "Supported record types",
      "id": "supported-record-types"
    },
    {
      "level": "h3",
      "text": "Short form response",
      "id": "short-form-response"
    },
    {
      "level": "h3",
      "text": "Disable DNSSEC checking",
      "id": "disable-dnssec-checking"
    },
    {
      "level": "h3",
      "text": "Refreshing existing results",
      "id": "refreshing-existing-results"
    },
    {
      "level": "h3",
      "text": "Changing DNS provider",
      "id": "changing-dns-provider"
    },
    {
      "level": "h2",
      "text": "`multi-dig` command",
      "id": "`multi-dig`-command"
    },
    {
      "level": "h3",
      "text": "Supported record types",
      "id": "supported-record-types"
    },
    {
      "level": "h3",
      "text": "Short form response",
      "id": "short-form-response"
    },
    {
      "level": "h3",
      "text": "Disable DNSSEC checking",
      "id": "disable-dnssec-checking"
    },
    {
      "level": "h3",
      "text": "Refreshing existing results",
      "id": "refreshing-existing-results"
    },
    {
      "level": "h3",
      "text": "Changing DNS provider",
      "id": "changing-dns-provider"
    },
    {
      "level": "h2",
      "text": "`whois` command",
      "id": "`whois`-command"
    },
    {
      "level": "h2",
      "text": "Other commands",
      "id": "other-commands"
    },
    {
      "level": "h3",
      "text": "`help` command",
      "id": "`help`-command"
    },
    {
      "level": "h3",
      "text": "`privacy` command",
      "id": "`privacy`-command"
    },
    {
      "level": "h3",
      "text": "`terms` command",
      "id": "`terms`-command"
    },
    {
      "level": "h3",
      "text": "`github` command",
      "id": "`github`-command"
    },
    {
      "level": "h3",
      "text": "`invite` command",
      "id": "`invite`-command"
    },
    {
      "level": "h2",
      "text": "Development",
      "id": "development"
    },
    {
      "level": "h2",
      "text": "Setting up a Tor client",
      "id": "setting-up-a-tor-client"
    },
    {
      "level": "h2",
      "text": "Setting up a local DNS proxy using socat",
      "id": "setting-up-a-local-dns-proxy-using-socat"
    },
    {
      "level": "h3",
      "text": "DNS over TCP, TLS, and HTTPS",
      "id": "dns-over-tcp,-tls,-and-https"
    },
    {
      "level": "h3",
      "text": "DNS over HTTPS",
      "id": "dns-over-https"
    },
    {
      "level": "h2",
      "text": "How it works",
      "id": "how-it-works"
    },
    {
      "level": "h2",
      "text": "Example",
      "id": "example"
    },
    {
      "level": "h2",
      "text": "Supported TLS versions",
      "id": "supported-tls-versions"
    },
    {
      "level": "h2",
      "text": "How ODoH works",
      "id": "how-odoh-works"
    },
    {
      "level": "h2",
      "text": "Cloudflare and third-party products",
      "id": "cloudflare-and-third-party-products"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Configure DNS64",
      "id": "configure-dns64"
    },
    {
      "level": "h2",
      "text": "Test DNS64",
      "id": "test-dns64"
    },
    {
      "level": "h2",
      "text": "Configuring 1.1.1.1",
      "id": "configuring-1.1.1.1"
    },
    {
      "level": "h2",
      "text": "Available Endpoints",
      "id": "available-endpoints"
    },
    {
      "level": "h2",
      "text": "Rate Limiting",
      "id": "rate-limiting"
    },
    {
      "level": "h2",
      "text": "Help",
      "id": "help"
    },
    {
      "level": "h2",
      "text": "Cloudflare’s commitment to privacy: 1.1.1.1 Public DNS Resolver",
      "id": "cloudflare’s-commitment-to-privacy:-1.1.1.1-public-dns-resolver"
    },
    {
      "level": "h2",
      "text": "Limited data sharing with APNIC",
      "id": "limited-data-sharing-with-apnic"
    },
    {
      "level": "h2",
      "text": "Data in public resolver logs",
      "id": "data-in-public-resolver-logs"
    },
    {
      "level": "h2",
      "text": "What about requests for content blocking?",
      "id": "what-about-requests-for-content-blocking?"
    },
    {
      "level": "h2",
      "text": "Frequently asked questions about the Cloudflare resolver for Firefox",
      "id": "frequently-asked-questions-about-the-cloudflare-resolver-for-firefox"
    },
    {
      "level": "h3",
      "text": "What is the Cloudflare resolver for Firefox?",
      "id": "what-is-the-cloudflare-resolver-for-firefox?"
    },
    {
      "level": "h3",
      "text": "What information does the Cloudflare resolver for Firefox collect?",
      "id": "what-information-does-the-cloudflare-resolver-for-firefox-collect?"
    },
    {
      "level": "h3",
      "text": "What is the Cloudflare promise?",
      "id": "what-is-the-cloudflare-promise?"
    },
    {
      "level": "h3",
      "text": "What about government requests for content blocking?",
      "id": "what-about-government-requests-for-content-blocking?"
    },
    {
      "level": "h2",
      "text": "Set up 1.1.1.1: Faster Internet",
      "id": "set-up-1.1.1.1:-faster-internet"
    },
    {
      "level": "h3",
      "text": "Enable 1.1.1.1 for Families",
      "id": "enable-1.1.1.1-for-families"
    },
    {
      "level": "h2",
      "text": "Configure 1.1.1.1 manually",
      "id": "configure-1.1.1.1-manually"
    },
    {
      "level": "h3",
      "text": "Android 11 or later",
      "id": "android-11-or-later"
    },
    {
      "level": "h3",
      "text": "Android 9 or 10",
      "id": "android-9-or-10"
    },
    {
      "level": "h3",
      "text": "Previous Android versions",
      "id": "previous-android-versions"
    },
    {
      "level": "h2",
      "text": "PS4",
      "id": "ps4"
    },
    {
      "level": "h2",
      "text": "Xbox One",
      "id": "xbox-one"
    },
    {
      "level": "h2",
      "text": "Nintendo",
      "id": "nintendo"
    },
    {
      "level": "h2",
      "text": "Nintendo Switch",
      "id": "nintendo-switch"
    },
    {
      "level": "h2",
      "text": "Set up 1.1.1.1: Faster Internet",
      "id": "set-up-1.1.1.1:-faster-internet"
    },
    {
      "level": "h3",
      "text": "Enable 1.1.1.1 for Families",
      "id": "enable-1.1.1.1-for-families"
    },
    {
      "level": "h2",
      "text": "Configure 1.1.1.1 manually",
      "id": "configure-1.1.1.1-manually"
    },
    {
      "level": "h2",
      "text": "Use command line interface (CLI)",
      "id": "use-command-line-interface-(cli)"
    },
    {
      "level": "h3",
      "text": "`resolv.conf`",
      "id": "`resolv.conf`"
    },
    {
      "level": "h3",
      "text": "`systemd-resolved`",
      "id": "`systemd-resolved`"
    },
    {
      "level": "h2",
      "text": "Use graphical user interface (GUI)",
      "id": "use-graphical-user-interface-(gui)"
    },
    {
      "level": "h3",
      "text": "GNOME",
      "id": "gnome"
    },
    {
      "level": "h3",
      "text": "KDE Plasma",
      "id": "kde-plasma"
    },
    {
      "level": "h2",
      "text": "Encrypt your DNS queries",
      "id": "encrypt-your-dns-queries"
    },
    {
      "level": "h2",
      "text": "Using DNS-Over-TLS on OpenWrt",
      "id": "using-dns-over-tls-on-openwrt"
    },
    {
      "level": "h2",
      "text": "FRITZ!Box",
      "id": "fritz!box"
    },
    {
      "level": "h2",
      "text": "Windows 10",
      "id": "windows-10"
    },
    {
      "level": "h2",
      "text": "Windows 11",
      "id": "windows-11"
    },
    {
      "level": "h2",
      "text": "Encrypt your DNS queries",
      "id": "encrypt-your-dns-queries"
    },
    {
      "level": "h3",
      "text": "Agent class API",
      "id": "agent-class-api"
    },
    {
      "level": "h3",
      "text": "WebSocket API",
      "id": "websocket-api"
    },
    {
      "level": "h3",
      "text": "State synchronization API",
      "id": "state-synchronization-api"
    },
    {
      "level": "h3",
      "text": "Scheduling API",
      "id": "scheduling-api"
    },
    {
      "level": "h3",
      "text": "SQL API",
      "id": "sql-api"
    },
    {
      "level": "h3",
      "text": "MCP Client API",
      "id": "mcp-client-api"
    },
    {
      "level": "h3",
      "text": "Client API",
      "id": "client-api"
    },
    {
      "level": "h3",
      "text": "React API",
      "id": "react-api"
    },
    {
      "level": "h3",
      "text": "Chat Agent",
      "id": "chat-agent"
    },
    {
      "level": "h3",
      "text": "Chat Agent React API",
      "id": "chat-agent-react-api"
    },
    {
      "level": "h3",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h3",
      "text": "Browser Rendering API",
      "id": "browser-rendering-api"
    },
    {
      "level": "h3",
      "text": "Browserbase",
      "id": "browserbase"
    },
    {
      "level": "h3",
      "text": "Calling your Agent",
      "id": "calling-your-agent"
    },
    {
      "level": "h3",
      "text": "Calling methods on Agents",
      "id": "calling-methods-on-agents"
    },
    {
      "level": "h3",
      "text": "Naming your Agents",
      "id": "naming-your-agents"
    },
    {
      "level": "h3",
      "text": "Authenticating Agents",
      "id": "authenticating-agents"
    },
    {
      "level": "h3",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h3",
      "text": "Project structure",
      "id": "project-structure"
    },
    {
      "level": "h3",
      "text": "Example configuration",
      "id": "example-configuration"
    },
    {
      "level": "h3",
      "text": "Handling HTTP requests",
      "id": "handling-http-requests"
    },
    {
      "level": "h3",
      "text": "Implementing Server-Sent Events",
      "id": "implementing-server-sent-events"
    },
    {
      "level": "h3",
      "text": "WebSockets vs. Server-Sent Events",
      "id": "websockets-vs.-server-sent-events"
    },
    {
      "level": "h3",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h3",
      "text": "Vector search",
      "id": "vector-search"
    },
    {
      "level": "h2",
      "text": "Trigger a Workflow",
      "id": "trigger-a-workflow"
    },
    {
      "level": "h2",
      "text": "Trigger a Workflow from another project",
      "id": "trigger-a-workflow-from-another-project"
    },
    {
      "level": "h3",
      "text": "Scheduling tasks",
      "id": "scheduling-tasks"
    },
    {
      "level": "h3",
      "text": "Managing scheduled tasks",
      "id": "managing-scheduled-tasks"
    },
    {
      "level": "h3",
      "text": "Set the initial state for an Agent",
      "id": "set-the-initial-state-for-an-agent"
    },
    {
      "level": "h3",
      "text": "Synchronizing state",
      "id": "synchronizing-state"
    },
    {
      "level": "h3",
      "text": "SQL API",
      "id": "sql-api"
    },
    {
      "level": "h3",
      "text": "Use Agent state as model context",
      "id": "use-agent-state-as-model-context"
    },
    {
      "level": "h3",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Calling AI Models",
      "id": "calling-ai-models"
    },
    {
      "level": "h3",
      "text": "Long-running model requests",
      "id": "long-running-model-requests"
    },
    {
      "level": "h3",
      "text": "Workers AI",
      "id": "workers-ai"
    },
    {
      "level": "h3",
      "text": "Hosted models",
      "id": "hosted-models"
    },
    {
      "level": "h3",
      "text": "Model routing",
      "id": "model-routing"
    },
    {
      "level": "h3",
      "text": "AI SDK",
      "id": "ai-sdk"
    },
    {
      "level": "h3",
      "text": "OpenAI compatible endpoints",
      "id": "openai-compatible-endpoints"
    },
    {
      "level": "h3",
      "text": "Connecting clients",
      "id": "connecting-clients"
    },
    {
      "level": "h3",
      "text": "React clients",
      "id": "react-clients"
    },
    {
      "level": "h3",
      "text": "Handling WebSocket events",
      "id": "handling-websocket-events"
    },
    {
      "level": "h2",
      "text": "What is the Agent?",
      "id": "what-is-the-agent?"
    },
    {
      "level": "h2",
      "text": "Layer 0: Durable Object",
      "id": "layer-0:-durable-object"
    },
    {
      "level": "h3",
      "text": "`constructor`",
      "id": "`constructor`"
    },
    {
      "level": "h3",
      "text": "RPC",
      "id": "rpc"
    },
    {
      "level": "h3",
      "text": "`fetch()`",
      "id": "`fetch()`"
    },
    {
      "level": "h3",
      "text": "WebSockets",
      "id": "websockets"
    },
    {
      "level": "h3",
      "text": "`alarm()`",
      "id": "`alarm()`"
    },
    {
      "level": "h3",
      "text": "`this.ctx`",
      "id": "`this.ctx`"
    },
    {
      "level": "h3",
      "text": "`this.ctx.storage`",
      "id": "`this.ctx.storage`"
    },
    {
      "level": "h3",
      "text": "`this.ctx.env`",
      "id": "`this.ctx.env`"
    },
    {
      "level": "h2",
      "text": "Layer 1: Partykit `Server`",
      "id": "layer-1:-partykit-`server`"
    },
    {
      "level": "h3",
      "text": "Addressing",
      "id": "addressing"
    },
    {
      "level": "h3",
      "text": "`onStart`",
      "id": "`onstart`"
    },
    {
      "level": "h3",
      "text": "`onRequest` and `onConnect`",
      "id": "`onrequest`-and-`onconnect`"
    },
    {
      "level": "h3",
      "text": "WebSockets",
      "id": "websockets"
    },
    {
      "level": "h3",
      "text": "`this.name`",
      "id": "`this.name`"
    },
    {
      "level": "h2",
      "text": "Layer 2: Agent",
      "id": "layer-2:-agent"
    },
    {
      "level": "h3",
      "text": "`this.state` and `this.setState()`",
      "id": "`this.state`-and-`this.setstate()`"
    },
    {
      "level": "h3",
      "text": "`this.sql`",
      "id": "`this.sql`"
    },
    {
      "level": "h3",
      "text": "RPC and Callable Methods",
      "id": "rpc-and-callable-methods"
    },
    {
      "level": "h3",
      "text": "`this.queue` and friends",
      "id": "`this.queue`-and-friends"
    },
    {
      "level": "h3",
      "text": "`this.schedule` and friends",
      "id": "`this.schedule`-and-friends"
    },
    {
      "level": "h3",
      "text": "`this.mcp` and friends",
      "id": "`this.mcp`-and-friends"
    },
    {
      "level": "h3",
      "text": "Email Handling",
      "id": "email-handling"
    },
    {
      "level": "h3",
      "text": "Context Management",
      "id": "context-management"
    },
    {
      "level": "h3",
      "text": "`this.onError`",
      "id": "`this.onerror`"
    },
    {
      "level": "h3",
      "text": "`this.destroy`",
      "id": "`this.destroy`"
    },
    {
      "level": "h3",
      "text": "Routing",
      "id": "routing"
    },
    {
      "level": "h3",
      "text": "Understanding LLM providers and model types",
      "id": "understanding-llm-providers-and-model-types"
    },
    {
      "level": "h3",
      "text": "What is Human-in-the-Loop?",
      "id": "what-is-human-in-the-loop?"
    },
    {
      "level": "h3",
      "text": "Best practices for Human-in-the-Loop workflows",
      "id": "best-practices-for-human-in-the-loop-workflows"
    },
    {
      "level": "h3",
      "text": "What are tools?",
      "id": "what-are-tools?"
    },
    {
      "level": "h3",
      "text": "Understanding tools",
      "id": "understanding-tools"
    },
    {
      "level": "h3",
      "text": "Common tool patterns",
      "id": "common-tool-patterns"
    },
    {
      "level": "h3",
      "text": "What are agents?",
      "id": "what-are-agents?"
    },
    {
      "level": "h3",
      "text": "Example: Booking vacations",
      "id": "example:-booking-vacations"
    },
    {
      "level": "h3",
      "text": "Three primary components of agent systems:",
      "id": "three-primary-components-of-agent-systems:"
    },
    {
      "level": "h2",
      "text": "What are workflows?",
      "id": "what-are-workflows?"
    },
    {
      "level": "h3",
      "text": "Understanding workflows in agent systems",
      "id": "understanding-workflows-in-agent-systems"
    },
    {
      "level": "h3",
      "text": "Core components of a workflow",
      "id": "core-components-of-a-workflow"
    },
    {
      "level": "h2",
      "text": "Writing and running tests",
      "id": "writing-and-running-tests"
    },
    {
      "level": "h3",
      "text": "Setup",
      "id": "setup"
    },
    {
      "level": "h3",
      "text": "Add the Agent configuration",
      "id": "add-the-agent-configuration"
    },
    {
      "level": "h3",
      "text": "Write a test",
      "id": "write-a-test"
    },
    {
      "level": "h3",
      "text": "Run tests",
      "id": "run-tests"
    }
  ],
  "url": "llms-txt#404",
  "links": []
}