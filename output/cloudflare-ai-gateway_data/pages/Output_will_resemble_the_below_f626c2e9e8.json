{
  "title": "Output will resemble the below:",
  "content": "Total Upload: 259.61 KiB / gzip: 47.23 KiB\ntxt\n((Number of Messages * 3) - 1,000,000) / 1,000,000  * $0.40\njs\nlet durableObjectStub = OBJECT_NAMESPACE.get(id); // retrieve Durable Object stub\nusing foo = await durableObjectStub.bar(); // billed as a request\nawait foo.baz(); // treated as part of the same RPC session created by calling bar(), not billed as a request\nawait durableObjectStub.cat(); // billed as a request\nmermaid\nflowchart TD\naccTitle: Single file purge  assets cached by a worker\naccDescr: This diagram is meant to help choose how to purge a file.\nA(\"You have a Worker script that runs on <code>https://</code><code>example.com/hello</code> <br> and this Worker makes a <code>fetch</code> request to <code>https://</code><code>notexample.com/hello</code>.\") --> B(Is <code>notexample.com</code> <br> an active zone on Cloudflare?)\n    B -- Yes --> C(Is <code>https://</code><code>notexample.com/</code> <br> proxied through Cloudflare?)\n    B -- No  --> D(Purge <code>https://</code><code>notexample.com/hello</code> <br> from the original <code>example.com</code> zone.)\n    C -- Yes --> E(Do you own <br> <code>notexample.com</code>?)\n    C -- No --> F(Purge <code>https://</code><code>notexample.com/hello</code> <br> from the original <code>example.com</code> zone.)\n    E -- Yes --> G(Purge <code>https://</code><code>notexample.com/hello</code> <br> from the <code>notexample.com</code> zone.)\n    E -- No --> H(Sorry, you can not purge the asset. <br> Only the owner of <code>notexample.com</code> can purge it.)\njs\n  export default {\n    async fetch(request, env, ctx) {\n      return new Response('Hello World!');\n    },\n  };\n  ts\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      return new Response('Hello World!');\n    },\n  } satisfies ExportedHandler<Env>;\n  js\nasync function handler(request) {\n  const base = 'https://example.com';\n  const statusCode = 301;\n\nconst destination = new URL(request.url, base);\n  return Response.redirect(destination.toString(), statusCode);\n}\n\n// Initialize Worker\naddEventListener('fetch', event => {\n  event.respondWith(handler(event.request));\n});\njs\nexport default {\n  fetch(request) {\n    const base = \"https://example.com\";\n    const statusCode = 301;\n\nconst source = new URL(request.url);\n    const destination = new URL(source.pathname, base);\n    return Response.redirect(destination.toString(), statusCode);\n  },\n};\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"kv_namespaces\": [\n      {\n        \"binding\": \"TODO\",\n        \"id\": \"<ID>\"\n      }\n    ]\n  }\n  toml\n  kv_namespaces = [\n    { binding = \"TODO\", id = \"<ID>\" }\n  ]\n  js\naddEventListener(\"fetch\", async (event) => {\n  return await getTodos()\n});\n\nasync function getTodos() {\n  // Get the value for the \"to-do:123\" key\n  // NOTE: Relies on the TODO KV binding that maps to the \"My Tasks\" namespace.\n  let value = await TODO.get(\"to-do:123\");\n\n// Return the value, as is, for the Response\n  event.respondWith(new Response(value));\n}\njs\nimport { getTodos } from './todos'\n\nexport default {\n  async fetch(request, env, ctx) {\n    // Passing the env parameter so other functions\n    // can reference the bindings available in the Workers application\n    return await getTodos(env)\n  },\n};\njs\nasync function getTodos(env) {\n  // NOTE: Relies on the TODO KV binding which has been provided inside of\n  // the env parameter of the `getTodos` function\n  let value = await env.TODO.get(\"to-do:123\");\n  return new Response(value);\n}\n\nexport { getTodos }\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"my-worker-dev\",\n    \"vars\": {\n      \"API_ACCOUNT_ID\": \"<EXAMPLE-ACCOUNT-ID>\"\n    }\n  }\n  toml\n  name = \"my-worker-dev\"\n\n# Define top-level environment variables\n  # under the `[vars]` block using\n  # the `key = \"value\"` format\n  [vars]\n  API_ACCOUNT_ID = \"<EXAMPLE-ACCOUNT-ID>\"\n  js\naddEventListener(\"fetch\", async (event) => {\n  console.log(API_ACCOUNT_ID) // Logs \"<EXAMPLE-ACCOUNT-ID>\"\n  return new Response(\"Hello, world!\")\n})\njs\nexport default {\n  async fetch(request, env, ctx) {\n    console.log(env.API_ACCOUNT_ID) // Logs \"<EXAMPLE-ACCOUNT-ID>\"\n    return new Response(\"Hello, world!\")\n  },\n};\njs\n  import { env } from \"cloudflare:workers\";\n\n// Access environment variables at the top level\n  const accountId = env.API_ACCOUNT_ID;\n\nexport default {\n    async fetch(request) {\n      console.log(accountId); // Logs \"<EXAMPLE-ACCOUNT-ID>\"\n      return new Response(\"Hello, world!\");\n    },\n  };\n  ts\n  import { env } from \"cloudflare:workers\";\n\n// Access environment variables at the top level\n  const accountId = env.API_ACCOUNT_ID;\n\nexport default {\n    async fetch(request: Request): Promise<Response> {\n      console.log(accountId) // Logs \"<EXAMPLE-ACCOUNT-ID>\"\n      return new Response(\"Hello, world!\")\n    },\n  };\n  js\naddEventListener(\"scheduled\", (event) => {\n  // ...\n});\njs\nexport default {\n  async scheduled(event, env, ctx) {\n    // ...\n  },\n};\njs\nasync function triggerEvent(event) {\n  // Fetch some data\n  console.log('cron processed', event.scheduledTime);\n}\n\n// Initialize Worker\naddEventListener('scheduled', event => {\n  event.waitUntil(triggerEvent(event));\n});\njs\nasync function triggerEvent(event) {\n  // Fetch some data\n  console.log('cron processed', event.scheduledTime);\n}\n\nexport default {\n  async scheduled(event, env, ctx) {\n    ctx.waitUntil(triggerEvent(event));\n  },\n};\njs\naddEventListener('fetch', event => {\n  event.respondWith(handleRequest(event.request));\n});\n\nasync function handleRequest(request) {\n  return new Response('Hello worker!', {\n    headers: { 'content-type': 'text/plain' },\n  });\n}\njs\n// Format: Service Worker\naddEventListener('fetch', event => {\n  let { pathname } = new URL(event.request.url);\n\n// Allow \"/ignore/*\" URLs to hit origin\n  if (pathname.startsWith('/ignore/')) return;\n\n// Otherwise, respond with something\n  event.respondWith(handler(event));\n});\njs\n// Format: Service Worker\naddEventListener('fetch', event => {\n  event.respondWith(handler(event));\n});\n\nasync function handler(event) {\n  // Forward / Proxy original request\n  let res = await fetch(event.request);\n\n// Add custom header(s)\n  res = new Response(res.body, res);\n  res.headers.set('x-foo', 'bar');\n\n// Cache the response\n  // NOTE: Does NOT block / wait\n  event.waitUntil(caches.default.put(event.request, res.clone()));\n\n// Done\n  return res;\n}\njs\n// Format: Service Worker\naddEventListener('fetch', event => {\n  // Proxy to origin on unhandled/uncaught exceptions\n  event.passThroughOnException();\n  throw new Error('Oops');\n});\njs\nlet start = Date.now();\nfor (let i = 0; i < 1e6; i++) {\n  doSpectreAttack();\n}\nlet end = Date.now();\njs\nlet cache = caches.default;\nawait cache.match(request);\njs\nlet myCache = await caches.open('custom:cache');\nawait myCache.match(request);\njs\n// recommended approach: use your Worker hostname to ensure efficient caching\nrequest.url = \"https://your-Worker-hostname.com/\";\n\nlet myCache = await caches.open('custom:cache');\nlet response = await myCache.match(request);\njs\ncache.put(request, response);\njs\ncache.match(request, options);\njs\ncache.delete(request, options);\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"main\": \"./src/index.js\",\n    \"r2_buckets\": [\n      {\n        \"binding\": \"MY_BUCKET\",\n        \"bucket_name\": \"<MY_BUCKET_NAME>\"\n      }\n    ]\n  }\n  toml\n  main = \"./src/index.js\"\n  r2_buckets = [\n    { binding = \"MY_BUCKET\", bucket_name = \"<MY_BUCKET_NAME>\" }\n  ]\n  js\nexport default {\n  async fetch(request, env) {\n    const key = url.pathname.slice(1);\n    await env.MY_BUCKET.put(key, request.body);\n    return new Response(`Put ${key} successfully!`);\n  },\n};\nts\nexport default {\n  fetch(request, env) {\n    let client = new Client(env.MY_SECRET); // `client` is guaranteed to be up-to-date with the latest value of `env.MY_SECRET` since a new instance is constructed with every incoming request\n\n// ... do things with `client`\n  },\n};\nts\nlet client = undefined;\n\nexport default {\n  fetch(request, env) {\n    client ??= new Client(env.MY_SECRET); // `client` here might not be updated when `env.MY_SECRET` changes, since it may already exist in global scope\n\n// ... do things with `client`\n  },\n};\njs\n  export default {\n    async fetch(request, env) {\n      return new Response(`Hi, ${env.NAME}`);\n    },\n  };\n  js\n  export class MyDurableObject extends DurableObject {\n    async sayHello() {\n      return `Hi, ${this.env.NAME}!`;\n    }\n  }\n  js\n  import { env } from \"cloudflare:workers\";\n  console.log(`Hi, ${env.Name}`);\n  js\nimport { env } from \"cloudflare:workers\";\nimport ApiClient from \"example-api-client\";\n\n// API_KEY and LOG_LEVEL now usable in top-level scope\nlet apiClient = ApiClient.new({ apiKey: env.API_KEY });\nconst LOG_LEVEL = env.LOG_LEVEL || \"info\";\n\nexport default {\n  fetch(req) {\n    // you can use apiClient or LOG_LEVEL, configured before any request is handled\n  },\n};\njs\nimport { env } from \"cloudflare:workers\";\n\n// This would error!\n// env.KV.get('my-key')\n\nexport default {\n  async fetch(req) {\n    // This works\n    let myVal = await env.KV.get(\"my-key\");\n    Response.new(myVal);\n  },\n};\njs\nimport { env } from \"cloudflare:workers\";\n\nexport default {\n  fetch(req) {\n    Response.new(sayHello());\n  },\n};\n\n// env is not an argument to sayHello...\nfunction sayHello() {\n  let myName = getName();\n  return `Hello, ${myName}`;\n}\n\n// ...nor is it an argument to getName\nfunction getName() {\n  return env.MY_NAME;\n}\njs\nimport { env, withEnv } from \"cloudflare:workers\";\n\nfunction logName() {\n  console.log(env.NAME);\n}\n\nexport default {\n  fetch(req) {\n    // this will log \"Alice\"\n    logName();\n\nwithEnv({ NAME: \"Bob\" }, () => {\n      // this will log \"Bob\"\n      logName();\n    });\n\n// ...etc...\n  },\n};\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"services\": [\n      {\n        \"binding\": \"DOC_SERVICE\",\n        \"service\": \"doc-worker\",\n        \"entrypoint\": \"DocServiceApi\",\n        \"props\": {\n          \"clientId\": \"frontend-worker\",\n          \"permissions\": [\n            \"read\",\n            \"write\"\n          ]\n        }\n      }\n    ]\n  }\n  toml\n  [[services]]\n  binding = \"DOC_SERVICE\"\n  service = \"doc-worker\"\n  entrypoint = \"DocServiceApi\"\n  props = { clientId = \"frontend-worker\", permissions = [\"read\", \"write\"] }\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"services\": [\n      {\n        \"binding\": \"FOO_DOCUMENT\",\n        \"service\": \"doc-worker\",\n        \"entrypoint\": \"DocumentApi\",\n        \"props\": {\n          \"docId\": \"e366592caec1d88dff724f74136b58b5\",\n          \"permissions\": [\n            \"read\",\n            \"write\"\n          ]\n        }\n      }\n    ]\n  }\n  toml\n  [[services]]\n  binding = \"FOO_DOCUMENT\"\n  service = \"doc-worker\"\n  entrypoint = \"DocumentApi\"\n  props = { docId = \"e366592caec1d88dff724f74136b58b5\", permissions = [\"read\", \"write\"] }\n  js\nimport { WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport class Greeter extends WorkerEntrypoint {\n  greet(name) {\n    return `Hello, ${name}!`;\n  }\n}\n\nexport default {\n  async fetch(request, env, ctx) {\n    let greeting = await ctx.exports.Greeter.greet(\"World\")\n    return new Response(greeting);\n  }\n}\njs\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport class Greeter extends WorkerEntrypoint {\n    greet(name) {\n      return `${this.ctx.props.greeting}, ${name}!`;\n    }\n  }\n\nexport default {\n    async fetch(request, env, ctx) {\n      // Make a custom greeter that uses the greeting \"Welcome\".\n      let greeter = ctx.exports.Greeter({props: {greeting: \"Welcome\"}})\n\n// Greet the world. Returns \"Welcome, World!\"\n      let greeting = await greeter.greet(\"World\")\n\nreturn new Response(greeting);\n    }\n  }\n  ts\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\ntype Props = {\n    greeting: string\n  }\n\nexport class Greeter extends WorkerEntrypoint<Env, Props> {\n    greet(name) {\n      return `${this.ctx.props.greeting}, ${name}!`;\n    }\n  }\n\nexport default {\n    async fetch(request, env, ctx) {\n      // Make a custom greeter that uses the greeting \"Welcome\".\n      let greeter = ctx.exports.Greeter({props: {greeting: \"Welcome\"}})\n\n// Greet the world. Returns \"Welcome, World!\"\n      let greeting = await greeter.greet(\"World\")\n\nreturn new Response(greeting);\n    }\n  } satisfies ExportedHandler<Env>;\n  js\nexport default {\n  async fetch(request, env, ctx) {\n    // Forward / proxy original request\n    let res = await fetch(request);\n\n// Add custom header(s)\n    res = new Response(res.body, res);\n    res.headers.set('x-foo', 'bar');\n\n// Cache the response\n    // NOTE: Does NOT block / wait\n    ctx.waitUntil(caches.default.put(request, res.clone()));\n\n// Done\n    return res;\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    // Proxy to origin on unhandled/uncaught exceptions\n    ctx.passThroughOnException();\n    throw new Error('Oops');\n  },\n};\njs\nlet encoder = new TextEncoder();\njs\nlet decoder = new TextDecoder();\njs\nlet eventSource = new EventSource(url, options);\njs\nexport default {\n  async fetch(req, env) {\n    let eventSource = new EventSource(url, { fetcher: env.MYFETCHER });\n    // ...\n  }\n};\njs\n  export default {\n    async scheduled(controller, env, ctx) {\n      return await fetch(\"https://example.com\", {\n        headers: {\n          \"X-Source\": \"Cloudflare-Workers\",\n        },\n      });\n    },\n  };\n  js\n  addEventListener(\"fetch\", (event) => {\n    // NOTE: can’t use fetch here, as we’re not in an async scope yet\n    event.respondWith(eventHandler(event));\n  });\n\nasync function eventHandler(event) {\n    // fetch can be awaited here since `event.respondWith()` waits for the Promise it receives to settle\n    const resp = await fetch(event.request);\n    return resp;\n  }\n  python\n  from workers import WorkerEntrypoint, Response, fetch\n\nclass Default(WorkerEntrypoint):\n      async def scheduled(self, controller, env, ctx):\n          return await fetch(\"https://example.com\", headers={\"X-Source\": \"Cloudflare-Workers\"})\n  typescript\nexport default {\n  async fetch(request) {\n    // Accept brotli or gzip compression\n    const headers = new Headers({\n      \"Accept-Encoding\": \"br, gzip\",\n    });\n    let response = await fetch(\"https://developers.cloudflare.com\", {\n      method: \"GET\",\n      headers,\n    });\n\n// As long as the original response body is returned and the Content-Encoding header is\n    // preserved, the same encoded data will be returned without needing to be compressed again.\n    return new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    });\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response('Hello World!');\n  },\n};\njs\nlet headers = new Headers();\n\nheaders.get('x-foo'); //=> null\n\nheaders.set('x-foo', '123');\nheaders.get('x-foo'); //=> \"123\"\n\nheaders.set('x-foo', 'hello');\nheaders.get('x-foo'); //=> \"hello\"\n\nheaders.append('x-foo', 'world');\nheaders.get('x-foo'); //=> \"hello, world\"\njs\nconst headers = new Headers();\n\nheaders.append(\"Set-Cookie\", \"cookie1=value_for_cookie_1; Path=/; HttpOnly;\");\nheaders.append(\"Set-Cookie\", \"cookie2=value_for_cookie_2; Path=/; HttpOnly;\");\n\nconsole.log(headers.getAll(\"Set-Cookie\"));\n// Array(2) [ cookie1=value_for_cookie_1; Path=/; HttpOnly;, cookie2=value_for_cookie_2; Path=/; HttpOnly; ]\njs\nnew HTMLRewriter()\n  .on(\"*\", new ElementHandler())\n  .onDocument(new DocumentHandler());\njs\nclass ElementHandler {\n  element(element) {\n    // An incoming element, such as `div`\n    console.log(`Incoming element: ${element.tagName}`);\n  }\n\ncomments(comment) {\n    // An incoming comment\n  }\n\ntext(text) {\n    // An incoming piece of text\n  }\n}\n\nasync function handleRequest(req) {\n  const res = await fetch(req);\n\nreturn new HTMLRewriter().on(\"div\", new ElementHandler()).transform(res);\n}\njs\nclass DocumentHandler {\n  doctype(doctype) {\n    // An incoming doctype, such as <!DOCTYPE html>\n  }\n\ncomments(comment) {\n    // An incoming comment\n  }\n\ntext(text) {\n    // An incoming piece of text\n  }\n\nend(end) {\n    // The end of the document\n  }\n}\njs\nclass UserElementHandler {\n  async element(element) {\n    let response = await fetch(new Request(\"/user\"));\n\n// fill in user info using response\n  }\n}\n\nasync function handleRequest(req) {\n  const res = await fetch(req);\n\n// run the user element handler via HTMLRewriter on a div with ID `user_info`\n  return new HTMLRewriter()\n    .on(\"div#user_info\", new UserElementHandler())\n    .transform(res);\n}\njs\nclass ElementHandler {\n  comments(comment) {\n    // An incoming comment element, such as <!-- My comment -->\n  }\n}\njs\nclass DocumentHandler {\n  doctype(doctype) {\n    // An incoming doctype element, such as\n    // <!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n  }\n}\njs\nclass DocumentHandler {\n  end(end) {\n    // The end of the document\n  }\n}\njs\nasync function handle(request) {\n  let oldResponse = await fetch(request);\n  let newResponse = new HTMLRewriter()\n    .on(\"*\", {\n      element(element) {\n        throw new Error(\"A really bad error.\");\n      },\n    })\n    .transform(oldResponse);\n\n// At this point, an expression like `await newResponse.text()`\n  // will throw `new Error(\"A really bad error.\")`.\n  // Thereafter, any use of `newResponse.body` will throw the same error,\n  // and `oldResponse.body` will be closed.\n\n// Alternatively, this will produce a truncated response to the client:\n  return newResponse;\n}\njs\nconst { port1, port2 } = new MessageChannel();\n\nport2.onmessage = (event) => {\n  console.log('Received message:', event.data);\n};\n\nport2.postMessage('Hello from port2!');\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"compatibility_date\": \"2024-09-23\"\n  }\n  toml\n  compatibility_flags = [ \"nodejs_compat\" ]\n  compatibility_date = \"2024-09-23\"\n  plaintext\n[unenv] <method name> is not implemented yet!\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_als\"\n    ]\n  }\n  toml\n  compatibility_flags = [ \"nodejs_als\" ]\n  typescript\nconst start = performance.now();\nfor (let i = 0; i < 1e6; i++) {\n  // do expensive work\n}\nconst end = performance.now();\nconst timing = end - start; // 0\ntypescript\nconst start = performance.now();\nconst response = await fetch(\"https://developers.cloudflare.com/\");\nconst end = performance.now();\nconst timing = end - start; // duration of the subrequest to developers.cloudflare.com\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response('Hello World!');\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n        const url = \"https://example.com\";\n        const modifiedRequest = new Request(url, request);\n    // ...\n  },\n};\njs\nlet request = new Request(input, options)\njs\n// Disable ScrapeShield for this request.\nfetch(event.request, { cf: { scrapeShield: false } })\njs\n      export default {\n        async fetch(request, env, ctx) {\n          // This sets up an event listener that will be called if the client disconnects from your\n          // worker.\n          request.signal.addEventListener(\"abort\", () => {\n            console.log(\"The request was aborted!\");\n          });\n\nconst { readable, writable } = new IdentityTransformStream();\n          sendPing(writable);\n          return new Response(readable, {\n            headers: { \"Content-Type\": \"text/plain\" },\n          });\n        },\n      };\n\nasync function sendPing(writable) {\n        const writer = writable.getWriter();\n        const enc = new TextEncoder();\n\nfor (;;) {\n          // Send 'ping' every second to keep the connection alive\n          await writer.write(enc.encode(\"ping\\r\\n\"));\n          await scheduler.wait(1000);\n        }\n      }\n      ts\n      export default {\n        async fetch(request, env, ctx): Promise<Response> {\n          // This sets up an event listener that will be called if the client disconnects from your\n          // worker.\n          request.signal.addEventListener('abort', () => {\n            console.log('The request was aborted!');\n          });\n\nconst { readable, writable } = new IdentityTransformStream();\n          sendPing(writable);\n          return new Response(readable, { headers: { 'Content-Type': 'text/plain' } });\n        },\n      } satisfies ExportedHandler<Env>;\n\nasync function sendPing(writable: WritableStream): Promise<void> {\n        const writer = writable.getWriter();\n        const enc = new TextEncoder();\n\nfor (;;) {\n          // Send 'ping' every second to keep the connection alive\n          await writer.write(enc.encode('ping\\r\\n'));\n          await scheduler.wait(1000);\n        }\n      }\n      js\nexport default {\n  async fetch(request, env, ctx) {\n        // Request context starts here\n    return new Response('Hello World!');\n  },\n};\njs\naddEventListener(\"fetch\", event => {\n  event.respondWith(eventHandler(event))\n})\n\n// No request context available here\n\nasync function eventHandler(event){\n  // Request context available here\n  return new Response(\"Hello, Workers!\")\n}\njs\nconst promise = fetch(\"https://example.com/\") // Error\nasync function eventHandler(event){..}\njs\n  const { writable, readable } = new FixedLengthStream(11);\n\nconst enc = new TextEncoder();\n  const writer = writable.getWriter();\n  writer.write(enc.encode(\"hello world\"));\n  writer.end();\n\nconst req = new Request('https://example.org', { method: 'POST', body: readable });\njs\nlet response = new Response(body, init);\njs\n  const { writable, readable } = new FixedLengthStream(11);\n\nconst enc = new TextEncoder();\n  const writer = writable.getWriter();\n  writer.write(enc.encode(\"hello world\"));\n  writer.end();\n\nreturn new Response(readable);\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"worker_b\",\n    \"main\": \"./src/workerB.js\"\n  }\n  toml\n  name = \"worker_b\"\n  main = \"./src/workerB.js\"\n  js\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport default class extends WorkerEntrypoint {\n    async fetch() {\n      return new Response(\"Hello from Worker B\");\n    }\n\nadd(a, b) {\n      return a + b;\n    }\n  }\n  ts\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport default class extends WorkerEntrypoint {\n    async fetch() {\n      return new Response(\"Hello from Worker B\");\n    }\n\nadd(a: number, b: number) {\n      return a + b;\n    }\n  }\n  python\n  from workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          return Response(\"Hello from Worker B\")\n\ndef add(self, a: int, b: int) -> int:\n          return a + b\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"worker_a\",\n    \"main\": \"./src/workerA.js\",\n    \"services\": [\n      {\n        \"binding\": \"WORKER_B\",\n        \"service\": \"worker_b\"\n      }\n    ]\n  }\n  toml\n  name = \"worker_a\"\n  main = \"./src/workerA.js\"\n  services = [\n    { binding = \"WORKER_B\", service = \"worker_b\" }\n  ]\n  js\n  export default {\n    async fetch(request, env) {\n      const result = await env.WORKER_B.add(1, 2);\n      return new Response(result);\n    },\n  };\n  ts\n  export default {\n    async fetch(request, env) {\n      const result = await env.WORKER_B.add(1, 2);\n      return new Response(result);\n    },\n  };\n  python\n  from workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          result = await self.env.WORKER_B.add(1, 2)\n      return Response(f\"Result: {result}\")\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"counter-service\",\n    \"main\": \"./src/counterService.js\"\n  }\n  toml\n  name = \"counter-service\"\n  main = \"./src/counterService.js\"\n  js\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport default class extends WorkerEntrypoint {\n    async fetch() {\n      return new Response(\"Hello from counter-service\");\n    }\n\nasync newCounter() {\n      let value = 0;\n      return (increment = 0) => {\n        value += increment;\n        return value;\n      };\n    }\n  }\n  ts\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport default class extends WorkerEntrypoint {\n    async fetch() {\n      return new Response(\"Hello from counter-service\");\n    }\n\nasync newCounter() {\n      let value = 0;\n      return (increment = 0) => {\n        value += increment;\n        return value;\n      };\n    }\n  }\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"client_worker\",\n    \"main\": \"./src/clientWorker.js\",\n    \"services\": [\n      {\n        \"binding\": \"COUNTER_SERVICE\",\n        \"service\": \"counter-service\"\n      }\n    ]\n  }\n  toml\n  name = \"client_worker\"\n  main = \"./src/clientWorker.js\"\n  services = [\n    { binding = \"COUNTER_SERVICE\", service = \"counter-service\" }\n  ]\n  js\n  export default {\n    async fetch(request, env) {\n      using f = await env.COUNTER_SERVICE.newCounter();\n      await f(2); // returns 2\n      await f(1); // returns 3\n      const count = await f(-5); // returns -2\n\nreturn new Response(count);\n    },\n  };\n  ts\n  export default {\n    async fetch(request: Request, env: Env) {\n      using f = await env.COUNTER_SERVICE.newCounter();\n      await f(2); // returns 2\n      await f(1); // returns 3\n      const count = await f(-5); // returns -2\n\nreturn new Response(count);\n    },\n  };\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"counter\",\n    \"main\": \"./src/counter.js\"\n  }\n  toml\n  name = \"counter\"\n  main = \"./src/counter.js\"\n  js\n  import { WorkerEntrypoint, RpcTarget } from \"cloudflare:workers\";\n\nclass Counter extends RpcTarget {\n    #value = 0;\n\nincrement(amount) {\n      this.#value += amount;\n      return this.#value;\n    }\n\nget value() {\n      return this.#value;\n    }\n  }\n\nexport class CounterService extends WorkerEntrypoint {\n    async newCounter() {\n      return new Counter();\n    }\n  }\n\nexport default {\n    fetch() {\n      return new Response(\"ok\");\n    },\n  };\n  ts\n  import { WorkerEntrypoint, RpcTarget } from \"cloudflare:workers\";\n\nclass Counter extends RpcTarget {\n    #value = 0;\n\nincrement(amount: number) {\n      this.#value += amount;\n      return this.#value;\n    }\n\nget value() {\n      return this.#value;\n    }\n  }\n\nexport class CounterService extends WorkerEntrypoint {\n    async newCounter() {\n      return new Counter();\n    }\n  }\n\nexport default {\n    fetch() {\n      return new Response(\"ok\");\n    },\n  };\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"client-worker\",\n    \"main\": \"./src/clientWorker.js\",\n    \"services\": [\n      {\n        \"binding\": \"COUNTER_SERVICE\",\n        \"service\": \"counter\",\n        \"entrypoint\": \"CounterService\"\n      }\n    ]\n  }\n  toml\n  name = \"client-worker\"\n  main = \"./src/clientWorker.js\"\n  services = [\n    { binding = \"COUNTER_SERVICE\", service = \"counter\", entrypoint = \"CounterService\" }\n  ]\n  js\n  export default {\n    async fetch(request, env) {\n      using counter = await env.COUNTER_SERVICE.newCounter();\n\nawait counter.increment(2); // returns 2\n      await counter.increment(1); // returns 3\n      await counter.increment(-5); // returns -2\n\nconst count = await counter.value; // returns -2\n\nreturn new Response(count);\n    },\n  };\n  ts\n  export default {\n    async fetch(request: Request, env: Env) {\n      using counter = await env.COUNTER_SERVICE.newCounter();\n\nawait counter.increment(2); // returns 2\n      await counter.increment(1); // returns 3\n      await counter.increment(-5); // returns -2\n\nconst count = await counter.value; // returns -2\n\nreturn new Response(count);\n    },\n  };\n  js\n  // Two round trips.\n  using counter = await env.COUNTER_SERVICE.getCounter();\n  await counter.increment();\n  ts\n  // Two round trips.\n  using counter = await env.COUNTER_SERVICE.getCounter();\n  await counter.increment();\n  js\n  // Only one round trip! Note the missing `await`.\n  using promiseForCounter = env.COUNTER_SERVICE.getCounter();\n  await promiseForCounter.increment();\n  ts\n  // Only one round trip! Note the missing `await`.\n  using promiseForCounter = env.COUNTER_SERVICE.getCounter();\n  await promiseForCounter.increment();\n  js\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport class MyService extends WorkerEntrypoint {\n    async foo() {\n      return {\n        bar: {\n          baz: () => \"qux\",\n        },\n      };\n    }\n  }\n  ts\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport class MyService extends WorkerEntrypoint {\n    async foo() {\n      return {\n        bar: {\n          baz: () => \"qux\",\n        },\n      };\n    }\n  }\n  js\n  export default {\n    async fetch(request, env) {\n      using foo = env.MY_SERVICE.foo();\n      let baz = await foo.bar.baz();\n      return new Response(baz);\n    },\n  };\n  ts\n  export default {\n    async fetch(request, env) {\n      using foo = env.MY_SERVICE.foo();\n      let baz = await foo.bar.baz();\n      return new Response(baz);\n    },\n  };\n  js\n  using counter = env.COUNTER_SERVICE.getCounter();\n  await env.ANOTHER_SERVICE.useCounter(counter);\n  ts\n  using counter = env.COUNTER_SERVICE.getCounter();\n  await env.ANOTHER_SERVICE.useCounter(counter);\n  js\n    export class MyService extends WorkerEntrypoint {\n      async foo() {\n        // Although this works, it puts a lot of memory pressure on the isolate.\n        // If possible, streaming the data from its original source is much preferred and would yield better performance.\n        // If you must buffer the data into memory, consider chunking it into smaller pieces if possible.\n\nconst sizeInBytes = 33 * 1024 * 1024; // 33 MiB\n        const arr = new Uint8Array(sizeInBytes);\n\nreturn new ReadableStream({\n          start(controller) {\n            controller.enqueue(arr);\n            controller.close();\n          },\n        });\n      }\n    }\n    ts\n    export class MyService extends WorkerEntrypoint {\n      async foo() {\n        // Although this works, it puts a lot of memory pressure on the isolate.\n        // If possible, streaming the data from its original source is much preferred and would yield better performance.\n        // If you must buffer the data into memory, consider chunking it into smaller pieces if possible.\n\nconst sizeInBytes = 33 * 1024 * 1024; // 33 MiB\n        const arr = new Uint8Array(sizeInBytes);\n\nreturn new ReadableStream({\n          start(controller) {\n            controller.enqueue(arr);\n            controller.close();\n          },\n        });\n      }\n    }\n    js\n  export default {\n    async fetch(request, env, ctx) {\n      // Fetch from origin server.\n      const response = await fetch(request);\n\n// ... and deliver our Response while that’s running.\n      return new Response(response.body, response);\n    },\n  };\n  js\n  addEventListener(\"fetch\", (event) => {\n    event.respondWith(fetchAndStream(event.request));\n  });\n\nasync function fetchAndStream(request) {\n    // Fetch from origin server.\n    const response = await fetch(request);\n\n// ... and deliver our Response while that’s running.\n    return new Response(readable.body, response);\n  }\n  js\n  export default {\n    async fetch(request, env, ctx) {\n      // Fetch from origin server.\n      const response = await fetch(request);\n\nconst { readable, writable } = new TransformStream({\n        transform(chunk, controller) {\n          controller.enqueue(modifyChunkSomehow(chunk));\n        },\n      });\n\n// Start pumping the body. NOTE: No await!\n      response.body.pipeTo(writable);\n\n// ... and deliver our Response while that’s running.\n      return new Response(readable, response);\n    },\n  };\n  js\n  addEventListener(\"fetch\", (event) => {\n    event.respondWith(fetchAndStream(event.request));\n  });\n\nasync function fetchAndStream(request) {\n    // Fetch from origin server.\n    const response = await fetch(request);\n\nconst { readable, writable } = new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(modifyChunkSomehow(chunk));\n      },\n    });\n\n// Start pumping the body. NOTE: No await!\n    response.body.pipeTo(writable);\n\n// ... and deliver our Response while that’s running.\n    return new Response(readable, response);\n  }\n  typescript\nimport { connect } from 'cloudflare:sockets';\n\nexport default {\n  async fetch(req): Promise<Response> {\n    const gopherAddr = { hostname: \"gopher.floodgap.com\", port: 70 };\n    const url = new URL(req.url);\n\ntry {\n      const socket = connect(gopherAddr);\n\nconst writer = socket.writable.getWriter()\n      const encoder = new TextEncoder();\n      const encoded = encoder.encode(url.pathname + \"\\r\\n\");\n      await writer.write(encoded);\n      await writer.close();\n\nreturn new Response(socket.readable, { headers: { \"Content-Type\": \"text/plain\" } });\n    } catch (error) {\n      return new Response(\"Socket connection failed: \" + error, { status: 500 });\n    }\n  }\n} satisfies ExportedHandler;\ntypescript\nimport { connect } from \"cloudflare:sockets\"\n\nconst address = {\n  hostname: \"example-postgres-db.com\",\n  port: 5432\n};\nconst socket = connect(address, { secureTransport: \"starttls\" });\nconst secureSocket = socket.startTls();\ntypescript\nimport { connect } from 'cloudflare:sockets';\nconst connectionUrl = { hostname: \"google.com\", port: 80 };\nexport interface Env { }\nexport default {\n  async fetch(req, env, ctx): Promise<Response> {\n    try {\n      const socket = connect(connectionUrl);\n      const writer = socket.writable.getWriter();\n      const encoder = new TextEncoder();\n      const encoded = encoder.encode(\"GET / HTTP/1.0\\r\\n\\r\\n\");\n      await writer.write(encoded);\n      await writer.close();\n\nreturn new Response(socket.readable, { headers: { \"Content-Type\": \"text/plain\" } });\n    } catch (error) {\n      return new Response(`Socket connection failed: ${error}`, { status: 500 });\n    }\n  }\n} satisfies ExportedHandler<Env>;\ntypescript\nimport { connect } from \"cloudflare:sockets\"\n\nconst socket = connect({ hostname: \"my-url.com\", port: 70 });\nconst reader = socket.readable.getReader();\nsocket.close();\n\n// After close() is called, you can no longer read from the readable side of the socket\nconst reader = socket.readable.getReader(); // This fails\njs\nconst myText = new TextEncoder().encode('Hello world!');\n\nconst myDigest = await crypto.subtle.digest(\n  {\n    name: 'SHA-256',\n  },\n  myText // The data you want to hash as an ArrayBuffer\n);\n\nconsole.log(new Uint8Array(myDigest));\njs\n  export default {\n    async fetch(req) {\n      // Fetch from origin\n      const res = await fetch(req);\n\n// We need to read the body twice so we `tee` it (get two instances)\n      const [bodyOne, bodyTwo] = res.body.tee();\n      // Make a new response so we can set the headers (responses from `fetch` are immutable)\n      const newRes = new Response(bodyOne, res);\n      // Create a SHA-256 digest stream and pipe the body into it\n      const digestStream = new crypto.DigestStream(\"SHA-256\");\n      bodyTwo.pipeTo(digestStream);\n      // Get the final result\n      const digest = await digestStream.digest;\n      // Turn it into a hex string\n      const hexString = [...new Uint8Array(digest)]\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('')\n      // Set a header with the SHA-256 hash and return the response\n      newRes.headers.set(\"x-content-digest\", `SHA-256=${hexString}`);\n      return newRes;\n    }\n  }\n  ts\n  export default {\n    async fetch(req): Promise<Response> {\n      // Fetch from origin\n      const res = await fetch(req);\n\n// We need to read the body twice so we `tee` it (get two instances)\n      const [bodyOne, bodyTwo] = res.body.tee();\n      // Make a new response so we can set the headers (responses from `fetch` are immutable)\n      const newRes = new Response(bodyOne, res);\n      // Create a SHA-256 digest stream and pipe the body into it\n      const digestStream = new crypto.DigestStream(\"SHA-256\");\n      bodyTwo.pipeTo(digestStream);\n      // Get the final result\n      const digest = await digestStream.digest;\n      // Turn it into a hex string\n      const hexString = [...new Uint8Array(digest)]\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('')\n      // Set a header with the SHA-256 hash and return the response\n      newRes.headers.set(\"x-content-digest\", `SHA-256=${hexString}`);\n      return newRes;\n    }\n  } satisfies ExportedHandler;\n  js\n  let keyPair = await crypto.subtle.generateKey(\n    {\n      name: 'AES-GCM',\n      length: 256,\n    },\n    true,\n    ['encrypt', 'decrypt']\n  );\n  js\naddEventListener(\"unhandledrejection\", (event) => {\n  console.log(event.promise); // The promise that was rejected.\n  console.log(event.reason); // The value or Error with which the promise was rejected.\n});\n\naddEventListener(\"rejectionhandled\", (event) => {\n  console.log(event.promise); // The promise that was rejected.\n  console.log(event.reason); // The value or Error with which the promise was rejected.\n});\njs\nconst promise = fetch(\"https://example.com\", {\n  method: \"POST\",\n  body: \"hello world\",\n});\nctx.waitUntil(promise);\njs\nnavigator.sendBeacon(\"https://example.com\", \"hello world\");\njs\nconst root = await navigator.storage.getDirctory();\n\nexport default {\n  async fetch(request) {\n    const fileHandle = await root.getFileHandle(\"hello.txt\", { create: true });\n    const writable = await fileHandle.createWritable();\n    await writable.write(\"Hello, world!\");\n    await writable.close();\n\nconst file = await fileHandle.getFile();\n    const contents = await file.text();\n\nreturn new Response(contents, { status: 200 });\n  },\n};\njs\n// { 0: <WebSocket>, 1: <WebSocket> }\nlet websocketPair = new WebSocketPair();\njs\nlet [client, server] = Object.values(new WebSocketPair());\nts\nimport assert from \"node:assert\";\nimport test, { after, before, describe } from \"node:test\";\nimport { unstable_startWorker } from \"wrangler\";\n\ndescribe(\"worker\", () => {\n  let worker;\n\nbefore(async () => {\n    worker = await unstable_startWorker({ config: \"wrangler.json\" });\n  });\n\ntest(\"hello world\", async () => {\n    assert.strictEqual(\n      await (await worker.fetch(\"http://example.com\")).text(),\n      \"Hello world\",\n    );\n  });\n\nafter(async () => {\n    await worker.dispose();\n  });\n});\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"my-worker\",\n    \"compatibility_date\": \"2024-09-19\",\n    \"assets\": {\n      \"directory\": \"./public/\"\n    }\n  }\n  toml\n  name = \"my-worker\"\n  compatibility_date = \"2024-09-19\"\n  assets = { directory = \"./public/\" }\n  txt\n_worker.js\n_redirects\n_headers\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"my-worker\",\n    \"compatibility_date\": \"2024-09-19\",\n    \"main\": \"src/index.ts\",\n    \"assets\": {\n      \"directory\": \"./public/\",\n      \"binding\": \"ASSETS\",\n      \"run_worker_first\": true\n    }\n  }\n  toml\n  name = \"my-worker\"\n  compatibility_date = \"2024-09-19\"\n  main = \"src/index.ts\"\n   # The following configuration unconditionally invokes the Worker script at\n   # `src/index.ts`, which can programatically fetch assets via the ASSETS binding\n  [assets]\n  directory = \"./public/\"\n  binding = \"ASSETS\"\n  run_worker_first = true\n  jsonc\n  {\n    \"name\": \"my-spa-worker\",\n    \"compatibility_date\": \"2025-12-31\",\n    \"main\": \"./src/index.ts\",\n    \"assets\": {\n      \"directory\": \"./dist/\",\n      \"not_found_handling\": \"single-page-application\",\n      \"binding\": \"ASSETS\",\n      \"run_worker_first\": [\"/api/*\", \"!/api/docs/*\"]\n    }\n  }\n  toml\n  name = \"my-spa-worker\"\n  compatibility_date = \"2025-12-31\"\n  main = \"./src/index.ts\"\n\n[assets]\n  directory = \"./dist/\"\n  not_found_handling = \"single-page-application\"\n  binding = \"ASSETS\"\n  run_worker_first = [ \"/api/*\", \"!/api/docs/*\" ]\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"my-worker\",\n    \"main\": \"./src/index.js\",\n    \"compatibility_date\": \"2024-09-19\",\n    \"assets\": {\n      \"directory\": \"./public/\",\n      \"binding\": \"ASSETS\"\n    }\n  }\n  toml\n  name = \"my-worker\"\n  main = \"./src/index.js\"\n  compatibility_date = \"2024-09-19\"\n\n[assets]\n  directory = \"./public/\"\n  binding = \"ASSETS\"\n  js\n  export default {\n    async fetch(request, env) {\n      const url = new URL(request.url);\n      if (url.pathname.startsWith(\"/api/\")) {\n        // TODO: Add your custom /api/* logic here.\n        return new Response(\"Ok\");\n      }\n      // Passes the incoming request through to the assets binding.\n      // No asset matched this request, so this will evaluate `not_found_handling` behavior.\n      return env.ASSETS.fetch(request);\n    },\n  };\n  ts\n  interface Env {\n    ASSETS: Fetcher;\n  }\n\nexport default {\n    async fetch(request, env): Promise<Response> {\n      const url = new URL(request.url);\n      if (url.pathname.startsWith(\"/api/\")) {\n        // TODO: Add your custom /api/* logic here.\n        return new Response(\"Ok\");\n      }\n      // Passes the incoming request through to the assets binding.\n      // No asset matched this request, so this will evaluate `not_found_handling` behavior.\n      return env.ASSETS.fetch(request);\n    },\n  } satisfies ExportedHandler<Env>;\n  mermaid\n  sequenceDiagram\n      participant User\n      participant Workers API\n      User<<->>Workers API: Submit manifest<br/>POST /client/v4/accounts/:accountId/workers/scripts/:scriptName/assets-upload-session\n      User<<->>Workers API: Upload files<br/>POST /client/v4/accounts/:accountId/workers/assets/upload?base64=true\n      User<<->>Workers API: Upload script version<br/>PUT /client/v4/accounts/:accountId/workers/scripts/:scriptName\n  mermaid\n  sequenceDiagram\n      participant User\n      participant Workers API\n      User<<->>Workers API: Submit manifest<br/>POST /client/v4/accounts/:accountId/workers/dispatch/namespaces/:dispatchNamespace/scripts/:scriptName/assets-upload-session\n      User<<->>Workers API: Upload files<br/>POST /client/v4/accounts/:accountId/workers/assets/upload?base64=true\n      User<<->>Workers API: Upload script version<br/>PUT /client/v4/accounts/:accountId/workers/dispatch/namespaces/:dispatchNamespace/scripts/:scriptName\n  bash\n  curl -X POST https://api.cloudflare.com/client/v4/accounts/{account_id}/workers/scripts/{script_name}/assets-upload-session \\\n  --header 'content-type: application/json' \\\n  --header 'Authorization: Bearer <API_TOKEN>' \\\n  --data '{\n    \"manifest\": {\n      \"/filea.html\": {\n        \"hash\": \"08f1dfda4574284ab3c21666d1\",\n        \"size\": 12\n      },\n      \"/fileb.html\": {\n        \"hash\": \"4f1c1af44620d531446ceef93f\",\n        \"size\": 23\n      },\n      \"/filec.html\": {\n        \"hash\": \"54995e302614e0523757a04ec1\",\n        \"size\": 23\n      }\n    }\n  }'\n  bash\n  curl -X POST https://api.cloudflare.com/client/v4/accounts/{account_id}/workers/dispatch/namespaces/{dispatch_namespace}/scripts/{script_name}/assets-upload-session \\\n  --header 'content-type: application/json' \\\n  --header 'Authorization: Bearer <API_TOKEN>' \\\n  --data '{\n    \"manifest\": {\n      \"/filea.html\": {\n        \"hash\": \"08f1dfda4574284ab3c21666d1\",\n        \"size\": 12\n      },\n      \"/fileb.html\": {\n        \"hash\": \"4f1c1af44620d531446ceef93f\",\n        \"size\": 23\n      },\n      \"/filec.html\": {\n        \"hash\": \"54995e302614e0523757a04ec1\",\n        \"size\": 23\n      }\n    }\n  }'\n  json\n{\n  \"result\": {\n    \"jwt\": \"<UPLOAD_TOKEN>\",\n    \"buckets\": [\n      [\"08f1dfda4574284ab3c21666d1\", \"4f1c1af44620d531446ceef93f\"],\n      [\"54995e302614e0523757a04ec1\"]\n    ]\n  },\n  \"success\": true,\n  \"errors\": null,\n  \"messages\": null\n}\nbash\n{\n  \"main_module\": \"main.js\",\n  \"assets\": {\n    \"jwt\": \"<completion_token>\"\n  },\n  \"compatibility_date\": \"2021-09-14\"\n}\nbash\n{\n  \"main_module\": \"main.js\",\n  \"keep_assets\": true,\n  \"compatibility_date\": \"2021-09-14\"\n}\nbash\n{\n  \"main_module\": \"main.js\",\n  \"assets\": {\n    \"jwt\": \"<completion_token>\",\n    \"config\" {\n      \"html_handling\": \"auto-trailing-slash\"\n    }\n  },\n  \"compatibility_date\": \"2021-09-14\"\n}\nbash\n{\n  \"main_module\": \"main.js\",\n  \"assets\": {\n    ...\n  },\n  \"bindings\": [\n    ...\n    {\n      \"name\": \"ASSETS\",\n      \"type\": \"assets\"\n    }\n    ...\n  ]\n  \"compatibility_date\": \"2021-09-14\"\n}\njs\n  #!/usr/bin/env -S npm run tsn -T\n\n/**\n   * Create a Worker that serves static assets\n   *\n   * This example demonstrates how to:\n   * - Upload static assets to Cloudflare Workers\n   * - Create and deploy a Worker that serves those assets\n   *\n   * Docs:\n   * - https://developers.cloudflare.com/workers/static-assets/direct-upload\n   *\n   * Prerequisites:\n   * 1. Generate an API token: https://developers.cloudflare.com/fundamentals/api/get-started/create-token/\n   * 2. Find your account ID: https://developers.cloudflare.com/fundamentals/setup/find-account-and-zone-ids/\n   * 3. Find your workers.dev subdomain: https://developers.cloudflare.com/workers/configuration/routing/workers-dev/\n   *\n   * Environment variables:\n   *   - CLOUDFLARE_API_TOKEN (required)\n   *   - CLOUDFLARE_ACCOUNT_ID (required)\n   *   - ASSETS_DIRECTORY (required)\n   *   - CLOUDFLARE_SUBDOMAIN (optional)\n   *\n   * Usage:\n   *   Place your static files in the ASSETS_DIRECTORY, then run this script.\n   *   Assets will be available at: my-script-with-assets.$subdomain.workers.dev/$filename\n   */\n\nimport crypto from \"crypto\";\n  import fs from \"fs\";\n  import { readFile } from \"node:fs/promises\";\n  import { extname } from \"node:path\";\n  import path from \"path\";\n  import { exit } from \"node:process\";\n\nimport Cloudflare from \"cloudflare\";\n\nconst WORKER_NAME = \"my-worker-with-assets\";\n  const SCRIPT_FILENAME = `${WORKER_NAME}.mjs`;\n\nfunction loadConfig() {\n    const apiToken = process.env[\"CLOUDFLARE_API_TOKEN\"];\n    if (!apiToken) {\n      throw new Error(\n        \"Missing required environment variable: CLOUDFLARE_API_TOKEN\",\n      );\n    }\n\nconst accountId = process.env[\"CLOUDFLARE_ACCOUNT_ID\"];\n    if (!accountId) {\n      throw new Error(\n        \"Missing required environment variable: CLOUDFLARE_ACCOUNT_ID\",\n      );\n    }\n\nconst assetsDirectory = process.env[\"ASSETS_DIRECTORY\"];\n    if (!assetsDirectory) {\n      throw new Error(\"Missing required environment variable: ASSETS_DIRECTORY\");\n    }\n\nif (!fs.existsSync(assetsDirectory)) {\n      throw new Error(`Assets directory does not exist: ${assetsDirectory}`);\n    }\n\nconst subdomain = process.env[\"CLOUDFLARE_SUBDOMAIN\"];\n\nreturn {\n      apiToken,\n      accountId,\n      assetsDirectory,\n      subdomain: subdomain || undefined,\n      workerName: WORKER_NAME,\n    };\n  }\n\nconst config = loadConfig();\n  const client = new Cloudflare({\n    apiToken: config.apiToken,\n  });\n\n/**\n   * Recursively reads all files from a directory and creates a manifest\n   * mapping file paths to their hash and size.\n   */\n  function createManifest(directory) {\n    const manifest = {};\n\nfunction processDirectory(currentDir, basePath = \"\") {\n      try {\n        const entries = fs.readdirSync(currentDir, { withFileTypes: true });\n\nfor (const entry of entries) {\n          const fullPath = path.join(currentDir, entry.name);\n          const relativePath = path.join(basePath, entry.name);\n\nif (entry.isDirectory()) {\n            processDirectory(fullPath, relativePath);\n          } else if (entry.isFile()) {\n            try {\n              const fileContent = fs.readFileSync(fullPath);\n              const extension = extname(relativePath).substring(1);\n\n// Generate a hash for the file\n              const hash = crypto\n                .createHash(\"sha256\")\n                .update(fileContent.toString(\"base64\") + extension)\n                .digest(\"hex\")\n                .slice(0, 32);\n\n// Normalize path separators to forward slashes\n              const manifestPath = `/${relativePath.replace(/\\\\/g, \"/\")}`;\n\nmanifest[manifestPath] = {\n                hash,\n                size: fileContent.length,\n              };\n\nconsole.log(\n                `Added to manifest: ${manifestPath} (${fileContent.length} bytes)`,\n              );\n            } catch (error) {\n              console.warn(`Failed to process file ${fullPath}:`, error);\n            }\n          }\n        }\n      } catch (error) {\n        throw new Error(`Failed to read directory ${currentDir}: ${error}`);\n      }\n    }\n\nprocessDirectory(directory);\n\nif (Object.keys(manifest).length === 0) {\n      throw new Error(`No files found in assets directory: ${directory}`);\n    }\n\nconsole.log(`Created manifest with ${Object.keys(manifest).length} files`);\n    return manifest;\n  }\n\n/**\n   * Generates the Worker script content that serves static assets\n   */\n  function generateWorkerScript(exampleFile) {\n    return `\n  export default {\n    async fetch(request, env, ctx) {\n      const url = new URL(request.url);\n\n// Serve a simple index page at the root\n      if (url.pathname === '/') {\n        return new Response(\n          \\`<!DOCTYPE html>\n  <html>\n  <head>\n    <title>Static Assets Worker</title>\n    <style>\n      body { font-family: Arial, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; }\n      h1 { color: #f38020; }\n      .asset-info { background: #f5f5f5; padding: 15px; border-radius: 5px; }\n    </style>\n  </head>\n  <body>\n    <h1>This Worker serves static assets!</h1>\n    <div class=\"asset-info\">\n      <p><strong>To access your assets,</strong> add <code>/filename</code> to the URL.</p>\n      <p>Try visiting <a href=\"\\${url.origin}/${exampleFile}\">/${exampleFile}</a></p>\n    </div>\n  </body>\n  </html>\\`,\n          {\n            status: 200,\n            headers: { 'Content-Type': 'text/html' }\n          }\n        );\n      }\n\n// Serve static assets for all other paths\n      return env.ASSETS.fetch(request);\n    }\n  };\n    `.trim();\n  }\n\n/**\n   * Creates upload payloads from buckets and manifest\n   */\n  async function createUploadPayloads(buckets, manifest, assetsDirectory) {\n    const payloads = [];\n\nfor (const bucket of buckets) {\n      const payload = {};\n\nfor (const hash of bucket) {\n        // Find the file path for this hash\n        const manifestEntry = Object.entries(manifest).find(\n          ([_, data]) => data.hash === hash,\n        );\n\nif (!manifestEntry) {\n          throw new Error(`Could not find file for hash: ${hash}`);\n        }\n\nconst [relativePath] = manifestEntry;\n        const fullPath = path.join(assetsDirectory, relativePath);\n\ntry {\n          const fileContent = await readFile(fullPath);\n          payload[hash] = fileContent.toString(\"base64\");\n          console.log(`Prepared for upload: ${relativePath}`);\n        } catch (error) {\n          throw new Error(`Failed to read file ${fullPath}: ${error}`);\n        }\n      }\n\npayloads.push(payload);\n    }\n\n/**\n   * Uploads asset payloads\n   */\n  async function uploadAssets(payloads, uploadJwt, accountId) {\n    let completionJwt;\n\nconsole.log(`Uploading ${payloads.length} payload(s)...`);\n\nfor (let i = 0; i < payloads.length; i++) {\n      const payload = payloads[i];\n      console.log(`Uploading payload ${i + 1}/${payloads.length}...`);\n\ntry {\n        const response = await client.workers.assets.upload.create(\n          {\n            account_id: accountId,\n            base64: true,\n            body: payload,\n          },\n          {\n            headers: { Authorization: `Bearer ${uploadJwt}` },\n          },\n        );\n\nif (response?.jwt) {\n          completionJwt = response.jwt;\n        }\n      } catch (error) {\n        throw new Error(`Failed to upload payload ${i + 1}: ${error}`);\n      }\n    }\n\nif (!completionJwt) {\n      throw new Error(\"Upload completed but no completion JWT received\");\n    }\n\nconsole.log(\"✅ All assets uploaded successfully\");\n    return completionJwt;\n  }\n\nasync function main() {\n    try {\n      console.log(\n        \"🚀 Starting Worker creation and deployment with static assets...\",\n      );\n      console.log(`📁 Assets directory: ${config.assetsDirectory}`);\n\nconsole.log(\"📝 Creating asset manifest...\");\n      const manifest = createManifest(config.assetsDirectory);\n      const exampleFile =\n        Object.keys(manifest)[0]?.replace(/^\\//, \"\") || \"file.txt\";\n\nconst scriptContent = generateWorkerScript(exampleFile);\n\nlet worker;\n      try {\n        worker = await client.workers.beta.workers.get(config.workerName, {\n          account_id: config.accountId,\n        });\n        console.log(`♻️  Worker ${config.workerName} already exists. Using it.`);\n      } catch (error) {\n        if (!(error instanceof Cloudflare.NotFoundError)) {\n          throw error;\n        }\n        console.log(`✏️  Creating Worker ${config.workerName}...`);\n        worker = await client.workers.beta.workers.create({\n          account_id: config.accountId,\n          name: config.workerName,\n          subdomain: {\n            enabled: config.subdomain !== undefined,\n          },\n          observability: {\n            enabled: true,\n          },\n        });\n      }\n\nconsole.log(`⚙️  Worker id: ${worker.id}`);\n      console.log(\"🔄 Starting asset upload session...\");\n\nconst uploadResponse = await client.workers.scripts.assets.upload.create(\n        config.workerName,\n        {\n          account_id: config.accountId,\n          manifest,\n        },\n      );\n\nconst { buckets, jwt: uploadJwt } = uploadResponse;\n\nif (!uploadJwt || !buckets) {\n        throw new Error(\"Failed to start asset upload session\");\n      }\n\nif (buckets.length === 0) {\n        console.log(\"✅ No new assets to upload!\");\n        // Use the initial upload JWT as completion JWT when no uploads are needed\n        completionJwt = uploadJwt;\n      } else {\n        const payloads = await createUploadPayloads(\n          buckets,\n          manifest,\n          config.assetsDirectory,\n        );\n\ncompletionJwt = await uploadAssets(payloads, uploadJwt, config.accountId);\n      }\n\nconsole.log(\"✏️  Creating Worker version...\");\n\n// Create a new version with assets\n      const version = await client.workers.beta.workers.versions.create(\n        worker.id,\n        {\n          account_id: config.accountId,\n          main_module: SCRIPT_FILENAME,\n          compatibility_date: new Date().toISOString().split(\"T\")[0],\n          bindings: [\n            {\n              type: \"assets\",\n              name: \"ASSETS\",\n            },\n          ],\n          assets: {\n            jwt: completionJwt,\n          },\n          modules: [\n            {\n              name: SCRIPT_FILENAME,\n              content_type: \"application/javascript+module\",\n              content_base64: Buffer.from(scriptContent).toString(\"base64\"),\n            },\n          ],\n        },\n      );\n\nconsole.log(\"🚚 Creating Worker deployment...\");\n\n// Create a deployment and point all traffic to the version we created\n      await client.workers.scripts.deployments.create(config.workerName, {\n        account_id: config.accountId,\n        strategy: \"percentage\",\n        versions: [\n          {\n            percentage: 100,\n            version_id: version.id,\n          },\n        ],\n      });\n\nconsole.log(\"✅ Deployment successful!\");\n\nif (config.subdomain) {\n        console.log(`\n  🌍 Your Worker is live!\n  📍 Base URL: https://${config.workerName}.${config.subdomain}.workers.dev/\n  📄 Try accessing: https://${config.workerName}.${config.subdomain}.workers.dev/${exampleFile}\n  `);\n      } else {\n        console.log(`\n  ⚠️  Set up a route, custom domain, or workers.dev subdomain to access your Worker.\n  Add CLOUDFLARE_SUBDOMAIN to your environment variables to set one up automatically.\n  `);\n      }\n    } catch (error) {\n      console.error(\"❌ Deployment failed:\", error);\n      exit(1);\n    }\n  }\n\nmain();\n  ts\n  #!/usr/bin/env -S npm run tsn -T\n\n/**\n   * Create a Worker that serves static assets\n   *\n   * This example demonstrates how to:\n   * - Upload static assets to Cloudflare Workers\n   * - Create and deploy a Worker that serves those assets\n   *\n   * Docs:\n   * - https://developers.cloudflare.com/workers/static-assets/direct-upload\n   *\n   * Prerequisites:\n   * 1. Generate an API token: https://developers.cloudflare.com/fundamentals/api/get-started/create-token/\n   * 2. Find your account ID: https://developers.cloudflare.com/fundamentals/setup/find-account-and-zone-ids/\n   * 3. Find your workers.dev subdomain: https://developers.cloudflare.com/workers/configuration/routing/workers-dev/\n   *\n   * Environment variables:\n   *   - CLOUDFLARE_API_TOKEN (required)\n   *   - CLOUDFLARE_ACCOUNT_ID (required)\n   *   - ASSETS_DIRECTORY (required)\n   *   - CLOUDFLARE_SUBDOMAIN (optional)\n   *\n   * Usage:\n   *   Place your static files in the ASSETS_DIRECTORY, then run this script.\n   *   Assets will be available at: my-script-with-assets.$subdomain.workers.dev/$filename\n   */\n\nimport crypto from 'crypto';\n  import fs from 'fs';\n  import { readFile } from 'node:fs/promises';\n  import { extname } from 'node:path';\n  import path from 'path';\n  import { exit } from 'node:process';\n\nimport Cloudflare from 'cloudflare';\n\ninterface Config {\n    apiToken: string;\n    accountId: string;\n    assetsDirectory: string;\n    subdomain: string | undefined;\n    workerName: string;\n  }\n\ninterface AssetManifest {\n    [path: string]: {\n      hash: string;\n      size: number;\n    };\n  }\n\ninterface UploadPayload {\n    [hash: string]: string; // base64 encoded content\n  }\n\nconst WORKER_NAME = 'my-worker-with-assets';\n  const SCRIPT_FILENAME = `${WORKER_NAME}.mjs`;\n\nfunction loadConfig(): Config {\n    const apiToken = process.env['CLOUDFLARE_API_TOKEN'];\n    if (!apiToken) {\n      throw new Error('Missing required environment variable: CLOUDFLARE_API_TOKEN');\n    }\n\nconst accountId = process.env['CLOUDFLARE_ACCOUNT_ID'];\n    if (!accountId) {\n      throw new Error('Missing required environment variable: CLOUDFLARE_ACCOUNT_ID');\n    }\n\nconst assetsDirectory = process.env['ASSETS_DIRECTORY'];\n    if (!assetsDirectory) {\n      throw new Error('Missing required environment variable: ASSETS_DIRECTORY');\n    }\n\nif (!fs.existsSync(assetsDirectory)) {\n      throw new Error(`Assets directory does not exist: ${assetsDirectory}`);\n    }\n\nconst subdomain = process.env['CLOUDFLARE_SUBDOMAIN'];\n\nreturn {\n      apiToken,\n      accountId,\n      assetsDirectory,\n      subdomain: subdomain || undefined,\n      workerName: WORKER_NAME,\n    };\n  }\n\nconst config = loadConfig();\n  const client = new Cloudflare({\n    apiToken: config.apiToken,\n  });\n\n/**\n   * Recursively reads all files from a directory and creates a manifest\n   * mapping file paths to their hash and size.\n   */\n  function createManifest(directory: string): AssetManifest {\n    const manifest: AssetManifest = {};\n\nfunction processDirectory(currentDir: string, basePath = ''): void {\n      try {\n        const entries = fs.readdirSync(currentDir, { withFileTypes: true });\n\nfor (const entry of entries) {\n          const fullPath = path.join(currentDir, entry.name);\n          const relativePath = path.join(basePath, entry.name);\n\nif (entry.isDirectory()) {\n            processDirectory(fullPath, relativePath);\n          } else if (entry.isFile()) {\n            try {\n              const fileContent = fs.readFileSync(fullPath);\n              const extension = extname(relativePath).substring(1);\n\n// Generate a hash for the file\n              const hash = crypto\n                .createHash('sha256')\n                .update(fileContent.toString('base64') + extension)\n                .digest('hex')\n                .slice(0, 32);\n\n// Normalize path separators to forward slashes\n              const manifestPath = `/${relativePath.replace(/\\\\/g, '/')}`;\n\nmanifest[manifestPath] = {\n                hash,\n                size: fileContent.length,\n              };\n\nconsole.log(`Added to manifest: ${manifestPath} (${fileContent.length} bytes)`);\n            } catch (error) {\n              console.warn(`Failed to process file ${fullPath}:`, error);\n            }\n          }\n        }\n      } catch (error) {\n        throw new Error(`Failed to read directory ${currentDir}: ${error}`);\n      }\n    }\n\nprocessDirectory(directory);\n\nif (Object.keys(manifest).length === 0) {\n      throw new Error(`No files found in assets directory: ${directory}`);\n    }\n\nconsole.log(`Created manifest with ${Object.keys(manifest).length} files`);\n    return manifest;\n  }\n\n/**\n   * Generates the Worker script content that serves static assets\n   */\n  function generateWorkerScript(exampleFile: string): string {\n    return `\n  export default {\n    async fetch(request, env, ctx) {\n      const url = new URL(request.url);\n\n// Serve a simple index page at the root\n      if (url.pathname === '/') {\n        return new Response(\n          \\`<!DOCTYPE html>\n  <html>\n  <head>\n    <title>Static Assets Worker</title>\n    <style>\n      body { font-family: Arial, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; }\n      h1 { color: #f38020; }\n      .asset-info { background: #f5f5f5; padding: 15px; border-radius: 5px; }\n    </style>\n  </head>\n  <body>\n    <h1>This Worker serves static assets!</h1>\n    <div class=\"asset-info\">\n      <p><strong>To access your assets,</strong> add <code>/filename</code> to the URL.</p>\n      <p>Try visiting <a href=\"\\${url.origin}/${exampleFile}\">/${exampleFile}</a></p>\n    </div>\n  </body>\n  </html>\\`,\n          {\n            status: 200,\n            headers: { 'Content-Type': 'text/html' }\n          }\n        );\n      }\n\n// Serve static assets for all other paths\n      return env.ASSETS.fetch(request);\n    }\n  };\n    `.trim();\n  }\n\n/**\n   * Creates upload payloads from buckets and manifest\n   */\n  async function createUploadPayloads(\n    buckets: string[][],\n    manifest: AssetManifest,\n    assetsDirectory: string\n  ): Promise<UploadPayload[]> {\n    const payloads: UploadPayload[] = [];\n\nfor (const bucket of buckets) {\n      const payload: UploadPayload = {};\n\nfor (const hash of bucket) {\n        // Find the file path for this hash\n        const manifestEntry = Object.entries(manifest).find(\n          ([_, data]) => data.hash === hash\n        );\n\nif (!manifestEntry) {\n          throw new Error(`Could not find file for hash: ${hash}`);\n        }\n\nconst [relativePath] = manifestEntry;\n        const fullPath = path.join(assetsDirectory, relativePath);\n\ntry {\n          const fileContent = await readFile(fullPath);\n          payload[hash] = fileContent.toString('base64');\n          console.log(`Prepared for upload: ${relativePath}`);\n        } catch (error) {\n          throw new Error(`Failed to read file ${fullPath}: ${error}`);\n        }\n      }\n\npayloads.push(payload);\n    }\n\n/**\n   * Uploads asset payloads\n   */\n  async function uploadAssets(\n    payloads: UploadPayload[],\n    uploadJwt: string,\n    accountId: string\n  ): Promise<string> {\n    let completionJwt: string | undefined;\n\nconsole.log(`Uploading ${payloads.length} payload(s)...`);\n\nfor (let i = 0; i < payloads.length; i++) {\n      const payload = payloads[i]!;\n      console.log(`Uploading payload ${i + 1}/${payloads.length}...`);\n\ntry {\n        const response = await client.workers.assets.upload.create(\n          {\n            account_id: accountId,\n            base64: true,\n            body: payload,\n          },\n          {\n            headers: { Authorization: `Bearer ${uploadJwt}` },\n          }\n        );\n\nif (response?.jwt) {\n          completionJwt = response.jwt;\n        }\n      } catch (error) {\n        throw new Error(`Failed to upload payload ${i + 1}: ${error}`);\n      }\n    }\n\nif (!completionJwt) {\n      throw new Error('Upload completed but no completion JWT received');\n    }\n\nconsole.log('✅ All assets uploaded successfully');\n    return completionJwt;\n  }\n\nasync function main(): Promise<void> {\n    try {\n      console.log('🚀 Starting Worker creation and deployment with static assets...');\n      console.log(`📁 Assets directory: ${config.assetsDirectory}`);\n\nconsole.log('📝 Creating asset manifest...');\n      const manifest = createManifest(config.assetsDirectory);\n      const exampleFile = Object.keys(manifest)[0]?.replace(/^\\//, '') || 'file.txt';\n\nconst scriptContent = generateWorkerScript(exampleFile);\n\nlet worker;\n      try {\n        worker = await client.workers.beta.workers.get(config.workerName, {\n          account_id: config.accountId,\n        });\n        console.log(`♻️  Worker ${config.workerName} already exists. Using it.`);\n      } catch (error) {\n        if (!(error instanceof Cloudflare.NotFoundError)) { throw error; }\n        console.log(`✏️  Creating Worker ${config.workerName}...`);\n        worker = await client.workers.beta.workers.create({\n          account_id: config.accountId,\n          name: config.workerName,\n          subdomain: {\n            enabled: config.subdomain !== undefined,\n          },\n          observability: {\n            enabled: true,\n          },\n        });\n      }\n\nconsole.log(`⚙️  Worker id: ${worker.id}`);\n      console.log('🔄 Starting asset upload session...');\n\nconst uploadResponse = await client.workers.scripts.assets.upload.create(\n        config.workerName,\n        {\n          account_id: config.accountId,\n          manifest,\n        }\n      );\n\nconst { buckets, jwt: uploadJwt } = uploadResponse;\n\nif (!uploadJwt || !buckets) {\n        throw new Error('Failed to start asset upload session');\n      }\n\nlet completionJwt: string;\n\nif (buckets.length === 0) {\n        console.log('✅ No new assets to upload!');\n        // Use the initial upload JWT as completion JWT when no uploads are needed\n        completionJwt = uploadJwt;\n      } else {\n        const payloads = await createUploadPayloads(\n          buckets,\n          manifest,\n          config.assetsDirectory\n        );\n\ncompletionJwt = await uploadAssets(\n          payloads,\n          uploadJwt,\n          config.accountId\n        );\n      }\n\nconsole.log('✏️  Creating Worker version...');\n\n// Create a new version with assets\n      const version = await client.workers.beta.workers.versions.create(worker.id, {\n        account_id: config.accountId,\n        main_module: SCRIPT_FILENAME,\n        compatibility_date: new Date().toISOString().split('T')[0]!,\n        bindings: [\n          {\n            type: 'assets',\n            name: 'ASSETS',\n          },\n        ],\n        assets: {\n          jwt: completionJwt,\n        },\n        modules: [\n          {\n            name: SCRIPT_FILENAME,\n            content_type: 'application/javascript+module',\n            content_base64: Buffer.from(scriptContent).toString('base64'),\n          },\n        ],\n      });\n\nconsole.log('🚚 Creating Worker deployment...');\n\n// Create a deployment and point all traffic to the version we created\n      await client.workers.scripts.deployments.create(config.workerName, {\n        account_id: config.accountId,\n        strategy: 'percentage',\n        versions: [\n          {\n              percentage: 100,\n              version_id: version.id,\n            },\n          ],\n      });\n\nconsole.log('✅ Deployment successful!');\n\nif (config.subdomain) {\n        console.log(`\n  🌍 Your Worker is live!\n  📍 Base URL: https://${config.workerName}.${config.subdomain}.workers.dev/\n  📄 Try accessing: https://${config.workerName}.${config.subdomain}.workers.dev/${exampleFile}\n  `);\n      } else {\n        console.log(`\n  ⚠️  Set up a route, custom domain, or workers.dev subdomain to access your Worker.\n  Add CLOUDFLARE_SUBDOMAIN to your environment variables to set one up automatically.\n  `);\n      }\n    } catch (error) {\n      console.error('❌ Deployment failed:', error);\n      exit(1);\n    }\n  }\n\nmain();\n  sh\n  npm create cloudflare@latest -- my-static-site\n  sh\n  yarn create cloudflare my-static-site\n  sh\n  pnpm create cloudflare@latest my-static-site\n  sh\ncd my-static-site\nsh\nnpx wrangler dev\nsh\nnpx wrangler deploy\nsh\n  npm create cloudflare@latest -- my-dynamic-site\n  sh\n  yarn create cloudflare my-dynamic-site\n  sh\n  pnpm create cloudflare@latest my-dynamic-site\n  sh\ncd my-dynamic-site\nsh\nnpx wrangler dev\nsh\nnpx wrangler deploy\ntxt\n[url]\n  [name]: [value]\ntxt",
  "code_samples": [
    {
      "code": "Note that larger Worker bundles can impact the start-up time of the Worker, as the Worker needs to be loaded into memory.\n\nTo reduce the upload size of a Worker, consider some of the following strategies:\n\n* Removing unnecessary dependencies and packages\n* Storing configuration files, static assets, and binary data using [Workers KV](https://developers.cloudflare.com/kv/), [R2](https://developers.cloudflare.com/r2/), [D1](https://developers.cloudflare.com/d1/), or [Workers Static Assets](https://developers.cloudflare.com/workers/static-assets/) instead of bundling them within your Worker code.\n* Splitting functionality across multiple Workers and connecting them using [Service bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/).\n\n***\n\n## Worker startup time\n\nA Worker must be able to be parsed and execute its global scope (top-level code outside of any handlers) within 1 second. Worker size can impact startup because there is more code to parse and evaluate. Avoiding expensive code in the global scope can keep startup efficient as well.\n\nYou can measure your Worker's startup time by deploying it to Cloudflare using [Wrangler](https://developers.cloudflare.com/workers/wrangler/). When you run `npx wrangler@latest deploy` or `npx wrangler@latest versions upload`, Wrangler will output the startup time of your Worker in the command-line output, using the `startup_time_ms` field in the [Workers Script API](https://developers.cloudflare.com/api/resources/workers/subresources/scripts/methods/update/) or [Workers Versions API](https://developers.cloudflare.com/api/resources/workers/subresources/scripts/subresources/versions/methods/create/).\n\nIf you are having trouble staying under this limit, consider [profiling using DevTools](https://developers.cloudflare.com/workers/observability/dev-tools/) locally to learn how to optimize your code.\n\nWhen you attempt to deploy a Worker using the [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/), but your deployment is rejected because your Worker exceeds the maximum startup time, Wrangler will automatically generate a CPU profile that you can import into Chrome DevTools or open directly in VSCode. You can use this to learn what code in your Worker uses large amounts of CPU time at startup. Refer to [`wrangler check startup`](https://developers.cloudflare.com/workers/wrangler/commands/#startup) for more details.\n\nExceeding this limit is most commonly caused by attempting to perform expensive initialization work directly in top level (global) scope, rather than either at build time or when your Worker's handler is invoked. For example, attempting to initialize an app by generating or consuming a large schema.\n\nNeed a higher limit?\n\nTo request an adjustment to a limit, complete the [Limit Increase Request Form](https://forms.gle/ukpeZVLWLnKeixDu7). If the limit can be increased, Cloudflare will contact you with next steps.\n\n***\n\n## Number of Workers\n\nYou can have up to 500 Workers on your account on the Workers Paid plan, and up to 100 Workers on the Workers Free plan.\n\nIf you need more than 500 Workers, consider using [Workers for Platforms](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/).\n\n***\n\n## Routes and domains\n\n### Number of routes per zone\n\nEach zone has a limit of 1,000 [routes](https://developers.cloudflare.com/workers/configuration/routing/routes/). If you require more than 1,000 routes on your zone, consider using [Workers for Platforms](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/).\n\n### Number of routes per zone when using `wrangler dev --remote`\n\nWhen you run a [remote development](https://developers.cloudflare.com/workers/development-testing/#remote-bindings) session using the `--remote` flag, a limit of 50 [routes](https://developers.cloudflare.com/workers/configuration/routing/routes/) per zone is enforced. The Quick Editor in the Cloudflare Dashboard also uses `wrangler dev --remote`, so any changes made there are subject to the same 50-route limit. If your zone has more than 50 routes, you **will not be able to run a remote session**. To fix this, you must remove routes until you are under the 50-route limit.\n\n### Number of custom domains per zone\n\nEach zone has a limit of 100 [custom domains](https://developers.cloudflare.com/workers/configuration/routing/custom-domains/). If you require more than 100 custom domains on your zone, consider using a wildcard [route](https://developers.cloudflare.com/workers/configuration/routing/routes/).\n\n### Number of routed zones per Worker\n\nWhen configuring [routing](https://developers.cloudflare.com/workers/configuration/routing/), the maximum number of zones that can be referenced by a Worker is 1,000. If you require more than 1,000 zones on your Worker, consider using [Workers for Platforms](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/).\n\n***\n\n## Image Resizing with Workers\n\nWhen using Image Resizing with Workers, refer to [Image Resizing documentation](https://developers.cloudflare.com/images/transform-images/) for more information on the applied limits.\n\n***\n\n## Log size\n\nYou can emit a maximum of 256 KB of data (across `console.log()` statements, exceptions, request metadata and headers) to the console for a single request. After you exceed this limit, further context associated with the request will not be recorded in logs, appear when tailing logs of your Worker, or within a [Tail Worker](https://developers.cloudflare.com/workers/observability/logs/tail-workers/).\n\nRefer to the [Workers Trace Event Logpush documentation](https://developers.cloudflare.com/workers/observability/logs/logpush/#limits) for information on the maximum size of fields sent to logpush destinations.\n\n***\n\n## Unbound and Bundled plan limits\n\nNote\n\nUnbound and Bundled plans have been deprecated and are no longer available for new accounts.\n\nIf your Worker is on an Unbound plan, your limits are exactly the same as the Workers Paid plan.\n\nIf your Worker is on a Bundled plan, your limits are the same as the Workers Paid plan except for the following differences:\n\n* Your limit for [subrequests](https://developers.cloudflare.com/workers/platform/limits/#subrequests) is 50/request\n* Your limit for [CPU time](https://developers.cloudflare.com/workers/platform/limits/#cpu-time) is 50ms for HTTP requests and 50ms for [Cron Triggers](https://developers.cloudflare.com/workers/configuration/cron-triggers/)\n* You have no [Duration](https://developers.cloudflare.com/workers/platform/limits/#duration) limits for [Cron Triggers](https://developers.cloudflare.com/workers/configuration/cron-triggers/), [Durable Object alarms](https://developers.cloudflare.com/durable-objects/api/alarms/), or [Queue consumers](https://developers.cloudflare.com/queues/configuration/javascript-apis/#consumer)\n* Your Cache API limits for calls/requests is 50\n\n***\n\n## Static Assets\n\n### Files\n\nThere is a 20,000 file count limit per [Worker version](https://developers.cloudflare.com/workers/configuration/versions-and-deployments/) for free users, and a 100,000 file count limit for paid users.\n\nThere is a 25 MiB individual file size limit for all users.\n\nNote\n\nTo use the increased limits in Wrangler you must use version 4.34.0 or higher.\n\n### Headers\n\nA `_headers` file may contain up to 100 rules and each line may contain up to 2,000 characters. The entire line, including spacing, header name, and value, counts towards this limit.\n\n### Redirects\n\nA `_redirects` file may contain up to 2,000 static redirects and 100 dynamic redirects, for a combined total of 2,100 redirects. Each redirect declaration has a 1,000-character limit.\n\n***\n\n## Related resources\n\nReview other developer platform resource limits.\n\n* [KV limits](https://developers.cloudflare.com/kv/platform/limits/)\n* [Durable Object limits](https://developers.cloudflare.com/durable-objects/platform/limits/)\n* [Queues limits](https://developers.cloudflare.com/queues/platform/limits/)\n\n</page>\n\n<page>\n---\ntitle: Pricing · Cloudflare Workers docs\ndescription: Workers plans and pricing information.\nlastUpdated: 2025-12-11T19:21:41.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/platform/pricing/\n  md: https://developers.cloudflare.com/workers/platform/pricing/index.md\n---\n\nBy default, users have access to the Workers Free plan. The Workers Free plan includes limited usage of Workers, Pages Functions, Workers KV and Hyperdrive. Read more about the [Free plan limits](https://developers.cloudflare.com/workers/platform/limits/#worker-limits).\n\nThe Workers Paid plan includes Workers, Pages Functions, Workers KV, Hyperdrive, and Durable Objects usage for a minimum charge of $5 USD per month for an account. The plan includes increased initial usage allotments, with clear charges for usage that exceeds the base plan. There are no additional charges for data transfer (egress) or throughput (bandwidth).\n\nAll included usage is on a monthly basis.\n\nPages Functions billing\n\nAll [Pages Functions](https://developers.cloudflare.com/pages/functions/) are billed as Workers. All pricing and inclusions in this document apply to Pages Functions. Refer to [Functions Pricing](https://developers.cloudflare.com/pages/functions/pricing/) for more information on Pages Functions pricing.\n\n## Workers\n\nUsers on the Workers Paid plan have access to the Standard usage model. Workers Enterprise accounts are billed based on the usage model specified in their contract. To switch to the Standard usage model, contact your Account Manager.\n\n| | Requests1, 2, 3 | Duration | CPU time |\n| - | - | - | - |\n| **Free** | 100,000 per day | No charge for duration | 10 milliseconds of CPU time per invocation |\n| **Standard** | 10 million included per month +$0.30 per additional million | No charge or limit for duration | 30 million CPU milliseconds included per month +$0.02 per additional million CPU milliseconds Max of [5 minutes of CPU time](https://developers.cloudflare.com/workers/platform/limits/#worker-limits) per invocation (default: 30 seconds) Max of 15 minutes of CPU time per [Cron Trigger](https://developers.cloudflare.com/workers/configuration/cron-triggers/) or [Queue Consumer](https://developers.cloudflare.com/queues/configuration/javascript-apis/#consumer) invocation |\n\n1 Inbound requests to your Worker. Cloudflare does not bill for [subrequests](https://developers.cloudflare.com/workers/platform/limits/#subrequests) you make from your Worker.\n\n2 WebSocket connections made to a Worker are charged as a request, representing the initial `Upgrade` connection made to establish the WebSocket. WebSocket messages routed through a Worker do not count as requests.\n\n3 Requests to static assets are free and unlimited.\n\n### Example pricing\n\n#### Example 1\n\nA Worker that serves 15 million requests per month, and uses an average of 7 milliseconds (ms) of CPU time per request, would have the following estimated costs:\n\n| | Monthly Costs | Formula |\n| - | - | - |\n| **Subscription** | $5.00 | |\n| **Requests** | $1.50 | (15,000,000 requests - 10,000,000 included requests) / 1,000,000 \\* $0.30 |\n| **CPU time** | $1.50 | ((7 ms of CPU time per request \\* 15,000,000 requests) - 30,000,000 included CPU ms) / 1,000,000 \\* $0.02 |\n| **Total** | $8.00 | |\n\n#### Example 2\n\nA project that serves 15 million requests per month, with 80% (12 million) requests serving [static assets](https://developers.cloudflare.com/workers/static-assets/) and the remaining invoking dynamic Worker code. The Worker uses an average of 7 milliseconds (ms) of time per request.\n\nRequests to static assets are free and unlimited. This project would have the following estimated costs:\n\n| | Monthly Costs | Formula |\n| - | - | - |\n| **Subscription** | $5.00 | |\n| **Requests to static assets** | $0 | - |\n| **Requests to Worker** | $0 | - |\n| **CPU time** | $0 | - |\n| **Total** | $5.00 | |\n| | | |\n\n#### Example 3\n\nA Worker that runs on a [Cron Trigger](https://developers.cloudflare.com/workers/configuration/cron-triggers/) once an hour to collect data from multiple APIs, process the data and create a report.\n\n* 720 requests/month\n* 3 minutes (180,000ms) of CPU time per request\n\nIn this scenario, the estimated monthly cost would be calculated as:\n\n| | Monthly Costs | Formula |\n| - | - | - |\n| **Subscription** | $5.00 | |\n| **Requests** | $0.00 | - |\n| **CPU time** | $1.99 | ((180,000 ms of CPU time per request \\* 720 requests) - 30,000,000 included CPU ms) / 1,000,000 \\* $0.02 |\n| **Total** | $6.99 | |\n| | | |\n\n#### Example 4\n\nA high traffic Worker that serves 100 million requests per month, and uses an average of 7 milliseconds (ms) of CPU time per request, would have the following estimated costs:\n\n| | Monthly Costs | Formula |\n| - | - | - |\n| **Subscription** | $5.00 | |\n| **Requests** | $27.00 | (100,000,000 requests - 10,000,000 included requests) / 1,000,000 \\* $0.30 |\n| **CPU time** | $13.40 | ((7 ms of CPU time per request \\* 100,000,000 requests) - 30,000,000 included CPU ms) / 1,000,000 \\* $0.02 |\n| **Total** | $45.40 | |\n\nCustom limits\n\nTo prevent accidental runaway bills or denial-of-wallet attacks, configure the maximum amount of CPU time that can be used per invocation by [defining limits in your Worker's Wrangler file](https://developers.cloudflare.com/workers/wrangler/configuration/#limits), or via the Cloudflare dashboard (**Workers & Pages** > Select your Worker > **Settings** > **CPU Limits**).\n\nIf you had a Worker on the Bundled usage model prior to the migration to Standard pricing on March 1, 2024, Cloudflare has automatically added a 50 ms CPU limit on your Worker.\n\n### How to switch usage models\n\nNote\n\nSome Workers Enterprise customers maintain the ability to change usage models.\n\nUsers on the Workers Paid plan have access to the Standard usage model. However, some users may still have a legacy usage model configured. Legacy usage models include Workers Unbound and Workers Bundled. Users are advised to move to the Workers Standard usage model. Changing the usage model only affects billable usage, and has no technical implications.\n\nTo change your default account-wide usage model:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. Find **Usage Model** on the right-side menu > **Change**.\n\nUsage models may be changed at the individual Worker level:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. In **Overview**, select your Worker > **Settings** > **Usage Model**.\n\nExisting Workers will not be impacted when changing the default usage model. You may change the usage model for individual Workers without affecting your account-wide default usage model.\n\n## Workers Logs\n\nWorkers Logs is included in both the Free and Paid [Workers plans](https://developers.cloudflare.com/workers/platform/pricing/).\n\n| | Log Events Written | Retention |\n| - | - | - |\n| **Workers Free** | 200,000 per day | 3 Days |\n| **Workers Paid** | 20 million included per month +$0.60 per additional million | 7 Days |\n\nWorkers Logs documentation\n\nFor more information and [examples of Workers Logs billing](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#example-pricing), refer to the [Workers Logs documentation](https://developers.cloudflare.com/workers/observability/logs/workers-logs).\n\n## Workers Trace Events Logpush\n\nWorkers Logpush is only available on the Workers Paid plan.\n\n| | Paid plan |\n| - | - |\n| Requests 1 | 10 million / month, +$0.05/million |\n\n1 Workers Logpush charges for request logs that reach your end destination after applying filtering or sampling.\n\n## Workers KV\n\nWorkers KV is included in both the Free and Paid [Workers plans](https://developers.cloudflare.com/workers/platform/pricing/).\n\n| | Free plan1 | Paid plan |\n| - | - | - |\n| Keys read | 100,000 / day | 10 million/month, + $0.50/million |\n| Keys written | 1,000 / day | 1 million/month, + $5.00/million |\n| Keys deleted | 1,000 / day | 1 million/month, + $5.00/million |\n| List requests | 1,000 / day | 1 million/month, + $5.00/million |\n| Stored data | 1 GB | 1 GB, + $0.50/ GB-month |\n\n1 The Workers Free plan includes limited Workers KV usage. All limits reset daily at 00:00 UTC. If you exceed any one of these limits, further operations of that type will fail with an error.\n\nNote\n\nWorkers KV pricing for read, write and delete operations is on a per-key basis. Bulk read operations are billed by the amount of keys read in a bulk read operation.\n\nKV documentation\n\nTo learn more about KV, refer to the [KV documentation](https://developers.cloudflare.com/kv/).\n\n## Hyperdrive\n\nHyperdrive is included in both the Free and Paid [Workers plans](https://developers.cloudflare.com/workers/platform/pricing/).\n\n| | Free plan[1](#user-content-fn-1) | Paid plan |\n| - | - | - |\n| Database queries[2](#user-content-fn-2) | 100,000 / day | Unlimited |\n\nFootnotes\n\n1: The Workers Free plan includes limited Hyperdrive usage. All limits reset daily at 00:00 UTC. If you exceed any one of these limits, further operations of that type will fail with an error.\n\n2: Database queries refers to any database statement made via Hyperdrive, whether a query (`SELECT`), a modification (`INSERT`,`UPDATE`, or `DELETE`) or a schema change (`CREATE`, `ALTER`, `DROP`).\n\n## Footnotes\n\n1. The Workers Free plan includes limited Hyperdrive usage. All limits reset daily at 00:00 UTC. If you exceed any one of these limits, further operations of that type will fail with an error. [↩](#user-content-fnref-1)\n\n2. Database queries refers to any database statement made via Hyperdrive, whether a query (`SELECT`), a modification (`INSERT`,`UPDATE`, or `DELETE`) or a schema change (`CREATE`, `ALTER`, `DROP`). [↩](#user-content-fnref-2)\n\nHyperdrive documentation\n\nTo learn more about Hyperdrive, refer to the [Hyperdrive documentation](https://developers.cloudflare.com/hyperdrive/).\n\n## Queues\n\nNote\n\nCloudflare Queues requires the [Workers Paid plan](https://developers.cloudflare.com/workers/platform/pricing/#workers) to use, but does not increase your monthly subscription cost.\n\nCloudflare Queues charges for the total number of operations against each of your queues during a given month.\n\n* An operation is counted for each 64 KB of data that is written, read, or deleted.\n* Messages larger than 64 KB are charged as if they were multiple messages: for example, a 65 KB message and a 127 KB message would both incur two operation charges when written, read, or deleted.\n* A KB is defined as 1,000 bytes, and each message includes approximately 100 bytes of internal metadata.\n* Operations are per message, not per batch. A batch of 10 messages (the default batch size), if processed, would incur 10x write, 10x read, and 10x delete operations: one for each message in the batch.\n* There are no data transfer (egress) or throughput (bandwidth) charges.\n\n| | Workers Paid |\n| - | - |\n| Standard operations | 1,000,000 operations/month included + $0.40/million operations |\n\nIn most cases, it takes 3 operations to deliver a message: 1 write, 1 read, and 1 delete. Therefore, you can use the following formula to estimate your monthly bill:",
      "language": "unknown"
    },
    {
      "code": "Additionally:\n\n* Each retry incurs a read operation. A batch of 10 messages that is retried would incur 10 operations for each retry.\n* Messages that reach the maximum retries and that are written to a [Dead Letter Queue](https://developers.cloudflare.com/queues/configuration/batching-retries/) incur a write operation for each 64 KB chunk. A message that was retried 3 times (the default), fails delivery on the fourth time and is written to a Dead Letter Queue would incur five (5) read operations.\n* Messages that are written to a queue, but that reach the maximum persistence duration (or \"expire\") before they are read, incur only a write and delete operation per 64 KB chunk.\n\nQueues billing examples\n\nTo learn more about Queues pricing and review billing examples, refer to [Queues Pricing](https://developers.cloudflare.com/queues/platform/pricing/).\n\n## D1\n\nD1 is available on both the Workers Free and Workers Paid plans.\n\n| | [Workers Free](https://developers.cloudflare.com/workers/platform/pricing/#workers) | [Workers Paid](https://developers.cloudflare.com/workers/platform/pricing/#workers) |\n| - | - | - |\n| Rows read | 5 million / day | First 25 billion / month included + $0.001 / million rows |\n| Rows written | 100,000 / day | First 50 million / month included + $1.00 / million rows |\n| Storage (per GB stored) | 5 GB (total) | First 5 GB included + $0.75 / GB-mo |\n\nTrack your D1 usage\n\nTo accurately track your usage, use the [meta object](https://developers.cloudflare.com/d1/worker-api/return-object/), [GraphQL Analytics API](https://developers.cloudflare.com/d1/observability/metrics-analytics/#query-via-the-graphql-api), or the [Cloudflare dashboard](https://dash.cloudflare.com/?to=/:account/workers/d1/). Select your D1 database, then view: Metrics > Row Metrics.\n\n### Definitions\n\n1. Rows read measure how many rows a query reads (scans), regardless of the size of each row. For example, if you have a table with 5000 rows and run a `SELECT * FROM table` as a full table scan, this would count as 5,000 rows read. A query that filters on an [unindexed column](https://developers.cloudflare.com/d1/best-practices/use-indexes/) may return fewer rows to your Worker, but is still required to read (scan) more rows to determine which subset to return.\n2. Rows written measure how many rows were written to D1 database. Write operations include `INSERT`, `UPDATE`, and `DELETE`. Each of these operations contribute towards rows written. A query that `INSERT` 10 rows into a `users` table would count as 10 rows written.\n3. DDL operations (for example, `CREATE`, `ALTER`, and `DROP`) are used to define or modify the structure of a database. They may contribute to a mix of read rows and write rows. Ensure you are accurately tracking your usage through the available tools ([meta object](https://developers.cloudflare.com/d1/worker-api/return-object/), [GraphQL Analytics API](https://developers.cloudflare.com/d1/observability/metrics-analytics/#query-via-the-graphql-api), or the [Cloudflare dashboard](https://dash.cloudflare.com/?to=/:account/workers/d1/)).\n4. Row size or the number of columns in a row does not impact how rows are counted. A row that is 1 KB and a row that is 100 KB both count as one row.\n5. Defining [indexes](https://developers.cloudflare.com/d1/best-practices/use-indexes/) on your table(s) reduces the number of rows read by a query when filtering on that indexed field. For example, if the `users` table has an index on a timestamp column `created_at`, the query `SELECT * FROM users WHERE created_at > ?1` would only need to read a subset of the table.\n6. Indexes will add an additional written row when writes include the indexed column, as there are two rows written: one to the table itself, and one to the index. The performance benefit of an index and reduction in rows read will, in nearly all cases, offset this additional write.\n7. Storage is based on gigabytes stored per month, and is based on the sum of all databases in your account. Tables and indexes both count towards storage consumed.\n8. Free limits reset daily at 00:00 UTC. Monthly included limits reset based on your monthly subscription renewal date, which is determined by the day you first subscribed.\n9. There are no data transfer (egress) or throughput (bandwidth) charges for data accessed from D1.\n10. [Read replication](https://developers.cloudflare.com/d1/best-practices/read-replication/) does not charge extra for read replicas. You incur the same usage billing based on `rows_read` and `rows_written` by your queries.\n\nD1 billing\n\nRefer to [D1 Pricing](https://developers.cloudflare.com/d1/platform/pricing/) to learn more about how D1 is billed.\n\n## Durable Objects\n\nNote\n\nDurable Objects are available both on Workers Free and Workers Paid plans.\n\n* **Workers Free plan**: Only Durable Objects with [SQLite storage backend](https://developers.cloudflare.com/durable-objects/best-practices/access-durable-objects-storage/#wrangler-configuration-for-sqlite-backed-durable-objects) are available.\n* **Workers Paid plan**: Durable Objects with either SQLite storage backend or [key-value storage backend](https://developers.cloudflare.com/durable-objects/reference/durable-objects-migrations/#create-durable-object-class-with-key-value-storage) are available.\n\nIf you wish to downgrade from a Workers Paid plan to a Workers Free plan, you must first ensure that you have deleted all Durable Object namespaces with the key-value storage backend.\n\n### Compute billing\n\nDurable Objects are billed for duration while the Durable Object is active and running in memory. Requests to a Durable Object keep it active or creates the object if it was inactive, not in memory.\n\n| | Free plan | Paid plan |\n| - | - | - |\n| Requests | 100,000 / day | 1 million, + $0.15/million Includes HTTP requests, RPC sessions1, WebSocket messages2, and alarm invocations |\n| Duration3 | 13,000 GB-s / day | 400,000 GB-s, + $12.50/million GB-s4,5 |\n\nFootnotes\n\n1 Each [RPC session](https://developers.cloudflare.com/workers/runtime-apis/rpc/lifecycle/) is billed as one request to your Durable Object. Every [RPC method call](https://developers.cloudflare.com/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/) on a [Durable Objects stub](https://developers.cloudflare.com/durable-objects/) is its own RPC session and therefore a single billed request.\n\nRPC method calls can return objects (stubs) extending [`RpcTarget`](https://developers.cloudflare.com/workers/runtime-apis/rpc/lifecycle/#lifetimes-memory-and-resource-management) and invoke calls on those stubs. Subsequent calls on the returned stub are part of the same RPC session and are not billed as separate requests. For example:",
      "language": "unknown"
    },
    {
      "code": "2 A request is needed to create a WebSocket connection. There is no charge for outgoing WebSocket messages, nor for incoming [WebSocket protocol pings](https://www.rfc-editor.org/rfc/rfc6455#section-5.5.2). For compute requests billing-only, a 20:1 ratio is applied to incoming WebSocket messages to factor in smaller messages for real-time communication. For example, 100 WebSocket incoming messages would be charged as 5 requests for billing purposes. The 20:1 ratio does not affect Durable Object metrics and analytics, which reflect actual usage.\n\n3 Application level auto-response messages handled by [`state.setWebSocketAutoResponse()`](https://developers.cloudflare.com/durable-objects/best-practices/websockets/) will not incur additional wall-clock time, and so they will not be charged.\n\n4 Duration is billed in wall-clock time as long as the Object is active, but is shared across all requests active on an Object at once. Calling `accept()` on a WebSocket in an Object will incur duration charges for the entire time the WebSocket is connected. It is recommended to use the WebSocket Hibernation API to avoid incurring duration charges once all event handlers finish running. For a complete explanation, refer to [When does a Durable Object incur duration charges?](https://developers.cloudflare.com/durable-objects/platform/pricing/#when-does-a-durable-object-incur-duration-charges).\n\n5 Duration billing charges for the 128 MB of memory your Durable Object is allocated, regardless of actual usage. If your account creates many instances of a single Durable Object class, Durable Objects may run in the same isolate on the same physical machine and share the 128 MB of memory. These Durable Objects are still billed as if they are allocated a full 128 MB of memory.\n\n### Storage billing\n\nThe [Durable Objects Storage API](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/) is only accessible from within Durable Objects. Pricing depends on the storage backend of your Durable Objects.\n\n* **SQLite-backed Durable Objects (recommended)**: [SQLite storage backend](https://developers.cloudflare.com/durable-objects/best-practices/access-durable-objects-storage/#create-sqlite-backed-durable-object-class) is recommended for all new Durable Object classes. Workers Free plan can only create and access SQLite-backed Durable Objects.\n* **Key-value backed Durable Objects**: [Key-value storage backend](https://developers.cloudflare.com/durable-objects/reference/durable-objects-migrations/#create-durable-object-class-with-key-value-storage) is only available on the Workers Paid plan.\n\n#### SQLite storage backend\n\nStorage billing on SQLite-backed Durable Objects\n\nStorage billing for SQLite-backed Durable Objects will be enabled in January 2026, with a target date of January 7, 2026 (no earlier). Only SQLite storage usage on and after the billing target date will incur charges. For more information, refer to [Billing for SQLite Storage](https://developers.cloudflare.com/changelog/2025-12-12-durable-objects-sqlite-storage-billing/).\n\n| | Workers Free plan | Workers Paid plan |\n| - | - | - |\n| Rows reads 1,2 | 5 million / day | First 25 billion / month included + $0.001 / million rows |\n| Rows written 1,2,3,4 | 100,000 / day | First 50 million / month included + $1.00 / million rows |\n| SQL Stored data 5 | 5 GB (total) | 5 GB-month, + $0.20/ GB-month |\n\nFootnotes\n\n1 Rows read and rows written included limits and rates match [D1 pricing](https://developers.cloudflare.com/d1/platform/pricing/), Cloudflare's serverless SQL database.\n\n2 Key-value methods like `get()`, `put()`, `delete()`, or `list()` store and query data in a hidden SQLite table and are billed as rows read and rows written.\n\n3 Each `setAlarm()` is billed as a single row written.\n\n4 Deletes are counted as rows written.\n\n5 Durable Objects will be billed for stored data until the [data is removed](https://developers.cloudflare.com/durable-objects/best-practices/access-durable-objects-storage/#remove-a-durable-objects-storage). Once the data is removed, the object will be cleaned up automatically by the system.\n\n#### Key-value storage backend\n\n| | Workers Paid plan |\n| - | - |\n| Read request units1,2 | 1 million, + $0.20/million |\n| Write request units3 | 1 million, + $1.00/million |\n| Delete requests4 | 1 million, + $1.00/million |\n| Stored data5 | 1 GB, + $0.20/ GB-month |\n\nFootnotes\n\n1 A request unit is defined as 4 KB of data read or written. A request that writes or reads more than 4 KB will consume multiple units, for example, a 9 KB write will consume 3 write request units.\n\n2 List operations are billed by read request units, based on the amount of data examined. For example, a list request that returns a combined 80 KB of keys and values will be billed 20 read request units. A list request that does not return anything is billed for 1 read request unit.\n\n3 Each `setAlarm` is billed as a single write request unit.\n\n4 Delete requests are unmetered. For example, deleting a 100 KB value will be charged one delete request.\n\n5 Durable Objects will be billed for stored data until the data is removed. Once the data is removed, the object will be cleaned up automatically by the system.\n\nRequests that hit the [Durable Objects in-memory cache](https://developers.cloudflare.com/durable-objects/reference/in-memory-state/) or that use the [multi-key versions of `get()`/`put()`/`delete()` methods](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/) are billed the same as if they were a normal, individual request for each key.\n\nDurable Objects billing examples\n\nFor more information and [examples of Durable Objects billing](https://developers.cloudflare.com/durable-objects/platform/pricing#compute-billing-examples), refer to [Durable Objects Pricing](https://developers.cloudflare.com/durable-objects/platform/pricing/).\n\n## Vectorize\n\nVectorize is currently only available on the Workers paid plan.\n\n| | [Workers Free](https://developers.cloudflare.com/workers/platform/pricing/#workers) | [Workers Paid](https://developers.cloudflare.com/workers/platform/pricing/#workers) |\n| - | - | - |\n| **Total queried vector dimensions** | 30 million queried vector dimensions / month | First 50 million queried vector dimensions / month included + $0.01 per million |\n| **Total stored vector dimensions** | 5 million stored vector dimensions | First 10 million stored vector dimensions + $0.05 per 100 million |\n\n### Calculating vector dimensions\n\nTo calculate your potential usage, calculate the queried vector dimensions and the stored vector dimensions, and multiply by the unit price. The formula is defined as `((queried vectors + stored vectors) * dimensions * ($0.01 / 1,000,000)) + (stored vectors * dimensions * ($0.05 / 100,000,000))`\n\n* For example, inserting 10,000 vectors of 768 dimensions each, and querying those 1,000 times per day (30,000 times per month) would be calculated as `((30,000 + 10,000) * 768) = 30,720,000` queried dimensions and `(10,000 * 768) = 7,680,000` stored dimensions (within the included monthly allocation)\n* Separately, and excluding the included monthly allocation, this would be calculated as `(30,000 + 10,000) * 768 * ($0.01 / 1,000,000) + (10,000 * 768 * ($0.05 / 100,000,000))` and sum to $0.31 per month.\n\n## Service bindings\n\nRequests made from your Worker to another worker via a [Service Binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/) do not incur additional request fees. This allows you to split apart functionality into multiple Workers, without incurring additional costs.\n\nFor example, if Worker A makes a subrequest to Worker B via a Service Binding, or calls an RPC method provided by Worker B via a Service Binding, this is billed as:\n\n* One request (for the initial invocation of Worker A)\n* The total amount of CPU time used across both Worker A and Worker B\n\nOnly available on Workers Standard pricing\n\nIf your Worker is on the deprecated Bundled or Unbound pricing plans, incoming requests from Service Bindings are charged the same as requests from the Internet. In the example above, you would be charged for two requests, one to Worker A, and one to Worker B.\n\n## Fine Print\n\nWorkers Paid plan is separate from any other Cloudflare plan (Free, Professional, Business) you may have. If you are an Enterprise customer, reach out to your account team to confirm pricing details.\n\nOnly requests that hit a Worker will count against your limits and your bill. Since Cloudflare Workers runs before the Cloudflare cache, the caching of a request still incurs costs. Refer to [Limits](https://developers.cloudflare.com/workers/platform/limits/) to review definitions and behavior after a limit is hit.\n\n</page>\n\n<page>\n---\ntitle: Choosing a data or storage product. · Cloudflare Workers docs\ndescription: Storage and database options available on Cloudflare's developer platform.\nlastUpdated: 2025-11-12T15:17:36.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/platform/storage-options/\n  md: https://developers.cloudflare.com/workers/platform/storage-options/index.md\n---\n\nThis guide describes the storage & database products available as part of Cloudflare Workers, including recommended use-cases and best practices.\n\n## Choose a storage product\n\nThe following table maps our storage & database products to common industry terms as well as recommended use-cases:\n\n| Use-case | Product | Ideal for |\n| - | - | - |\n| Key-value storage | [Workers KV](https://developers.cloudflare.com/kv/) | Configuration data, service routing metadata, personalization (A/B testing) |\n| Object storage / blob storage | [R2](https://developers.cloudflare.com/r2/) | User-facing web assets, images, machine learning and training datasets, analytics datasets, log and event data. |\n| Accelerate a Postgres or MySQL database | [Hyperdrive](https://developers.cloudflare.com/hyperdrive/) | Connecting to an existing database in a cloud or on-premise using your existing database drivers & ORMs. |\n| Global coordination & stateful serverless | [Durable Objects](https://developers.cloudflare.com/durable-objects/) | Building collaborative applications; global coordination across clients; real-time WebSocket applications; strongly consistent, transactional storage. |\n| Lightweight SQL database | [D1](https://developers.cloudflare.com/d1/) | Relational data, including user profiles, product listings and orders, and/or customer data. |\n| Task processing, batching and messaging | [Queues](https://developers.cloudflare.com/queues/) | Background job processing (emails, notifications, APIs), message queuing, and deferred tasks. |\n| Vector search & embeddings queries | [Vectorize](https://developers.cloudflare.com/vectorize/) | Storing [embeddings](https://developers.cloudflare.com/workers-ai/models/#text-embeddings) from AI models for semantic search and classification tasks. |\n| Streaming ingestion | [Pipelines](https://developers.cloudflare.com/pipelines/) | Streaming data ingestion and processing, including clickstream analytics, telemetry/log data, and structured data for querying |\n| Time-series metrics | [Analytics Engine](https://developers.cloudflare.com/analytics/analytics-engine/) | Write and query high-cardinality time-series data, usage metrics, and service-level telemetry using Workers and/or SQL. |\n\nApplications can build on multiple storage & database products: for example, using Workers KV for session data; R2 for large file storage, media assets and user-uploaded files; and Hyperdrive to connect to a hosted Postgres or MySQL database.\n\nPages Functions\n\nStorage options can also be used by your front-end application built with Cloudflare Pages. For more information on available storage options for Pages applications, refer to the [Pages Functions bindings documentation](https://developers.cloudflare.com/pages/functions/bindings/).\n\n## SQL database options\n\nThere are three options for SQL-based databases available when building applications with Workers.\n\n* **Hyperdrive** if you have an existing Postgres or MySQL database, require large (1TB, 100TB or more) single databases, and/or want to use your existing database tools. You can also connect Hyperdrive to database platforms like [PlanetScale](https://planetscale.com/) or [Neon](https://neon.tech/).\n* **D1** for lightweight, serverless applications that are read-heavy, have global users that benefit from D1's [read replication](https://developers.cloudflare.com/d1/best-practices/read-replication/), and do not require you to manage and maintain a traditional RDBMS.\n* **Durable Objects** for stateful serverless workloads, per-user or per-customer SQL state, and building distributed systems (D1 and Queues are built on Durable Objects) where Durable Object's [strict serializability](https://blog.cloudflare.com/durable-objects-easy-fast-correct-choose-three/) enables global ordering of requests and storage operations.\n\n### Session storage\n\nWe recommend using [Workers KV](https://developers.cloudflare.com/kv/) for storing session data, credentials (API keys), and/or configuration data. These are typically read at high rates (thousands of RPS or more), are not typically modified (within KV's 1 write RPS per unique key limit), and do not need to be immediately consistent.\n\nFrequently read keys benefit from KV's [internal cache](https://developers.cloudflare.com/kv/concepts/how-kv-works/), and repeated reads to these \"hot\" keys will typically see latencies in the 500µs to 10ms range.\n\nAuthentication frameworks like [OpenAuth](https://openauth.js.org/docs/storage/cloudflare/) use Workers KV as session storage when deployed to Cloudflare, and [Cloudflare Access](https://developers.cloudflare.com/cloudflare-one/access-controls/policies/) uses KV to securely store and distribute user credentials so that they can be validated as close to the user as possible and reduce overall latency.\n\n## Product overviews\n\n### Workers KV\n\nWorkers KV is an eventually consistent key-value data store that caches on the Cloudflare global network.\n\nIt is ideal for projects that require:\n\n* High volumes of reads and/or repeated reads to the same keys.\n* Low-latency global reads (typically within 10ms for hot keys)\n* Per-object time-to-live (TTL).\n* Distributed configuration and/or session storage.\n\nTo get started with KV:\n\n* Read how [KV works](https://developers.cloudflare.com/kv/concepts/how-kv-works/).\n* Create a [KV namespace](https://developers.cloudflare.com/kv/concepts/kv-namespaces/).\n* Review the [KV Runtime API](https://developers.cloudflare.com/kv/api/).\n* Learn about KV [Limits](https://developers.cloudflare.com/kv/platform/limits/).\n\n### R2\n\nR2 is S3-compatible blob storage that allows developers to store large amounts of unstructured data without egress fees associated with typical cloud storage services.\n\nIt is ideal for projects that require:\n\n* Storage for files which are infrequently accessed.\n* Large object storage (for example, gigabytes or more per object).\n* Strong consistency per object.\n* Asset storage for websites (refer to [caching guide](https://developers.cloudflare.com/r2/buckets/public-buckets/#caching))\n\nTo get started with R2:\n\n* Read the [Get started guide](https://developers.cloudflare.com/r2/get-started/).\n* Learn about R2 [Limits](https://developers.cloudflare.com/r2/platform/limits/).\n* Review the [R2 Workers API](https://developers.cloudflare.com/r2/api/workers/workers-api-reference/).\n\n### Durable Objects\n\nDurable Objects provide low-latency coordination and consistent storage for the Workers platform through global uniqueness and a transactional storage API.\n\n* Global Uniqueness guarantees that there will be a single instance of a Durable Object class with a given ID running at once, across the world. Requests for a Durable Object ID are routed by the Workers runtime to the Cloudflare data center that owns the Durable Object.\n\n* The transactional storage API provides strongly consistent key-value storage to the Durable Object. Each Object can only read and modify keys associated with that Object. Execution of a Durable Object is single-threaded, but multiple request events may still be processed out-of-order from how they arrived at the Object.\n\nIt is ideal for projects that require:\n\n* Real-time collaboration (such as a chat application or a game server).\n* Consistent storage.\n* Data locality.\n\nTo get started with Durable Objects:\n\n* Read the [introductory blog post](https://blog.cloudflare.com/introducing-workers-durable-objects/).\n* Review the [Durable Objects documentation](https://developers.cloudflare.com/durable-objects/).\n* Get started with [Durable Objects](https://developers.cloudflare.com/durable-objects/get-started/).\n* Learn about Durable Objects [Limits](https://developers.cloudflare.com/durable-objects/platform/limits/).\n\n### D1\n\n[D1](https://developers.cloudflare.com/d1/) is Cloudflare’s native serverless database. With D1, you can create a database by importing data or defining your tables and writing your queries within a Worker or through the API.\n\nD1 is ideal for:\n\n* Persistent, relational storage for user data, account data, and other structured datasets.\n* Use-cases that require querying across your data ad-hoc (using SQL).\n* Workloads with a high ratio of reads to writes (most web applications).\n\nTo get started with D1:\n\n* Read [the documentation](https://developers.cloudflare.com/d1)\n* Follow the [Get started guide](https://developers.cloudflare.com/d1/get-started/) to provision your first D1 database.\n* Review the [D1 Workers Binding API](https://developers.cloudflare.com/d1/worker-api/).\n\nNote\n\nIf your working data size exceeds 10 GB (the maximum size for a D1 database), consider splitting the database into multiple, smaller D1 databases.\n\n### Queues\n\nCloudflare Queues allows developers to send and receive messages with guaranteed delivery. It integrates with [Cloudflare Workers](https://developers.cloudflare.com/workers) and offers at-least once delivery, message batching, and does not charge for egress bandwidth.\n\nQueues is ideal for:\n\n* Offloading work from a request to schedule later.\n* Send data from Worker to Worker (inter-Service communication).\n* Buffering or batching data before writing to upstream systems, including third-party APIs or [Cloudflare R2](https://developers.cloudflare.com/queues/examples/send-errors-to-r2/).\n\nTo get started with Queues:\n\n* [Set up your first queue](https://developers.cloudflare.com/queues/get-started/).\n* Learn more [about how Queues works](https://developers.cloudflare.com/queues/reference/how-queues-works/).\n\n### Hyperdrive\n\nHyperdrive is a service that accelerates queries you make to MySQL and Postgres databases, making it faster to access your data from across the globe, irrespective of your users’ location.\n\nHyperdrive allows you to:\n\n* Connect to an existing database from Workers without connection overhead.\n* Cache frequent queries across Cloudflare's global network to reduce response times on highly trafficked content.\n* Reduce load on your origin database with connection pooling.\n\nTo get started with Hyperdrive:\n\n* [Connect Hyperdrive](https://developers.cloudflare.com/hyperdrive/get-started/) to your existing database.\n* Learn more [about how Hyperdrive speeds up your database queries](https://developers.cloudflare.com/hyperdrive/concepts/how-hyperdrive-works/).\n\n## Pipelines\n\nPipelines is a streaming ingestion service that allows you to ingest high volumes of real time data, without managing any infrastructure.\n\nPipelines allows you to:\n\n* Ingest data at extremely high throughput (tens of thousands of records per second or more)\n* Batch and write data directly to object storage, ready for querying\n* (Future) Transform and aggregate data during ingestion\n\nTo get started with Pipelines:\n\n* [Create a Pipeline](https://developers.cloudflare.com/pipelines/getting-started/) that can batch and write records to R2.\n\n### Analytics Engine\n\nAnalytics Engine is Cloudflare's time-series and metrics database that allows you to write unlimited-cardinality analytics at scale using a built-in API to write data points from Workers and query that data using SQL directly.\n\nAnalytics Engine allows you to:\n\n* Expose custom analytics to your own customers\n* Build usage-based billing systems\n* Understand the health of your service on a per-customer or per-user basis\n* Add instrumentation to frequently called code paths, without impacting performance or overwhelming external analytics systems with events\n\nCloudflare uses Analytics Engine internally to store and product per-product metrics for products like D1 and R2 at scale.\n\nTo get started with Analytics Engine:\n\n* Learn how to [get started with Analytics Engine](https://developers.cloudflare.com/analytics/analytics-engine/get-started/)\n* See [an example of writing time-series data to Analytics Engine](https://developers.cloudflare.com/analytics/analytics-engine/recipes/usage-based-billing-for-your-saas-product/)\n* Understand the [SQL API](https://developers.cloudflare.com/analytics/analytics-engine/sql-api/) for reading data from your Analytics Engine datasets\n\n### Vectorize\n\nVectorize is a globally distributed vector database that enables you to build full-stack, AI-powered applications with Cloudflare Workers and [Workers AI](https://developers.cloudflare.com/workers-ai/).\n\nVectorize allows you to:\n\n* Store embeddings from any vector embeddings model (Bring Your Own embeddings) for semantic search and classification tasks.\n* Add context to Large Language Model (LLM) queries by using vector search as part of a [Retrieval Augmented Generation](https://developers.cloudflare.com/workers-ai/guides/tutorials/build-a-retrieval-augmented-generation-ai/) (RAG) workflow.\n* [Filter on vector metadata](https://developers.cloudflare.com/vectorize/reference/metadata-filtering/) to reduce the search space and return more relevant results.\n\nTo get started with Vectorize:\n\n* [Create your first vector database](https://developers.cloudflare.com/vectorize/get-started/intro/).\n* Combine [Workers AI and Vectorize](https://developers.cloudflare.com/vectorize/get-started/embeddings/) to generate, store and query text embeddings.\n* Learn more about [how vector databases work](https://developers.cloudflare.com/vectorize/reference/what-is-a-vector-database/).\n\n## SQL in Durable Objects vs D1\n\nCloudflare Workers offers a SQLite-backed serverless database product - [D1](https://developers.cloudflare.com/d1/). How should you compare [SQLite in Durable Objects](https://developers.cloudflare.com/durable-objects/best-practices/access-durable-objects-storage/) and D1?\n\n**D1 is a managed database product.**\n\nD1 fits into a familiar architecture for developers, where application servers communicate with a database over the network. Application servers are typically Workers; however, D1 also supports external, non-Worker access via an [HTTP API](https://developers.cloudflare.com/api/resources/d1/subresources/database/methods/query/), which helps unlock [third-party tooling](https://developers.cloudflare.com/d1/reference/community-projects/#_top) support for D1.\n\nD1 aims for a \"batteries included\" feature set, including the above HTTP API, [database schema management](https://developers.cloudflare.com/d1/reference/migrations/#_top), [data import/export](https://developers.cloudflare.com/d1/best-practices/import-export-data/), and [database query insights](https://developers.cloudflare.com/d1/observability/metrics-analytics/#query-insights).\n\nWith D1, your application code and SQL database queries are not colocated which can impact application performance. If performance is a concern with D1, Workers has [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement/#_top) to dynamically run your Worker in the best location to reduce total Worker request latency, considering everything your Worker talks to, including D1.\n\n**SQLite in Durable Objects is a lower-level compute with storage building block for distributed systems.**\n\nBy design, Durable Objects are accessed with Workers-only.\n\nDurable Objects require a bit more effort, but in return, give you more flexibility and control. With Durable Objects, you must implement two pieces of code that run in different places: a front-end Worker which routes incoming requests from the Internet to a unique Durable Object, and the Durable Object itself, which runs on the same machine as the SQLite database. You get to choose what runs where, and it may be that your application benefits from running some application business logic right next to the database.\n\nWith SQLite in Durable Objects, you may also need to build some of your own database tooling that comes out-of-the-box with D1.\n\nSQL query pricing and limits are intended to be identical between D1 ([pricing](https://developers.cloudflare.com/d1/platform/pricing/), [limits](https://developers.cloudflare.com/d1/platform/limits/)) and SQLite in Durable Objects ([pricing](https://developers.cloudflare.com/durable-objects/platform/pricing/#sql-storage-billing), [limits](https://developers.cloudflare.com/durable-objects/platform/limits/)).\n\n</page>\n\n<page>\n---\ntitle: Workers for Platforms · Cloudflare Workers docs\ndescription: Deploy custom code on behalf of your users or let your users\n  directly deploy their own code to your platform, managing infrastructure.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/platform/workers-for-platforms/\n  md: https://developers.cloudflare.com/workers/platform/workers-for-platforms/index.md\n---\n\nDeploy custom code on behalf of your users or let your users directly deploy their own code to your platform, managing infrastructure.\n\n</page>\n\n<page>\n---\ntitle: How the Cache works · Cloudflare Workers docs\ndescription: How Workers interacts with the Cloudflare cache.\nlastUpdated: 2025-05-28T19:12:24.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/reference/how-the-cache-works/\n  md: https://developers.cloudflare.com/workers/reference/how-the-cache-works/index.md\n---\n\nWorkers was designed and built on top of Cloudflare's global network to allow developers to interact directly with the Cloudflare cache. The cache can provide ephemeral, data center-local storage, as a convenient way to frequently access static or dynamic content.\n\nBy allowing developers to write to the cache, Workers provide a way to customize cache behavior on Cloudflare’s CDN. To learn about the benefits of caching, refer to the Learning Center’s article on [What is Caching?](https://www.cloudflare.com/learning/cdn/what-is-caching/).\n\nCloudflare Workers run before the cache but can also be utilized to modify assets once they are returned from the cache. Modifying assets returned from cache allows for the ability to sign or personalize responses while also reducing load on an origin and reducing latency to the end user by serving assets from a nearby location.\n\n## Interact with the Cloudflare Cache\n\nConceptually, there are two ways to interact with Cloudflare’s Cache using a Worker:\n\n* Call to [`fetch()`](https://developers.cloudflare.com/workers/runtime-apis/fetch/) in a Workers script. Requests proxied through Cloudflare are cached even without Workers according to a zone’s default or configured behavior (for example, static assets like files ending in `.jpg` are cached by default). Workers can further customize this behavior by:\n\n  * Setting Cloudflare cache rules (that is, operating on the `cf` object of a [request](https://developers.cloudflare.com/workers/runtime-apis/request/)).\n\n* Store responses using the [Cache API](https://developers.cloudflare.com/workers/runtime-apis/cache/) from a Workers script. This allows caching responses that did not come from an origin and also provides finer control by:\n\n  * Customizing cache behavior of any asset by setting headers such as `Cache-Control` on the response passed to `cache.put()`.\n\n  * Caching responses generated by the Worker itself through `cache.put()`.\n\nTiered caching\n\nThe Cache API is not compatible with tiered caching. To take advantage of tiered caching, use the [fetch API](https://developers.cloudflare.com/workers/runtime-apis/fetch/).\n\n### Single file purge assets cached by a worker\n\nWhen using single-file purge to purge assets cached by a Worker, make sure not to purge the end user URL. Instead, purge the URL that is in the `fetch` request. For example, you have a Worker that runs on `https://example.com/hello` and this Worker makes a `fetch` request to `https://notexample.com/hello`.\n\nAs far as cache is concerned, the asset in the `fetch` request (`https://notexample.com/hello`) is the asset that is cached. To purge it, you need to purge `https://notexample.com/hello`.\n\nPurging the end user URL, `https://example.com/hello`, will not work because that is not the URL that cache sees. You need to confirm in your Worker which URL you are actually fetching, so you can purge the correct asset.\n\nIn the previous example, `https://notexample.com/hello` is not proxied through Cloudflare. If `https://notexample.com/hello` was proxied ([orange-clouded](https://developers.cloudflare.com/dns/proxy-status/)) through Cloudflare, then you must own `notexample.com` and purge `https://notexample.com/hello` from the `notexample.com` zone.\n\nTo better understand the example, review the following diagram:",
      "language": "unknown"
    },
    {
      "code": "### Purge assets stored with the Cache API\n\nAssets stored in the cache through [Cache API](https://developers.cloudflare.com/workers/runtime-apis/cache/) operations can be purged in a couple of ways:\n\n* Call `cache.delete` within a Worker to invalidate the cache for the asset with a matching request variable.\n\n  * Assets purged in this way are only purged locally to the data center the Worker runtime was executed.\n\n* To purge an asset globally, use the standard [cache purge options](https://developers.cloudflare.com/cache/how-to/purge-cache/). Based on cache API implementation, not all cache purge endpoints function for purging assets stored by the Cache API.\n\n  * All assets on a zone can be purged by using the [Purge Everything](https://developers.cloudflare.com/cache/how-to/purge-cache/purge-everything/) cache operation. This purge will remove all assets associated with a Cloudflare zone from cache in all data centers regardless of the method set.\n\n  * [Cache Tags](https://developers.cloudflare.com/cache/how-to/purge-cache/purge-by-tags/#add-cache-tag-http-response-headers) can be added to requests dynamically in a Worker by calling `response.headers.append()` and appending `Cache-Tag` values dynamically to that request. Once set, those tags can be used to selectively purge assets from cache without invalidating all cached assets on a zone.\n\n* Currently, it is not possible to purge a URL stored through Cache API that uses a custom cache key set by a Worker. Instead, use a [custom key created via Cache Rules](https://developers.cloudflare.com/cache/how-to/cache-rules/settings/#cache-key). Alternatively, purge your assets using purge everything, purge by tag, purge by host or purge by prefix.\n\n## Edge versus browser caching\n\nThe browser cache is controlled through the `Cache-Control` header sent in the response to the client (the `Response` instance return from the handler). Workers can customize browser cache behavior by setting this header on the response.\n\nOther means to control Cloudflare’s cache that are not mentioned in this documentation include: Page Rules and Cloudflare cache settings. Refer to the [How to customize Cloudflare’s cache](https://developers.cloudflare.com/cache/concepts/customize-cache/) if you wish to avoid writing JavaScript with still some granularity of control.\n\nWhat should I use: the Cache API or fetch for caching objects on Cloudflare?\n\nFor requests where Workers are behaving as middleware (that is, Workers are sending a subrequest via `fetch`) it is recommended to use `fetch`. This is because preexisting settings are in place that optimize caching while preventing unintended dynamic caching. For projects where there is no backend (that is, the entire project is on Workers as in [Workers Sites](https://developers.cloudflare.com/workers/configuration/sites/start-from-scratch)) the Cache API is the only option to customize caching.\n\nThe asset will be cached under the hostname specified within the Worker's subrequest — not the Worker's own hostname. Therefore, in order to purge the cached asset, the purge will have to be performed for the hostname included in the Worker subrequest.\n\n### `fetch`\n\nIn the context of Workers, a [`fetch`](https://developers.cloudflare.com/workers/runtime-apis/fetch/) provided by the runtime communicates with the Cloudflare cache. First, `fetch` checks to see if the URL matches a different zone. If it does, it reads through that zone’s cache (or Worker). Otherwise, it reads through its own zone’s cache, even if the URL is for a non-Cloudflare site. Cache settings on `fetch` automatically apply caching rules based on your Cloudflare settings. `fetch` does not allow you to modify or inspect objects before they reach the cache, but does allow you to modify how it will cache.\n\nWhen a response fills the cache, the response header contains `CF-Cache-Status: HIT`. You can tell an object is attempting to cache if one sees the `CF-Cache-Status` at all.\n\nThis [template](https://developers.cloudflare.com/workers/examples/cache-using-fetch/) shows ways to customize Cloudflare cache behavior on a given request using fetch.\n\n### Cache API\n\nThe [Cache API](https://developers.cloudflare.com/workers/runtime-apis/cache/) can be thought of as an ephemeral key-value store, whereby the `Request` object (or more specifically, the request URL) is the key, and the `Response` is the value.\n\nThere are two types of cache namespaces available to the Cloudflare Cache:\n\n* **`caches.default`** – You can access the default cache (the same cache shared with `fetch` requests) by accessing `caches.default`. This is useful when needing to override content that is already cached, after receiving the response.\n* **`caches.open()`** – You can access a namespaced cache (separate from the cache shared with `fetch` requests) using `let cache = await caches.open(CACHE_NAME)`. Note that [`caches.open`](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open) is an async function, unlike `caches.default`.\n\nWhen to use the Cache API:\n\n* When you want to programmatically save and/or delete responses from a cache. For example, say an origin is responding with a `Cache-Control: max-age:0` header and cannot be changed. Instead, you can clone the `Response`, adjust the header to the `max-age=3600` value, and then use the Cache API to save the modified `Response` for an hour.\n\n* When you want to programmatically access a Response from a cache without relying on a `fetch` request. For example, you can check to see if you have already cached a `Response` for the `https://example.com/slow-response` endpoint. If so, you can avoid the slow request.\n\nThis [template](https://developers.cloudflare.com/workers/examples/cache-api/) shows ways to use the cache API. For limits of the cache API, refer to [Limits](https://developers.cloudflare.com/workers/platform/limits/#cache-api-limits).\n\nTiered caching and the Cache API\n\nCache API within Workers does not support tiered caching. Tiered Cache concentrates connections to origin servers so they come from a small number of data centers rather than the full set of network locations. Cache API is local to a data center, this means that `cache.match` does a lookup, `cache.put` stores a response, and `cache.delete` removes a stored response only in the cache of the data center that the Worker handling the request is in. Because these methods apply only to local cache, they will not work with tiered cache.\n\n## Related resources\n\n* [Cache API](https://developers.cloudflare.com/workers/runtime-apis/cache/)\n* [Customize cache behavior with Workers](https://developers.cloudflare.com/cache/interaction-cloudflare-products/workers/)\n\n</page>\n\n<page>\n---\ntitle: How Workers works · Cloudflare Workers docs\ndescription: The difference between the Workers runtime versus traditional\n  browsers and Node.js.\nlastUpdated: 2025-08-20T18:47:44.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/reference/how-workers-works/\n  md: https://developers.cloudflare.com/workers/reference/how-workers-works/index.md\n---\n\nThough Cloudflare Workers behave similarly to [JavaScript](https://www.cloudflare.com/learning/serverless/serverless-javascript/) in the browser or in Node.js, there are a few differences in how you have to think about your code. Under the hood, the Workers runtime uses the [V8 engine](https://www.cloudflare.com/learning/serverless/glossary/what-is-chrome-v8/) — the same engine used by Chromium and Node.js. The Workers runtime also implements many of the standard [APIs](https://developers.cloudflare.com/workers/runtime-apis/) available in most modern browsers.\n\nThe differences between JavaScript written for the browser or Node.js happen at runtime. Rather than running on an individual's machine (for example, [a browser application or on a centralized server](https://www.cloudflare.com/learning/serverless/glossary/client-side-vs-server-side/)), Workers functions run on [Cloudflare's global network](https://www.cloudflare.com/network) - a growing global network of thousands of machines distributed across hundreds of locations.\n\nEach of these machines hosts an instance of the Workers runtime, and each of those runtimes is capable of running thousands of user-defined applications. This guide will review some of those differences.\n\nFor more information, refer to the [Cloud Computing without Containers blog post](https://blog.cloudflare.com/cloud-computing-without-containers).\n\nThe three largest differences are: Isolates, Compute per Request, and Distributed Execution.\n\n## Isolates\n\n[V8](https://v8.dev) orchestrates isolates: lightweight contexts that provide your code with variables it can access and a safe environment to be executed within. You could even consider an isolate a sandbox for your function to run in.\n\nA single instance of the runtime can run hundreds or thousands of isolates, seamlessly switching between them. Each isolate's memory is completely isolated, so each piece of code is protected from other untrusted or user-written code on the runtime. Isolates are also designed to start very quickly. Instead of creating a virtual machine for each function, an isolate is created within an existing environment. This model eliminates the cold starts of the virtual machine model.\n\nUnlike other serverless providers which use [containerized processes](https://www.cloudflare.com/learning/serverless/serverless-vs-containers/) each running an instance of a language runtime, Workers pays the overhead of a JavaScript runtime once on the start of a container. Workers processes are able to run essentially limitless scripts with almost no individual overhead. Any given isolate can start around a hundred times faster than a Node process on a container or virtual machine. Notably, on startup isolates consume an order of magnitude less memory.\n\nTraditional architecture\n\nWorkers V8 isolates\n\nUser code\n\nProcess overhead\n\nA given isolate has its own scope, but isolates are not necessarily long-lived. An isolate may be spun down and evicted for a number of reasons:\n\n* Resource limitations on the machine.\n* A suspicious script - anything seen as trying to break out of the isolate sandbox.\n* Individual [resource limits](https://developers.cloudflare.com/workers/platform/limits/).\n\nBecause of this, it is generally advised that you not store mutable state in your global scope unless you have accounted for this contingency.\n\nIf you are interested in how Cloudflare handles security with the Workers runtime, you can [read more about how Isolates relate to Security and Spectre Threat Mitigation](https://developers.cloudflare.com/workers/reference/security-model/).\n\n## Compute per request\n\nMost Workers are a variation on the default Workers flow:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "For Workers written in [ES modules syntax](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/), when a request to your `*.workers.dev` subdomain or to your Cloudflare-managed domain is received by any of Cloudflare's data centers, the request invokes the [`fetch()` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) defined in your Worker code with the given request. You can respond to the request by returning a [`Response`](https://developers.cloudflare.com/workers/runtime-apis/response/) object.\n\n## Distributed execution\n\nIsolates are resilient and continuously available for the duration of a request, but in rare instances isolates may be evicted. When a Worker hits official [limits](https://developers.cloudflare.com/workers/platform/limits/) or when resources are exceptionally tight on the machine the request is running on, the runtime will selectively evict isolates after their events are properly resolved.\n\nLike all other JavaScript platforms, a single Workers instance may handle multiple requests including concurrent requests in a single-threaded event loop. That means that other requests may (or may not) be processed during awaiting any `async` tasks (such as `fetch`) if other requests come in while processing a request. Because there is no guarantee that any two user requests will be routed to the same or a different instance of your Worker, Cloudflare recommends you do not use or mutate global state.\n\n## Related resources\n\n* [`fetch()` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) - Review how incoming HTTP requests to a Worker are passed to the `fetch()` handler.\n* [Request](https://developers.cloudflare.com/workers/runtime-apis/request/) - Learn how incoming HTTP requests are passed to the `fetch()` handler.\n* [Workers limits](https://developers.cloudflare.com/workers/platform/limits/) - Learn about Workers limits including Worker size, startup time, and more.\n\n</page>\n\n<page>\n---\ntitle: Migrate from Service Workers to ES Modules · Cloudflare Workers docs\ndescription: Write your Worker code in ES modules syntax for an optimized experience.\nlastUpdated: 2025-12-30T07:16:34.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/\n  md: https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/index.md\n---\n\nThis guide will show you how to migrate your Workers from the [Service Worker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) format to the [ES modules](https://blog.cloudflare.com/workers-javascript-modules/) format.\n\n## Advantages of migrating\n\nThere are several reasons to migrate your Workers to the ES modules format:\n\n1. Your Worker will run faster. With service workers, bindings are exposed as globals. This means that for every request, the Workers runtime must create a new JavaScript execution context, which adds overhead and time. Workers written using ES modules can reuse the same execution context across multiple requests.\n2. Implementing [Durable Objects](https://developers.cloudflare.com/durable-objects/) requires Workers that use ES modules.\n3. Bindings for [D1](https://developers.cloudflare.com/d1/), [Workers AI](https://developers.cloudflare.com/workers-ai/), [Vectorize](https://developers.cloudflare.com/vectorize/), [Workflows](https://developers.cloudflare.com/workflows/), and [Images](https://developers.cloudflare.com/images/transform-images/bindings/) can only be used from Workers that use ES modules.\n4. You can [gradually deploy changes to your Worker](https://developers.cloudflare.com/workers/configuration/versions-and-deployments/gradual-deployments/) when you use the ES modules format.\n5. You can easily publish Workers using ES modules to `npm`, allowing you to import and reuse Workers within your codebase.\n\n## Migrate a Worker\n\nThe following example demonstrates a Worker that redirects all incoming requests to a URL with a `301` status code.\n\nService Workers are deprecated\n\nService Workers are deprecated, but still supported. We recommend using [Module Workers](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) instead. New features may not be supported for Service Workers.\n\nWith the Service Worker syntax, the example Worker looks like:",
      "language": "unknown"
    },
    {
      "code": "Workers using ES modules format replace the `addEventListener` syntax with an object definition, which must be the file's default export (via `export default`). The previous example code becomes:",
      "language": "unknown"
    },
    {
      "code": "## Bindings\n\n[Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/) allow your Workers to interact with resources on the Cloudflare developer platform.\n\nWorkers using ES modules format do not rely on any global bindings. However, Service Worker syntax accesses bindings on the global scope.\n\nTo understand bindings, refer the following `TODO` KV namespace binding example. To create a `TODO` KV namespace binding, you will:\n\n1. Create a KV namespace named `My Tasks` and receive an ID that you will use in your binding.\n2. Create a Worker.\n3. Find your Worker's [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) and add a KV namespace binding:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "In the following sections, you will use your binding in Service Worker and ES modules format.\n\nReference KV from Durable Objects and Workers\n\nTo learn more about how to reference KV from Workers, refer to the [KV bindings documentation](https://developers.cloudflare.com/kv/concepts/kv-bindings/).\n\n### Bindings in Service Worker format\n\nIn Service Worker syntax, your `TODO` KV namespace binding is defined in the global scope of your Worker. Your `TODO` KV namespace binding is available to use anywhere in your Worker application's code.",
      "language": "unknown"
    },
    {
      "code": "### Bindings in ES modules format\n\nIn ES modules format, bindings are only available inside the `env` parameter that is provided at the entry point to your Worker.\n\nTo access the `TODO` KV namespace binding in your Worker code, the `env` parameter must be passed from the `fetch` handler in your Worker to the `getTodos` function.",
      "language": "unknown"
    },
    {
      "code": "The following code represents a `getTodos` function that calls the `get` function on the `TODO` KV binding.",
      "language": "unknown"
    },
    {
      "code": "## Environment variables\n\n[Environment variables](https://developers.cloudflare.com/workers/configuration/environment-variables/) are accessed differently in code written in ES modules format versus Service Worker format.\n\nReview the following example environment variable configuration in the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "### Environment variables in Service Worker format\n\nIn Service Worker format, the `API_ACCOUNT_ID` is defined in the global scope of your Worker application. Your `API_ACCOUNT_ID` environment variable is available to use anywhere in your Worker application's code.",
      "language": "unknown"
    },
    {
      "code": "### Environment variables in ES modules format\n\nIn ES modules format, environment variables are available through the `env` parameter provided at the entrypoint to your Worker application:",
      "language": "unknown"
    },
    {
      "code": "You can also import `env` from `cloudflare:workers` to access environment variables from anywhere in your code, including the top-level scope:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "This approach is useful for initializing configuration or accessing environment variables from deeply nested functions without passing `env` through every function call. For more details, refer to [Importing `env` as a global](https://developers.cloudflare.com/workers/runtime-apis/bindings/#importing-env-as-a-global).\n\n## Cron Triggers\n\nTo handle a [Cron Trigger](https://developers.cloudflare.com/workers/configuration/cron-triggers/) event in a Worker written with ES modules syntax, implement a [`scheduled()` event handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/scheduled/#syntax), which is the equivalent of listening for a `scheduled` event in Service Worker syntax.\n\nThis example code:",
      "language": "unknown"
    },
    {
      "code": "Then becomes:",
      "language": "unknown"
    },
    {
      "code": "## Access `event` or `context` data\n\nWorkers often need access to data not in the `request` object. For example, sometimes Workers use [`waitUntil`](https://developers.cloudflare.com/workers/runtime-apis/context/#waituntil) to delay execution. Workers using ES modules format can access `waitUntil` via the `context` parameter. Refer to [ES modules parameters](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/#parameters) for more information.\n\nThis example code:",
      "language": "unknown"
    },
    {
      "code": "Then becomes:",
      "language": "unknown"
    },
    {
      "code": "## Service Worker syntax\n\nA Worker written in Service Worker syntax consists of two parts:\n\n1. An event listener that listens for `FetchEvents`.\n2. An event handler that returns a [Response](https://developers.cloudflare.com/workers/runtime-apis/response/) object which is passed to the event’s `.respondWith()` method.\n\nWhen a request is received on one of Cloudflare’s global network servers for a URL matching a Worker, Cloudflare's server passes the request to the Workers runtime. This dispatches a `FetchEvent` in the [isolate](https://developers.cloudflare.com/workers/reference/how-workers-works/#isolates) where the Worker is running.",
      "language": "unknown"
    },
    {
      "code": "Below is an example of the request response workflow:\n\n1. An event listener for the `FetchEvent` tells the script to listen for any request coming to your Worker. The event handler is passed the `event` object, which includes `event.request`, a [`Request`](https://developers.cloudflare.com/workers/runtime-apis/request/) object which is a representation of the HTTP request that triggered the `FetchEvent`.\n\n2. The call to `.respondWith()` lets the Workers runtime intercept the request in order to send back a custom response (in this example, the plain text `'Hello worker!'`).\n\n   * The `FetchEvent` handler typically culminates in a call to the method `.respondWith()` with either a [`Response`](https://developers.cloudflare.com/workers/runtime-apis/response/) or `Promise<Response>` that determines the response.\n\n   * The `FetchEvent` object also provides [two other methods](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) to handle unexpected exceptions and operations that may complete after a response is returned.\n\nLearn more about [the lifecycle methods of the `fetch()` handler](https://developers.cloudflare.com/workers/runtime-apis/rpc/lifecycle/).\n\n### Supported `FetchEvent` properties\n\n* `event.type` string\n\n  * The type of event. This will always return `\"fetch\"`.\n\n* `event.request` Request\n\n  * The incoming HTTP request.\n\n* `event.respondWith(responseResponse|Promise)` : void\n\n  * Refer to [`respondWith`](#respondwith).\n\n* `event.waitUntil(promisePromise)` : void\n\n  * Refer to [`waitUntil`](#waituntil).\n\n* `event.passThroughOnException()` : void\n\n  * Refer to [`passThroughOnException`](#passthroughonexception).\n\n### `respondWith`\n\nIntercepts the request and allows the Worker to send a custom response.\n\nIf a `fetch` event handler does not call `respondWith`, the runtime delivers the event to the next registered `fetch` event handler. In other words, while not recommended, this means it is possible to add multiple `fetch` event handlers within a Worker.\n\nIf no `fetch` event handler calls `respondWith`, then the runtime forwards the request to the origin as if the Worker did not. However, if there is no origin – or the Worker itself is your origin server, which is always true for `*.workers.dev` domains – then you must call `respondWith` for a valid response.",
      "language": "unknown"
    },
    {
      "code": "### `waitUntil`\n\nThe `waitUntil` command extends the lifetime of the `\"fetch\"` event. It accepts a `Promise`-based task which the Workers runtime will execute before the handler terminates but without blocking the response. For example, this is ideal for [caching responses](https://developers.cloudflare.com/workers/runtime-apis/cache/#put) or handling logging.\n\nWith the Service Worker format, `waitUntil` is available within the `event` because it is a native `FetchEvent` property.\n\nWith the ES modules format, `waitUntil` is moved and available on the `context` parameter object.",
      "language": "unknown"
    },
    {
      "code": "### `passThroughOnException`\n\nThe `passThroughOnException` method prevents a runtime error response when the Worker throws an unhandled exception. Instead, the script will [fail open](https://community.microfocus.com/cyberres/b/sws-22/posts/security-fundamentals-part-1-fail-open-vs-fail-closed), which will proxy the request to the origin server as though the Worker was never invoked.\n\nTo prevent JavaScript errors from causing entire requests to fail on uncaught exceptions, `passThroughOnException()` causes the Workers runtime to yield control to the origin server.\n\nWith the Service Worker format, `passThroughOnException` is added to the `FetchEvent` interface, making it available within the `event`.\n\nWith the ES modules format, `passThroughOnException` is available on the `context` parameter object.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Protocols · Cloudflare Workers docs\ndescription: Supported protocols on the Workers platform.\nlastUpdated: 2025-12-17T00:24:18.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/reference/protocols/\n  md: https://developers.cloudflare.com/workers/reference/protocols/index.md\n---\n\nCloudflare Workers support the following protocols and interfaces:\n\n| Protocol | Inbound | Outbound |\n| - | - | - |\n| **HTTP / HTTPS** | Handle incoming HTTP requests using the [`fetch()` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) | Make HTTP subrequests using the [`fetch()` API](https://developers.cloudflare.com/workers/runtime-apis/fetch/) |\n| **Direct TCP sockets** | Support for handling inbound TCP connections is [coming soon](https://blog.cloudflare.com/workers-tcp-socket-api-connect-databases/) | Create outbound TCP connections using the [`connect()` API](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/) |\n| **WebSockets** | Accept incoming WebSocket connections using the [`WebSocket` API](https://developers.cloudflare.com/workers/runtime-apis/websockets/) | |\n| **HTTP/3 (QUIC)** | Accept inbound requests over [HTTP/3](https://www.cloudflare.com/learning/performance/what-is-http3/) by enabling it on your [zone](https://developers.cloudflare.com/fundamentals/concepts/accounts-and-zones/#zones) in **Speed** > **Settings** > **Protocol Optimization** area of the [Cloudflare dashboard](https://dash.cloudflare.com/). | |\n| **SMTP** | Use [Email Workers](https://developers.cloudflare.com/email-routing/email-workers/) to process and forward email, without having to manage TCP connections to SMTP email servers | [Email Workers](https://developers.cloudflare.com/email-routing/email-workers/) |\n\n</page>\n\n<page>\n---\ntitle: Security model · Cloudflare Workers docs\ndescription: \"This article includes an overview of Cloudflare security\n  architecture, and then addresses two frequently asked about issues: V8 bugs\n  and Spectre.\"\nlastUpdated: 2025-02-19T14:52:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/reference/security-model/\n  md: https://developers.cloudflare.com/workers/reference/security-model/index.md\n---\n\nThis article includes an overview of Cloudflare security architecture, and then addresses two frequently asked about issues: V8 bugs and Spectre.\n\nSince the very start of the Workers project, security has been a high priority — there was a concern early on that when hosting a large number of tenants on shared infrastructure, side channels of various kinds would pose a threat. The Cloudflare Workers runtime is carefully designed to defend against side channel attacks.\n\nTo this end, Workers is designed to make it impossible for code to measure its own execution time locally. For example, the value returned by `Date.now()` is locked in place while code is executing. No other timers are provided. Moreover, Cloudflare provides no access to concurrency (for example, multi-threading), as it could allow attackers to construct ad hoc timers. These design choices cannot be introduced retroactively into other platforms — such as web browsers — because they remove APIs that existing applications depend on. They were possible in Workers only because of runtime design choices from the start.\n\nWhile these early design decisions have proven effective, Cloudflare is continuing to add defense-in-depth, including techniques to disrupt attacks by rescheduling Workers to create additional layers of isolation between suspicious Workers and high-value Workers.\n\nThe Workers approach is very different from the approach taken by most of the industry. It is resistant to the entire range of [Spectre-style attacks](https://www.cloudflare.com/learning/security/threats/meltdown-spectre/), without requiring special attention paid to each one and without needing to block speculation in general. However, because the Workers approach is different, it requires careful study. Cloudflare is currently working with researchers at Graz University of Technology (TU Graz) to study what has been done. These researchers include some of the people who originally discovered Spectre. Cloudflare will publish the results of this research as they becomes available.\n\nFor more details, refer to [this talk](https://www.infoq.com/presentations/cloudflare-v8/) by Kenton Varda, architect of Cloudflare Workers. Spectre is covered near the end.\n\n## Architectural overview\n\nBeginning with a quick overview of the Workers runtime architecture:\n\nThere are two fundamental parts of designing a code sandbox: secure isolation and API design.\n\n### Isolation\n\nFirst, a secure execution environment needed to be created wherein code cannot access anything it is not supposed to.\n\nFor this, the primary tool is V8, the JavaScript engine developed by Google for use in Chrome. V8 executes code inside isolates, which prevent that code from accessing memory outside the isolate — even within the same process. Importantly, this means Cloudflare can run many isolates within a single process. This is essential for an edge compute platform like Workers where Cloudflare must host many thousands of guest applications on every machine and rapidly switch between these guests thousands of times per second with minimal overhead. If Cloudflare had to run a separate process for every guest, the number of tenants Cloudflare could support would be drastically reduced, and Cloudflare would have to limit edge compute to a small number of big Enterprise customers. With isolate technology, Cloudflare can make edge compute available to everyone.\n\nSometimes, though, Cloudflare does decide to schedule a Worker in its own private process. Cloudflare does this if the Worker uses certain features that needs an extra layer of isolation. For example, when a developer uses the devtools debugger to inspect their Worker, Cloudflare runs that Worker in a separate process. This is because historically, in the browser, the inspector protocol has only been usable by the browser’s trusted operator, and therefore has not received as much security scrutiny as the rest of V8. In order to hedge against the increased risk of bugs in the inspector protocol, Cloudflare moves inspected Workers into a separate process with a process-level sandbox. Cloudflare also uses process isolation as an extra defense against Spectre.\n\nAdditionally, even for isolates that run in a shared process with other isolates, Cloudflare runs multiple instances of the whole runtime on each machine, which is called cordons. Workers are distributed among cordons by assigning each Worker a level of trust and separating low-trusted Workers from those trusted more highly. As one example of this in operation: a customer who signs up for the Free plan will not be scheduled in the same process as an Enterprise customer. This provides some defense-in-depth in the case a zero-day security vulnerability is found in V8.\n\nAt the whole-process level, Cloudflare applies another layer of sandboxing for defense in depth. The layer 2 sandbox uses Linux namespaces and `seccomp` to prohibit all access to the filesystem and network. Namespaces and `seccomp` are commonly used to implement containers. However, Cloudflare's use of these technologies is much stricter than what is usually possible in container engines, because Cloudflare configures namespaces and `seccomp` after the process has started but before any isolates have been loaded. This means, for example, Cloudflare can (and does) use a totally empty filesystem (mount namespace) and uses `seccomp` to block absolutely all filesystem-related system calls. Container engines cannot normally prohibit all filesystem access because doing so would make it impossible to use `exec()` to start the guest program from disk. In the Workers case, Cloudflare's guest programs are not native binaries and the Workers runtime itself has already finished loading before Cloudflare blocks filesystem access.\n\nThe layer 2 sandbox also totally prohibits network access. Instead, the process is limited to communicating only over local UNIX domain sockets to talk to other processes on the same system. Any communication to the outside world must be mediated by some other local process outside the sandbox.\n\nOne such process in particular, which is called the supervisor, is responsible for fetching Worker code and configuration from disk or from other internal services. The supervisor ensures that the sandbox process cannot read any configuration except that which is relevant to the Workers that it should be running.\n\nFor example, when the sandbox process receives a request for a Worker it has not seen before, that request includes the encryption key for that Worker’s code, including attached secrets. The sandbox can then pass that key to the supervisor in order to request the code. The sandbox cannot request any Worker for which it has not received the appropriate key. It cannot enumerate known Workers. It also cannot request configuration it does not need; for example, it cannot request the TLS key used for HTTPS traffic to the Worker.\n\nAside from reading configuration, the other reason for the sandbox to talk to other processes on the system is to implement APIs exposed to Workers.\n\n### API design\n\nThere is a saying: If a tree falls in the forest, but no one is there to hear it, does it make a sound? A Cloudflare saying: If a Worker executes in a fully-isolated environment in which it is totally prevented from communicating with the outside world, does it actually run?\n\nComplete code isolation is, in fact, useless. In order for Workers to do anything useful, they have to be allowed to communicate with users. At the very least, a Worker needs to be able to receive requests and respond to them. For Workers to send requests to the world safely, APIs are needed.\n\nIn the context of sandboxing, API design takes on a new level of responsibility. Cloudflare APIs define exactly what a Worker can and cannot do. Cloudflare must be very careful to design each API so that it can only express allowed operations and no more. For example, Cloudflare wants to allow Workers to make and receive HTTP requests, while not allowing them to be able to access the local filesystem or internal network services.\n\nCurrently, Workers does not allow any access to the local filesystem. Therefore, Cloudflare does not expose a filesystem API at all. No API means no access.\n\nBut, imagine if Workers did want to support local filesystem access in the future. How can that be done? Workers should not see the whole filesystem. Imagine, though, if each Worker had its own private directory on the filesystem where it can store whatever it wants.\n\nTo do this, Workers would use a design based on [capability-based security](https://en.wikipedia.org/wiki/Capability-based_security). Capabilities are a big topic, but in this case, what it would mean is that Cloudflare would give the Worker an object of type `Directory`, representing a directory on the filesystem. This object would have an API that allows creating and opening files and subdirectories, but does not permit traversing up the parent directory. Effectively, each Worker would see its private `Directory` as if it were the root of their own filesystem.\n\nHow would such an API be implemented? As described above, the sandbox process cannot access the real filesystem. Instead, file access would be mediated by the supervisor process. The sandbox talks to the supervisor using [Cap’n Proto RPC](https://capnproto.org/rpc.html), a capability-based RPC protocol. (Cap’n Proto is an open source project currently maintained by the Cloudflare Workers team.) This protocol makes it very easy to implement capability-based APIs, so that Cloudflare can strictly limit the sandbox to accessing only the files that belong to the Workers it is running.\n\nNow what about network access? Today, Workers are allowed to talk to the rest of the world only via HTTP — both incoming and outgoing. There is no API for other forms of network access, therefore it is prohibited; although, Cloudflare plans to support other protocols in the future.\n\nAs mentioned before, the sandbox process cannot connect directly to the network. Instead, all outbound HTTP requests are sent over a UNIX domain socket to a local proxy service. That service implements restrictions on the request. For example, it verifies that the request is either addressed to a public Internet service or to the Worker’s zone’s own origin server, not to internal services that might be visible on the local machine or network. It also adds a header to every request identifying the Worker from which it originates, so that abusive requests can be traced and blocked. Once everything is in order, the request is sent on to the Cloudflare network's HTTP caching layer and then out to the Internet.\n\nSimilarly, inbound HTTP requests do not go directly to the Workers runtime. They are first received by an inbound proxy service. That service is responsible for TLS termination (the Workers runtime never sees TLS keys), as well as identifying the correct Worker script to run for a particular request URL. Once everything is in order, the request is passed over a UNIX domain socket to the sandbox process.\n\n## V8 bugs and the patch gap\n\nEvery non-trivial piece of software has bugs and sandboxing technologies are no exception. Virtual machines, containers, and isolates — which Workers use — also have bugs.\n\nWorkers rely heavily on isolation provided by V8, the JavaScript engine built by Google for use in Chrome. This has pros and cons. On one hand, V8 is an extraordinarily complicated piece of technology, creating a wider attack surface than virtual machines. More complexity means more opportunities for something to go wrong. However, an extraordinary amount of effort goes into finding and fixing V8 bugs, owing to its position as arguably the most popular sandboxing technology in the world. Google regularly pays out 5-figure bounties to anyone finding a V8 sandbox escape. Google also operates fuzzing infrastructure that automatically finds bugs faster than most humans can. Google’s investment does a lot to minimize the danger of V8 zero-days — bugs that are found by malicious actors and not known to Google.\n\nBut, what happens after a bug is found and reported? V8 is open source, so fixes for security bugs are developed in the open and released to everyone at the same time. It is important that any patch be rolled out to production as fast as possible, before malicious actors can develop an exploit.\n\nThe time between publishing the fix and deploying it is known as the patch gap. Google previously [announced that Chrome’s patch gap had been reduced from 33 days to 15 days](https://www.zdnet.com/article/google-cuts-chrome-patch-gap-in-half-from-33-to-15-days/).\n\nFortunately, Cloudflare directly controls the machines on which the Workers runtime operates. Nearly the entire build and release process has been automated, so the moment a V8 patch is published, Cloudflare systems automatically build a new release of the Workers runtime and, after one-click sign-off from the necessary (human) reviewers, automatically push that release out to production.\n\nAs a result, the Workers patch gap is now under 24 hours. A patch published by V8’s team in Munich during their work day will usually be in production before the end of the US work day.\n\n## Spectre: Introduction\n\nThe V8 team at Google has stated that [V8 itself cannot defend against Spectre](https://arxiv.org/abs/1902.05178). Workers does not need to depend on V8 for this. The Workers environment presents many alternative approaches to mitigating Spectre.\n\n### What is it?\n\nSpectre is a class of attacks in which a malicious program can trick the CPU into speculatively performing computation using data that the program is not supposed to have access to. The CPU eventually realizes the problem and does not allow the program to see the results of the speculative computation. However, the program may be able to derive bits of the secret data by looking at subtle side effects of the computation, such as the effects on the cache.\n\nFor more information about Spectre, refer to the [Learning Center page on the topic](https://www.cloudflare.com/learning/security/threats/meltdown-spectre/).\n\n### Why does it matter for Workers?\n\nSpectre encompasses a wide variety of vulnerabilities present in modern CPUs. The specific vulnerabilities vary by architecture and model and it is likely that many vulnerabilities exist which have not yet been discovered.\n\nThese vulnerabilities are a problem for every cloud compute platform. Any time you have more than one tenant running code on the same machine, Spectre attacks are possible. However, the closer together the tenants are, the more difficult it can be to mitigate specific vulnerabilities. Many of the known issues can be mitigated at the kernel level (protecting processes from each other) or at the hypervisor level (protecting VMs), often with the help of CPU microcode updates and various defenses (many of which can come with serious performance impact).\n\nIn Cloudflare Workers, tenants are isolated from each other using V8 isolates — not processes nor VMs. This means that Workers cannot necessarily rely on OS or hypervisor patches to prevent Spectre. Workers need its own strategy.\n\n### Why not use process isolation?\n\nCloudflare Workers is designed to run your code in every single Cloudflare location.\n\nWorkers is designed to be a platform accessible to everyone. It needs to handle a huge number of tenants, where many tenants get very little traffic.\n\nCombine these two points and planning becomes difficult.\n\nA typical, non-edge serverless provider could handle a low-traffic tenant by sending all of that tenant’s traffic to a single machine, so that only one copy of the application needs to be loaded. If the machine can handle, say, a dozen tenants, that is plenty. That machine can be hosted in a massive data center with millions of machines, achieving economies of scale. However, this centralization incurs latency and worldwide bandwidth costs when the users are not nearby.\n\nWith Workers, on the other hand, every tenant, regardless of traffic level, currently runs in every Cloudflare location. And in the quest to get as close to the end user as possible, Cloudflare sometimes chooses locations that only have space for a limited number of machines. The net result is that Cloudflare needs to be able to host thousands of active tenants per machine, with the ability to rapidly spin up inactive ones on-demand. That means that each guest cannot take more than a couple megabytes of memory — hardly enough space for a call stack, much less everything else that a process needs.\n\nMoreover, Cloudflare need context switching to be computationally efficient. Many Workers resident in memory will only handle an event every now and then, and many Workers spend less than a fraction of a millisecond on any particular event. In this environment, a single core can easily find itself switching between thousands of different tenants every second. To handle one event, a significant amount of communication needs to happen between the guest application and its host, meaning still more switching and communications overhead. If each tenant lives in its own process, all this overhead is orders of magnitude larger than if many tenants live in a single process. When using strict process isolation in Workers, the CPU cost can easily be 10x what it is with a shared process.\n\nIn order to keep Workers inexpensive, fast, and accessible to everyone, Cloudflare needed to find a way to host multiple tenants in a single process.\n\n### There is no fix for Spectre\n\nSpectre does not have an official solution. Not even when using heavyweight virtual machines. Everyone is still vulnerable.\n\nThe industry encounters new Spectre attacks. Every couple months, researchers uncover a new Spectre vulnerability, CPU vendors release new microcode, and OS vendors release kernel patches. Everyone must continue updating.\n\nBut is it enough to merely deploy the latest patches?\n\nMore vulnerabilities exist but have not yet been publicized. To defend against Spectre, Cloudflare needed to take a different approach. It is not enough to block individual known vulnerabilities. Instead, entire classes of vulnerabilities must be addressed at once.\n\n### Building a defense\n\nIt is unlikely that any all-encompassing fix for Spectre will be found. However, the following thought experiment raises points to consider:\n\nFundamentally, all Spectre vulnerabilities use side channels to detect hidden processor state. Side channels, by definition, involve observing some non-deterministic behavior of a system. Conveniently, most software execution environments try hard to eliminate non-determinism, because non-deterministic execution makes applications unreliable.\n\nHowever, there are a few sorts of non-determinism that are still common. The most obvious among these is timing. The industry long ago gave up on the idea that a program should take the same amount of time every time it runs, because deterministic timing is fundamentally at odds with heuristic performance optimization. Most Spectre attacks focus on timing as a way to detect the hidden microarchitectural state of the CPU.\n\nSome have proposed that this can be solved by making timers inaccurate or adding random noise. However, it turns out that this does not stop attacks; it only makes them slower. If the timer tracks real time at all, then anything you can do to make it inaccurate can be overcome by running an attack multiple times and using statistics to filter out inconsistencies.\n\nMany security researchers see this as the end of the story. What good is slowing down an attack if the attack is still possible?\n\n### Cascading slow-downs\n\nHowever, measures that slow down an attack can be powerful.\n\nThe key insight is this: as an attack becomes slower, new techniques become practical to make it even slower still. The goal, then, is to chain together enough techniques that an attack becomes so slow as to be uninteresting.\n\nMuch of cryptography, after all, is technically vulnerable to brute force attacks — technically, with enough time, you can break it. But when the time required is thousands (or even billions) of years, this is a sufficient defense.\n\nWhat can be done to slow down Spectre attacks to the point of meaninglessness?\n\n## Freezing a Spectre attack\n\n### Step 0: Do not allow native code\n\nWorkers does not allow our customers to upload native-code binaries to run on the Cloudflare network — only JavaScript and WebAssembly. Many other languages, like Python, Rust, or even Cobol, can be compiled or transpiled to one of these two formats. Both are passed through V8 to convert these formats into true native code.\n\nThis, in itself, does not necessarily make Spectre attacks harder. However, this is presented as step 0 because it is fundamental to enabling the following steps.\n\nAccepting native code programs implies being beholden to an existing CPU architecture (typically, x86). In order to execute code with reasonable performance, it is usually necessary to run the code directly on real hardware, severely limiting the host’s control over how that execution plays out. For example, a kernel or hypervisor has no ability to prohibit applications from invoking the `CLFLUSH` instruction, an instruction [which is useful in side channel attacks](https://gruss.cc/files/flushflush.pdf) and almost nothing else.\n\nMoreover, supporting native code typically implies supporting whole existing operating systems and software stacks, which bring with them decades of expectations about how the architecture works under them. For example, x86 CPUs allow a kernel or hypervisor to disable the RDTSC instruction, which reads a high-precision timer. Realistically, though, disabling it will break many programs because they are implemented to use RDTSC any time they want to know the current time.\n\nSupporting native code would limit choice in future mitigation techniques. There is greater freedom in using an abstract intermediate format.\n\n### Step 1: Disallow timers and multi-threading\n\nIn Workers, you can get the current time using the JavaScript Date API by calling `Date.now()`. However, the time value returned is not the current time. `Date.now()` returns the time of the last I/O. It does not advance during code execution. For example, if an attacker writes:",
      "language": "unknown"
    },
    {
      "code": "The values of `start` and `end` will always be exactly the same. The attacker cannot use `Date` to measure the execution time of their code, which they would need to do to carry out an attack.\n\nNote\n\nThis measure was implemented in mid-2017, before Spectre was announced. This measure was implemented because Cloudflare was already concerned about side channel timing attacks. The Workers team has designed the system with side channels in mind.\n\nSimilarly, multi-threading and shared memory are not permitted in Workers. Everything related to the processing of one event happens on the same thread. Otherwise, one would be able to race threads in order to guess and check the underlying timer. Multiple Workers are not allowed to operate on the same request concurrently. For example, if you have installed a Cloudflare App on your zone which is implemented using Workers, and your zone itself also uses Workers, then a request to your zone may actually be processed by two Workers in sequence. These run in the same thread.\n\nAt this point, measuring code execution time locally is prevented. However, it can still be measured remotely. For example, the HTTP client that is sending a request to trigger the execution of the Worker can measure how long it takes for the Worker to respond. Such a measurement is likely to be very noisy, as it would have to traverse the Internet and incur general networking costs. Such noise can be overcome, in theory, by executing the attack many times and taking an average.\n\nNote\n\nIt has been suggested that if Workers reset its execution environment on every request, that Workers would be in a much safer position against timing attacks. Unfortunately, it is not so simple. The execution state could be stored in a client — not the Worker itself — allowing a Worker to resume its previous state on every new request.\n\nIn adversarial testing and with help from leading Spectre experts, Cloudflare has not been able to develop a remote timing attack that works in production. However, the lack of a working attack does not mean that Workers should stop building defenses. Instead, the Workers team is currently testing some more advanced measures.\n\n### Step 2: Dynamic process isolation\n\nIf an attack is possible at all, it would take a long time to run — hours at the very least, maybe as long as weeks. But once an attack has been running even for a second, there is a large amount of new data that can be used to trigger further measures.\n\nSpectre attacks exhibit abnormal behavior that would not usually be seen in a normal program. These attacks intentionally try to create pathological performance scenarios in order to amplify microarchitectural effects. This is especially true when the attack has already been forced to run billions of times in a loop in order to overcome other mitigations, like those discussed above. This tends to show up in metrics like CPU performance counters.\n\nNow, the usual problem with using performance metrics to detect Spectre attacks is that there are sometimes false positives. Sometimes, a legitimate program behaves poorly. The runtime cannot shut down every application that has poor performance.\n\nInstead, the runtime chooses to reschedule any Worker with suspicious performance metrics into its own process. As described above, the runtime cannot do this with every Worker because the overhead would be too high. However, it is acceptable to isolate a few Worker processes as a defense mechanism. If the Worker is legitimate, it will keep operating, with a little more overhead. Fortunately, Cloudflare can relocate a Worker into its own process at basically any time.\n\nIn fact, elaborate performance-counter based triggering may not even be necessary here. If a Worker uses a large amount of CPU time per event, then the overhead of isolating it in its own process is relatively less because it switches context less often. So, the runtime might as well use process isolation for any Worker that is CPU-hungry.\n\nOnce a Worker is isolated, Cloudflare can rely on the operating system’s Spectre defenses, as most desktop web browsers do.\n\nCloudflare has been working with the experts at Graz Technical University to develop this approach. TU Graz’s team co-discovered Spectre itself and has been responsible for a huge number of the follow-on discoveries since then. Cloudflare has developed the ability to dynamically isolate Workers and has identified metrics which reliably detect attacks.\n\nAs mentioned previously, process isolation is not a complete defense. Over time, Spectre attacks tend to be slower to carry out which means Cloudflare has the ability to reasonably guess and identify malicious actors. Isolating the process further slows down the potential attack.\n\n### Step 3: Periodic whole-memory shuffling\n\nAt this point, all known attacks have been prevented. This leaves Workers susceptible to unknown attacks in the future, as with all other CPU-based systems. However, all new attacks will generally be very slow, taking days or longer, leaving Cloudflare with time to prepare a defense.\n\nFor example, it is within reason to restart the entire Workers runtime on a daily basis. This will reset the locations of everything in memory, forcing attacks to restart the process of discovering the locations of secrets. Cloudflare can also reschedule Workers across physical machines or cordons, so that the window to attack any particular neighbor is limited.\n\nIn general, because Workers are fundamentally preemptible (unlike containers or VMs), Cloudflare has a lot of freedom to frustrate attacks.\n\nCloudflare sees this as an ongoing investment — not something that will ever be done.\n\n</page>\n\n<page>\n---\ntitle: Cache · Cloudflare Workers docs\ndescription: Control reading and writing from the Cloudflare global network cache.\nlastUpdated: 2025-10-23T17:17:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/cache/\n  md: https://developers.cloudflare.com/workers/runtime-apis/cache/index.md\n---\n\n## Background\n\nThe [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) allows fine grained control of reading and writing from the [Cloudflare global network](https://www.cloudflare.com/network/) cache.\n\nThe Cache API is available globally but the contents of the cache do not replicate outside of the originating data center. A `GET /users` response can be cached in the originating data center, but will not exist in another data center unless it has been explicitly created.\n\nTiered caching\n\nThe `cache.put` method is not compatible with tiered caching. Refer to [Cache API](https://developers.cloudflare.com/workers/reference/how-the-cache-works/#cache-api) for more information. To perform tiered caching, use the [fetch API](https://developers.cloudflare.com/workers/reference/how-the-cache-works/#interact-with-the-cloudflare-cache).\n\nWorkers deployed to custom domains have access to functional `cache` operations. So do [Pages functions](https://developers.cloudflare.com/pages/functions/), whether attached to custom domains or `*.pages.dev` domains.\n\nHowever, any Cache API operations in the Cloudflare Workers dashboard editor and [Playground](https://developers.cloudflare.com/workers/playground/) previews will have no impact. For Workers fronted by [Cloudflare Access](https://www.cloudflare.com/teams/access/), the Cache API is not currently available.\n\nNote\n\nThis individualized zone cache object differs from Cloudflare’s Global CDN. For details, refer to [How the cache works](https://developers.cloudflare.com/workers/reference/how-the-cache-works/).\n\n***\n\n## Accessing Cache\n\nThe `caches.default` API is strongly influenced by the web browsers’ Cache API, but there are some important differences. For instance, Cloudflare Workers runtime exposes a single global cache object.",
      "language": "unknown"
    },
    {
      "code": "You may create and manage additional Cache instances via the [`caches.open`](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage/open) method.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nWhen using the cache API, avoid overriding the hostname in cache requests, as this can lead to unnecessary DNS lookups and cache inefficiencies. Always use the hostname that matches the domain associated with your Worker.",
      "language": "unknown"
    },
    {
      "code": "***\n\n## Headers\n\nOur implementation of the Cache API respects the following HTTP headers on the response passed to `put()`:\n\n* `Cache-Control`\n  * Controls caching directives. This is consistent with [Cloudflare Cache-Control Directives](https://developers.cloudflare.com/cache/concepts/cache-control#cache-control-directives). Refer to [Edge TTL](https://developers.cloudflare.com/cache/how-to/configure-cache-status-code#edge-ttl) for a list of HTTP response codes and their TTL when `Cache-Control` directives are not present.\n* `Cache-Tag`\n  * Allows resource purging by tag(s) later.\n* `ETag`\n  * Allows `cache.match()` to evaluate conditional requests with `If-None-Match`.\n* `Expires` string\n  * A string that specifies when the resource becomes invalid.\n* `Last-Modified`\n  * Allows `cache.match()` to evaluate conditional requests with `If-Modified-Since`.\n\nThis differs from the web browser Cache API as they do not honor any headers on the request or response.\n\nNote\n\nResponses with `Set-Cookie` headers are never cached, because this sometimes indicates that the response contains unique data. To store a response with a `Set-Cookie` header, either delete that header or set `Cache-Control: private=Set-Cookie` on the response before calling `cache.put()`.\n\nUse the `Cache-Control` method to store the response without the `Set-Cookie` header.\n\n***\n\n## Methods\n\n### `Put`",
      "language": "unknown"
    },
    {
      "code": "* `put(request, response)` : Promise\n\n  * Attempts to add a response to the cache, using the given request as the key. Returns a promise that resolves to `undefined` regardless of whether the cache successfully stored the response.\n\nNote\n\nThe `stale-while-revalidate` and `stale-if-error` directives are not supported when using the `cache.put` or `cache.match` methods.\n\n#### Parameters\n\n* `request` string | Request\n\n  * Either a string or a [`Request`](https://developers.cloudflare.com/workers/runtime-apis/request/) object to serve as the key. If a string is passed, it is interpreted as the URL for a new Request object.\n\n* `response` Response\n\n  * A [`Response`](https://developers.cloudflare.com/workers/runtime-apis/response/) object to store under the given key.\n\n#### Invalid parameters\n\n`cache.put` will throw an error if:\n\n* The `request` passed is a method other than `GET`.\n* The `response` passed has a `status` of [`206 Partial Content`](https://www.webfx.com/web-development/glossary/http-status-codes/what-is-a-206-status-code/).\n* The `response` passed contains the header `Vary: *`. The value of the `Vary` header is an asterisk (`*`). Refer to the [Cache API specification](https://w3c.github.io/ServiceWorker/#cache-put) for more information.\n\n#### Errors\n\n`cache.put` returns a `413` error if `Cache-Control` instructs not to cache or if the response is too large.\n\n### `Match`",
      "language": "unknown"
    },
    {
      "code": "* `match(request, options)` : Promise`<Response | undefined>`\n\n  * Returns a promise wrapping the response object keyed to that request.\n\nNote\n\nThe `stale-while-revalidate` and `stale-if-error` directives are not supported when using the `cache.put` or `cache.match` methods.\n\n#### Parameters\n\n* `request` string | Request\n\n  * The string or [`Request`](https://developers.cloudflare.com/workers/runtime-apis/request/) object used as the lookup key. Strings are interpreted as the URL for a new `Request` object.\n\n* `options`\n\n  * Can contain one possible property: `ignoreMethod` (Boolean). When `true`, the request is considered to be a `GET` request regardless of its actual value.\n\nUnlike the browser Cache API, Cloudflare Workers do not support the `ignoreSearch` or `ignoreVary` options on `match()`. You can accomplish this behavior by removing query strings or HTTP headers at `put()` time.\n\nOur implementation of the Cache API respects the following HTTP headers on the request passed to `match()`:\n\n* `Range`\n\n  * Results in a `206` response if a matching response with a Content-Length header is found. Your Cloudflare cache always respects range requests, even if an `Accept-Ranges` header is on the response.\n\n* `If-Modified-Since`\n\n  * Results in a `304` response if a matching response is found with a `Last-Modified` header with a value before the time specified in `If-Modified-Since`.\n\n* `If-None-Match`\n\n  * Results in a `304` response if a matching response is found with an `ETag` header with a value that matches a value in `If-None-Match`.\n\nNote\n\n`cache.match()` never sends a subrequest to the origin. If no matching response is found in cache, the promise that `cache.match()` returns is fulfilled with `undefined`.\n\n#### Errors\n\n`cache.match` generates a `504` error response when the requested content is missing or expired. The Cache API does not expose this `504` directly to the Worker script, instead returning `undefined`. Nevertheless, the underlying `504` is still visible in Cloudflare Logs.\n\nIf you use Cloudflare Logs, you may see these `504` responses with the `RequestSource` of `edgeWorkerCacheAPI`. Again, these are expected if the cached asset was missing or expired. Note that `edgeWorkerCacheAPI` requests are already filtered out in other views, such as Cache Analytics. To filter out these requests or to filter requests by end users of your website only, refer to [Filter end users](https://developers.cloudflare.com/analytics/graphql-api/features/filtering/#filter-end-users).\n\n### `Delete`",
      "language": "unknown"
    },
    {
      "code": "* `delete(request, options)` : Promise`<boolean>`\n\nDeletes the `Response` object from the cache and returns a `Promise` for a Boolean response:\n\n* `true`: The response was cached but is now deleted\n* `false`: The response was not in the cache at the time of deletion.\n\nGlobal purges\n\nThe `cache.delete` method only purges content of the cache in the data center that the Worker was invoked. For global purges, refer to [Purging assets stored with the Cache API](https://developers.cloudflare.com/workers/reference/how-the-cache-works/#purge-assets-stored-with-the-cache-api).\n\n#### Parameters\n\n* `request` string | Request\n\n  * The string or [`Request`](https://developers.cloudflare.com/workers/runtime-apis/request/) object used as the lookup key. Strings are interpreted as the URL for a new `Request` object.\n\n* `options` object\n\n  * Can contain one possible property: `ignoreMethod` (Boolean). Consider the request method a GET regardless of its actual value.\n\n***\n\n## Related resources\n\n* [How the cache works](https://developers.cloudflare.com/workers/reference/how-the-cache-works/)\n* [Example: Cache using `fetch()`](https://developers.cloudflare.com/workers/examples/cache-using-fetch/)\n* [Example: using the Cache API](https://developers.cloudflare.com/workers/examples/cache-api/)\n* [Example: caching POST requests](https://developers.cloudflare.com/workers/examples/cache-post-request/)\n\n</page>\n\n<page>\n---\ntitle: Bindings (env) · Cloudflare Workers docs\ndescription: Worker Bindings that allow for interaction with other Cloudflare Resources.\nlastUpdated: 2025-10-24T20:41:09.000Z\nchatbotDeprioritize: false\ntags: Bindings\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/bindings/\n  md: https://developers.cloudflare.com/workers/runtime-apis/bindings/index.md\n---\n\nBindings allow your Worker to interact with resources on the Cloudflare Developer Platform. Bindings provide better performance and less restrictions when accessing resources from Workers than the [REST APIs](https://developers.cloudflare.com/api/) which are intended for non-Workers applications.\n\nThe following bindings are available today:\n\n* [AI](https://developers.cloudflare.com/workers-ai/get-started/workers-wrangler/#2-connect-your-worker-to-workers-ai)\n* [Analytics Engine](https://developers.cloudflare.com/analytics/analytics-engine)\n* [Assets](https://developers.cloudflare.com/workers/static-assets/binding/)\n* [Browser Rendering](https://developers.cloudflare.com/browser-rendering)\n* [D1](https://developers.cloudflare.com/d1/worker-api/)\n* [Dispatcher (Workers for Platforms)](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/configuration/dynamic-dispatch/)\n* [Durable Objects](https://developers.cloudflare.com/durable-objects/api/)\n* [Dynamic Worker Loaders](https://developers.cloudflare.com/workers/runtime-apis/bindings/worker-loader/)\n* [Environment Variables](https://developers.cloudflare.com/workers/configuration/environment-variables/)\n* [Hyperdrive](https://developers.cloudflare.com/hyperdrive)\n* [Images](https://developers.cloudflare.com/images/transform-images/bindings/)\n* [KV](https://developers.cloudflare.com/kv/api/)\n* [mTLS](https://developers.cloudflare.com/workers/runtime-apis/bindings/mtls/)\n* [Queues](https://developers.cloudflare.com/queues/configuration/javascript-apis/)\n* [R2](https://developers.cloudflare.com/r2/api/workers/workers-api-reference/)\n* [Rate Limiting](https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/)\n* [Secrets](https://developers.cloudflare.com/workers/configuration/secrets/)\n* [Secrets Store](https://developers.cloudflare.com/secrets-store/integrations/workers/)\n* [Service bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/)\n* [Vectorize](https://developers.cloudflare.com/vectorize/reference/client-api/)\n* [Version metadata](https://developers.cloudflare.com/workers/runtime-apis/bindings/version-metadata/)\n* [Workflows](https://developers.cloudflare.com/workflows/)\n\n## What is a binding?\n\nWhen you declare a binding on your Worker, you grant it a specific capability, such as being able to read and write files to an [R2](https://developers.cloudflare.com/r2/) bucket. For example:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "You can think of a binding as a permission and an API in one piece. With bindings, you never have to add secret keys or tokens to your Worker in order to access resources on your Cloudflare account — the permission is embedded within the API itself. The underlying secret is never exposed to your Worker's code, and therefore can't be accidentally leaked.\n\n## Making changes to bindings\n\nWhen you deploy a change to your Worker, and only change its bindings (i.e. you don't change the Worker's code), Cloudflare may reuse existing isolates that are already running your Worker. This improves performance — you can change an environment variable or other binding without unnecessarily reloading your code.\n\nAs a result, you must be careful when \"polluting\" global scope with derivatives of your bindings. Anything you create there might continue to exist despite making changes to any underlying bindings. Consider an external client instance which uses a secret API key accessed from `env`: if you put this client instance in global scope and then make changes to the secret, a client instance using the original value might continue to exist. The correct approach would be to create a new client instance for each request.\n\nThe following is a good approach:",
      "language": "unknown"
    },
    {
      "code": "Compared to this alternative, which might have surprising and unwanted behavior:",
      "language": "unknown"
    },
    {
      "code": "If you have more advanced needs, explore the [AsyncLocalStorage API](https://developers.cloudflare.com/workers/runtime-apis/nodejs/asynclocalstorage/), which provides a mechanism for exposing values down to child execution handlers.\n\n## How to access `env`\n\nBindings are located on the `env` object, which can be accessed in several ways:\n\n* It is an argument to entrypoint handlers such as [`fetch`](https://developers.cloudflare.com/workers/runtime-apis/fetch/):",
      "language": "unknown"
    },
    {
      "code": "- It is as class property on [WorkerEntrypoint](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc/#bindings-env), [DurableObject](https://developers.cloudflare.com/durable-objects/), and [Workflow](https://developers.cloudflare.com/workflows/):",
      "language": "unknown"
    },
    {
      "code": "- It can be imported from `cloudflare:workers`:",
      "language": "unknown"
    },
    {
      "code": "### Importing `env` as a global\n\nImporting `env` from `cloudflare:workers` is useful when you need to access a binding such as [secrets](https://developers.cloudflare.com/workers/configuration/secrets/) or [environment variables](https://developers.cloudflare.com/workers/configuration/environment-variables/) in top-level global scope. For example, to initialize an API client:",
      "language": "unknown"
    },
    {
      "code": "Workers do not allow I/O from outside a request context. This means that even though `env` is accessible from the top-level scope, you will not be able to access every binding's methods.\n\nFor instance, environment variables and secrets are accessible, and you are able to call `env.NAMESPACE.get` to get a [Durable Object stub](https://developers.cloudflare.com/durable-objects/api/stub/) in the top-level context. However, calling methods on the Durable Object stub, making [calls to a KV store](https://developers.cloudflare.com/kv/api/), and [calling to other Workers](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings) will not work.",
      "language": "unknown"
    },
    {
      "code": "Additionally, importing `env` from `cloudflare:workers` lets you avoid passing `env` as an argument through many function calls if you need to access a binding from a deeply-nested function. This can be helpful in a complex codebase.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nWhile using `env` from `cloudflare:workers` may be simpler to write than passing it through a series of function calls, passing `env` as an argument is a helpful pattern for dependency injection and testing.\n\n### Overriding `env` values\n\nThe `withEnv` function provides a mechanism for overriding values of `env`.\n\nImagine a user has defined the [environment variable](https://developers.cloudflare.com/workers/configuration/environment-variables/) \"NAME\" to be \"Alice\" in their Wrangler configuration file and deployed a Worker. By default, logging `env.NAME` would print \"Alice\". Using the `withEnv` function, you can override the value of \"NAME\".",
      "language": "unknown"
    },
    {
      "code": "This can be useful when testing code that relies on an imported `env` object.\n\n</page>\n\n<page>\n---\ntitle: Console · Cloudflare Workers docs\ndescription: Supported methods of the `console` API in Cloudflare Workers\nlastUpdated: 2025-07-25T16:42:51.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/console/\n  md: https://developers.cloudflare.com/workers/runtime-apis/console/index.md\n---\n\nThe `console` object provides a set of methods to help you emit logs, warnings, and debug code.\n\nAll standard [methods of the `console` API](https://developer.mozilla.org/en-US/docs/Web/API/console) are present on the `console` object in Workers.\n\nHowever, some methods are no ops — they can be called, and do not emit an error, but do not do anything. This ensures compatibility with libraries which may use these APIs.\n\nThe table below enumerates each method, and the extent to which it is supported in Workers.\n\nAll methods noted as \"✅ supported\" have the following behavior:\n\n* They will be written to the console in local dev (`npx wrangler@latest dev`)\n* They will appear in live logs, when tailing logs in the dashboard or running [`wrangler tail`](https://developers.cloudflare.com/workers/observability/log-from-workers/#use-wrangler-tail)\n* They will create entries in the `logs` field of [Tail Worker](https://developers.cloudflare.com/workers/observability/tail-workers/) events and [Workers Trace Events](https://developers.cloudflare.com/logs/logpush/logpush-job/datasets/account/workers_trace_events/), which can be pushed to a destination of your choice via [Logpush](https://developers.cloudflare.com/workers/observability/logpush/).\n\nAll methods noted as \"🟡 partial support\" have the following behavior:\n\n* In both production and local development the method can be safely called, but will do nothing (no op)\n* In the [Workers Playground](https://workers.cloudflare.com/playground), Quick Editor in the Workers dashboard, and remote preview mode (`wrangler dev --remote`) calling the method will behave as expected, print to the console, etc.\n\nRefer to [Log from Workers](https://developers.cloudflare.com/workers/observability/log-from-workers/) for more on debugging and adding logs to Workers.\n\n| Method | Behavior |\n| - | - |\n| [`console.debug()`](https://developer.mozilla.org/en-US/docs/Web/API/console/debug_static) | ✅ supported |\n| [`console.error()`](https://developer.mozilla.org/en-US/docs/Web/API/console/error_static) | ✅ supported |\n| [`console.info()`](https://developer.mozilla.org/en-US/docs/Web/API/console/info_static) | ✅ supported |\n| [`console.log()`](https://developer.mozilla.org/en-US/docs/Web/API/console/log_static) | ✅ supported |\n| [`console.warn()`](https://developer.mozilla.org/en-US/docs/Web/API/console/warn_static) | ✅ supported |\n| [`console.clear()`](https://developer.mozilla.org/en-US/docs/Web/API/console/clear_static) | 🟡 partial support |\n| [`console.count()`](https://developer.mozilla.org/en-US/docs/Web/API/console/count_static) | 🟡 partial support |\n| [`console.group()`](https://developer.mozilla.org/en-US/docs/Web/API/console/group_static) | 🟡 partial support |\n| [`console.table()`](https://developer.mozilla.org/en-US/docs/Web/API/console/table_static) | 🟡 partial support |\n| [`console.trace()`](https://developer.mozilla.org/en-US/docs/Web/API/console/trace_static) | 🟡 partial support |\n| [`console.assert()`](https://developer.mozilla.org/en-US/docs/Web/API/console/assert_static) | ⚪ no op |\n| [`console.countReset()`](https://developer.mozilla.org/en-US/docs/Web/API/console/countreset_static) | ⚪ no op |\n| [`console.dir()`](https://developer.mozilla.org/en-US/docs/Web/API/console/dir_static) | ⚪ no op |\n| [`console.dirxml()`](https://developer.mozilla.org/en-US/docs/Web/API/console/dirxml_static) | ⚪ no op |\n| [`console.groupCollapsed()`](https://developer.mozilla.org/en-US/docs/Web/API/console/groupcollapsed_static) | ⚪ no op |\n| [`console.groupEnd`](https://developer.mozilla.org/en-US/docs/Web/API/console/groupend_static) | ⚪ no op |\n| [`console.profile()`](https://developer.mozilla.org/en-US/docs/Web/API/console/profile_static) | ⚪ no op |\n| [`console.profileEnd()`](https://developer.mozilla.org/en-US/docs/Web/API/console/profileend_static) | ⚪ no op |\n| [`console.time()`](https://developer.mozilla.org/en-US/docs/Web/API/console/time_static) | ⚪ no op |\n| [`console.timeEnd()`](https://developer.mozilla.org/en-US/docs/Web/API/console/timeend_static) | ⚪ no op |\n| [`console.timeLog()`](https://developer.mozilla.org/en-US/docs/Web/API/console/timelog_static) | ⚪ no op |\n| [`console.timeStamp()`](https://developer.mozilla.org/en-US/docs/Web/API/console/timestamp_static) | ⚪ no op |\n| [`console.createTask()`](https://developer.chrome.com/blog/devtools-modern-web-debugging/#linked-stack-traces) | 🔴 Will throw an exception in production, but works in local dev, Quick Editor, and remote preview |\n\n</page>\n\n<page>\n---\ntitle: Context (ctx) · Cloudflare Workers docs\ndescription: The Context API in Cloudflare Workers, including props, exports,\n  waitUntil and passThroughOnException.\nlastUpdated: 2025-10-08T11:57:37.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/context/\n  md: https://developers.cloudflare.com/workers/runtime-apis/context/index.md\n---\n\nThe Context API provides methods to manage the lifecycle of your Worker or Durable Object.\n\nContext is exposed via the following places:\n\n* As the third parameter in all [handlers](https://developers.cloudflare.com/workers/runtime-apis/handlers/), including the [`fetch()` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/). (`fetch(request, env, ctx)`)\n* As a class property of the [`WorkerEntrypoint` class](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc) (`this.ctx`)\n\nNote that the Context API is available strictly in stateless contexts, that is, not [Durable Objects](https://developers.cloudflare.com/durable-objects/). However, Durable Objects have a different object, the [Durable Object State](https://developers.cloudflare.com/durable-objects/api/state/), which is available as `this.ctx` inside a Durable Object class, and provides some of the same functionality as the Context API.\n\n## `props`\n\n`ctx.props` provides a way to pass additional configuration to a worker based on the context in which it was invoked. For example, when your Worker is called by another Worker, `ctx.props` can provide information about the calling worker.\n\nFor example, imagine that you are configuring a Worker called \"frontend-worker\", which must talk to another Worker called \"doc-worker\" in order to manipulate documents. You might configure \"frontend-worker\" with a [Service Binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings) like:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Now frontend-worker can make calls to doc-worker with code like `env.DOC_SERVICE.getDoc(id)`. This will make a [Remote Procedure Call](https://developers.cloudflare.com/workers/runtime-apis/rpc/) invoking the method `getDoc()` of the class `DocServiceApi`, a [`WorkerEntrypoint` class](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc) exported by doc-worker.\n\nThe configuration contains a `props` value. This in an arbitrary JSON value. When the `DOC_SERVICE` binding is used, the `DocServiceApi` instance receiving the call will be able to access this `props` value as `this.ctx.props`. Here, we've configured `props` to specify that the call comes from frontend-worker, and that it should be allowed to read and write documents. However, the contents of `props` can be anything you want.\n\nThe Workers platform is designed to ensure that `ctx.props` can only be set by someone who has permission to edit and deploy the worker to which it is being delivered. This means that you can trust that the content of `ctx.props` is authentic. There is no need to use secret keys or cryptographic signatures in a `ctx.props` value.\n\n`ctx.props` can also be used to configure an RPC interface to represent a *specific* resource, thus creating a \"custom binding\". For example, we could configure a Service Binding to our \"doc-worker\" which grants access only to a specific document:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Here, we've placed a `docId` property in `ctx.props`. The `DocumentApi` class could be designed to provide an API to the specific document identified by `ctx.props.docId`, and enforcing the given permissions.\n\n## `exports`\n\nCompatibility flag required\n\nTo use `ctx.exports`, you must use [the `enable_ctx_exports` compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags#enable-ctxexports).\n\n`ctx.exports` provides automatically-configured \"loopback\" bindings for all of your top-level exports.\n\n* For each top-level export that `extends WorkerEntrypoint` (or simply implements a fetch handler), `ctx.exports` automatically contains a [Service Binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings).\n* For each top-level export that `extends DurableObject` (and which has been configured with storage via a [migration](https://developers.cloudflare.com/durable-objects/reference/durable-objects-migrations/)), `ctx.exports` automatically contains a [Durable Object namespace binding](https://developers.cloudflare.com/durable-objects/api/namespace/).\n\nFor example:",
      "language": "unknown"
    },
    {
      "code": "In this example, the default fetch handler calls the `Greeter` class over RPC, like how you'd use a Service Binding. However, there is no external configuration required. `ctx.exports` is populated *automatically* from your top-level imports.\n\n### Specifying `ctx.props` when using `ctx.exports`\n\nLoopback Service Bindings in `ctx.exports` have an extra capability that regular Service Bindings do not: the caller can specify the value of `ctx.props` that should be delivered to the callee.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Specifying props dynamically is permitted in this case because the caller is the same Worker, and thus can be presumed to be trusted to specify any props. The ability to customize props is particularly useful when the resulting binding is to be passed to another Worker over RPC or used in the `env` of a [dynamically-loaded worker](https://developers.cloudflare.com/workers/runtime-apis/bindings/worker-loader/).\n\nNote that `props` values specified in this way are allowed to contain any \"persistently\" serializable type. This includes all basic [structured clonable data types](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm). It also includes Service Bindings themselves: you can place a Service Binding into the `props` of another Service Binding.\n\n### TypeScript types for `ctx.exports` and `ctx.props`\n\nIf using TypeScript, you should use [the `wrangler types` command](https://developers.cloudflare.com/workers/wrangler/commands/#types) to auto-generate types for your project. The generated types will ensure `ctx.exports` is typed correctly.\n\nWhen declaring an entrypoint class that accepts `props`, make sure to declare it as `extends WorkerEntrypoint<Env, Props>`, where `Props` is the type of `ctx.props`. See the example above.\n\n## `waitUntil`\n\n`ctx.waitUntil()` extends the lifetime of your Worker, allowing you to perform work without blocking returning a response, and that may continue after a response is returned. It accepts a `Promise`, which the Workers runtime will continue executing, even after a response has been returned by the Worker's [handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/).\n\n`waitUntil` is commonly used to:\n\n* Fire off events to external analytics providers. (note that when you use [Workers Analytics Engine](https://developers.cloudflare.com/analytics/analytics-engine/), you do not need to use `waitUntil`)\n* Put items into cache using the [Cache API](https://developers.cloudflare.com/workers/runtime-apis/cache/)\n\nAlternatives to waitUntil\n\nIf you are using `waitUntil()` to emit logs or exceptions, we recommend using [Tail Workers](https://developers.cloudflare.com/workers/observability/logs/tail-workers/) instead. Even if your Worker throws an uncaught exception, the Tail Worker will execute, ensuring that you can emit logs or exceptions regardless of the Worker's invocation status.\n\n[Cloudflare Queues](https://developers.cloudflare.com/queues/) is purpose-built for performing work out-of-band, without blocking returning a response back to the client Worker.\n\nYou can call `waitUntil()` multiple times. Similar to `Promise.allSettled`, even if a promise passed to one `waitUntil` call is rejected, promises passed to other `waitUntil()` calls will still continue to execute.\n\nFor example:",
      "language": "unknown"
    },
    {
      "code": "## `passThroughOnException`\n\nReuse of body\n\nThe Workers Runtime uses streaming for request and response bodies. It does not buffer the body. Hence, if an exception occurs after the body has been consumed, `passThroughOnException()` cannot send the body again.\n\nIf this causes issues, we recommend cloning the request body and handling exceptions in code. This will protect against uncaught code exceptions. However some exception times such as exceed CPU or memory limits will not be mitigated.\n\nThe `passThroughOnException` method allows a Worker to [fail open](https://community.microfocus.com/cyberres/b/sws-22/posts/security-fundamentals-part-1-fail-open-vs-fail-closed), and pass a request through to an origin server when a Worker throws an unhandled exception. This can be useful when using Workers as a layer in front of an existing service, allowing the service behind the Worker to handle any unexpected error cases that arise in your Worker.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Encoding · Cloudflare Workers docs\ndescription: Takes a stream of code points as input and emits a stream of bytes.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/encoding/\n  md: https://developers.cloudflare.com/workers/runtime-apis/encoding/index.md\n---\n\n## TextEncoder\n\n### Background\n\nThe `TextEncoder` takes a stream of code points as input and emits a stream of bytes. Encoding types passed to the constructor are ignored and a UTF-8 `TextEncoder` is created.\n\n[`TextEncoder()`](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/TextEncoder) returns a newly constructed `TextEncoder` that generates a byte stream with UTF-8 encoding. `TextEncoder` takes no parameters and throws no exceptions.\n\n### Constructor",
      "language": "unknown"
    },
    {
      "code": "### Properties\n\n* `encoder.encoding` DOMString read-only\n  * The name of the encoder as a string describing the method the `TextEncoder` uses (always `utf-8`).\n\n### Methods\n\n* `encode(inputUSVString)` : Uint8Array\n\n  * Encodes a string input.\n\n***\n\n## TextDecoder\n\n### Background\n\nThe `TextDecoder` interface represents a UTF-8 decoder. Decoders take a stream of bytes as input and emit a stream of code points.\n\n[`TextDecoder()`](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/TextDecoder) returns a newly constructed `TextDecoder` that generates a code-point stream.\n\n### Constructor",
      "language": "unknown"
    },
    {
      "code": "### Properties\n\n* `decoder.encoding` DOMString read-only\n\n  * The name of the decoder that describes the method the `TextDecoder` uses.\n\n* `decoder.fatal` boolean read-only\n\n  * Indicates if the error mode is fatal.\n\n* `decoder.ignoreBOM` boolean read-only\n\n  * Indicates if the byte-order marker is ignored.\n\n### Methods\n\n* `decode()` : DOMString\n  * Decodes using the method specified in the `TextDecoder` object. Learn more at [MDN’s `TextDecoder` documentation](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder/decode).\n\n</page>\n\n<page>\n---\ntitle: EventSource · Cloudflare Workers docs\ndescription: EventSource is a server-sent event API that allows a server to push\n  events to a client.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/eventsource/\n  md: https://developers.cloudflare.com/workers/runtime-apis/eventsource/index.md\n---\n\n## Background\n\nThe [`EventSource`](https://developer.mozilla.org/en-US/docs/Web/API/EventSource) interface is a server-sent event API that allows a server to push events to a client. The `EventSource` object is used to receive server-sent events. It connects to a server over HTTP and receives events in a text-based format.\n\n### Constructor",
      "language": "unknown"
    },
    {
      "code": "* `url` USVString - The URL to which to connect.\n* `options` EventSourceInit - An optional dictionary containing any optional settings.\n\nBy default, the `EventSource` will use the global `fetch()` function under the covers to make requests. If you need to use a different fetch implementation as provided by a Cloudflare Workers binding, you can pass the `fetcher` option:",
      "language": "unknown"
    },
    {
      "code": "Note that the `fetcher` option is a Cloudflare Workers specific extension.\n\n### Properties\n\n* `eventSource.url` USVString read-only\n  * The URL of the event source.\n* `eventSource.readyState` USVString read-only\n  * The state of the connection.\n* `eventSource.withCredentials` Boolean read-only\n  * A Boolean indicating whether the `EventSource` object was instantiated with cross-origin (CORS) credentials set (`true`), or not (`false`).\n\n### Methods\n\n* `eventSource.close()`\n  * Closes the connection.\n* `eventSource.onopen`\n  * An event handler called when a connection is opened.\n* `eventSource.onmessage`\n  * An event handler called when a message is received.\n* `eventSource.onerror`\n  * An event handler called when an error occurs.\n\n### Events\n\n* `message`\n  * Fired when a message is received.\n* `open`\n  * Fired when the connection is opened.\n* `error`\n  * Fired when an error occurs.\n\n### Class Methods\n\n* `EventSource.from(readableStreamReadableStream) : EventSource`\n  * This is a Cloudflare Workers specific extension that creates a new `EventSource` object from an existing `ReadableStream`. Such an instance does not initiate a new connection but instead attaches to the provided stream.\n\n</page>\n\n<page>\n---\ntitle: Fetch · Cloudflare Workers docs\ndescription: An interface for asynchronously fetching resources via HTTP\n  requests inside of a Worker.\nlastUpdated: 2025-11-11T15:40:52.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/fetch/\n  md: https://developers.cloudflare.com/workers/runtime-apis/fetch/index.md\n---\n\nThe [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) provides an interface for asynchronously fetching resources via HTTP requests inside of a Worker.\n\nNote\n\nAsynchronous tasks such as `fetch` must be executed within a [handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/). If you try to call `fetch()` within [global scope](https://developer.mozilla.org/en-US/docs/Glossary/Global_scope), your Worker will throw an error. Learn more about [the Request context](https://developers.cloudflare.com/workers/runtime-apis/request/#the-request-context).\n\nWorker to Worker\n\nWorker-to-Worker `fetch` requests are possible with [Service bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/) or by enabling the [`global_fetch_strictly_public` compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#global-fetch-strictly-public).\n\n## Syntax\n\n* Module Worker",
      "language": "unknown"
    },
    {
      "code": "* Service Worker\n\n  Service Workers are deprecated\n\n  Service Workers are deprecated, but still supported. We recommend using [Module Workers](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) instead. New features may not be supported for Service Workers.",
      "language": "unknown"
    },
    {
      "code": "* Python Worker",
      "language": "unknown"
    },
    {
      "code": "- `fetch(resource, options optional)` : Promise`<Response>`\n- Fetch returns a promise to a Response.\n\n### Parameters\n\n* [`resource`](https://developer.mozilla.org/en-US/docs/Web/API/fetch#resource) Request | string | URL\n\n* `options` options\n\n  * `cache` `undefined | 'no-store' | 'no-cache'` optional\n    * Standard HTTP `cache` header. Only `cache: 'no-store'` and `cache: 'no-cache'` are supported. Any other `cache` header will result in a `TypeError` with the message `Unsupported cache mode: <attempted-cache-mode>`. \\_ For all requests this forwards the `Pragma: no-cache` and `Cache-Control: no-cache` headers to the origin. \\_ For `no-store`, requests to origins not hosted by Cloudflare bypass the use of Cloudflare's caches. \\_ For `no-cache`, requests to origins not hosted by Cloudflare are forced to revalidate with the origin before resonding.\n  * An object that defines the content and behavior of the request.\n\n***\n\n## How the `Accept-Encoding` header is handled\n\nWhen making a subrequest with the `fetch()` API, you can specify which forms of compression to prefer that the server will respond with (if the server supports it) by including the [`Accept-Encoding`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Accept-Encoding) header.\n\nWorkers supports both the gzip and brotli compression algorithms. Usually it is not necessary to specify `Accept-Encoding` or `Content-Encoding` headers in the Workers Runtime production environment – brotli or gzip compression is automatically requested when fetching from an origin and applied to the response when returning data to the client, depending on the capabilities of the client and origin server.\n\nTo support requesting brotli from the origin, you must enable the [`brotli_content_encoding`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#brotli-content-encoding-support) compatibility flag in your Worker. Soon, this compatibility flag will be enabled by default for all Workers past an upcoming compatibility date.\n\n### Passthrough behavior\n\nOne scenario where the Accept-Encoding header is useful is for passing through compressed data from a server to the client, where the Accept-Encoding allows the worker to directly receive the compressed data stream from the server without it being decompressed beforehand. As long as you do not read the body of the compressed response prior to returning it to the client and keep the `Content-Encoding` header intact, it will \"pass through\" without being decompressed and then recompressed again. This can be helpful when using Workers in front of origin servers or when fetching compressed media assets, to ensure that the same compression used by the origin server is used in the response that your Worker returns.\n\nIn addition to a change in the content encoding, recompression is also needed when a response uses an encoding not supported by the client. As an example, when a Worker requests either brotli or gzip as the encoding but the client only supports gzip, recompression will still be needed if the server returns brotli-encoded data to the server (and will be applied automatically). Note that this behavior may also vary based on the [compression rules](https://developers.cloudflare.com/rules/compression-rules/), which can be used to configure what compression should be applied for different types of data on the server side.",
      "language": "unknown"
    },
    {
      "code": "## Related resources\n\n* [Example: use `fetch` to respond with another site](https://developers.cloudflare.com/workers/examples/respond-with-another-site/)\n* [Example: Fetch HTML](https://developers.cloudflare.com/workers/examples/fetch-html/)\n* [Example: Fetch JSON](https://developers.cloudflare.com/workers/examples/fetch-json/)\n* [Example: cache using Fetch](https://developers.cloudflare.com/workers/examples/cache-using-fetch/)\n* Write your Worker code in [ES modules syntax](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) for an optimized experience.\n* [Error 526](https://developers.cloudflare.com/support/troubleshooting/http-status-codes/cloudflare-5xx-errors/error-526/#error-526-in-the-workers-context)\n* [Fetch API in a partial setup](https://developers.cloudflare.com/workers/platform/known-issues/#fetch-api-in-cname-setup)\n\n</page>\n\n<page>\n---\ntitle: Handlers · Cloudflare Workers docs\ndescription: Methods, such as `fetch()`, on Workers that can receive and process\n  external inputs.\nlastUpdated: 2025-08-14T16:04:08.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/handlers/\n  md: https://developers.cloudflare.com/workers/runtime-apis/handlers/index.md\n---\n\nHandlers are methods on Workers that can receive and process external inputs, and can be invoked from outside your Worker. For example, the `fetch()` handler receives an HTTP request, and can return a response:",
      "language": "unknown"
    },
    {
      "code": "The following handlers are available within Workers:\n\n* [Alarm Handler](https://developers.cloudflare.com/durable-objects/api/alarms/)\n* [Email Handler](https://developers.cloudflare.com/email-routing/email-workers/runtime-api/)\n* [Fetch Handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/)\n* [Queue Handler](https://developers.cloudflare.com/queues/configuration/javascript-apis/#consumer)\n* [Scheduled Handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/scheduled/)\n* [Tail Handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/tail/)\n\n## Handlers in Python Workers\n\nWhen you [write Workers in Python](https://developers.cloudflare.com/workers/languages/python/), handlers are placed in a class named `Default` that extends the [`WorkerEntrypoint` class](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc/) (which you can import from the `workers` SDK module).\n\n</page>\n\n<page>\n---\ntitle: Headers · Cloudflare Workers docs\ndescription: Access HTTP request and response headers.\nlastUpdated: 2025-01-28T15:34:30.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/headers/\n  md: https://developers.cloudflare.com/workers/runtime-apis/headers/index.md\n---\n\n## Background\n\nAll HTTP request and response headers are available through the [Headers API](https://developer.mozilla.org/en-US/docs/Web/API/Headers).\n\nWhen a header name possesses multiple values, those values will be concatenated as a single, comma-delimited string value. This means that `Headers.get` will always return a string or a `null` value. This applies to all header names except for `Set-Cookie`, which requires `Headers.getAll`. This is documented below in [Differences](#differences).",
      "language": "unknown"
    },
    {
      "code": "## Differences\n\n* Despite the fact that the `Headers.getAll` method has been made obsolete, Cloudflare still offers this method but only for use with the `Set-Cookie` header. This is because cookies will often contain date strings, which include commas. This can make parsing multiple values in a `Set-Cookie` header more difficult. Any attempts to use `Headers.getAll` with other header names will throw an error. A brief history `Headers.getAll` is available in this [GitHub issue](https://github.com/whatwg/fetch/issues/973).\n\n* Due to [RFC 6265](https://www.rfc-editor.org/rfc/rfc6265) prohibiting folding multiple `Set-Cookie` headers into a single header, the `Headers.append` method will allow you to set multiple `Set-Cookie` response headers instead of appending the value onto the existing header.",
      "language": "unknown"
    },
    {
      "code": "* In Cloudflare Workers, the `Headers.get` method returns a [`USVString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) instead of a [`ByteString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String), which is specified by the spec. For most scenarios, this should have no noticeable effect. To compare the differences between these two string classes, refer to this [Playground example](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbMutvvsCMALAJx-cAzAHZeANkG8AHAAZOU7t2EBWAEy9eqsXNWdOALg5HjbHv34jxk2fMUr1m7Z12cAsACgAwuioQApr7YACJQAM4w6KFQ0D76JBhYeATEJFRwwH4MAERQNH4AHgB0AFahWaSoUGAB6Zk5eUWlWR7evgEQ2AAqdDB+cXAwMGBQAMYEUD7IxXAAbnChIwiwEADUwOi44H4eHgURSCS4fqhw4BAkAN7uAJDzdFQj8X4QIwAWABQIfgCOIH6hEAAlJcbtdqucxucGCQsoBeDcAXHtZUHgkggCCoKSeAgkaFUPwAdxInQKEAAog8Nn4EO9AYUAiNKe9IYDkc8SPTKbgsVCSABlCBLKgAc0KqAQ6GAnleiG8R3ehQVaIx3JZoIZVFC6GqhTA6CF7yynVeYRIJrgJAAqryAGr8wVCkj46KvEjmyH6LIAGhIzLVPk12t1+sNxtCprD5oAQnR-Hbcg6nRAXW7sT5LZ0AGLYKQe70co5cgiq67XZDIEgACT8cCOCAjXxIoRAg0iflwJAg6EdmAA1iQfGA6I7nSRo7GBfHQt6yGj+yAEKCy6bgEM-BlfOM0yBQv9LTa48LQoUiaHUiSSMM8cOwGASDBBec4Ivy-jEFR466KLOk2FCqzzq81a1mGuIEpWQFUqE7wXDC+ZttgkJZHEcGFucAC+xbXF8EDzlQZ6EgASv8EQan4BpSn4Ix9pQ5xJn4JAAAatAGfgMa6NAdoBJBEeE-r0YBNaQR2XY7vRdFzhAMCzgyK6IGE-qFF6lwkAJwEkBhNxoe4aEeCYelGGYAiWBI0hyAoShqBoWg6HoLQ+P4gQhLxUQxFQcQJDg+CEKQaQZNkGSEF5cDlPEVQ1H5WRkLqZDNF49ntF0PR9K6gzDJCExUFMmpUDs7gXFkwBwLkAD66ybNUSH1EcjRlDp7j6Q1rCGRYogmTY5n2FZTguMwHhAA).\n\n## Cloudflare headers\n\nCloudflare sets a number of its own custom headers on incoming requests and outgoing responses. While some may be used for its own tracking and bookkeeping, many of these can be useful to your own applications – or Workers – too.\n\nFor a list of documented Cloudflare request headers, refer to [Cloudflare HTTP headers](https://developers.cloudflare.com/fundamentals/reference/http-headers/).\n\n## Related resources\n\n* [Logging headers to console](https://developers.cloudflare.com/workers/examples/logging-headers/) - Review how to log headers in the console.\n* [Cloudflare HTTP headers](https://developers.cloudflare.com/fundamentals/reference/http-headers/) - Contains a list of specific headers that Cloudflare adds.\n\n</page>\n\n<page>\n---\ntitle: HTMLRewriter · Cloudflare Workers docs\ndescription: Build comprehensive and expressive HTML parsers inside of a Worker application.\nlastUpdated: 2025-08-20T18:47:44.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/html-rewriter/\n  md: https://developers.cloudflare.com/workers/runtime-apis/html-rewriter/index.md\n---\n\n## Background\n\nThe `HTMLRewriter` class allows developers to build comprehensive and expressive HTML parsers inside of a Cloudflare Workers application. It can be thought of as a jQuery-like experience directly inside of your Workers application. Leaning on a powerful JavaScript API to parse and transform HTML, `HTMLRewriter` allows developers to build deeply functional applications.\n\nThe `HTMLRewriter` class should be instantiated once in your Workers script, with a number of handlers attached using the `on` and `onDocument` functions.\n\n***\n\n## Constructor",
      "language": "unknown"
    },
    {
      "code": "***\n\n## Global types\n\nThroughout the `HTMLRewriter` API, there are a few consistent types that many properties and methods use:\n\n* `Content` string | Response | ReadableStream\n\n  * Content inserted in the output stream should be a string, [`Response`](https://developers.cloudflare.com/workers/runtime-apis/response/), or [`ReadableStream`](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestream/).\n\n* `ContentOptions` Object\n\n  * `{ html: Boolean }` Controls the way the HTMLRewriter treats inserted content. If the `html` boolean is set to true, content is treated as raw HTML. If the `html` boolean is set to false or not provided, content will be treated as text and proper HTML escaping will be applied to it.\n\n***\n\n## Handlers\n\nThere are two handler types that can be used with `HTMLRewriter`: element handlers and document handlers.\n\n### Element Handlers\n\nAn element handler responds to any incoming element, when attached using the `.on` function of an `HTMLRewriter` instance. The element handler should respond to `element`, `comments`, and `text`. The example processes `div` elements with an `ElementHandler` class.",
      "language": "unknown"
    },
    {
      "code": "### Document Handlers\n\nA document handler represents the incoming HTML document. A number of functions can be defined on a document handler to query and manipulate a document’s `doctype`, `comments`, `text`, and `end`. Unlike an element handler, a document handler’s `doctype`, `comments`, `text`, and `end` functions are not scoped by a particular selector. A document handler's functions are called for all the content on the page including the content outside of the top-level HTML tag:",
      "language": "unknown"
    },
    {
      "code": "#### Async Handlers\n\nAll functions defined on both element and document handlers can return either `void` or a `Promise<void>`. Making your handler function `async` allows you to access external resources such as an API via fetch, Workers KV, Durable Objects, or the cache.",
      "language": "unknown"
    },
    {
      "code": "### Element\n\nThe `element` argument, used only in element handlers, is a representation of a DOM element. A number of methods exist on an element to query and manipulate it:\n\n#### Properties\n\n* `tagName` string\n\n  * The name of the tag, such as `\"h1\"` or `\"div\"`. This property can be assigned different values, to modify an element’s tag.\n\n* `attributes` Iterator read-only\n\n  * A `[name, value]` pair of the tag’s attributes.\n\n* `removed` boolean\n\n  * Indicates whether the element has been removed or replaced by one of the previous handlers.\n\n* `namespaceURI` String\n\n  * Represents the [namespace URI](https://infra.spec.whatwg.org/#namespaces) of an element.\n\n#### Methods\n\n* `getAttribute(namestring)` : string | null\n\n  * Returns the value for a given attribute name on the element, or `null` if it is not found.\n\n* `hasAttribute(namestring)` : boolean\n\n  * Returns a boolean indicating whether an attribute exists on the element.\n\n* `setAttribute(namestring, valuestring)` : Element\n\n  * Sets an attribute to a provided value, creating the attribute if it does not exist.\n\n* `removeAttribute(namestring)` : Element\n\n  * Removes the attribute.\n\n* `before(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Inserts content before the element.\n\n  Content and ContentOptions\n\n  Refer to [Global types](https://developers.cloudflare.com/workers/runtime-apis/html-rewriter/#global-types) for more information on `Content` and `ContentOptions`.\n\n* `after(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Inserts content right after the element.\n\n* `prepend(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Inserts content right after the start tag of the element.\n\n* `append(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Inserts content right before the end tag of the element.\n\n* `replace(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Removes the element and inserts content in place of it.\n\n* `setInnerContent(contentContent, contentOptionsContentOptionsoptional)`\n\n  : Element\n\n  * Replaces content of the element.\n\n* `remove()` : Element\n\n  * Removes the element with all its content.\n\n* `removeAndKeepContent()` : Element\n\n  * Removes the start tag and end tag of the element but keeps its inner content intact.\n\n* `onEndTag(handlerFunction<void>)` : void\n\n  * Registers a handler that is invoked when the end tag of the element is reached.\n\n### EndTag\n\nThe `endTag` argument, used only in handlers registered with `element.onEndTag`, is a limited representation of a DOM element.\n\n#### Properties\n\n* `name` string\n  * The name of the tag, such as `\"h1\"` or `\"div\"`. This property can be assigned different values, to modify an element's tag.\n\n#### Methods\n\n* `before(contentContent, contentOptionsContentOptionsoptional)` : EndTag\n\n  * Inserts content right before the end tag.\n\n* `after(contentContent, contentOptionsContentOptionsoptional)` : EndTag\n\n  * Inserts content right after the end tag.\n\n  Content and ContentOptions\n\n  Refer to [Global types](https://developers.cloudflare.com/workers/runtime-apis/html-rewriter/#global-types) for more information on `Content` and `ContentOptions`.\n\n* `remove()` : EndTag\n\n  * Removes the element with all its content.\n\n### Text chunks\n\nSince Cloudflare performs zero-copy streaming parsing, text chunks are not the same thing as text nodes in the lexical tree. A lexical tree text node can be represented by multiple chunks, as they arrive over the wire from the origin.\n\nConsider the following markup: `<div>Hey. How are you?</div>`. It is possible that the Workers script will not receive the entire text node from the origin at once; instead, the `text` element handler will be invoked for each received part of the text node. For example, the handler might be invoked with `“Hey. How ”,` then `“are you?”`. When the last chunk arrives, the text’s `lastInTextNode` property will be set to `true`. Developers should make sure to concatenate these chunks together.\n\n#### Properties\n\n* `removed` boolean\n\n  * Indicates whether the element has been removed or replaced by one of the previous handlers.\n\n* `text` string read-only\n\n  * The text content of the chunk. Could be empty if the chunk is the last chunk of the text node.\n\n* `lastInTextNode` boolean read-only\n\n  * Specifies whether the chunk is the last chunk of the text node.\n\n#### Methods\n\n* `before(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Inserts content before the element.\n\n  Content and ContentOptions\n\n  Refer to [Global types](https://developers.cloudflare.com/workers/runtime-apis/html-rewriter/#global-types) for more information on `Content` and `ContentOptions`.\n\n* `after(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Inserts content right after the element.\n\n* `replace(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Removes the element and inserts content in place of it.\n\n* `remove()` : Element\n\n  * Removes the element with all its content.\n\n### Comments\n\nThe `comments` function on an element handler allows developers to query and manipulate HTML comment tags.",
      "language": "unknown"
    },
    {
      "code": "#### Properties\n\n* `comment.removed` boolean\n\n  * Indicates whether the element has been removed or replaced by one of the previous handlers.\n\n* `comment.text` string\n\n  * The text of the comment. This property can be assigned different values, to modify comment’s text.\n\n#### Methods\n\n* `before(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Inserts content before the element.\n\n  Content and ContentOptions\n\n  Refer to [Global types](https://developers.cloudflare.com/workers/runtime-apis/html-rewriter/#global-types) for more information on `Content` and `ContentOptions`.\n\n* `after(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Inserts content right after the element.\n\n* `replace(contentContent, contentOptionsContentOptionsoptional)` : Element\n\n  * Removes the element and inserts content in place of it.\n\n* `remove()` : Element\n\n  * Removes the element with all its content.\n\n### Doctype\n\nThe `doctype` function on a document handler allows developers to query a document’s [doctype](https://developer.mozilla.org/en-US/docs/Glossary/Doctype).",
      "language": "unknown"
    },
    {
      "code": "#### Properties\n\n* `doctype.name` string | null read-only\n\n  * The doctype name.\n\n* `doctype.publicId` string | null read-only\n\n  * The quoted string in the doctype after the PUBLIC atom.\n\n* `doctype.systemId` string | null read-only\n\n  * The quoted string in the doctype after the SYSTEM atom or immediately after the `publicId`.\n\n### End\n\nThe `end` function on a document handler allows developers to append content to the end of a document.",
      "language": "unknown"
    },
    {
      "code": "#### Methods\n\n* `append(contentContent, contentOptionsContentOptionsoptional)` : DocumentEnd\n\n  * Inserts content after the end of the document.\n\n  Content and ContentOptions\n\n  Refer to [Global types](https://developers.cloudflare.com/workers/runtime-apis/html-rewriter/#global-types) for more information on `Content` and `ContentOptions`.\n\n***\n\n## Selectors\n\nThis is what selectors are and what they are used for.\n\n* `*`\n\n  * Any element.\n\n* `E`\n\n  * Any element of type E.\n\n* `E:nth-child(n)`\n\n  * An E element, the n-th child of its parent.\n\n* `E:first-child`\n\n  * An E element, first child of its parent.\n\n* `E:nth-of-type(n)`\n\n  * An E element, the n-th sibling of its type.\n\n* `E:first-of-type`\n\n  * An E element, first sibling of its type.\n\n* `E:not(s)`\n\n  * An E element that does not match either compound selectors.\n\n* `E.warning`\n\n  * An E element belonging to the class warning.\n\n* `E#myid`\n\n  * An E element with ID equal to myid.\n\n* `E[foo]`\n\n  * An E element with a foo attribute.\n\n* `E[foo=\"bar\"]`\n\n  * An E element whose foo attribute value is exactly equal to bar.\n\n* `E[foo=\"bar\" i]`\n\n  * An E element whose foo attribute value is exactly equal to any (ASCII-range) case-permutation of bar.\n\n* `E[foo=\"bar\" s]`\n\n  * An E element whose foo attribute value is exactly and case-sensitively equal to bar.\n\n* `E[foo~=\"bar\"]`\n\n  * An E element whose foo attribute value is a list of whitespace-separated values, one of which is exactly equal to bar.\n\n* `E[foo^=\"bar\"]`\n\n  * An E element whose foo attribute value begins exactly with the string bar.\n\n* `E[foo$=\"bar\"]`\n\n  * An E element whose foo attribute value ends exactly with the string bar.\n\n* `E[foo*=\"bar\"]`\n\n  * An E element whose foo attribute value contains the substring bar.\n\n* `E[foo|=\"en\"]`\n\n  * An E element whose foo attribute value is a hyphen-separated list of values beginning with en.\n\n* `E F`\n\n  * An F element descendant of an E element.\n\n* `E > F`\n\n  * An F element child of an E element.\n\n***\n\n## Errors\n\nIf a handler throws an exception, parsing is immediately halted, the transformed response body is errored with the thrown exception, and the untransformed response body is canceled (closed). If the transformed response body was already partially streamed back to the client, the client will see a truncated response.",
      "language": "unknown"
    },
    {
      "code": "***\n\n## Related resources\n\n* [Introducing `HTMLRewriter`](https://blog.cloudflare.com/introducing-htmlrewriter/)\n* [Tutorial: Localize a Website](https://developers.cloudflare.com/pages/tutorials/localize-a-website/)\n* [Example: rewrite links](https://developers.cloudflare.com/workers/examples/rewrite-links/)\n* [Example: Inject Turnstile](https://developers.cloudflare.com/workers/examples/turnstile-html-rewriter/)\n\n</page>\n\n<page>\n---\ntitle: MessageChannel · Cloudflare Workers docs\ndescription: Channel messaging with MessageChannel and MessagePort\nlastUpdated: 2025-08-12T19:18:16.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/messagechannel/\n  md: https://developers.cloudflare.com/workers/runtime-apis/messagechannel/index.md\n---\n\n## Background\n\nThe [MessageChannel API](https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel) provides a way to create a communication channel between different parts of your application.\n\nThe Workers runtime provides a minimal implementation of the `MessageChannel` API that is currently limited to uses with a single Worker instance. This means that you can use `MessageChannel` to send messages between different parts of your Worker, but not across different Workers.",
      "language": "unknown"
    },
    {
      "code": "Any value that can be used with the `structuredClone(...)` API can be sent over the port.\n\n## Differences\n\nThere are a number of key limitations to the `MessageChannel` API in Workers:\n\n* Transfer lists are currently not supported. This means that you will not be able to transfer ownership of objects like `ArrayBuffer` or `MessagePort` between ports.\n* The `MessagePort` is not yet serializable. This means that you cannot send a `MessagePort` object through the `postMessage` method or via JSRPC calls.\n* The `'messageerror'` event is only partially supported. If the `'onmessage'` handler throws an error, the `'messageerror'` event will be triggered, however, it will not be triggered when there are errors serializing or deserializing the message data. Instead, the error will be thrown when the `postMessage` method is called on the sending port.\n* The `'close'` event will be emitted on both ports when one of the ports is closed, however it will not be emitted when the Worker is terminated or when one of the ports is garbage collected.\n\n</page>\n\n<page>\n---\ntitle: Node.js compatibility · Cloudflare Workers docs\ndescription: Node.js APIs available in Cloudflare Workers\nlastUpdated: 2025-10-16T15:15:47.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/nodejs/\n  md: https://developers.cloudflare.com/workers/runtime-apis/nodejs/index.md\n---\n\nWhen you write a Worker, you may need to import packages from [npm](https://www.npmjs.com/). Many npm packages rely on APIs from the [Node.js runtime](https://nodejs.org/en/about), and will not work unless these Node.js APIs are available.\n\nCloudflare Workers provides a subset of Node.js APIs in two forms:\n\n1. As built-in APIs provided by the Workers Runtime. Most of these APIs are full implementations of the corresponding Node.js APIs, while a few are partially supported or non-functional stubs intended for the APIs to be available for import only but not for actual use.\n2. As polyfill shim implementations that [Wrangler](https://developers.cloudflare.com/workers/wrangler/) adds to your Worker's code, allowing it to import the module, but calling API methods will throw errors.\n\n## Get Started\n\nTo enable built-in Node.js APIs and add polyfills, add the `nodejs_compat` compatibility flag to your [wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/), and ensure that your Worker's [compatibility date](https://developers.cloudflare.com/workers/configuration/compatibility-dates/) is 2024-09-23 or later. [Learn more about the Node.js compatibility flag and v2](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag).\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## Supported Node.js APIs\n\nThe runtime APIs from Node.js listed below as \"🟢 supported\" are currently natively supported in the Workers Runtime. Item listed as \"🟡 partially supported\" are either only partially implemented or are implemented as non-functional stubs.\n\n[Deprecated or experimental APIs from Node.js](https://nodejs.org/docs/latest/api/documentation.html#stability-index), and APIs that do not fit in a serverless context, are not included as part of the list below:\n\n| API Name | Natively supported by the Workers Runtime |\n| - | - |\n| [Assertion testing](https://developers.cloudflare.com/workers/runtime-apis/nodejs/assert/) | 🟢 supported |\n| [Asynchronous context tracking](https://developers.cloudflare.com/workers/runtime-apis/nodejs/asynclocalstorage/) | 🟢 supported |\n| [Async hooks](https://nodejs.org/docs/latest/api/async_hooks.html) | 🟡 partially supported (non-functional) |\n| [Buffer](https://developers.cloudflare.com/workers/runtime-apis/nodejs/buffer/) | 🟢 supported |\n| [Child processes](https://nodejs.org/docs/latest/api/child_process.html) | 🟡 partially supported (non-functional) |\n| [Cluster](https://nodejs.org/docs/latest/api/cluster.html) | 🟡 partially supported (non-functional) |\n| [Console](https://nodejs.org/docs/latest/api/console.html) | 🟡 partially supported |\n| [Crypto](https://developers.cloudflare.com/workers/runtime-apis/nodejs/crypto/) | 🟢 supported |\n| [Debugger](https://developers.cloudflare.com/workers/observability/dev-tools/) | 🟢 supported via [Chrome Dev Tools integration](https://developers.cloudflare.com/workers/observability/dev-tools/) |\n| [Diagnostics Channel](https://developers.cloudflare.com/workers/runtime-apis/nodejs/diagnostics-channel/) | 🟢 supported |\n| [DNS](https://developers.cloudflare.com/workers/runtime-apis/nodejs/dns/) | 🟢 supported |\n| Errors | 🟢 supported |\n| [Events](https://developers.cloudflare.com/workers/runtime-apis/nodejs/eventemitter/) | 🟢 supported |\n| [File system](https://developers.cloudflare.com/workers/runtime-apis/nodejs/fs/) | 🟢 supported |\n| Globals | 🟢 supported |\n| [HTTP](https://developers.cloudflare.com/workers/runtime-apis/nodejs/http/) | 🟢 supported |\n| [HTTP/2](https://nodejs.org/docs/latest/api/http2.html) | 🟡 partially supported (non-functional) |\n| [HTTPS](https://developers.cloudflare.com/workers/runtime-apis/nodejs/https/) | 🟢 supported |\n| [Inspector](https://nodejs.org/docs/latest/api/inspector.html) | 🟡 partially supported via [Chrome Dev Tools integration](https://developers.cloudflare.com/workers/observability/dev-tools/) |\n| [Module](https://nodejs.org/docs/latest/api/module.html) | 🟡 partially supported |\n| [Net](https://developers.cloudflare.com/workers/runtime-apis/nodejs/net/) | 🟢 supported |\n| [OS](https://nodejs.org/docs/latest/api/os.html) | 🟡 partially supported |\n| [Path](https://developers.cloudflare.com/workers/runtime-apis/nodejs/path/) | 🟢 supported |\n| [Performance hooks](https://nodejs.org/docs/latest/api/perf_hooks.html) | 🟡 partially supported |\n| [Process](https://developers.cloudflare.com/workers/runtime-apis/nodejs/process/) | 🟢 supported |\n| [Punycode](https://nodejs.org/docs/latest/api/punycode.html) (deprecated) | 🟢 supported |\n| [Readline](https://nodejs.org/docs/latest/api/readline.html) | 🟡 partially supported (non-functional) |\n| [REPL](https://nodejs.org/docs/latest/api/repl.html) | 🟡 partially supported (non-functional) |\n| [Query strings](https://nodejs.org/docs/latest/api/querystring.html) | 🟢 supported |\n| [SQLite](https://nodejs.org/docs/latest/api/sqlite.html) | ⚪ not yet supported |\n| [Stream](https://developers.cloudflare.com/workers/runtime-apis/nodejs/streams) | 🟢 supported |\n| [String decoder](https://developers.cloudflare.com/workers/runtime-apis/nodejs/string-decoder/) | 🟢 supported |\n| [Test runner](https://nodejs.org/docs/latest/api/test.html) | ⚪ not supported |\n| [Timers](https://developers.cloudflare.com/workers/runtime-apis/nodejs/timers/) | 🟢 supported |\n| [TLS/SSL](https://developers.cloudflare.com/workers/runtime-apis/nodejs/tls/) | 🟡 partially supported |\n| [UDP/datagram](https://nodejs.org/docs/latest/api/dgram.html) | 🟡 partially supported (non-functional) |\n| [URL](https://developers.cloudflare.com/workers/runtime-apis/nodejs/url/) | 🟢 supported |\n| [Utilities](https://developers.cloudflare.com/workers/runtime-apis/nodejs/util/) | 🟢 supported |\n| [V8](https://nodejs.org/docs/latest/api/v8.html) | 🟡 partially supported (non-functional) |\n| [VM](https://nodejs.org/docs/latest/api/vm.html) | 🟡 partially supported (non-functional) |\n| [Web Crypto API](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/) | 🟢 supported |\n| [Web Streams API](https://developers.cloudflare.com/workers/runtime-apis/streams/) | 🟢 supported |\n| [Zlib](https://developers.cloudflare.com/workers/runtime-apis/nodejs/zlib/) | 🟢 supported |\n\nUnless otherwise specified, native implementations of Node.js APIs in Workers are intended to match the implementation in the [Current release of Node.js](https://github.com/nodejs/release#release-schedule).\n\nIf an API you wish to use is missing and you want to suggest that Workers support it, please add a post or comment in the [Node.js APIs discussions category](https://github.com/cloudflare/workerd/discussions/categories/node-js-apis) on GitHub.\n\n### Node.js API Polyfills\n\nNode.js APIs that are not yet supported in the Workers runtime are polyfilled via [Wrangler](https://developers.cloudflare.com/workers/wrangler/), which uses [unenv](https://github.com/unjs/unenv). If the `nodejs_compat` [compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/) is enabled, and your Worker's [compatibility date](https://developers.cloudflare.com/workers/configuration/compatibility-dates/) is 2024-09-23 or later, Wrangler will automatically inject polyfills into your Worker's code.\n\nAdding polyfills maximizes compatibility with existing npm packages by providing modules with mocked methods. Calling these mocked methods will either noop or will throw an error with a message like:",
      "language": "unknown"
    },
    {
      "code": "This allows you to import packages that use these Node.js modules, even if certain methods are not supported.\n\n## Enable only AsyncLocalStorage\n\nIf you need to enable only the Node.js `AsyncLocalStorage` API, you can enable the `nodejs_als` compatibility flag:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Performance and timers · Cloudflare Workers docs\ndescription: Measure timing, performance, and timing of subrequests and other operations.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/performance/\n  md: https://developers.cloudflare.com/workers/runtime-apis/performance/index.md\n---\n\n## Background\n\nThe Workers runtime supports a subset of the [`Performance` API](https://developer.mozilla.org/en-US/docs/Web/API/Performance), used to measure timing and performance, as well as timing of subrequests and other operations.\n\n### `performance.now()`\n\nThe [`performance.now()` method](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) returns timestamp in milliseconds, representing the time elapsed since `performance.timeOrigin`.\n\nWhen Workers are deployed to Cloudflare, as a security measure to [mitigate against Spectre attacks](https://developers.cloudflare.com/workers/reference/security-model/#step-1-disallow-timers-and-multi-threading), APIs that return timers, including [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) and [`Date.now()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now), only advance or increment after I/O occurs. Consider the following examples:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "By wrapping a subrequest in calls to `performance.now()` or `Date.now()` APIs, you can measure the timing of a subrequest, fetching a key from KV, an object from R2, or any other form of I/O in your Worker.\n\nIn local development, however, timers will increment regardless of whether I/O happens or not. This means that if you need to measure timing of a piece of code that is CPU intensive, that does not involve I/O, you can run your Worker locally, via [Wrangler](https://developers.cloudflare.com/workers/wrangler/), which uses the open-source Workers runtime, [workerd](https://github.com/cloudflare/workerd) — the same runtime that your Worker runs in when deployed to Cloudflare.\n\n### `performance.timeOrigin`\n\nThe [`performance.timeOrigin`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/timeOrigin) API is a read-only property that returns a baseline timestamp to base other measurements off of.\n\nIn the Workers runtime, the `timeOrigin` property returns 0.\n\n</page>\n\n<page>\n---\ntitle: Request · Cloudflare Workers docs\ndescription: Interface that represents an HTTP request.\nlastUpdated: 2025-11-20T16:03:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/request/\n  md: https://developers.cloudflare.com/workers/runtime-apis/request/index.md\n---\n\nThe [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request) interface represents an HTTP request and is part of the [Fetch API](https://developers.cloudflare.com/workers/runtime-apis/fetch/).\n\n## Background\n\nThe most common way you will encounter a `Request` object is as a property of an incoming request:",
      "language": "unknown"
    },
    {
      "code": "You may also want to construct a `Request` yourself when you need to modify a request object, because the incoming `request` parameter that you receive from the [`fetch()` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) is immutable.",
      "language": "unknown"
    },
    {
      "code": "The [`fetch() handler`](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) invokes the `Request` constructor. The [`RequestInit`](#options) and [`RequestInitCfProperties`](#the-cf-property-requestinitcfproperties) types defined below also describe the valid parameters that can be passed to the [`fetch() handler`](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/).\n\n***\n\n## Constructor",
      "language": "unknown"
    },
    {
      "code": "### Parameters\n\n* `input` string | Request\n\n  * Either a string that contains a URL, or an existing `Request` object.\n\n* `options` options optional\n\n  * Optional options object that contains settings to apply to the `Request`.\n\n#### `options`\n\nAn object containing properties that you want to apply to the request.\n\n* `cache` `undefined | 'no-store' | 'no-cache'` optional\n\n  * Standard HTTP `cache` header. Only `cache: 'no-store'` and `cache: 'no-cache'` are supported. Any other cache header will result in a `TypeError` with the message `Unsupported cache mode: <attempted-cache-mode>`.\n\n* `cf` RequestInitCfProperties optional\n\n  * Cloudflare-specific properties that can be set on the `Request` that control how Cloudflare’s global network handles the request.\n\n* `method` string optional\n\n  * The HTTP request method. The default is `GET`. In Workers, all [HTTP request methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods) are supported, except for [`CONNECT`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/CONNECT).\n\n* `headers` Headers optional\n\n  * A [`Headers` object](https://developer.mozilla.org/en-US/docs/Web/API/Headers).\n\n* `body` string | ReadableStream | FormData | URLSearchParams optional\n\n  * The request body, if any.\n  * Note that a request using the GET or HEAD method cannot have a body.\n\n* `redirect` string optional\n\n  * The redirect mode to use: `follow`, `error`, or `manual`. The default for a new `Request` object is `follow`. Note, however, that the incoming `Request` property of a `FetchEvent` will have redirect mode `manual`.\n\n* `signal` AbortSignal optional\n\n  * If provided, the request can be canceled by triggering an abort on the corresponding `AbortController`.\n\n#### The `cf` property (`RequestInitCfProperties`)\n\nAn object containing Cloudflare-specific properties that can be set on the `Request` object. For example:",
      "language": "unknown"
    },
    {
      "code": "Invalid or incorrectly-named keys in the `cf` object will be silently ignored. Consider using TypeScript and generating types by running [`wrangler types`](https://developers.cloudflare.com/workers/languages/typescript/#generate-types) to ensure proper use of the `cf` object.\n\n* `apps` boolean optional\n\n  * Whether [Cloudflare Apps](https://www.cloudflare.com/apps/) should be enabled for this request. Defaults to `true`.\n\n* `cacheEverything` boolean optional\n\n  * Treats all content as static and caches all [file types](https://developers.cloudflare.com/cache/concepts/default-cache-behavior#default-cached-file-extensions) beyond the Cloudflare default cached content. Respects cache headers from the origin web server. This is equivalent to setting the Page Rule [**Cache Level** (to **Cache Everything**)](https://developers.cloudflare.com/rules/page-rules/reference/settings/). Defaults to `false`. This option applies to `GET` and `HEAD` request methods only.\n\n* `cacheKey` string optional\n\n  * A request’s cache key is what determines if two requests are the same for caching purposes. If a request has the same cache key as some previous request, then Cloudflare can serve the same cached response for both.\n\n* `cacheTags` Array\\<string> optional\n\n  * This option appends additional [**Cache-Tag**](https://developers.cloudflare.com/cache/how-to/purge-cache/purge-by-tags/) headers to the response from the origin server. This allows for purges of cached content based on tags provided by the Worker, without modifications to the origin server. This is performed using the [**Purge by Tag**](https://developers.cloudflare.com/cache/how-to/purge-cache/purge-by-tags/#purge-using-cache-tags) feature.\n\n* `cacheTtl` number optional\n\n  * This option forces Cloudflare to cache the response for this request, regardless of what headers are seen on the response. This is equivalent to setting two Page Rules: [**Edge Cache TTL**](https://developers.cloudflare.com/cache/how-to/edge-browser-cache-ttl/) and [**Cache Level** (to **Cache Everything**)](https://developers.cloudflare.com/rules/page-rules/reference/settings/). The value must be zero or a positive number. A value of `0` indicates that the cache asset expires immediately. This option applies to `GET` and `HEAD` request methods only.\n\n* `cacheTtlByStatus` `{ [key: string]: number }` optional\n\n  * This option is a version of the `cacheTtl` feature which chooses a TTL based on the response’s status code. If the response to this request has a status code that matches, Cloudflare will cache for the instructed time and override cache instructives sent by the origin. For example: `{ \"200-299\": 86400, \"404\": 1, \"500-599\": 0 }`. The value can be any integer, including zero and negative integers. A value of `0` indicates that the cache asset expires immediately. Any negative value instructs Cloudflare not to cache at all. This option applies to `GET` and `HEAD` request methods only.\n\n* `image` Object | null optional\n\n  * Enables [Image Resizing](https://developers.cloudflare.com/images/transform-images/) for this request. The possible values are described in [Transform images via Workers](https://developers.cloudflare.com/images/transform-images/transform-via-workers/) documentation.\n\n* `mirage` boolean optional\n\n  * Whether [Mirage](https://www.cloudflare.com/website-optimization/mirage/) (deprecated) should be enabled for this request, if otherwise configured for this zone. Defaults to `true`.\n\n* `polish` string optional\n\n  * Sets [Polish](https://blog.cloudflare.com/introducing-polish-automatic-image-optimizati/) mode. The possible values are `lossy`, `lossless` or `off`.\n\n* `resolveOverride` string optional\n\n  * Directs the request to an alternate origin server by overriding the DNS lookup. The value of `resolveOverride` specifies an alternate hostname which will be used when determining the origin IP address, instead of using the hostname specified in the URL. The `Host` header of the request will still match what is in the URL. Thus, `resolveOverride` allows a request to be sent to a different server than the URL / `Host` header specifies. However, `resolveOverride` will only take effect if both the URL host and the host specified by `resolveOverride` are within your zone. If either specifies a host from a different zone / domain, then the option will be ignored for security reasons. If you need to direct a request to a host outside your zone (while keeping the `Host` header pointing within your zone), first create a CNAME record within your zone pointing to the outside host, and then set `resolveOverride` to point at the CNAME record. Note that, for security reasons, it is not possible to set the `Host` header to specify a host outside of your zone unless the request is actually being sent to that host.\n\n* `scrapeShield` boolean optional\n\n  * Whether [ScrapeShield](https://blog.cloudflare.com/introducing-scrapeshield-discover-defend-dete/) should be enabled for this request, if otherwise configured for this zone. Defaults to `true`.\n\n* `webp` boolean optional\n\n  * Enables or disables [WebP](https://blog.cloudflare.com/a-very-webp-new-year-from-cloudflare/) image format in [Polish](https://developers.cloudflare.com/images/polish/).\n\n***\n\n## Properties\n\nAll properties of an incoming `Request` object (the request you receive from the [`fetch()` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/)) are read-only. To modify the properties of an incoming request, create a new `Request` object and pass the options to modify to its [constructor](#constructor).\n\n* `body` ReadableStream read-only\n\n  * Stream of the body contents.\n\n* `bodyUsed` Boolean read-only\n\n  * Declares whether the body has been used in a response yet.\n\n* `cf` IncomingRequestCfProperties read-only\n\n  * An object containing properties about the incoming request provided by Cloudflare’s global network.\n  * This property is read-only (unless created from an existing `Request`). To modify its values, pass in the new values on the [`cf` key of the `init` options argument](https://developers.cloudflare.com/workers/runtime-apis/request/#the-cf-property-requestinitcfproperties) when creating a new `Request` object.\n\n* `headers` Headers read-only\n\n  * A [`Headers` object](https://developer.mozilla.org/en-US/docs/Web/API/Headers).\n\n  * Compared to browsers, Cloudflare Workers imposes very few restrictions on what headers you are allowed to send. For example, a browser will not allow you to set the `Cookie` header, since the browser is responsible for handling cookies itself. Workers, however, has no special understanding of cookies, and treats the `Cookie` header like any other header.\n\n  Warning\n\n  If the response is a redirect and the redirect mode is set to `follow` (see below), then all headers will be forwarded to the redirect destination, even if the destination is a different hostname or domain. This includes sensitive headers like `Cookie`, `Authorization`, or any application-specific headers. If this is not the behavior you want, you should set redirect mode to `manual` and implement your own redirect policy. Note that redirect mode defaults to `manual` for requests that originated from the Worker's client, so this warning only applies to `fetch()`es made by a Worker that are not proxying the original request.\n\n* `method` string read-only\n\n  * Contains the request’s method, for example, `GET`, `POST`, etc.\n\n* `redirect` string read-only\n\n  * The redirect mode to use: `follow`, `error`, or `manual`. The `fetch` method will automatically follow redirects if the redirect mode is set to `follow`. If set to `manual`, the `3xx` redirect response will be returned to the caller as-is. The default for a new `Request` object is `follow`. Note, however, that the incoming `Request` property of a `FetchEvent` will have redirect mode `manual`.\n\n* `signal` AbortSignal read-only\n\n  * The `AbortSignal` corresponding to this request. If you use the [`enable_request_signal`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#enable-requestsignal-for-incoming-requests) compatibility flag, you can attach an event listener to the signal. This allows you to perform cleanup tasks or write to logs before your Worker's invocation ends. For example, if you run the Worker below, and then abort the request from the client, a log will be written:\n\n    * JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* `url` string read-only\n\n  * Contains the URL of the request.\n\n### `IncomingRequestCfProperties`\n\nIn addition to the properties on the standard [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object, the `request.cf` object on an inbound `Request` contains information about the request provided by Cloudflare’s global network.\n\nAll plans have access to:\n\n* `asn` Number\n\n  * ASN of the incoming request, for example, `395747`.\n\n* `asOrganization` string\n\n  * The organization which owns the ASN of the incoming request, for example, `Google Cloud`.\n\n* `botManagement` Object | null\n\n  * Only set when using Cloudflare Bot Management. Object with the following properties: `score`, `verifiedBot`, `staticResource`, `ja3Hash`, `ja4`, and `detectionIds`. Refer to [Bot Management Variables](https://developers.cloudflare.com/bots/reference/bot-management-variables/) for more details.\n\n* `clientAcceptEncoding` string | null\n\n  * If Cloudflare replaces the value of the `Accept-Encoding` header, the original value is stored in the `clientAcceptEncoding` property, for example, `\"gzip, deflate, br\"`.\n\n* `colo` string\n\n  * The three-letter [`IATA`](https://en.wikipedia.org/wiki/IATA_airport_code) airport code of the data center that the request hit, for example, `\"DFW\"`.\n\n* `country` string | null\n\n  * Country of the incoming request. The two-letter country code in the request. This is the same value as that provided in the `CF-IPCountry` header, for example, `\"US\"`.\n\n* `isEUCountry` string | null\n\n  * If the country of the incoming request is in the EU, this will return `\"1\"`. Otherwise, this property is either omitted or `false`.\n\n* `httpProtocol` string\n\n  * HTTP Protocol, for example, `\"HTTP/2\"`.\n\n* `hostMetadata` Object | undefined\n\n  * Only populated when the incoming request is from a zone with custom hostname metadata. Refer to the Cloudflare for Platforms documentation for more about what you can add as [custom hostname metadata](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/custom-metadata/), and how it is exposed on the `hostMetadata` field.\n\n* `requestPriority` string | null\n\n  * The browser-requested prioritization information in the request object, for example, `\"weight=192;exclusive=0;group=3;group-weight=127\"`.\n\n* `tlsCipher` string\n\n  * The cipher for the connection to Cloudflare, for example, `\"AEAD-AES128-GCM-SHA256\"`.\n\n* `tlsClientAuth` Object | null\n\n  * Only set when using Cloudflare Access or API Shield (mTLS). Object with the following properties: `certFingerprintSHA1`, `certFingerprintSHA256`, `certIssuerDN`, `certIssuerDNLegacy`, `certIssuerDNRFC2253`, `certIssuerSKI`, `certIssuerSerial`, `certNotAfter`, `certNotBefore`, `certPresented`, `certRevoked`, `certSKI`, `certSerial`, `certSubjectDN`, `certSubjectDNLegacy`, `certSubjectDNRFC2253`, `certVerified`.\n\n* `tlsClientCiphersSha1` string\n\n  * The SHA-1 hash (Base64-encoded) of the cipher suite sent by the client during the TLS handshake, encoded in big-endian format. For example, `\"GXSPDLP4G3X+prK73a4wBuOaHRc=\"`.\n\n* `tlsClientExtensionsSha1` string\n\n  * The SHA-1 hash (Base64-encoded) of the TLS client extensions sent during the handshake, encoded in big-endian format. For example, `\"OWFiM2I5ZDc0YWI0YWYzZmFkMGU0ZjhlYjhiYmVkMjgxNTU5YTU2Mg==\"`.\n\n* `tlsClientExtensionsSha1Le` string\n\n  * The SHA-1 hash (Base64-encoded) of the TLS client extensions sent during the handshake, encoded in little-endian format. For example, `\"7zIpdDU5pvFPPBI2/PCzqbaXnRA=\"`.\n\n* `tlsClientHelloLength` string\n\n  * The length of the client hello message sent in a [TLS handshake](https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/). For example, `\"508\"`. Specifically, the length of the bytestring of the client hello.\n\n* `tlsClientRandom` string\n\n  * The value of the 32-byte random value provided by the client in a [TLS handshake](https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/). Refer to [RFC 8446](https://datatracker.ietf.org/doc/html/rfc8446#section-4.1.2) for more details.\n\n* `tlsVersion` string\n\n  * The TLS version of the connection to Cloudflare, for example, `TLSv1.3`.\n\n* `city` string | null\n\n  * City of the incoming request, for example, `\"Austin\"`.\n\n* `continent` string | null\n\n  * Continent of the incoming request, for example, `\"NA\"`.\n\n* `latitude` string | null\n\n  * Latitude of the incoming request, for example, `\"30.27130\"`.\n\n* `longitude` string | null\n\n  * Longitude of the incoming request, for example, `\"-97.74260\"`.\n\n* `postalCode` string | null\n\n  * Postal code of the incoming request, for example, `\"78701\"`.\n\n* `metroCode` string | null\n\n  * Metro code (DMA) of the incoming request.\n\n    Currently `metroCode` is not populated, but this may change in the future. Refer to the [Changelog](https://developers.cloudflare.com/changelog/) for any updates.\n\n* `region` string | null\n\n  * If known, the [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) name for the first level region associated with the IP address of the incoming request, for example, `\"Texas\"`.\n\n* `regionCode` string | null\n\n  * If known, the [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) code for the first-level region associated with the IP address of the incoming request, for example, `\"TX\"`.\n\n* `timezone` string\n\n  * Timezone of the incoming request, for example, `\"America/Chicago\"`.\n\nWarning\n\nThe `request.cf` object is not available in the Cloudflare Workers dashboard or Playground preview editor.\n\n***\n\n## Methods\n\n### Instance methods\n\nThese methods are only available on an instance of a `Request` object or through its prototype.\n\n* `clone()` : Request\n\n  * Creates a copy of the `Request` object.\n\n* `arrayBuffer()` : Promise\\<ArrayBuffer>\n\n  * Returns a promise that resolves with an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) representation of the request body.\n\n* `formData()` : Promise\\<FormData>\n\n  * Returns a promise that resolves with a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) representation of the request body.\n\n* `json()` : Promise\\<Object>\n\n  * Returns a promise that resolves with a JSON representation of the request body.\n\n* `text()` : Promise\\<string>\n\n  * Returns a promise that resolves with a string (text) representation of the request body.\n\n***\n\n## The `Request` context\n\nEach time a Worker is invoked by an incoming HTTP request, the [`fetch()` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch) is called on your Worker. The `Request` context starts when the `fetch()` handler is called, and asynchronous tasks (such as making a subrequest using the [`fetch() API`](https://developers.cloudflare.com/workers/runtime-apis/fetch/)) can only be run inside the `Request` context:",
      "language": "unknown"
    },
    {
      "code": "### When passing a promise to fetch event `.respondWith()`\n\nIf you pass a Response promise to the fetch event `.respondWith()` method, the request context is active during any asynchronous tasks which run before the Response promise has settled. You can pass the event to an async handler, for example:",
      "language": "unknown"
    },
    {
      "code": "### Errors when attempting to access an inactive `Request` context\n\nAny attempt to use APIs such as `fetch()` or access the `Request` context during script startup will throw an exception:",
      "language": "unknown"
    },
    {
      "code": "This code snippet will throw during script startup, and the `\"fetch\"` event listener will never be registered.\n\n***\n\n### Set the `Content-Length` header\n\nThe `Content-Length` header will be automatically set by the runtime based on whatever the data source for the `Request` is. Any value manually set by user code in the `Headers` will be ignored. To have a `Content-Length` header with a specific value specified, the `body` of the `Request` must be either a `FixedLengthStream` or a fixed-length value just as a string or `TypedArray`.\n\nA `FixedLengthStream` is an identity `TransformStream` that permits only a fixed number of bytes to be written to it.",
      "language": "unknown"
    },
    {
      "code": "Using any other type of `ReadableStream` as the body of a request will result in Chunked-Encoding being used.\n\n***\n\n## Related resources\n\n* [Examples: Modify request property](https://developers.cloudflare.com/workers/examples/modify-request-property/)\n* [Examples: Accessing the `cf` object](https://developers.cloudflare.com/workers/examples/accessing-the-cloudflare-object/)\n* [Reference: `Response`](https://developers.cloudflare.com/workers/runtime-apis/response/)\n* Write your Worker code in [ES modules syntax](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) for an optimized experience.\n\n</page>\n\n<page>\n---\ntitle: Response · Cloudflare Workers docs\ndescription: Interface that represents an HTTP response.\nlastUpdated: 2025-02-19T14:52:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/response/\n  md: https://developers.cloudflare.com/workers/runtime-apis/response/index.md\n---\n\nThe `Response` interface represents an HTTP response and is part of the Fetch API.\n\n***\n\n## Constructor",
      "language": "unknown"
    },
    {
      "code": "### Parameters\n\n* `body` optional\n\n  * An object that defines the body text for the response. Can be `null` or any one of the following types:\n\n    * BufferSource\n    * FormData\n    * ReadableStream\n    * URLSearchParams\n    * USVString\n\n* `init` optional\n\n  * An `options` object that contains custom settings to apply to the response.\n\nValid options for the `options` object include:\n\n* `cf` any | null\n  * An object that contains Cloudflare-specific information. This object is not part of the Fetch API standard and is only available in Cloudflare Workers. This field is only used by consumers of the Response for informational purposes and does not have any impact on Workers behavior.\n* `encodeBody` string\n  * Workers have to compress data according to the `content-encoding` header when transmitting, to serve data that is already compressed, this property has to be set to `\"manual\"`, otherwise the default is `\"automatic\"`.\n* `headers` Headers | ByteString\n  * Any headers to add to your response that are contained within a [`Headers`](https://developers.cloudflare.com/workers/runtime-apis/request/#parameters) object or object literal of [`ByteString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) key-value pairs.\n* `status` int\n  * The status code for the response, such as `200`.\n* `statusText` string\n  * The status message associated with the status code, such as, `OK`.\n* `webSocket` WebSocket | null\n  * This is present in successful WebSocket handshake responses. For example, if a client sends a WebSocket upgrade request to an origin and a Worker intercepts the request and then forwards it to the origin and the origin replies with a successful WebSocket upgrade response, the Worker sees `response.webSocket`. This establishes a WebSocket connection proxied through a Worker. Note that you cannot intercept data flowing over a WebSocket connection.\n\n## Properties\n\n* `response.body` Readable Stream\n  * A getter to get the body contents.\n* `response.bodyUsed` boolean\n  * A boolean indicating if the body was used in the response.\n* `response.headers` Headers\n  * The headers for the response.\n* `response.ok` boolean\n  * A boolean indicating if the response was successful (status in the range `200`-`299`).\n* `response.redirected` boolean\n  * A boolean indicating if the response is the result of a redirect. If so, its URL list has more than one entry.\n* `response.status` int\n  * The status code of the response (for example, `200` to indicate success).\n* `response.statusText` string\n  * The status message corresponding to the status code (for example, `OK` for `200`).\n* `response.url` string\n  * The URL of the response. The value is the final URL obtained after any redirects.\n* `response.webSocket` WebSocket?\n  * This is present in successful WebSocket handshake responses. For example, if a client sends a WebSocket upgrade request to an origin and a Worker intercepts the request and then forwards it to the origin and the origin replies with a successful WebSocket upgrade response, the Worker sees `response.webSocket`. This establishes a WebSocket connection proxied through a Worker. Note that you cannot intercept data flowing over a WebSocket connection.\n\n## Methods\n\n### Instance methods\n\n* `clone()` : Response\n\n  * Creates a clone of a [`Response`](#response) object.\n\n* `json()` : Response\n\n  * Creates a new response with a JSON-serialized payload.\n\n* `redirect()` : Response\n\n  * Creates a new response with a different URL.\n\n### Additional instance methods\n\n`Response` implements the [`Body`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#body) mixin of the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), and therefore `Response` instances additionally have the following methods available:\n\n* `arrayBuffer()` : Promise\\<ArrayBuffer>\n\n  * Takes a [`Response`](#response) stream, reads it to completion, and returns a promise that resolves with an [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer).\n\n* `formData()` : Promise\\<FormData>\n\n  * Takes a [`Response`](#response) stream, reads it to completion, and returns a promise that resolves with a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.\n\n* `json()` : Promise\\<JSON>\n\n  * Takes a [`Response`](#response) stream, reads it to completion, and returns a promise that resolves with the result of parsing the body text as [`JSON`](https://developer.mozilla.org/en-US/docs/Web/).\n\n* `text()` : Promise\\<USVString>\n\n  * Takes a [`Response`](#response) stream, reads it to completion, and returns a promise that resolves with a [`USVString`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) (text).\n\n### Set the `Content-Length` header\n\nThe `Content-Length` header will be automatically set by the runtime based on whatever the data source for the `Response` is. Any value manually set by user code in the `Headers` will be ignored. To have a `Content-Length` header with a specific value specified, the `body` of the `Response` must be either a `FixedLengthStream` or a fixed-length value just as a string or `TypedArray`.\n\nA `FixedLengthStream` is an identity `TransformStream` that permits only a fixed number of bytes to be written to it.",
      "language": "unknown"
    },
    {
      "code": "Using any other type of `ReadableStream` as the body of a response will result in chunked encoding being used.\n\n***\n\n## Related resources\n\n* [Examples: Modify response](https://developers.cloudflare.com/workers/examples/modify-response/)\n* [Examples: Conditional response](https://developers.cloudflare.com/workers/examples/conditional-response/)\n* [Reference: `Request`](https://developers.cloudflare.com/workers/runtime-apis/request/)\n* Write your Worker code in [ES modules syntax](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) for an optimized experience.\n\n</page>\n\n<page>\n---\ntitle: Remote-procedure call (RPC) · Cloudflare Workers docs\ndescription: The built-in, JavaScript-native RPC system built into Workers and\n  Durable Objects.\nlastUpdated: 2025-09-23T20:48:09.000Z\nchatbotDeprioritize: false\ntags: RPC\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/rpc/\n  md: https://developers.cloudflare.com/workers/runtime-apis/rpc/index.md\n---\n\nNote\n\nTo use RPC, [define a compatibility date](https://developers.cloudflare.com/workers/configuration/compatibility-dates) of `2024-04-03` or higher, or include `rpc` in your [compatibility flags](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag).\n\nWorkers provide a built-in, JavaScript-native [RPC (Remote Procedure Call)](https://en.wikipedia.org/wiki/Remote_procedure_call) system, allowing you to:\n\n* Define public methods on your Worker that can be called by other Workers on the same Cloudflare account, via [Service Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc)\n* Define public methods on [Durable Objects](https://developers.cloudflare.com/durable-objects) that can be called by other workers on the same Cloudflare account that declare a binding to it.\n\nThe RPC system is designed to feel as similar as possible to calling a JavaScript function in the same Worker. In most cases, you should be able to write code in the same way you would if everything was in a single Worker.\n\n## Example\n\nFor example, if Worker B implements the public method `add(a, b)`:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "- Python",
      "language": "unknown"
    },
    {
      "code": "Worker A can declare a [binding](https://developers.cloudflare.com/workers/runtime-apis/bindings) to Worker B:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Making it possible for Worker A to call the `add()` method from Worker B:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "The client, in this case Worker A, calls Worker B and tells it to execute a specific procedure using specific arguments that the client provides. This is accomplished with standard JavaScript classes.\n\n## All calls are asynchronous\n\nWhether or not the method you are calling was declared asynchronous on the server side, it will behave as such on the client side. You must `await` the result.\n\nNote that RPC calls do not actually return `Promise`s, but they return a type that behaves like a `Promise`. The type is a \"custom thenable\", in that it implements the method `then()`. JavaScript supports awaiting any \"thenable\" type, so, for the most part, you can treat the return value like a Promise.\n\n(We'll see why the type is not actually a Promise a bit later.)\n\n## Structured clonable types, and more\n\nNearly all types that are [Structured Cloneable](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types) can be used as a parameter or return value of an RPC method. This includes, most basic \"value\" types in JavaScript, including objects, arrays, strings and numbers.\n\nAs an exception to Structured Clone, application-defined classes (or objects with custom prototypes) cannot be passed over RPC, except as described below.\n\nThe RPC system also supports a number of types that are not Structured Cloneable, including:\n\n* Functions, which are replaced by stubs that call back to the sender.\n* Application-defined classes that extend `RpcTarget`, which are similarly replaced by stubs.\n* [ReadableStream](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestream/) and [WriteableStream](https://developers.cloudflare.com/workers/runtime-apis/streams/writablestream/), with automatic streaming flow control.\n* [Request](https://developers.cloudflare.com/workers/runtime-apis/request/) and [Response](https://developers.cloudflare.com/workers/runtime-apis/response/), for conveniently representing HTTP messages.\n* RPC stubs themselves, even if the stub was received from a third Worker.\n\n## Functions\n\nYou can send a function over RPC. When you do so, the function is replaced by a \"stub\". The recipient can call the stub like a function, but doing so makes a new RPC back to the place where the function originated.\n\n### Return functions from RPC methods\n\nConsider the following two Workers, connected via a [Service Binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc). The counter service provides the RPC method `newCounter()`, which returns a function:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "This function can then be called by the client Worker:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "Note\n\nRefer to [Explicit Resource Management](https://developers.cloudflare.com/workers/runtime-apis/rpc/lifecycle) to learn more about the `using` declaration shown in the example above.\n\nHow is this possible? The system is not serializing the function itself. When the function returned by `CounterService` is called, it runs within `CounterService` — even if it is called by another Worker.\n\nUnder the hood, the caller is not really calling the function itself directly, but calling what is called a \"stub\". A \"stub\" is a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) object that allows the client to call the remote service as if it were local, running in the same Worker. Behind the scenes, it calls back to the Worker that implements `CounterService` and asks it to execute the function closure that had been returned earlier.\n\n### Send functions as parameters of RPC methods\n\nYou can also send a function in the parameters of an RPC. This enables the \"server\" to call back to the \"client\", reversing the direction of the relationship.\n\nBecause of this, the words \"client\" and \"server\" can be ambiguous when talking about RPC. The \"server\" is a Durable Object or WorkerEntrypoint, and the \"client\" is the Worker that invoked the server via a binding. But, RPCs can flow both ways between the two. When talking about an individual RPC, we recommend instead using the words \"caller\" and \"callee\".\n\n## Class Instances\n\nTo use an instance of a class that you define as a parameter or return value of an RPC method, you must extend the built-in `RpcTarget` class.\n\nConsider the following example:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "The method `increment` can be called directly by the client, as can the public property `value`:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "Note\n\nRefer to [Explicit Resource Management](https://developers.cloudflare.com/workers/runtime-apis/rpc/lifecycle) to learn more about the `using` declaration shown in the example above.\n\nClasses that extend `RpcTarget` work a lot like functions: the object itself is not serialized, but is instead replaced by a stub. In this case, the stub itself is not callable, but its methods are. Calling any method on the stub actually makes an RPC back to the original object, where it was created.\n\nAs shown above, you can also access properties of classes. Properties behave like RPC methods that don't take any arguments — you await the property to asynchronously fetch its current value. Note that the act of awaiting the property (which, behind the scenes, calls `.then()` on it) is what causes the property to be fetched. If you do not use `await` when accessing the property, it will not be fetched.\n\nNote\n\nWhile it's possible to define a similar interface to the caller using an object that contains many functions, this is less efficient. If you return an object that contains five functions, then you are creating five stubs. If you return a class instance, where the class declares five methods, you are only returning a single stub. Returning a single stub is often more efficient and easier to reason about. Moreover, when returning a plain object (not a class), non-function properties of the object will be transmitted at the time the object itself is transmitted; they cannot be fetched asynchronously on-demand.\n\nNote\n\nClasses which do not inherit `RpcTarget` cannot be sent over RPC at all. This differs from Structured Clone, which defines application-defined classes as clonable. Why the difference? By default, the Structured Clone algorithm simply ignores an object's class entirely. So, the recipient receives a plain object, containing the original object's instance properties but entirely missing its original type. This behavior is rarely useful in practice, and could be confusing if the developer had intended the class to be treated as an `RpcTarget`. So, Workers RPC has chosen to disallow classes that are not `RpcTarget`s, to avoid any confusion.\n\n### Promise pipelining\n\nWhen you call an RPC method and get back an object, it's common to immediately call a method on the object:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "But consider the case where the Worker service that you are calling may be far away across the network, as in the case of [Smart Placement](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/#smart-placement) or [Durable Objects](https://developers.cloudflare.com/durable-objects). The code above makes two round trips, once when calling `getCounter()`, and again when calling `.increment()`. We'd like to avoid this.\n\nWith most RPC systems, the only way to avoid the problem would be to combine the two calls into a single \"batch\" call, perhaps called `getCounterAndIncrement()`. However, this makes the interface worse. You wouldn't design a local interface this way.\n\nWorkers RPC allows a different approach: You can simply omit the first `await`:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "In this code, `getCounter()` returns a promise for a counter. Normally, the only thing you would do with a promise is `await` it. However, Workers RPC promises are special: they also allow you to initiate speculative calls on the future result of the promise. These calls are sent to the server immediately, without waiting for the initial call to complete. Thus, multiple chained calls can be completed in a single round trip.\n\nHow does this work? The promise returned by an RPC is not a real JavaScript `Promise`. Instead, it is a custom [\"Thenable\"](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise#thenables). It has a `.then()` method like `Promise`, which allows it to be used in all the places where you'd use a normal `Promise`. For instance, you can `await` it. But, in addition to that, an RPC promise also acts like a stub. Calling any method name on the promise forms a speculative call on the promise's eventual result. This is known as \"promise pipelining\".\n\nThis works when calling properties of objects returned by RPC methods as well. For example:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "If the initial RPC ends up throwing an exception, then any pipelined calls will also fail with the same exception\n\n## ReadableStream, WriteableStream, Request and Response\n\nYou can send and receive [`ReadableStream`](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestream/), [`WriteableStream`](https://developers.cloudflare.com/workers/runtime-apis/streams/writablestream/), [`Request`](https://developers.cloudflare.com/workers/runtime-apis/request/), and [`Response`](https://developers.cloudflare.com/workers/runtime-apis/response/) using RPC methods. When doing so, bytes in the body are automatically streamed with appropriate flow control. This allows you to send messages over RPC which are larger than [the typical 32 MiB limit](#limitations).\n\nOnly [byte-oriented streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_byte_streams) (streams with an underlying byte source of `type: \"bytes\"`) are supported.\n\nIn all cases, ownership of the stream is transferred to the recipient. The sender can no longer read/write the stream after sending it. If the sender wishes to keep its own copy, it can use the [`tee()` method of `ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/tee) or the [`clone()` method of `Request` or `Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response/clone). Keep in mind that doing this may force the system to buffer bytes and lose the benefits of flow control.\n\n## Forwarding RPC stubs\n\nA stub received over RPC from one Worker can be forwarded over RPC to another Worker.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Here, three different workers are involved:\n\n1. The calling Worker (we'll call this the \"introducer\")\n2. `COUNTER_SERVICE`\n3. `ANOTHER_SERVICE`\n\nWhen `ANOTHER_SERVICE` calls a method on the `counter` that is passed to it, this call will automatically be proxied through the introducer and on to the [`RpcTarget`](https://developers.cloudflare.com/workers/runtime-apis/rpc/) class implemented by `COUNTER_SERVICE`.\n\nIn this way, the introducer Worker can connect two Workers that did not otherwise have any ability to form direct connections to each other.\n\nCurrently, this proxying only lasts until the end of the Workers' execution contexts. A proxy connection cannot be persisted for later use.\n\n## Video Tutorial\n\nIn this video, we explore how Cloudflare Workers support Remote Procedure Calls (RPC) to simplify communication between Workers. Learn how to implement RPC in your JavaScript applications and build serverless solutions with ease. Whether you're managing microservices or optimizing web architecture, this tutorial will show you how to quickly set up and use Cloudflare Workers for RPC calls. By the end of this video, you'll understand how to call functions between Workers, pass functions as arguments, and implement user authentication with Cloudflare Workers.\n\n## More Details\n\n* [Lifecycle](https://developers.cloudflare.com/workers/runtime-apis/rpc/lifecycle/)\n* [Reserved Methods](https://developers.cloudflare.com/workers/runtime-apis/rpc/reserved-methods/)\n* [Visibility and Security Model](https://developers.cloudflare.com/workers/runtime-apis/rpc/visibility/)\n* [TypeScript](https://developers.cloudflare.com/workers/runtime-apis/rpc/typescript/)\n* [Error handling](https://developers.cloudflare.com/workers/runtime-apis/rpc/error-handling/)\n\n## Limitations\n\n* [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement/) is currently ignored when making RPC calls. If Smart Placement is enabled for Worker A, and Worker B declares a [Service Binding](https://developers.cloudflare.com/workers/runtime-apis/bindings) to it, when Worker B calls Worker A via RPC, Worker A will run locally, on the same machine.\n\n* The maximum serialized RPC limit is 32 MiB. Consider using [`ReadableStream`](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestream/) when returning more data.\n\n  * JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Streams - Runtime APIs · Cloudflare Workers docs\ndescription: A web standard API that allows JavaScript to programmatically\n  access and process streams of data.\nlastUpdated: 2025-12-16T04:37:37.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/streams/\n  md: https://developers.cloudflare.com/workers/runtime-apis/streams/index.md\n---\n\nThe [Streams API](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) is a web standard API that allows JavaScript to programmatically access and process streams of data.\n\n* [ReadableStream](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestream/)\n* [ReadableStream BYOBReader](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestreambyobreader/)\n* [ReadableStream DefaultReader](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestreamdefaultreader/)\n* [TransformStream](https://developers.cloudflare.com/workers/runtime-apis/streams/transformstream/)\n* [WritableStream](https://developers.cloudflare.com/workers/runtime-apis/streams/writablestream/)\n* [WritableStream DefaultWriter](https://developers.cloudflare.com/workers/runtime-apis/streams/writablestreamdefaultwriter/)\n\nUse the Streams API to avoid buffering large requests or responses in memory. This enables you to parse extremely large request or response bodies within a Worker's 128 MB memory limit. This is faster than buffering the entire payload into memory, as your Worker can start processing data incrementally, and allows your Worker to handle multi-gigabyte payloads or files within its memory limits.\n\nWorkers do not need to prepare an entire response body before returning a `Response`. You can use a [`ReadableStream`](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestream/) to stream a response body after sending the response status line and headers.\n\nNote\n\nBy default, Cloudflare Workers is capable of streaming responses using the [Streams APIs](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API). To maintain the streaming behavior, you should only modify the response body using the methods in the Streams APIs.\n\nIf your Worker only forwards subrequest responses to the client verbatim without reading their body text, then its body handling is already optimal and you do not have to use these APIs.\n\nThe worker can create a `Response` object using a `ReadableStream` as the body. Any data provided through the `ReadableStream` will be streamed to the client as it becomes available.\n\n* Module Worker",
      "language": "unknown"
    },
    {
      "code": "* Service Worker\n\n  Service Workers are deprecated\n\n  Service Workers are deprecated, but still supported. We recommend using [Module Workers](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) instead. New features may not be supported for Service Workers.",
      "language": "unknown"
    },
    {
      "code": "A [`TransformStream`](https://developers.cloudflare.com/workers/runtime-apis/streams/transformstream/) and the [`ReadableStream.pipeTo()`](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestream/#methods) method can be used to modify the response body as it is being streamed:\n\n* Module Worker",
      "language": "unknown"
    },
    {
      "code": "* Service Worker\n\n  Service Workers are deprecated\n\n  Service Workers are deprecated, but still supported. We recommend using [Module Workers](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) instead. New features may not be supported for Service Workers.",
      "language": "unknown"
    },
    {
      "code": "This example calls `response.body.pipeTo(writable)` but does not `await` it. This is so it does not block the forward progress of the remainder of the `fetchAndStream()` function. It continues to run asynchronously until the response is complete or the client disconnects.\n\nThe runtime can continue running a function (`response.body.pipeTo(writable)`) after a response is returned to the client. This example pumps the subrequest response body to the final response body. However, you can use more complicated logic, such as adding a prefix or a suffix to the body or to process it somehow.\n\n***\n\n## Common issues\n\nWarning\n\nThe Streams API is only available inside of the [Request context](https://developers.cloudflare.com/workers/runtime-apis/request/), inside the `fetch` event listener callback.\n\n***\n\n## Related resources\n\n* [Stream large JSON](https://developers.cloudflare.com/workers/examples/streaming-json/) - Parse and transform large JSON request and response bodies\n* [MDN's Streams API documentation](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API)\n* [Streams API spec](https://streams.spec.whatwg.org/)\n* Write your Worker code in [ES modules syntax](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) for an optimized experience.\n\n</page>\n\n<page>\n---\ntitle: TCP sockets · Cloudflare Workers docs\ndescription: Use the `connect()` API to create outbound TCP connections from Workers.\nlastUpdated: 2025-08-12T20:02:42.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/\n  md: https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/index.md\n---\n\nThe Workers runtime provides the `connect()` API for creating outbound [TCP connections](https://www.cloudflare.com/learning/ddos/glossary/tcp-ip/) from Workers.\n\nMany application-layer protocols are built on top of the Transmission Control Protocol (TCP). These application-layer protocols, including SSH, MQTT, SMTP, FTP, IRC, and most database wire protocols including MySQL, PostgreSQL, MongoDB, require an underlying TCP socket API in order to work.\n\nNote\n\nConnecting to a PostgreSQL database? You should use [Hyperdrive](https://developers.cloudflare.com/hyperdrive/), which provides the `connect()` API with built-in connection pooling and query caching.\n\nNote\n\nTCP Workers outbound connections are sourced from a prefix that is not part of [list of IP ranges](https://www.cloudflare.com/ips/).\n\n## `connect()`\n\nThe `connect()` function returns a TCP socket, with both a [readable](https://developers.cloudflare.com/workers/runtime-apis/streams/readablestream/) and [writable](https://developers.cloudflare.com/workers/runtime-apis/streams/writablestream/) stream of data. This allows you to read and write data on an ongoing basis, as long as the connection remains open.\n\n`connect()` is provided as a [Runtime API](https://developers.cloudflare.com/workers/runtime-apis/), and is accessed by importing the `connect` function from `cloudflare:sockets`. This process is similar to how one imports built-in modules in Node.js. Refer to the following codeblock for an example of creating a TCP socket, writing to it, and returning the readable side of the socket as a response:",
      "language": "unknown"
    },
    {
      "code": "* `connect(address: SocketAddress | string, options?: optional SocketOptions)` : `Socket`\n  * `connect()` accepts either a URL string or [`SocketAddress`](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/#socketaddress) to define the hostname and port number to connect to, and an optional configuration object, [`SocketOptions`](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/#socketoptions). It returns an instance of a [`Socket`](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/#socket).\n\n### `SocketAddress`\n\n* `hostname` string\n\n  * The hostname to connect to. Example: `cloudflare.com`.\n\n* `port` number\n\n  * The port number to connect to. Example: `5432`.\n\n### `SocketOptions`\n\n* `secureTransport` \"off\" | \"on\" | \"starttls\" — Defaults to `off`\n\n  * Specifies whether or not to use [TLS](https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/) when creating the TCP socket.\n  * `off` — Do not use TLS.\n  * `on` — Use TLS.\n  * `starttls` — Do not use TLS initially, but allow the socket to be upgraded to use TLS by calling [`startTls()`](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/#opportunistic-tls-starttls).\n\n* `allowHalfOpen` boolean — Defaults to `false`\n\n  * Defines whether the writable side of the TCP socket will automatically close on end-of-file (EOF). When set to `false`, the writable side of the TCP socket will automatically close on EOF. When set to `true`, the writable side of the TCP socket will remain open on EOF.\n  * This option is similar to that offered by the Node.js [`net` module](https://nodejs.org/api/net.html) and allows interoperability with code which utilizes it.\n\n### `SocketInfo`\n\n* `remoteAddress` string | null\n\n  * The address of the remote peer the socket is connected to. May not always be set.\n\n* `localAddress` string | null\n\n  * The address of the local network endpoint for this socket. May not always be set.\n\n### `Socket`\n\n* `readable` : ReadableStream\n\n  * Returns the readable side of the TCP socket.\n\n* `writable` : WritableStream\n\n  * Returns the writable side of the TCP socket.\n  * The `WritableStream` returned only accepts chunks of `Uint8Array` or its views.\n\n* `opened` `Promise<SocketInfo>`\n\n  * This promise is resolved when the socket connection is established and is rejected if the socket encounters an error.\n\n* `closed` `Promise<void>`\n\n  * This promise is resolved when the socket is closed and is rejected if the socket encounters an error.\n\n* `close()` `Promise<void>`\n\n  * Closes the TCP socket. Both the readable and writable streams are forcibly closed.\n\n* `startTls()` : Socket\n\n  * Upgrades an insecure socket to a secure one that uses TLS, returning a new [Socket](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets#socket). Note that in order to call `startTls()`, you must set [`secureTransport`](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/#socketoptions) to `starttls` when initially calling `connect()` to create the socket.\n\n## Opportunistic TLS (StartTLS)\n\nMany TCP-based systems, including databases and email servers, require that clients use opportunistic TLS (otherwise known as [StartTLS](https://en.wikipedia.org/wiki/Opportunistic_TLS)) when connecting. In this pattern, the client first creates an insecure TCP socket, without TLS, and then upgrades it to a secure TCP socket, that uses TLS. The `connect()` API simplifies this by providing a method, `startTls()`, which returns a new `Socket` instance that uses TLS:",
      "language": "unknown"
    },
    {
      "code": "* `startTls()` can only be called if `secureTransport` is set to `starttls` when creating the initial TCP socket.\n* Once `startTls()` is called, the initial socket is closed and can no longer be read from or written to. In the example above, anytime after `startTls()` is called, you would use the newly created `secureSocket`. Any existing readers and writers based off the original socket will no longer work. You must create new readers and writers from the newly created `secureSocket`.\n* `startTls()` should only be called once on an existing socket.\n\n## Handle errors\n\nTo handle errors when creating a new TCP socket, reading from a socket, or writing to a socket, wrap these calls inside [`try/catch`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch) statement blocks. The following example opens a connection to Google.com, initiates a HTTP request, and returns the response. If this fails and throws an exception, it returns a `500` response:",
      "language": "unknown"
    },
    {
      "code": "## Close TCP connections\n\nYou can close a TCP connection by calling `close()` on the socket. This will close both the readable and writable sides of the socket.",
      "language": "unknown"
    },
    {
      "code": "## Considerations\n\n* Outbound TCP sockets to [Cloudflare IP ranges](https://www.cloudflare.com/ips/) are blocked.\n* TCP sockets cannot be created in global scope and shared across requests. You should always create TCP sockets within a handler (ex: [`fetch()`](https://developers.cloudflare.com/workers/get-started/guide/#3-write-code), [`scheduled()`](https://developers.cloudflare.com/workers/runtime-apis/handlers/scheduled/), [`queue()`](https://developers.cloudflare.com/queues/configuration/javascript-apis/#consumer)) or [`alarm()`](https://developers.cloudflare.com/durable-objects/api/alarms/).\n* Each open TCP socket counts towards the maximum number of [open connections](https://developers.cloudflare.com/workers/platform/limits/#simultaneous-open-connections) that can be simultaneously open.\n* By default, Workers cannot create outbound TCP connections on port `25` to send email to SMTP mail servers. [Cloudflare Email Workers](https://developers.cloudflare.com/email-routing/email-workers/) provides APIs to process and forward email.\n* Support for handling inbound TCP connections is [coming soon](https://blog.cloudflare.com/workers-tcp-socket-api-connect-databases/). Currently, it is not possible to make an inbound TCP connection to your Worker, for example, by using the `CONNECT` HTTP method.\n\n## Troubleshooting\n\nReview descriptions of common error messages you may see when working with TCP Sockets, what the error messages mean, and how to solve them.\n\n### `proxy request failed, cannot connect to the specified address`\n\nYour socket is connecting to an address that was disallowed. Examples of a disallowed address include Cloudflare IPs, `localhost`, and private network IPs.\n\nIf you need to connect to addresses on port `80` or `443` to make HTTP requests, use [`fetch`](https://developers.cloudflare.com/workers/runtime-apis/fetch/).\n\n### `TCP Loop detected`\n\nYour socket is connecting back to the Worker that initiated the outbound connection. In other words, the Worker is connecting back to itself. This is currently not supported.\n\n### `Connections to port 25 are prohibited`\n\nYour socket is connecting to an address on port `25`. This is usually the port used for SMTP mail servers. Workers cannot create outbound connections on port `25`. Consider using [Cloudflare Email Workers](https://developers.cloudflare.com/email-routing/email-workers/) instead.\n\n</page>\n\n<page>\n---\ntitle: Web Crypto · Cloudflare Workers docs\ndescription: A set of low-level functions for common cryptographic tasks.\nlastUpdated: 2025-02-19T14:52:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/web-crypto/\n  md: https://developers.cloudflare.com/workers/runtime-apis/web-crypto/index.md\n---\n\n## Background\n\nThe Web Crypto API provides a set of low-level functions for common cryptographic tasks. The Workers runtime implements the full surface of this API, but with some differences in the [supported algorithms](#supported-algorithms) compared to those implemented in most browsers.\n\nPerforming cryptographic operations using the Web Crypto API is significantly faster than performing them purely in JavaScript. If you want to perform CPU-intensive cryptographic operations, you should consider using the Web Crypto API.\n\nThe Web Crypto API is implemented through the `SubtleCrypto` interface, accessible via the global `crypto.subtle` binding. A simple example of calculating a digest (also known as a hash) is:",
      "language": "unknown"
    },
    {
      "code": "Some common uses include [signing requests](https://developers.cloudflare.com/workers/examples/signing-requests/).\n\nWarning\n\nThe Web Crypto API differs significantly from the [Node.js Crypto API](https://developers.cloudflare.com/workers/runtime-apis/nodejs/crypto/). If you are working with code that relies on the Node.js Crypto API, you can use it by enabling the [`nodejs_compat` compatibility flag](https://developers.cloudflare.com/workers/runtime-apis/nodejs/).\n\n***\n\n## Constructors\n\n* `crypto.DigestStream(algorithm)` DigestStream\n\n  * A non-standard extension to the `crypto` API that supports generating a hash digest from streaming data. The `DigestStream` itself is a [`WritableStream`](https://developers.cloudflare.com/workers/runtime-apis/streams/writablestream/) that does not retain the data written into it. Instead, it generates a hash digest automatically when the flow of data has ended.\n\n### Parameters\n\n* `algorithm`string | object\n\n  * Describes the algorithm to be used, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#Syntax).\n\n### Usage\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "## Methods\n\n* `crypto.randomUUID()` : string\n\n  * Generates a new random (version 4) UUID as defined in [RFC 4122](https://www.rfc-editor.org/rfc/rfc4122.txt).\n\n* `crypto.getRandomValues(bufferArrayBufferView)` : ArrayBufferView\n\n  * Fills the passed `ArrayBufferView` with cryptographically sound random values and returns the `buffer`.\n\n### Parameters\n\n* `buffer`ArrayBufferView\n\n  * Must be an Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | BigInt64Array | BigUint64Array.\n\n## SubtleCrypto Methods\n\nThese methods are all accessed via [`crypto.subtle`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto#Methods), which is also documented in detail on MDN.\n\n### encrypt\n\n* `encrypt(algorithm, key, data)` : Promise\\<ArrayBuffer>\n\n  * Returns a Promise that fulfills with the encrypted data corresponding to the clear text, algorithm, and key given as parameters.\n\n#### Parameters\n\n* `algorithm`object\n\n  * Describes the algorithm to be used, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#Syntax).\n\n* `key`CryptoKey\n\n* `data`BufferSource\n\n### decrypt\n\n* `decrypt(algorithm, key, data)` : Promise\\<ArrayBuffer>\n\n  * Returns a Promise that fulfills with the clear data corresponding to the ciphertext, algorithm, and key given as parameters.\n\n#### Parameters\n\n* `algorithm`object\n\n  * Describes the algorithm to be used, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt#Syntax).\n\n* `key`CryptoKey\n\n* `data`BufferSource\n\n### sign\n\n* `sign(algorithm, key, data)` : Promise\\<ArrayBuffer>\n\n  * Returns a Promise that fulfills with the signature corresponding to the text, algorithm, and key given as parameters.\n\n#### Parameters\n\n* `algorithm`string | object\n\n  * Describes the algorithm to be used, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/sign#Syntax).\n\n* `key`CryptoKey\n\n* `data`ArrayBuffer\n\n### verify\n\n* `verify(algorithm, key, signature, data)` : Promise\\<boolean>\n\n  * Returns a Promise that fulfills with a Boolean value indicating if the signature given as a parameter matches the text, algorithm, and key that are also given as parameters.\n\n#### Parameters\n\n* `algorithm`string | object\n\n  * Describes the algorithm to be used, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/verify#Syntax).\n\n* `key`CryptoKey\n\n* `signature`ArrayBuffer\n\n* `data`ArrayBuffer\n\n### digest\n\n* `digest(algorithm, data)` : Promise\\<ArrayBuffer>\n\n  * Returns a Promise that fulfills with a digest generated from the algorithm and text given as parameters.\n\n#### Parameters\n\n* `algorithm`string | object\n\n  * Describes the algorithm to be used, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest#Syntax).\n\n* `data`ArrayBuffer\n\n### generateKey\n\n* `generateKey(algorithm, extractable, keyUsages)` : Promise\\<CryptoKey> | Promise\\<CryptoKeyPair>\n\n  * Returns a Promise that fulfills with a newly-generated `CryptoKey`, for symmetrical algorithms, or a `CryptoKeyPair`, containing two newly generated keys, for asymmetrical algorithms. For example, to generate a new AES-GCM key:",
      "language": "unknown"
    },
    {
      "code": "#### Parameters\n\n* `algorithm`object\n\n  * Describes the algorithm to be used, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey#Syntax).\n\n* `extractable`bool\n\n* `keyUsages`Array\n\n  * An Array of strings indicating the [possible usages of the new key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey#Syntax).\n\n### deriveKey\n\n* `deriveKey(algorithm, baseKey, derivedKeyAlgorithm, extractable, keyUsages)` : Promise\\<CryptoKey>\n\n  * Returns a Promise that fulfills with a newly generated `CryptoKey` derived from the base key and specific algorithm given as parameters.\n\n#### Parameters\n\n* `algorithm`object\n\n  * Describes the algorithm to be used, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#Syntax).\n\n* `baseKeyCryptoKey`\n\n* `derivedKeyAlgorithmobject`\n  * Defines the algorithm the derived key will be used for in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#Syntax).\n\n* `extractablebool`\n\n* `keyUsagesArray`\n  * An Array of strings indicating the [possible usages of the new key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#Syntax)\n\n### deriveBits\n\n* `deriveBits(algorithm, baseKey, length)` : Promise\\<ArrayBuffer>\n\n  * Returns a Promise that fulfills with a newly generated buffer of pseudo-random bits derived from the base key and specific algorithm given as parameters. It returns a Promise which will be fulfilled with an `ArrayBuffer` containing the derived bits. This method is very similar to `deriveKey()`, except that `deriveKey()` returns a `CryptoKey` object rather than an `ArrayBuffer`. Essentially, `deriveKey()` is composed of `deriveBits()` followed by `importKey()`.\n\n#### Parameters\n\n* `algorithm`object\n\n  * Describes the algorithm to be used, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits#Syntax).\n\n* `baseKey`CryptoKey\n\n* `length`int\n\n  * Length of the bit string to derive.\n\n### importKey\n\n* `importKey(format, keyData, algorithm, extractable, keyUsages)` : Promise\\<CryptoKey>\n\n  * Transform a key from some external, portable format into a `CryptoKey` for use with the Web Crypto API.\n\n#### Parameters\n\n* `format`string\n\n  * Describes [the format of the key to be imported](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#Syntax).\n\n* `keyData`ArrayBuffer\n\n* `algorithm`object\n\n  * Describes the algorithm to be used, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#Syntax).\n\n* `extractable`bool\n\n* `keyUsages`Array\n\n  * An Array of strings indicating the [possible usages of the new key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#Syntax)\n\n### exportKey\n\n* `exportKey(formatstring, keyCryptoKey)` : Promise\\<ArrayBuffer>\n\n  * Transform a `CryptoKey` into a portable format, if the `CryptoKey` is `extractable`.\n\n#### Parameters\n\n* `format`string\n\n  * Describes the [format in which the key will be exported](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey#Syntax).\n\n* `key`CryptoKey\n\n### wrapKey\n\n* `wrapKey(format, key, wrappingKey, wrapAlgo)` : Promise\\<ArrayBuffer>\n\n  * Transform a `CryptoKey` into a portable format, and then encrypt it with another key. This renders the `CryptoKey` suitable for storage or transmission in untrusted environments.\n\n#### Parameters\n\n* `format`string\n\n  * Describes the [format in which the key will be exported](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/wrapKey#Syntax) before being encrypted.\n\n* `key`CryptoKey\n\n* `wrappingKey`CryptoKey\n\n* `wrapAlgo`object\n\n  * Describes the algorithm to be used to encrypt the exported key, including any required parameters, in [an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/wrapKey#Syntax).\n\n### unwrapKey\n\n* `unwrapKey(format, key, unwrappingKey, unwrapAlgo, \n  unwrappedKeyAlgo, extractable, keyUsages)` : Promise\\<CryptoKey>\n\n  * Transform a key that was wrapped by `wrapKey()` back into a `CryptoKey`.\n\n#### Parameters\n\n* `format`string\n\n  * Described the [data format of the key to be unwrapped](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/unwrapKey#Syntax).\n\n* `key`CryptoKey\n\n* `unwrappingKey`CryptoKey\n\n* `unwrapAlgo`object\n\n  * Describes the algorithm that was used to encrypt the wrapped key, [in an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/unwrapKey#Syntax).\n\n* `unwrappedKeyAlgo`object\n\n  * Describes the key to be unwrapped, [in an algorithm-specific format](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/unwrapKey#Syntax).\n\n* `extractable`bool\n\n* `keyUsages`Array\n\n  * An Array of strings indicating the [possible usages of the new key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/unwrapKey#Syntax)\n\n### timingSafeEqual\n\n* `timingSafeEqual(a, b)` : bool\n\n  * Compare two buffers in a way that is resistant to timing attacks. This is a non-standard extension to the Web Crypto API.\n\n#### Parameters\n\n* `a`ArrayBuffer | TypedArray\n\n* `b`ArrayBuffer | TypedArray\n\n### Supported algorithms\n\nWorkers implements all operations of the [WebCrypto standard](https://www.w3.org/TR/WebCryptoAPI/), as shown in the following table.\n\nA checkmark (✓) indicates that this feature is believed to be fully supported according to the spec.\\\nAn x (✘) indicates that this feature is part of the specification but not implemented.\\\nIf a feature only implements the operation partially, details are listed.\n\n| Algorithm | sign() verify() | encrypt() decrypt() | digest() | deriveBits() deriveKey() | generateKey() | wrapKey() unwrapKey() | exportKey() | importKey() |\n| - | - | - | - | - | - | - | - | - |\n| RSASSA PKCS1 v1.5 | ✓ | | | | ✓ | | ✓ | ✓ |\n| RSA PSS | ✓ | | | | ✓ | | ✓ | ✓ |\n| RSA OAEP | | ✓ | | | ✓ | ✓ | ✓ | ✓ |\n| ECDSA | ✓ | | | | ✓ | | ✓ | ✓ |\n| ECDH | | | | ✓ | ✓ | | ✓ | ✓ |\n| Ed25519[1](#footnote-1) | ✓ | | | | ✓ | | ✓ | ✓ |\n| X25519[1](#footnote-1) | | | | ✓ | ✓ | | ✓ | ✓ |\n| NODE ED25519[2](#footnote-2) | ✓ | | | | ✓ | | ✓ | ✓ |\n| AES CTR | | ✓ | | | ✓ | ✓ | ✓ | ✓ |\n| AES CBC | | ✓ | | | ✓ | ✓ | ✓ | ✓ |\n| AES GCM | | ✓ | | | ✓ | ✓ | ✓ | ✓ |\n| AES KW | | | | | ✓ | ✓ | ✓ | ✓ |\n| HMAC | ✓ | | | | ✓ | | ✓ | ✓ |\n| SHA 1 | | | ✓ | | | | | |\n| SHA 256 | | | ✓ | | | | | |\n| SHA 384 | | | ✓ | | | | | |\n| SHA 512 | | | ✓ | | | | | |\n| MD5[3](#footnote-3) | | | ✓ | | | | | |\n| HKDF | | | | ✓ | | | | ✓ |\n| PBKDF2 | | | | ✓ | | | | ✓ |\n\n**Footnotes:**\n\n1. []()Algorithms as specified in the [Secure Curves API](https://wicg.github.io/webcrypto-secure-curves).\n\n2. []()Legacy non-standard EdDSA is supported for the Ed25519 curve in addition to the Secure Curves version. Since this algorithm is non-standard, note the following while using it:\n\n   * Use `NODE-ED25519` as the algorithm and `namedCurve` parameters.\n   * Unlike NodeJS, Cloudflare will not support raw import of private keys.\n   * The algorithm implementation may change over time. While Cloudflare cannot guarantee it at this time, Cloudflare will strive to maintain backward compatibility and compatibility with NodeJS's behavior. Any notable compatibility notes will be communicated in release notes and via this developer documentation.\n\n3. []()MD5 is not part of the WebCrypto standard but is supported in Cloudflare Workers for interacting with legacy systems that require MD5. MD5 is considered a weak algorithm. Do not rely upon MD5 for security.\n\n***\n\n## Related resources\n\n* [SubtleCrypto documentation on MDN](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto)\n* [SubtleCrypto documentation as part of the W3C Web Crypto API specification](https://www.w3.org/TR/WebCryptoAPI//#subtlecrypto-interface)\n* [Example: signing requests](https://developers.cloudflare.com/workers/examples/signing-requests/)\n\n</page>\n\n<page>\n---\ntitle: JavaScript and web standards · Cloudflare Workers docs\ndescription: Standardized APIs for use by Workers running on Cloudflare's global network.\nlastUpdated: 2025-10-16T14:16:15.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/web-standards/\n  md: https://developers.cloudflare.com/workers/runtime-apis/web-standards/index.md\n---\n\n## JavaScript standards\n\nThe Cloudflare Workers runtime is [built on top of the V8 JavaScript and WebAssembly engine](https://developers.cloudflare.com/workers/reference/how-workers-works/). The Workers runtime is updated at least once a week, to at least the version of V8 that is currently used by Google Chrome's stable release. This means you can safely use the latest JavaScript features, with no need for transpilers.\n\nAll of the [standard built-in objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference) supported by the current Google Chrome stable release are supported, with a few notable exceptions:\n\n* For security reasons, the following are not allowed:\n\n  * `eval()`\n  * `new Function`\n  * [`WebAssembly.compile`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/compile_static)\n  * [`WebAssembly.compileStreaming`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/compileStreaming_static)\n  * `WebAssembly.instantiate` with a [buffer parameter](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiate_static#primary_overload_%E2%80%94_taking_wasm_binary_code)\n  * [`WebAssembly.instantiateStreaming`](https://developer.mozilla.org/en-US/docs/WebAssembly/JavaScript_interface/instantiateStreaming_static)\n\n* `Date.now()` returns the time of the last I/O; it does not advance during code execution.\n\n***\n\n## Web standards and global APIs\n\nThe following methods are available per the [Worker Global Scope](https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope):\n\n### Base64 utility methods\n\n* atob()\n\n  * Decodes a string of data which has been encoded using base-64 encoding.\n\n* btoa()\n\n  * Creates a base-64 encoded ASCII string from a string of binary data.\n\n### Timers\n\n* setInterval()\n\n  * Schedules a function to execute every time a given number of milliseconds elapses.\n\n* clearInterval()\n\n  * Cancels the repeated execution set using [`setInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/setInterval).\n\n* setTimeout()\n\n  * Schedules a function to execute in a given amount of time.\n\n* clearTimeout()\n\n  * Cancels the delayed execution set using [`setTimeout()`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout).\n\nNote\n\nTimers are only available inside of [the Request Context](https://developers.cloudflare.com/workers/runtime-apis/request/#the-request-context).\n\n### `performance.timeOrigin` and `performance.now()`\n\n* performance.timeOrigin\n\n  * Returns the high resolution time origin. Workers uses the UNIX epoch as the time origin, meaning that `performance.timeOrigin` will always return `0`.\n\n* performance.now()\n\n  * Returns a `DOMHighResTimeStamp` representing the number of milliseconds elapsed since `performance.timeOrigin`. Note that Workers intentionally reduces the precision of `performance.now()` such that it returns the time of the last I/O and does not advance during code execution. Effectively, because of this, and because `performance.timeOrigin` is always, `0`, `performance.now()` will always equal `Date.now()`, yielding a consistent view of the passage of time within a Worker.\n\n### `EventTarget` and `Event`\n\nThe [`EventTarget`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) and [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) API allow objects to publish and subscribe to events.\n\n### `AbortController` and `AbortSignal`\n\nThe [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) and [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) APIs provide a common model for canceling asynchronous operations.\n\n### Fetch global\n\n* fetch()\n  * Starts the process of fetching a resource from the network. Refer to [Fetch API](https://developers.cloudflare.com/workers/runtime-apis/fetch/).\n\nNote\n\nThe Fetch API is only available inside of [the Request Context](https://developers.cloudflare.com/workers/runtime-apis/request/#the-request-context).\n\n***\n\n## Encoding API\n\nBoth `TextEncoder` and `TextDecoder` support UTF-8 encoding/decoding.\n\n[Refer to the MDN documentation for more information](https://developer.mozilla.org/en-US/docs/Web/API/Encoding_API).\n\nThe [`TextEncoderStream`](https://developer.mozilla.org/en-US/docs/Web/API/TextEncoderStream) and [`TextDecoderStream`](https://developer.mozilla.org/en-US/docs/Web/API/TextDecoderStream) classes are also available.\n\n***\n\n## URL API\n\nThe URL API supports URLs conforming to HTTP and HTTPS schemes.\n\n[Refer to the MDN documentation for more information](https://developer.mozilla.org/en-US/docs/Web/API/URL)\n\nNote\n\nThe default URL class behavior differs from the URL Spec documented above.\n\nA new spec-compliant implementation of the URL class can be enabled using the `url_standard` [compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/).\n\n***\n\n## Compression Streams\n\nThe `CompressionStream` and `DecompressionStream` classes support the deflate, deflate-raw and gzip compression methods.\n\n[Refer to the MDN documentation for more information](https://developer.mozilla.org/en-US/docs/Web/API/Compression_Streams_API)\n\n***\n\n## URLPattern API\n\nThe `URLPattern` API provides a mechanism for matching URLs based on a convenient pattern syntax.\n\n[Refer to the MDN documentation for more information](https://developer.mozilla.org/en-US/docs/Web/API/URLPattern).\n\n***\n\n## `Intl`\n\nThe `Intl` API allows you to format dates, times, numbers, and more to the format that is used by a provided locale (language and region).\n\n[Refer to the MDN documentation for more information](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl).\n\n***\n\n## `navigator.userAgent`\n\nWhen the [`global_navigator`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#global-navigator) compatibility flag is set, the [`navigator.userAgent`](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userAgent) property is available with the value `'Cloudflare-Workers'`. This can be used, for example, to reliably determine that code is running within the Workers environment.\n\n## Unhandled promise rejections\n\nThe [`unhandledrejection`](https://developer.mozilla.org/en-US/docs/Web/API/Window/unhandledrejection_event) event is emitted by the global scope when a JavaScript promise is rejected without a rejection handler attached.\n\nThe [`rejectionhandled`](https://developer.mozilla.org/en-US/docs/Web/API/Window/rejectionhandled_event) event is emitted by the global scope when a JavaScript promise rejection is handled late (after a rejection handler is attached to the promise after an `unhandledrejection` event has already been emitted).",
      "language": "unknown"
    },
    {
      "code": "***\n\n## `navigator.sendBeacon(url[, data])`\n\nWhen the [`global_navigator`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#global-navigator) compatibility flag is set, the [`navigator.sendBeacon(...)`](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon) API is available to send an HTTP `POST` request containing a small amount of data to a web server. This API is intended as a means of transmitting analytics or diagnostics information asynchronously on a best-effort basis.\n\nFor example, you can replace:",
      "language": "unknown"
    },
    {
      "code": "with `navigator.sendBeacon(...)`:",
      "language": "unknown"
    },
    {
      "code": "## The Web File System Access API\n\nWhen the `enable_web_file_system` compatibility flag is set, Workers supports the [Web File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API), which allows you to read and write files and directories to a virtual file system within the Worker environment. This API provides access to the same in-memory virtual file system as the [`node:fs` module](https://developers.cloudflare.com/workers/runtime-apis/nodejs/fs/) but does not require Node.js compatibility to be enabled.",
      "language": "unknown"
    },
    {
      "code": "Please refer to the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API) for more information on using this API, and to the [`node:fs` documentation](https://developers.cloudflare.com/workers/runtime-apis/nodejs/fs/) for details on the virtual file system structure and limitations.\n\n</page>\n\n<page>\n---\ntitle: WebAssembly (Wasm) · Cloudflare Workers docs\ndescription: Execute code written in a language other than JavaScript or write\n  an entire Cloudflare Worker in Rust.\nlastUpdated: 2025-08-11T21:35:02.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/webassembly/\n  md: https://developers.cloudflare.com/workers/runtime-apis/webassembly/index.md\n---\n\n[WebAssembly](https://webassembly.org/) (abbreviated Wasm) allows you to compile languages like [Rust](https://developers.cloudflare.com/workers/languages/rust/), Go, or C to a binary format that can run in a wide variety of environments, including [web browsers](https://developer.mozilla.org/en-US/docs/WebAssembly#browser_compatibility), Cloudflare Workers, and other WebAssembly runtimes.\n\nYou can use WebAssembly to:\n\n* Execute code written in a language other than JavaScript, via `WebAssembly.instantiate()`.\n\n  Note\n\n  `WebAssembly.instantiate()` only supports pre-compiled modules as documented in the [web-standards documentation](https://developers.cloudflare.com/workers/runtime-apis/web-standards/#javascript-standards).\n\n* Write an entire Cloudflare Worker in Rust, using bindings that make Workers' JavaScript APIs available directly from your Rust code.\n\nMost programming languages can be compiled to Wasm, although support varies across languages and compilers. Guides are available for the following languages:\n\n* [Wasm in JavaScript](https://developers.cloudflare.com/workers/runtime-apis/webassembly/javascript/)\n\n## Supported proposals\n\nWebAssembly is a rapidly evolving set of standards, with [many proposed APIs](https://webassembly.org/roadmap/) which are in various stages of development. In general, Workers supports the same set of features that are available in Google Chrome.\n\n### SIMD\n\nSIMD is supported on Workers. For more information on using SIMD in WebAssembly, refer to [Fast, parallel applications with WebAssembly SIMD](https://v8.dev/features/simd).\n\n### Threading\n\nThreading is not possible in Workers. Each Worker runs in a single thread, and the [Web Worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API) API is not supported.\n\n## Binary size\n\nCompiling to WebAssembly often requires including additional runtime dependencies. As a result, Workers that use WebAssembly are typically larger than an equivalent Worker written in JavaScript. The larger your Worker is, the longer it may take your Worker to start. Refer to [Worker startup time](https://developers.cloudflare.com/workers/platform/limits/#worker-startup-time) for more information. We recommend using tools like [`wasm-opt`](https://github.com/brson/wasm-opt-rs) to optimize the size of your Wasm binary.\n\n## WebAssembly System Interface (WASI)\n\nThe [WebAssembly System Interface](https://wasi.dev/) (abbreviated WASI) is a modular system interface for WebAssembly that standardizes a set of underlying system calls for networking, file system access, and more. Applications can depend on the WebAssembly System Interface to behave identically across host environments and operating systems.\n\nWASI is an earlier and more rapidly evolving set of standards than Wasm. WASI support is experimental on Cloudflare Workers, with only some syscalls implemented. Refer to our [open source implementation of WASI](https://github.com/cloudflare/workers-wasi), and [blog post about WASI on Workers](https://blog.cloudflare.com/announcing-wasi-on-workers/) demonstrating its use.\n\n### Resources on WebAssembly\n\n* [Serverless Rust with Cloudflare Workers](https://blog.cloudflare.com/cloudflare-workers-as-a-serverless-rust-platform/)\n* [WebAssembly on Cloudflare Workers](https://blog.cloudflare.com/webassembly-on-cloudflare-workers/)\n\n</page>\n\n<page>\n---\ntitle: WebSockets · Cloudflare Workers docs\ndescription: Communicate in real time with your Cloudflare Workers.\nlastUpdated: 2024-11-22T16:22:29.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/runtime-apis/websockets/\n  md: https://developers.cloudflare.com/workers/runtime-apis/websockets/index.md\n---\n\n## Background\n\nWebSockets allow you to communicate in real time with your Cloudflare Workers serverless functions. For a complete example, refer to [Using the WebSockets API](https://developers.cloudflare.com/workers/examples/websockets/).\n\nNote\n\nIf your application needs to coordinate among multiple WebSocket connections, such as a chat room or game match, you will need clients to send messages to a single-point-of-coordination. Durable Objects provide a single-point-of-coordination for Cloudflare Workers, and are often used in parallel with WebSockets to persist state over multiple clients and connections. In this case, refer to [Durable Objects](https://developers.cloudflare.com/durable-objects/) to get started, and prefer using the Durable Objects' extended [WebSockets API](https://developers.cloudflare.com/durable-objects/best-practices/websockets/).\n\n## Constructor",
      "language": "unknown"
    },
    {
      "code": "The WebSocketPair returned from this constructor is an Object, with two WebSockets at keys `0` and `1`.\n\nThese WebSockets are commonly referred to as `client` and `server`. The below example combines `Object.values` and ES6 destructuring to retrieve the WebSockets as `client` and `server`:",
      "language": "unknown"
    },
    {
      "code": "## Methods\n\n### accept\n\n* `accept()`\n  * Accepts the WebSocket connection and begins terminating requests for the WebSocket on Cloudflare's global network. This effectively enables the Workers runtime to begin responding to and handling WebSocket requests.\n\n### addEventListener\n\n* `addEventListener(eventWebSocketEvent, callbackFunctionFunction)`\n  * Add callback functions to be executed when an event has occurred on the WebSocket.\n\n#### Parameters\n\n* `event` WebSocketEvent\n\n  * The WebSocket event (refer to [Events](https://developers.cloudflare.com/workers/runtime-apis/websockets/#events)) to listen to.\n\n* `callbackFunction(messageMessage)` Function\n\n  * A function to be called when the WebSocket responds to a specific event.\n\n### close\n\n* `close(codenumber, reasonstring)`\n  * Close the WebSocket connection.\n\n#### Parameters\n\n* `codeinteger` optional\n\n  * An integer indicating the close code sent by the server. This should match an option from the [list of status codes](https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#status_codes) provided by the WebSocket spec.\n\n* `reasonstring` optional\n\n  * A human-readable string indicating why the WebSocket connection was closed.\n\n### send\n\n* `send(messagestring | ArrayBuffer | ArrayBufferView)`\n  * Send a message to the other WebSocket in this WebSocket pair.\n\n#### Parameters\n\n* `messagestring`\n  * The message to send down the WebSocket connection to the corresponding client. This should be a string or something coercible into a string; for example, strings and numbers will be simply cast into strings, but objects and arrays should be cast to JSON strings using `JSON.stringify`, and parsed in the client.\n\n***\n\n## Events\n\n* `close`\n  * An event indicating the WebSocket has closed.\n* `error`\n  * An event indicating there was an error with the WebSocket.\n* `message`\n  * An event indicating a new message received from the client, including the data passed by the client.\n\nNote\n\nWebSocket messages received by a Worker have a size limit of 1 MiB (1048576). If a larger message is sent, the WebSocket will be automatically closed with a `1009` \"Message is too large\" response.\n\n## Types\n\n### Message\n\n* `data` any - The data passed back from the other WebSocket in your pair.\n* `type` string - Defaults to `message`.\n\n***\n\n## Related resources\n\n* [Mozilla Developer Network's (MDN) documentation on the WebSocket class](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\n* [Our WebSocket template for building applications on Workers using WebSockets](https://github.com/cloudflare/websocket-template)\n\n</page>\n\n<page>\n---\ntitle: Miniflare · Cloudflare Workers docs\ndescription: >-\n  Miniflare is a simulator for developing and testing\n\n  Cloudflare Workers. It's written in\n\n  TypeScript, and runs your code in a sandbox implementing Workers' runtime\n  APIs.\nlastUpdated: 2025-04-10T20:52:52.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/testing/miniflare/\n  md: https://developers.cloudflare.com/workers/testing/miniflare/index.md\n---\n\nWarning\n\nThis documentation describes the Miniflare API, which is only relevant for advanced use cases. Instead, most users should use [Wrangler](https://developers.cloudflare.com/workers/wrangler) to build, run & deploy their Workers locally\n\n**Miniflare** is a simulator for developing and testing [**Cloudflare Workers**](https://workers.cloudflare.com/). It's written in TypeScript, and runs your code in a sandbox implementing Workers' runtime APIs.\n\n* 🎉 **Fun:** develop Workers easily with detailed logging, file watching and pretty error pages supporting source maps.\n* 🔋 **Full-featured:** supports most Workers features, including KV, Durable Objects, WebSockets, modules and more.\n* ⚡ **Fully-local:** test and develop Workers without an Internet connection. Reload code on change quickly.\n\n[Get Started](https://developers.cloudflare.com/workers/testing/miniflare/get-started)\n\n[GitHub](https://github.com/cloudflare/workers-sdk/tree/main/packages/miniflare)\n\n[NPM](https://npmjs.com/package/miniflare)\n\n***\n\nThese docs primarily cover Miniflare specific things. For more information on runtime APIs, refer to the [Cloudflare Workers docs](https://developers.cloudflare.com/workers).\n\nIf you find something that doesn't behave as it does in the production Workers environment (and this difference isn't documented), or something's wrong in these docs, please [open a GitHub issue](https://github.com/cloudflare/workers-sdk/issues/new/choose).\n\n* [Get Started](https://developers.cloudflare.com/workers/testing/miniflare/get-started/)\n* [Writing tests ](https://developers.cloudflare.com/workers/testing/miniflare/writing-tests/): Write integration tests against Workers using Miniflare.\n* [Core](https://developers.cloudflare.com/workers/testing/miniflare/core/)\n* [Developing](https://developers.cloudflare.com/workers/testing/miniflare/developing/)\n* [Migrations ](https://developers.cloudflare.com/workers/testing/miniflare/migrations/): Review migration guides for specific versions of Miniflare.\n* [Storage](https://developers.cloudflare.com/workers/testing/miniflare/storage/)\n\n</page>\n\n<page>\n---\ntitle: Wrangler's unstable_startWorker() · Cloudflare Workers docs\ndescription: Write integration tests using Wrangler's `unstable_startWorker()` API\nlastUpdated: 2025-04-10T14:17:11.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/testing/unstable_startworker/\n  md: https://developers.cloudflare.com/workers/testing/unstable_startworker/index.md\n---\n\nNote\n\nFor most users, Cloudflare recommends using the Workers Vitest integration. If you have been using `unstable_dev()`, refer to the [Migrate from `unstable_dev()` guide](https://developers.cloudflare.com/workers/testing/vitest-integration/migration-guides/migrate-from-unstable-dev/).\n\nWarning\n\n`unstable_startWorker()` is an experimental API subject to breaking changes.\n\nIf you do not want to use Vitest, consider using [Wrangler's `unstable_startWorker()` API](https://developers.cloudflare.com/workers/wrangler/api/#unstable_startworker). This API exposes the internals of Wrangler's dev server, and allows you to customise how it runs. Compared to using [Miniflare directly for testing](https://developers.cloudflare.com/workers/testing/miniflare/writing-tests/), you can pass in a Wrangler configuration file, and it will automatically load the configuration for you.\n\nThis example uses `node:test`, but should apply to any testing framework:",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Vitest integration · Cloudflare Workers docs\ndescription: For most users, Cloudflare recommends using the Workers Vitest\n  integration for testing Workers and Pages Functions projects. Vitest is a\n  popular JavaScript testing framework featuring a very fast watch mode, Jest\n  compatibility, and out-of-the-box support for TypeScript. In this integration,\n  Cloudflare provides a custom pool that allows your Vitest tests to run inside\n  the Workers runtime.\nlastUpdated: 2025-04-10T14:17:11.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/testing/vitest-integration/\n  md: https://developers.cloudflare.com/workers/testing/vitest-integration/index.md\n---\n\nFor most users, Cloudflare recommends using the Workers Vitest integration for testing Workers and [Pages Functions](https://developers.cloudflare.com/pages/functions/) projects. [Vitest](https://vitest.dev/) is a popular JavaScript testing framework featuring a very fast watch mode, Jest compatibility, and out-of-the-box support for TypeScript. In this integration, Cloudflare provides a custom pool that allows your Vitest tests to run *inside* the Workers runtime.\n\nThe Workers Vitest integration:\n\n* Supports both **unit tests** and **integration tests**.\n* Provides direct access to Workers runtime APIs and bindings.\n* Implements isolated per-test storage.\n* Runs tests fully-locally using [Miniflare](https://miniflare.dev/).\n* Leverages Vitest's hot-module reloading for near instant reruns.\n* Provides a declarative interface for mocking outbound requests.\n* Supports projects with multiple Workers.\n\n[Write your first test](https://developers.cloudflare.com/workers/testing/vitest-integration/write-your-first-test/)\n\n</page>\n\n<page>\n---\ntitle: Billing and Limitations · Cloudflare Workers docs\ndescription: Billing, troubleshooting, and limitations for Static assets on Workers\nlastUpdated: 2025-06-20T19:49:19.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/static-assets/billing-and-limitations/\n  md: https://developers.cloudflare.com/workers/static-assets/billing-and-limitations/index.md\n---\n\n## Billing\n\nRequests to a project with static assets can either return static assets or invoke the Worker script, depending on if the request [matches a static asset or not](https://developers.cloudflare.com/workers/static-assets/routing/).\n\n* Requests to static assets are free and unlimited. Requests to the Worker script (for example, in the case of SSR content) are billed according to Workers pricing. Refer to [pricing](https://developers.cloudflare.com/workers/platform/pricing/#example-2) for an example.\n* There is no additional cost for storing Assets.\n* **Important note for free tier users**: When using [`run_worker_first`](https://developers.cloudflare.com/workers/static-assets/binding/#run_worker_first), requests matching the specified patterns will always invoke your Worker script. If you exceed your free tier request limits, these requests will receive a 429 (Too Many Requests) response instead of falling back to static asset serving. Negative patterns (patterns beginning with `!/`) will continue to serve assets correctly, as requests are directed to assets, without invoking your Worker script.\n\n## Limitations\n\nSee the [Platform Limits](https://developers.cloudflare.com/workers/platform/limits/#static-assets)\n\n## Troubleshooting\n\n* `assets.bucket is a required field` — if you see this error, you need to update Wrangler to at least `3.78.10` or later. `bucket` is not a required field.\n\n</page>\n\n<page>\n---\ntitle: Configuration and Bindings · Cloudflare Workers docs\ndescription: Details on how to configure Workers static assets and its binding.\nlastUpdated: 2025-09-23T20:48:09.000Z\nchatbotDeprioritize: false\ntags: Bindings\nsource_url:\n  html: https://developers.cloudflare.com/workers/static-assets/binding/\n  md: https://developers.cloudflare.com/workers/static-assets/binding/index.md\n---\n\nConfiguring a Worker with assets requires specifying a [directory](https://developers.cloudflare.com/workers/static-assets/binding/#directory) and, optionally, an [assets binding](https://developers.cloudflare.com/workers/static-assets/binding/), in your Worker's Wrangler file. The [assets binding](https://developers.cloudflare.com/workers/static-assets/binding/) allows you to dynamically fetch assets from within your Worker script (e.g. `env.ASSETS.fetch()`), similarly to how you might with a make a `fetch()` call with a [Service binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/http/).\n\nOnly one collection of static assets can be configured in each Worker.\n\n## `directory`\n\nThe folder of static assets to be served. For many frameworks, this is the `./public/`, `./dist/`, or `./build/` folder.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "### Ignoring assets\n\nSometime there are files in the asset directory that should not be uploaded.\n\nIn this case, create a `.assetsignore` file in the root of the assets directory. This file takes the same format as `.gitignore`.\n\nWrangler will not upload asset files that match lines in this file.\n\n**Example**\n\nYou are migrating from a Pages project where the assets directory is `dist`. You do not want to upload the server-side Worker code nor Pages configuration files as public client-side assets. Add the following `.assetsignore` file:",
      "language": "unknown"
    },
    {
      "code": "Now Wrangler will not upload these files as client-side assets when deploying the Worker.\n\n## `run_worker_first`\n\nControls whether to invoke the Worker script regardless of a request which would have otherwise matched an asset. `run_worker_first = false` (default) will serve any static asset matching a request, while `run_worker_first = true` will unconditionally [invoke your Worker script](https://developers.cloudflare.com/workers/static-assets/routing/worker-script/#run-your-worker-script-first).\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "You can also specify `run_worker_first` as an array of route patterns to selectively run the Worker script first only for specific routes.\n\nThe array supports glob patterns with `*` for deep matching and negative patterns with `!` prefix.\n\nNegative patterns have precedence over non-negative patterns. The Worker will run first when a non-negative pattern matches and none of the negative pattern matches.\n\nThe order in which the patterns are listed is not significant.\n\n`run_worker_first` is often paired with the [`not_found_handling = \"single-page-application\"` setting](https://developers.cloudflare.com/workers/static-assets/routing/single-page-application/#advanced-routing-control):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "In this configuration, requests to `/api/*` routes will invoke the Worker script first, except for `/api/docs/*` which will follow the default asset-first routing behavior.\n\n## `binding`\n\nConfiguring the optional [binding](https://developers.cloudflare.com/workers/runtime-apis/bindings) gives you access to the collection of assets from within your Worker script.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "In the example above, assets would be available through `env.ASSETS`.\n\n### Runtime API Reference\n\n#### `fetch()`\n\n**Parameters**\n\n* `request: Request | URL | string` Pass a [Request object](https://developers.cloudflare.com/workers/runtime-apis/request/), URL object, or URL string. Requests made through this method have `html_handling` and `not_found_handling` configuration applied to them.\n\n**Response**\n\n* `Promise<Response>` Returns a static asset response for the given request.\n\n**Example**\n\nYour dynamic code can make new, or forward incoming requests to your project's static assets using the assets binding. For example, `env.ASSETS.fetch(request)`, `env.ASSETS.fetch(new URL('https://assets.local/my-file'))` or `env.ASSETS.fetch('https://assets.local/my-file')`.\n\nTake the following example that configures a Worker script to return a response under all requests headed for `/api/`. Otherwise, the Worker script will pass the incoming request through to the asset binding. In this case, because a Worker script is only invoked when the requested route has not matched any static assets, this will always evaluate [`not_found_handling`](https://developers.cloudflare.com/workers/static-assets/#routing-behavior) behavior.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "## Routing configuration\n\nFor the various static asset routing configuration options, refer to [Routing](https://developers.cloudflare.com/workers/static-assets/routing/).\n\n## Smart Placement\n\n[Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement/) can be used to place a Worker's code close to your back-end infrastructure. Smart Placement will only have an effect if you specified a `main`, pointing to your Worker code.\n\n### Smart Placement with Worker Code First\n\nIf you desire to run your [Worker code ahead of assets](https://developers.cloudflare.com/workers/static-assets/routing/worker-script/#run-your-worker-script-first) by setting `run_worker_first=true`, all requests must first travel to your Smart-Placed Worker. As a result, you may experience increased latency for asset requests.\n\nUse Smart Placement with `run_worker_first=true` when you need to integrate with other backend services, authenticate requests before serving any assets, or if your want to make modifications to your assets before serving them.\n\nIf you want some assets served as quickly as possible to the user, but others to be served behind a smart-placed Worker, considering splitting your app into multiple Workers and [using service bindings to connect them](https://developers.cloudflare.com/workers/configuration/smart-placement/#best-practices).\n\n### Smart Placement with Assets First\n\nEnabling Smart Placement with `run_worker_first=false` (or not specifying it) lets you serve assets from as close as possible to your users, but moves your Worker logic to run most efficiently (such as near a database).\n\nUse Smart Placement with `run_worker_first=false` (or not specifying it) when prioritizing fast asset delivery.\n\nThis will not impact the [default routing behavior](https://developers.cloudflare.com/workers/static-assets/#routing-behavior).\n\n</page>\n\n<page>\n---\ntitle: Direct Uploads · Cloudflare Workers docs\ndescription: Upload assets through the Workers API.\nlastUpdated: 2025-11-17T17:54:44.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/static-assets/direct-upload/\n  md: https://developers.cloudflare.com/workers/static-assets/direct-upload/index.md\n---\n\nNote\n\nDirectly uploading assets via APIs is an advanced approach which, unless you are building a programatic integration, most users will not need. Instead, we encourage users to deploy your Worker with [Wrangler](https://developers.cloudflare.com/workers/static-assets/get-started/#1-create-a-new-worker-project-using-the-cli).\n\nOur API empowers users to upload and include static assets as part of a Worker. These static assets can be served for free, and additionally, users can also fetch assets through an optional [assets binding](https://developers.cloudflare.com/workers/static-assets/binding/) to power more advanced applications. This guide will describe the process for attaching assets to your Worker directly with the API.\n\n* Workers",
      "language": "unknown"
    },
    {
      "code": "* Workers for Platforms",
      "language": "unknown"
    },
    {
      "code": "The asset upload flow can be distilled into three distinct phases:\n\n1. Registration of a manifest\n2. Upload of the assets\n3. Deployment of the Worker\n\n## Upload manifest\n\nThe asset manifest is a ledger which keeps track of files we want to use in our Worker. This manifest is used to track assets associated with each Worker version, and eliminate the need to upload unchanged files prior to a new upload.\n\nThe [manifest upload request](https://developers.cloudflare.com/api/resources/workers/subresources/scripts/subresources/assets/subresources/upload/methods/create/) describes each file which we intend to upload. Each file is its own key representing the file path and name, and is an object which contains metadata about the file.\n\n`hash` represents a 32 hexadecimal character hash of the file, while `size` is the size (in bytes) of the file.\n\n* Workers",
      "language": "unknown"
    },
    {
      "code": "* Workers for Platforms",
      "language": "unknown"
    },
    {
      "code": "The resulting response will contain a JWT, which provides authentication during file upload. The JWT is valid for one hour.\n\nIn addition to the JWT, the response instructs users how to optimally batch upload their files. These instructions are encoded in the `buckets` field. Each array in `buckets` contains a list of file hashes which should be uploaded together. Unmodified files will not be returned in the `buckets` field (as they do not need to be re-uploaded) if they have recently been uploaded in previous versions of your Worker.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nIf all assets have been previously uploaded, `buckets` will be empty, and `jwt` will contain a completion token. Uploading files is not necessary, and you can skip directly to [uploading a new script or version](https://developers.cloudflare.com/workers/static-assets/direct-upload/#createdeploy-new-version).\n\n### Limitations\n\n* Limits differ based on account plan. Refer to [Account Plan Limits](https://developers.cloudflare.com/workers/platform/limits/#account-plan-limits) for more information on limitations of static assets.\n\n## Upload Static Assets\n\nThe [file upload API](https://developers.cloudflare.com/api/resources/workers/subresources/assets/subresources/upload/methods/create/) requires files be uploaded using `multipart/form-data`. The contents of each file must be base64 encoded, and the `base64` query parameter in the URL must be set to `true`.\n\nThe provided `Content-Type` header of each file part will be attached when eventually serving the file. If you wish to avoid sending a `Content-Type` header in your deployment, `application/null` may be sent at upload time.\n\nThe `Authorization` header must be provided as a bearer token, using the JWT (upload token) from the aforementioned manifest upload call.\n\nOnce every file in the manifest has been uploaded, a status code of 201 will be returned, with the `jwt` field present. This JWT is a final \"completion\" token which can be used to create a deployment of a Worker with this set of assets. This completion token is valid for 1 hour.\n\n## Create/Deploy New Version\n\n[Script](https://developers.cloudflare.com/api/resources/workers/subresources/scripts/methods/update/), [Version](https://developers.cloudflare.com/api/resources/workers/subresources/scripts/subresources/versions/methods/create/), and [Workers for Platform script](https://developers.cloudflare.com/api/resources/workers_for_platforms/subresources/dispatch/subresources/namespaces/subresources/scripts/methods/update/) upload endpoints require specifying a metadata part in the form data. Here, we can provide the completion token from the previous (upload assets) step.",
      "language": "unknown"
    },
    {
      "code": "If this is a Worker which already has assets, and you wish to just re-use the existing set of assets, we do not have to specify the completion token again. Instead, we can pass the boolean `keep_assets` option.",
      "language": "unknown"
    },
    {
      "code": "Asset [routing configuration](https://developers.cloudflare.com/workers/wrangler/configuration/#assets) can be provided in the `assets` object, such as `html_handling` and `not_found_handling`.",
      "language": "unknown"
    },
    {
      "code": "Optionally, an assets binding can be provided if you wish to fetch and serve assets from within your Worker code.",
      "language": "unknown"
    },
    {
      "code": "## Programmatic Example\n\nThis example is from [cloudflare-typescript](https://github.com/cloudflare/cloudflare-typescript/blob/main/examples/workers/script-with-assets-upload.ts).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Get Started · Cloudflare Workers docs\ndescription: Run front-end websites — static or dynamic — directly on\n  Cloudflare's global network.\nlastUpdated: 2025-06-05T13:25:05.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/static-assets/get-started/\n  md: https://developers.cloudflare.com/workers/static-assets/get-started/index.md\n---\n\nFor most front-end applications, you'll want to use a framework. Workers supports number of popular [frameworks](https://developers.cloudflare.com/workers/framework-guides/) that come with ready-to-use components, a pre-defined and structured architecture, and community support. View [framework specific guides](https://developers.cloudflare.com/workers/framework-guides/) to get started using a framework.\n\nAlternatively, you may prefer to build your website from scratch if:\n\n* You're interested in learning by implementing core functionalities on your own.\n* You're working on a simple project where you might not need a framework.\n* You want to optimize for performance by minimizing external dependencies.\n* You require complete control over every aspect of the application.\n* You want to build your own framework.\n\nThis guide will instruct you through setting up and deploying a static site or a full-stack application without a framework on Workers.\n\n## Deploy a static site\n\nThis guide will instruct you through setting up and deploying a static site on Workers.\n\n### 1. Create a new Worker project using the CLI\n\n[C3 (`create-cloudflare-cli`)](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare) is a command-line tool designed to help you set up and deploy new applications to Cloudflare. Open a terminal window and run C3 to create your Worker project:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Static site`.\n* For *Which language do you want to use?*, choose `TypeScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nAfter setting up your project, change your directory by running the following command:",
      "language": "unknown"
    },
    {
      "code": "### 2. Develop locally\n\nAfter you have created your Worker, run the [`wrangler dev`](https://developers.cloudflare.com/workers/wrangler/commands/#dev) in the project directory to start a local server. This will allow you to preview your project locally during development.",
      "language": "unknown"
    },
    {
      "code": "### 3. Deploy your project\n\nYour project can be deployed to a `*.workers.dev` subdomain or a [Custom Domain](https://developers.cloudflare.com/workers/configuration/routing/custom-domains/), from your own machine or from any CI/CD system, including [Cloudflare's own](https://developers.cloudflare.com/workers/ci-cd/builds/).\n\nThe [`wrangler deploy`](https://developers.cloudflare.com/workers/wrangler/commands/#deploy) will build and deploy your project. If you're using CI, ensure you update your [\"deploy command\"](https://developers.cloudflare.com/workers/ci-cd/builds/configuration/#build-settings) configuration appropriately.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nLearn about how assets are configured and how routing works from [Routing configuration](https://developers.cloudflare.com/workers/static-assets/routing/).\n\n## Deploy a full-stack application\n\nThis guide will instruct you through setting up and deploying dynamic and interactive server-side rendered (SSR) applications on Cloudflare Workers.\n\nWhen building a full-stack application, you can use any [Workers bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/), [including assets' own](https://developers.cloudflare.com/workers/static-assets/binding/), to interact with resources on the Cloudflare Developer Platform.\n\n### 1. Create a new Worker project\n\n[C3 (`create-cloudflare-cli`)](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare) is a command-line tool designed to help you set up and deploy new applications to Cloudflare.\n\nOpen a terminal window and run C3 to create your Worker project:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `SSR / full-stack app`.\n* For *Which language do you want to use?*, choose `TypeScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nAfter setting up your project, change your directory by running the following command:",
      "language": "unknown"
    },
    {
      "code": "### 2. Develop locally\n\nAfter you have created your Worker, run the [`wrangler dev`](https://developers.cloudflare.com/workers/wrangler/commands/#dev) in the project directory to start a local server. This will allow you to preview your project locally during development.",
      "language": "unknown"
    },
    {
      "code": "### 3. Modify your Project\n\nWith your new project generated and running, you can begin to write and edit your project:\n\n* The `src/index.ts` file is populated with sample code. Modify its content to change the server-side behavior of your Worker.\n* The `public/index.html` file is populated with sample code. Modify its content, or anything else in `public/`, to change the static assets of your Worker.\n\nThen, save the files and reload the page. Your project's output will have changed based on your modifications.\n\n### 4. Deploy your Project\n\nYour project can be deployed to a `*.workers.dev` subdomain or a [Custom Domain](https://developers.cloudflare.com/workers/configuration/routing/custom-domains/), from your own machine or from any CI/CD system, including [Cloudflare's own](https://developers.cloudflare.com/workers/ci-cd/builds/).\n\nThe [`wrangler deploy`](https://developers.cloudflare.com/workers/wrangler/commands/#deploy) will build and deploy your project. If you're using CI, ensure you update your [\"deploy command\"](https://developers.cloudflare.com/workers/ci-cd/builds/configuration/#build-settings) configuration appropriately.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nLearn about how assets are configured and how routing works from [Routing configuration](https://developers.cloudflare.com/workers/static-assets/routing/).\n\n</page>\n\n<page>\n---\ntitle: Headers · Cloudflare Workers docs\ndescription: \"When serving static assets, Workers will attach some headers to\n  the response by default. These are:\"\nlastUpdated: 2025-08-22T14:24:45.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/static-assets/headers/\n  md: https://developers.cloudflare.com/workers/static-assets/headers/index.md\n---\n\n## Default headers\n\nWhen serving static assets, Workers will attach some headers to the response by default. These are:\n\n* **`Content-Type`**\n\n  A `Content-Type` header is attached to the response if one is provided during [the asset upload process](https://developers.cloudflare.com/workers/static-assets/direct-upload/). [Wrangler](https://developers.cloudflare.com/workers/wrangler/commands/#deploy) automatically determines the MIME type of the file, based on its extension.\n\n* **`Cache-Control: public, max-age=0, must-revalidate`**\n\n  Sent when the request does not have an `Authorization` or `Range` header, this response header tells the browser that the asset can be cached, but that the browser should revalidate the freshness of the content every time before using it. This default behavior ensures good website performance for static pages, while still guaranteeing that stale content will never be served.\n\n* **`ETag`**\n\n  This header complements the default `Cache-Control` header. Its value is a hash of the static asset file, and browsers can use this in subsequent requests with an `If-None-Match` header to check for freshness, without needing to re-download the entire file in the case of a match.\n\n* **`CF-Cache-Status`**\n\n  This header indicates whether the asset was served from the cache (`HIT`) or not (`MISS`).[1](#user-content-fn-1)\n\nCloudflare reserves the right to attach new headers to static asset responses at any time in order to improve performance or harden the security of your Worker application.\n\n## Custom headers\n\nThe default response headers served on static asset responses can be overridden, removed, or added to, by creating a plain text file called `_headers` without a file extension, in the static asset directory of your project. This file will not itself be served as a static asset, but will instead be parsed by Workers and its rules will be applied to static asset responses.\n\nIf you are using a framework, you will often have a directory named `public/` or `static/`, and this usually contains deploy-ready assets, such as favicons, `robots.txt` files, and site manifests. These files get copied over to a final output directory during the build, so this is the perfect place to author your `_headers` file. If you are not using a framework, the `_headers` file can go directly into your [static assets directory](https://developers.cloudflare.com/workers/static-assets/binding/#directory).\n\nHeaders defined in the `_headers` file override what Cloudflare ordinarily sends.\n\nWarning\n\nCustom headers defined in the `_headers` file are not applied to responses generated by your Worker code, even if the request URL matches a rule defined in `_headers`. If you use a server-side rendered (SSR) framework, have configured `assets.run_worker_first`, or otherwise use a Worker script, you will likely need to attach any custom headers you wish to apply directly within that Worker script.\n\n### Attach a header\n\nHeader rules are defined in multi-line blocks. The first line of a block is the URL or URL pattern where the rule's headers should be applied. On the next line, an indented list of header names and header values must be written:",
      "language": "unknown"
    },
    {
      "code": "Using absolute URLs is supported, though be aware that absolute URLs must begin with `https` and specifying a port is not supported. `_headers` rules ignore the incoming request's port and protocol when matching against an incoming request. For example, a rule like `https://example.com/path` would match against requests to `other://example.com:1234/path`.\n\nYou can define as many `[name]: [value]` pairs as you require on subsequent lines. For example:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Worker startup time",
      "id": "worker-startup-time"
    },
    {
      "level": "h2",
      "text": "Number of Workers",
      "id": "number-of-workers"
    },
    {
      "level": "h2",
      "text": "Routes and domains",
      "id": "routes-and-domains"
    },
    {
      "level": "h3",
      "text": "Number of routes per zone",
      "id": "number-of-routes-per-zone"
    },
    {
      "level": "h3",
      "text": "Number of routes per zone when using `wrangler dev --remote`",
      "id": "number-of-routes-per-zone-when-using-`wrangler-dev---remote`"
    },
    {
      "level": "h3",
      "text": "Number of custom domains per zone",
      "id": "number-of-custom-domains-per-zone"
    },
    {
      "level": "h3",
      "text": "Number of routed zones per Worker",
      "id": "number-of-routed-zones-per-worker"
    },
    {
      "level": "h2",
      "text": "Image Resizing with Workers",
      "id": "image-resizing-with-workers"
    },
    {
      "level": "h2",
      "text": "Log size",
      "id": "log-size"
    },
    {
      "level": "h2",
      "text": "Unbound and Bundled plan limits",
      "id": "unbound-and-bundled-plan-limits"
    },
    {
      "level": "h2",
      "text": "Static Assets",
      "id": "static-assets"
    },
    {
      "level": "h3",
      "text": "Files",
      "id": "files"
    },
    {
      "level": "h3",
      "text": "Headers",
      "id": "headers"
    },
    {
      "level": "h3",
      "text": "Redirects",
      "id": "redirects"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Workers",
      "id": "workers"
    },
    {
      "level": "h3",
      "text": "Example pricing",
      "id": "example-pricing"
    },
    {
      "level": "h3",
      "text": "How to switch usage models",
      "id": "how-to-switch-usage-models"
    },
    {
      "level": "h2",
      "text": "Workers Logs",
      "id": "workers-logs"
    },
    {
      "level": "h2",
      "text": "Workers Trace Events Logpush",
      "id": "workers-trace-events-logpush"
    },
    {
      "level": "h2",
      "text": "Workers KV",
      "id": "workers-kv"
    },
    {
      "level": "h2",
      "text": "Hyperdrive",
      "id": "hyperdrive"
    },
    {
      "level": "h2",
      "text": "Footnotes",
      "id": "footnotes"
    },
    {
      "level": "h2",
      "text": "Queues",
      "id": "queues"
    },
    {
      "level": "h2",
      "text": "D1",
      "id": "d1"
    },
    {
      "level": "h3",
      "text": "Definitions",
      "id": "definitions"
    },
    {
      "level": "h2",
      "text": "Durable Objects",
      "id": "durable-objects"
    },
    {
      "level": "h3",
      "text": "Compute billing",
      "id": "compute-billing"
    },
    {
      "level": "h3",
      "text": "Storage billing",
      "id": "storage-billing"
    },
    {
      "level": "h2",
      "text": "Vectorize",
      "id": "vectorize"
    },
    {
      "level": "h3",
      "text": "Calculating vector dimensions",
      "id": "calculating-vector-dimensions"
    },
    {
      "level": "h2",
      "text": "Service bindings",
      "id": "service-bindings"
    },
    {
      "level": "h2",
      "text": "Fine Print",
      "id": "fine-print"
    },
    {
      "level": "h2",
      "text": "Choose a storage product",
      "id": "choose-a-storage-product"
    },
    {
      "level": "h2",
      "text": "SQL database options",
      "id": "sql-database-options"
    },
    {
      "level": "h3",
      "text": "Session storage",
      "id": "session-storage"
    },
    {
      "level": "h2",
      "text": "Product overviews",
      "id": "product-overviews"
    },
    {
      "level": "h3",
      "text": "Workers KV",
      "id": "workers-kv"
    },
    {
      "level": "h3",
      "text": "R2",
      "id": "r2"
    },
    {
      "level": "h3",
      "text": "Durable Objects",
      "id": "durable-objects"
    },
    {
      "level": "h3",
      "text": "D1",
      "id": "d1"
    },
    {
      "level": "h3",
      "text": "Queues",
      "id": "queues"
    },
    {
      "level": "h3",
      "text": "Hyperdrive",
      "id": "hyperdrive"
    },
    {
      "level": "h2",
      "text": "Pipelines",
      "id": "pipelines"
    },
    {
      "level": "h3",
      "text": "Analytics Engine",
      "id": "analytics-engine"
    },
    {
      "level": "h3",
      "text": "Vectorize",
      "id": "vectorize"
    },
    {
      "level": "h2",
      "text": "SQL in Durable Objects vs D1",
      "id": "sql-in-durable-objects-vs-d1"
    },
    {
      "level": "h2",
      "text": "Interact with the Cloudflare Cache",
      "id": "interact-with-the-cloudflare-cache"
    },
    {
      "level": "h3",
      "text": "Single file purge assets cached by a worker",
      "id": "single-file-purge-assets-cached-by-a-worker"
    },
    {
      "level": "h3",
      "text": "Purge assets stored with the Cache API",
      "id": "purge-assets-stored-with-the-cache-api"
    },
    {
      "level": "h2",
      "text": "Edge versus browser caching",
      "id": "edge-versus-browser-caching"
    },
    {
      "level": "h3",
      "text": "`fetch`",
      "id": "`fetch`"
    },
    {
      "level": "h3",
      "text": "Cache API",
      "id": "cache-api"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Isolates",
      "id": "isolates"
    },
    {
      "level": "h2",
      "text": "Compute per request",
      "id": "compute-per-request"
    },
    {
      "level": "h2",
      "text": "Distributed execution",
      "id": "distributed-execution"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Advantages of migrating",
      "id": "advantages-of-migrating"
    },
    {
      "level": "h2",
      "text": "Migrate a Worker",
      "id": "migrate-a-worker"
    },
    {
      "level": "h2",
      "text": "Bindings",
      "id": "bindings"
    },
    {
      "level": "h3",
      "text": "Bindings in Service Worker format",
      "id": "bindings-in-service-worker-format"
    },
    {
      "level": "h3",
      "text": "Bindings in ES modules format",
      "id": "bindings-in-es-modules-format"
    },
    {
      "level": "h2",
      "text": "Environment variables",
      "id": "environment-variables"
    },
    {
      "level": "h3",
      "text": "Environment variables in Service Worker format",
      "id": "environment-variables-in-service-worker-format"
    },
    {
      "level": "h3",
      "text": "Environment variables in ES modules format",
      "id": "environment-variables-in-es-modules-format"
    },
    {
      "level": "h2",
      "text": "Cron Triggers",
      "id": "cron-triggers"
    },
    {
      "level": "h2",
      "text": "Access `event` or `context` data",
      "id": "access-`event`-or-`context`-data"
    },
    {
      "level": "h2",
      "text": "Service Worker syntax",
      "id": "service-worker-syntax"
    },
    {
      "level": "h3",
      "text": "Supported `FetchEvent` properties",
      "id": "supported-`fetchevent`-properties"
    },
    {
      "level": "h3",
      "text": "`respondWith`",
      "id": "`respondwith`"
    },
    {
      "level": "h3",
      "text": "`waitUntil`",
      "id": "`waituntil`"
    },
    {
      "level": "h3",
      "text": "`passThroughOnException`",
      "id": "`passthroughonexception`"
    },
    {
      "level": "h2",
      "text": "Architectural overview",
      "id": "architectural-overview"
    },
    {
      "level": "h3",
      "text": "Isolation",
      "id": "isolation"
    },
    {
      "level": "h3",
      "text": "API design",
      "id": "api-design"
    },
    {
      "level": "h2",
      "text": "V8 bugs and the patch gap",
      "id": "v8-bugs-and-the-patch-gap"
    },
    {
      "level": "h2",
      "text": "Spectre: Introduction",
      "id": "spectre:-introduction"
    },
    {
      "level": "h3",
      "text": "What is it?",
      "id": "what-is-it?"
    },
    {
      "level": "h3",
      "text": "Why does it matter for Workers?",
      "id": "why-does-it-matter-for-workers?"
    },
    {
      "level": "h3",
      "text": "Why not use process isolation?",
      "id": "why-not-use-process-isolation?"
    },
    {
      "level": "h3",
      "text": "There is no fix for Spectre",
      "id": "there-is-no-fix-for-spectre"
    },
    {
      "level": "h3",
      "text": "Building a defense",
      "id": "building-a-defense"
    },
    {
      "level": "h3",
      "text": "Cascading slow-downs",
      "id": "cascading-slow-downs"
    },
    {
      "level": "h2",
      "text": "Freezing a Spectre attack",
      "id": "freezing-a-spectre-attack"
    },
    {
      "level": "h3",
      "text": "Step 0: Do not allow native code",
      "id": "step-0:-do-not-allow-native-code"
    },
    {
      "level": "h3",
      "text": "Step 1: Disallow timers and multi-threading",
      "id": "step-1:-disallow-timers-and-multi-threading"
    },
    {
      "level": "h3",
      "text": "Step 2: Dynamic process isolation",
      "id": "step-2:-dynamic-process-isolation"
    },
    {
      "level": "h3",
      "text": "Step 3: Periodic whole-memory shuffling",
      "id": "step-3:-periodic-whole-memory-shuffling"
    },
    {
      "level": "h2",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h2",
      "text": "Accessing Cache",
      "id": "accessing-cache"
    },
    {
      "level": "h2",
      "text": "Headers",
      "id": "headers"
    },
    {
      "level": "h2",
      "text": "Methods",
      "id": "methods"
    },
    {
      "level": "h3",
      "text": "`Put`",
      "id": "`put`"
    },
    {
      "level": "h3",
      "text": "`Match`",
      "id": "`match`"
    },
    {
      "level": "h3",
      "text": "`Delete`",
      "id": "`delete`"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "What is a binding?",
      "id": "what-is-a-binding?"
    },
    {
      "level": "h2",
      "text": "Making changes to bindings",
      "id": "making-changes-to-bindings"
    },
    {
      "level": "h2",
      "text": "How to access `env`",
      "id": "how-to-access-`env`"
    },
    {
      "level": "h3",
      "text": "Importing `env` as a global",
      "id": "importing-`env`-as-a-global"
    },
    {
      "level": "h3",
      "text": "Overriding `env` values",
      "id": "overriding-`env`-values"
    },
    {
      "level": "h2",
      "text": "`props`",
      "id": "`props`"
    },
    {
      "level": "h2",
      "text": "`exports`",
      "id": "`exports`"
    },
    {
      "level": "h3",
      "text": "Specifying `ctx.props` when using `ctx.exports`",
      "id": "specifying-`ctx.props`-when-using-`ctx.exports`"
    },
    {
      "level": "h3",
      "text": "TypeScript types for `ctx.exports` and `ctx.props`",
      "id": "typescript-types-for-`ctx.exports`-and-`ctx.props`"
    },
    {
      "level": "h2",
      "text": "`waitUntil`",
      "id": "`waituntil`"
    },
    {
      "level": "h2",
      "text": "`passThroughOnException`",
      "id": "`passthroughonexception`"
    },
    {
      "level": "h2",
      "text": "TextEncoder",
      "id": "textencoder"
    },
    {
      "level": "h3",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h3",
      "text": "Constructor",
      "id": "constructor"
    },
    {
      "level": "h3",
      "text": "Properties",
      "id": "properties"
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": "methods"
    },
    {
      "level": "h2",
      "text": "TextDecoder",
      "id": "textdecoder"
    },
    {
      "level": "h3",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h3",
      "text": "Constructor",
      "id": "constructor"
    },
    {
      "level": "h3",
      "text": "Properties",
      "id": "properties"
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": "methods"
    },
    {
      "level": "h2",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h3",
      "text": "Constructor",
      "id": "constructor"
    },
    {
      "level": "h3",
      "text": "Properties",
      "id": "properties"
    },
    {
      "level": "h3",
      "text": "Methods",
      "id": "methods"
    },
    {
      "level": "h3",
      "text": "Events",
      "id": "events"
    },
    {
      "level": "h3",
      "text": "Class Methods",
      "id": "class-methods"
    },
    {
      "level": "h2",
      "text": "Syntax",
      "id": "syntax"
    },
    {
      "level": "h3",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h2",
      "text": "How the `Accept-Encoding` header is handled",
      "id": "how-the-`accept-encoding`-header-is-handled"
    },
    {
      "level": "h3",
      "text": "Passthrough behavior",
      "id": "passthrough-behavior"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Handlers in Python Workers",
      "id": "handlers-in-python-workers"
    },
    {
      "level": "h2",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h2",
      "text": "Differences",
      "id": "differences"
    },
    {
      "level": "h2",
      "text": "Cloudflare headers",
      "id": "cloudflare-headers"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h2",
      "text": "Constructor",
      "id": "constructor"
    },
    {
      "level": "h2",
      "text": "Global types",
      "id": "global-types"
    },
    {
      "level": "h2",
      "text": "Handlers",
      "id": "handlers"
    },
    {
      "level": "h3",
      "text": "Element Handlers",
      "id": "element-handlers"
    },
    {
      "level": "h3",
      "text": "Document Handlers",
      "id": "document-handlers"
    },
    {
      "level": "h3",
      "text": "Element",
      "id": "element"
    },
    {
      "level": "h3",
      "text": "EndTag",
      "id": "endtag"
    },
    {
      "level": "h3",
      "text": "Text chunks",
      "id": "text-chunks"
    },
    {
      "level": "h3",
      "text": "Comments",
      "id": "comments"
    },
    {
      "level": "h3",
      "text": "Doctype",
      "id": "doctype"
    },
    {
      "level": "h3",
      "text": "End",
      "id": "end"
    },
    {
      "level": "h2",
      "text": "Selectors",
      "id": "selectors"
    },
    {
      "level": "h2",
      "text": "Errors",
      "id": "errors"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h2",
      "text": "Differences",
      "id": "differences"
    },
    {
      "level": "h2",
      "text": "Get Started",
      "id": "get-started"
    },
    {
      "level": "h2",
      "text": "Supported Node.js APIs",
      "id": "supported-node.js-apis"
    },
    {
      "level": "h3",
      "text": "Node.js API Polyfills",
      "id": "node.js-api-polyfills"
    },
    {
      "level": "h2",
      "text": "Enable only AsyncLocalStorage",
      "id": "enable-only-asynclocalstorage"
    },
    {
      "level": "h2",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h3",
      "text": "`performance.now()`",
      "id": "`performance.now()`"
    },
    {
      "level": "h3",
      "text": "`performance.timeOrigin`",
      "id": "`performance.timeorigin`"
    },
    {
      "level": "h2",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h2",
      "text": "Constructor",
      "id": "constructor"
    },
    {
      "level": "h3",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h2",
      "text": "Properties",
      "id": "properties"
    },
    {
      "level": "h3",
      "text": "`IncomingRequestCfProperties`",
      "id": "`incomingrequestcfproperties`"
    },
    {
      "level": "h2",
      "text": "Methods",
      "id": "methods"
    },
    {
      "level": "h3",
      "text": "Instance methods",
      "id": "instance-methods"
    },
    {
      "level": "h2",
      "text": "The `Request` context",
      "id": "the-`request`-context"
    },
    {
      "level": "h3",
      "text": "When passing a promise to fetch event `.respondWith()`",
      "id": "when-passing-a-promise-to-fetch-event-`.respondwith()`"
    },
    {
      "level": "h3",
      "text": "Errors when attempting to access an inactive `Request` context",
      "id": "errors-when-attempting-to-access-an-inactive-`request`-context"
    },
    {
      "level": "h3",
      "text": "Set the `Content-Length` header",
      "id": "set-the-`content-length`-header"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Constructor",
      "id": "constructor"
    },
    {
      "level": "h3",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h2",
      "text": "Properties",
      "id": "properties"
    },
    {
      "level": "h2",
      "text": "Methods",
      "id": "methods"
    },
    {
      "level": "h3",
      "text": "Instance methods",
      "id": "instance-methods"
    },
    {
      "level": "h3",
      "text": "Additional instance methods",
      "id": "additional-instance-methods"
    },
    {
      "level": "h3",
      "text": "Set the `Content-Length` header",
      "id": "set-the-`content-length`-header"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Example",
      "id": "example"
    },
    {
      "level": "h2",
      "text": "All calls are asynchronous",
      "id": "all-calls-are-asynchronous"
    },
    {
      "level": "h2",
      "text": "Structured clonable types, and more",
      "id": "structured-clonable-types,-and-more"
    },
    {
      "level": "h2",
      "text": "Functions",
      "id": "functions"
    },
    {
      "level": "h3",
      "text": "Return functions from RPC methods",
      "id": "return-functions-from-rpc-methods"
    },
    {
      "level": "h3",
      "text": "Send functions as parameters of RPC methods",
      "id": "send-functions-as-parameters-of-rpc-methods"
    },
    {
      "level": "h2",
      "text": "Class Instances",
      "id": "class-instances"
    },
    {
      "level": "h3",
      "text": "Promise pipelining",
      "id": "promise-pipelining"
    },
    {
      "level": "h2",
      "text": "ReadableStream, WriteableStream, Request and Response",
      "id": "readablestream,-writeablestream,-request-and-response"
    },
    {
      "level": "h2",
      "text": "Forwarding RPC stubs",
      "id": "forwarding-rpc-stubs"
    },
    {
      "level": "h2",
      "text": "Video Tutorial",
      "id": "video-tutorial"
    },
    {
      "level": "h2",
      "text": "More Details",
      "id": "more-details"
    },
    {
      "level": "h2",
      "text": "Limitations",
      "id": "limitations"
    },
    {
      "level": "h2",
      "text": "Common issues",
      "id": "common-issues"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "`connect()`",
      "id": "`connect()`"
    },
    {
      "level": "h3",
      "text": "`SocketAddress`",
      "id": "`socketaddress`"
    },
    {
      "level": "h3",
      "text": "`SocketOptions`",
      "id": "`socketoptions`"
    },
    {
      "level": "h3",
      "text": "`SocketInfo`",
      "id": "`socketinfo`"
    },
    {
      "level": "h3",
      "text": "`Socket`",
      "id": "`socket`"
    },
    {
      "level": "h2",
      "text": "Opportunistic TLS (StartTLS)",
      "id": "opportunistic-tls-(starttls)"
    },
    {
      "level": "h2",
      "text": "Handle errors",
      "id": "handle-errors"
    },
    {
      "level": "h2",
      "text": "Close TCP connections",
      "id": "close-tcp-connections"
    },
    {
      "level": "h2",
      "text": "Considerations",
      "id": "considerations"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h3",
      "text": "`proxy request failed, cannot connect to the specified address`",
      "id": "`proxy-request-failed,-cannot-connect-to-the-specified-address`"
    },
    {
      "level": "h3",
      "text": "`TCP Loop detected`",
      "id": "`tcp-loop-detected`"
    },
    {
      "level": "h3",
      "text": "`Connections to port 25 are prohibited`",
      "id": "`connections-to-port-25-are-prohibited`"
    },
    {
      "level": "h2",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h2",
      "text": "Constructors",
      "id": "constructors"
    },
    {
      "level": "h3",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h3",
      "text": "Usage",
      "id": "usage"
    },
    {
      "level": "h2",
      "text": "Methods",
      "id": "methods"
    },
    {
      "level": "h3",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h2",
      "text": "SubtleCrypto Methods",
      "id": "subtlecrypto-methods"
    },
    {
      "level": "h3",
      "text": "encrypt",
      "id": "encrypt"
    },
    {
      "level": "h3",
      "text": "decrypt",
      "id": "decrypt"
    },
    {
      "level": "h3",
      "text": "sign",
      "id": "sign"
    },
    {
      "level": "h3",
      "text": "verify",
      "id": "verify"
    },
    {
      "level": "h3",
      "text": "digest",
      "id": "digest"
    },
    {
      "level": "h3",
      "text": "generateKey",
      "id": "generatekey"
    },
    {
      "level": "h3",
      "text": "deriveKey",
      "id": "derivekey"
    },
    {
      "level": "h3",
      "text": "deriveBits",
      "id": "derivebits"
    },
    {
      "level": "h3",
      "text": "importKey",
      "id": "importkey"
    },
    {
      "level": "h3",
      "text": "exportKey",
      "id": "exportkey"
    },
    {
      "level": "h3",
      "text": "wrapKey",
      "id": "wrapkey"
    },
    {
      "level": "h3",
      "text": "unwrapKey",
      "id": "unwrapkey"
    },
    {
      "level": "h3",
      "text": "timingSafeEqual",
      "id": "timingsafeequal"
    },
    {
      "level": "h3",
      "text": "Supported algorithms",
      "id": "supported-algorithms"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "JavaScript standards",
      "id": "javascript-standards"
    },
    {
      "level": "h2",
      "text": "Web standards and global APIs",
      "id": "web-standards-and-global-apis"
    },
    {
      "level": "h3",
      "text": "Base64 utility methods",
      "id": "base64-utility-methods"
    },
    {
      "level": "h3",
      "text": "Timers",
      "id": "timers"
    },
    {
      "level": "h3",
      "text": "`performance.timeOrigin` and `performance.now()`",
      "id": "`performance.timeorigin`-and-`performance.now()`"
    },
    {
      "level": "h3",
      "text": "`EventTarget` and `Event`",
      "id": "`eventtarget`-and-`event`"
    },
    {
      "level": "h3",
      "text": "`AbortController` and `AbortSignal`",
      "id": "`abortcontroller`-and-`abortsignal`"
    },
    {
      "level": "h3",
      "text": "Fetch global",
      "id": "fetch-global"
    },
    {
      "level": "h2",
      "text": "Encoding API",
      "id": "encoding-api"
    },
    {
      "level": "h2",
      "text": "URL API",
      "id": "url-api"
    },
    {
      "level": "h2",
      "text": "Compression Streams",
      "id": "compression-streams"
    },
    {
      "level": "h2",
      "text": "URLPattern API",
      "id": "urlpattern-api"
    },
    {
      "level": "h2",
      "text": "`Intl`",
      "id": "`intl`"
    },
    {
      "level": "h2",
      "text": "`navigator.userAgent`",
      "id": "`navigator.useragent`"
    },
    {
      "level": "h2",
      "text": "Unhandled promise rejections",
      "id": "unhandled-promise-rejections"
    },
    {
      "level": "h2",
      "text": "`navigator.sendBeacon(url[, data])`",
      "id": "`navigator.sendbeacon(url[,-data])`"
    },
    {
      "level": "h2",
      "text": "The Web File System Access API",
      "id": "the-web-file-system-access-api"
    },
    {
      "level": "h2",
      "text": "Supported proposals",
      "id": "supported-proposals"
    },
    {
      "level": "h3",
      "text": "SIMD",
      "id": "simd"
    },
    {
      "level": "h3",
      "text": "Threading",
      "id": "threading"
    },
    {
      "level": "h2",
      "text": "Binary size",
      "id": "binary-size"
    },
    {
      "level": "h2",
      "text": "WebAssembly System Interface (WASI)",
      "id": "webassembly-system-interface-(wasi)"
    },
    {
      "level": "h3",
      "text": "Resources on WebAssembly",
      "id": "resources-on-webassembly"
    },
    {
      "level": "h2",
      "text": "Background",
      "id": "background"
    },
    {
      "level": "h2",
      "text": "Constructor",
      "id": "constructor"
    },
    {
      "level": "h2",
      "text": "Methods",
      "id": "methods"
    },
    {
      "level": "h3",
      "text": "accept",
      "id": "accept"
    },
    {
      "level": "h3",
      "text": "addEventListener",
      "id": "addeventlistener"
    },
    {
      "level": "h3",
      "text": "close",
      "id": "close"
    },
    {
      "level": "h3",
      "text": "send",
      "id": "send"
    },
    {
      "level": "h2",
      "text": "Events",
      "id": "events"
    },
    {
      "level": "h2",
      "text": "Types",
      "id": "types"
    },
    {
      "level": "h3",
      "text": "Message",
      "id": "message"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Billing",
      "id": "billing"
    },
    {
      "level": "h2",
      "text": "Limitations",
      "id": "limitations"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h2",
      "text": "`directory`",
      "id": "`directory`"
    },
    {
      "level": "h3",
      "text": "Ignoring assets",
      "id": "ignoring-assets"
    },
    {
      "level": "h2",
      "text": "`run_worker_first`",
      "id": "`run_worker_first`"
    },
    {
      "level": "h2",
      "text": "`binding`",
      "id": "`binding`"
    },
    {
      "level": "h3",
      "text": "Runtime API Reference",
      "id": "runtime-api-reference"
    },
    {
      "level": "h2",
      "text": "Routing configuration",
      "id": "routing-configuration"
    },
    {
      "level": "h2",
      "text": "Smart Placement",
      "id": "smart-placement"
    },
    {
      "level": "h3",
      "text": "Smart Placement with Worker Code First",
      "id": "smart-placement-with-worker-code-first"
    },
    {
      "level": "h3",
      "text": "Smart Placement with Assets First",
      "id": "smart-placement-with-assets-first"
    },
    {
      "level": "h2",
      "text": "Upload manifest",
      "id": "upload-manifest"
    },
    {
      "level": "h3",
      "text": "Limitations",
      "id": "limitations"
    },
    {
      "level": "h2",
      "text": "Upload Static Assets",
      "id": "upload-static-assets"
    },
    {
      "level": "h2",
      "text": "Create/Deploy New Version",
      "id": "create/deploy-new-version"
    },
    {
      "level": "h2",
      "text": "Programmatic Example",
      "id": "programmatic-example"
    },
    {
      "level": "h2",
      "text": "Deploy a static site",
      "id": "deploy-a-static-site"
    },
    {
      "level": "h3",
      "text": "1. Create a new Worker project using the CLI",
      "id": "1.-create-a-new-worker-project-using-the-cli"
    },
    {
      "level": "h3",
      "text": "2. Develop locally",
      "id": "2.-develop-locally"
    },
    {
      "level": "h3",
      "text": "3. Deploy your project",
      "id": "3.-deploy-your-project"
    },
    {
      "level": "h2",
      "text": "Deploy a full-stack application",
      "id": "deploy-a-full-stack-application"
    },
    {
      "level": "h3",
      "text": "1. Create a new Worker project",
      "id": "1.-create-a-new-worker-project"
    },
    {
      "level": "h3",
      "text": "2. Develop locally",
      "id": "2.-develop-locally"
    },
    {
      "level": "h3",
      "text": "3. Modify your Project",
      "id": "3.-modify-your-project"
    },
    {
      "level": "h3",
      "text": "4. Deploy your Project",
      "id": "4.-deploy-your-project"
    },
    {
      "level": "h2",
      "text": "Default headers",
      "id": "default-headers"
    },
    {
      "level": "h2",
      "text": "Custom headers",
      "id": "custom-headers"
    },
    {
      "level": "h3",
      "text": "Attach a header",
      "id": "attach-a-header"
    }
  ],
  "url": "llms-txt#output-will-resemble-the-below:",
  "links": []
}