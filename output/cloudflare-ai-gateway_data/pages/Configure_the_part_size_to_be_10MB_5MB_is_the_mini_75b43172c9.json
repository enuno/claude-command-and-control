{
  "title": "Configure the part size to be 10MB. 5MB is the minimum part size, except for the last part",
  "content": "partsize = 10 * 1024 * 1024\n\ndef upload_file(worker_endpoint, filename, partsize):\n    url = f\"{worker_endpoint}{filename}\"\n\n# Create the multipart upload\n    uploadId = requests.post(url, params={\"action\": \"mpu-create\"}).json()[\"uploadId\"]\n\npart_count = math.ceil(os.stat(filename).st_size / partsize)\n    # Create an executor for up to 25 concurrent uploads.\n    executor = concurrent.futures.ThreadPoolExecutor(25)\n    # Submit a task to the executor to upload each part\n    futures = [\n        executor.submit(upload_part, filename, partsize, url, uploadId, index)\n        for index in range(part_count)\n    ]\n    concurrent.futures.wait(futures)\n    # get the parts from the futures\n    uploaded_parts = [future.result() for future in futures]\n\n# complete the multipart upload\n    response = requests.post(\n        url,\n        params={\"action\": \"mpu-complete\", \"uploadId\": uploadId},\n        json={\"parts\": uploaded_parts},\n    )\n    if response.status_code == 200:\n        print(\"ðŸŽ‰ successfully completed multipart upload\")\n    else:\n        print(response.text)\n\ndef upload_part(filename, partsize, url, uploadId, index):\n    # Open the file in rb mode, which treats it as raw bytes rather than attempting to parse utf-8\n    with open(filename, \"rb\") as file:\n        file.seek(partsize * index)\n        part = file.read(partsize)\n\n# Retry policy for when uploading a part fails\n    s = requests.Session()\n    retries = Retry(total=3, status_forcelist=[400, 500, 502, 503, 504])\n    s.mount(\"https://\", HTTPAdapter(max_retries=retries))\n\nreturn s.put(\n        url,\n        params={\n            \"action\": \"mpu-uploadpart\",\n            \"uploadId\": uploadId,\n            \"partNumber\": str(index + 1),\n        },\n        data=part,\n    ).json()\n\nupload_file(worker_endpoint, filename, partsize)\nsh\n  npm create cloudflare@latest -- r2-worker\n  sh\n  yarn create cloudflare r2-worker\n  sh\n  pnpm create cloudflare@latest r2-worker\n  sh\ncd r2-worker\nsh\nnpx wrangler r2 bucket create <YOUR_BUCKET_NAME>\nsh\nnpx wrangler r2 bucket list\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"r2_buckets\": [\n      {\n        \"binding\": \"MY_BUCKET\",\n        \"bucket_name\": \"<YOUR_BUCKET_NAME>\"\n      }\n    ]\n  }\n  toml\n  [[r2_buckets]]\n  binding = 'MY_BUCKET' # <~ valid JavaScript variable name\n  bucket_name = '<YOUR_BUCKET_NAME>'\n  ts\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport default class extends WorkerEntrypoint<Env> {\n    async fetch(request: Request) {\n      const url = new URL(request.url);\n      const key = url.pathname.slice(1);\n\nswitch (request.method) {\n        case \"PUT\": {\n          await this.env.R2.put(key, request.body, {\n            onlyIf: request.headers,\n            httpMetadata: request.headers,\n          });\n          return new Response(`Put ${key} successfully!`);\n        }\n        case \"GET\": {\n          const object = await this.env.R2.get(key, {\n            onlyIf: request.headers,\n            range: request.headers,\n          });\n\nif (object === null) {\n            return new Response(\"Object Not Found\", { status: 404 });\n          }\n\nconst headers = new Headers();\n          object.writeHttpMetadata(headers);\n          headers.set(\"etag\", object.httpEtag);\n\n// When no body is present, preconditions have failed\n          return new Response(\"body\" in object ? object.body : undefined, {\n            status: \"body\" in object ? 200 : 412,\n            headers,\n          });\n        }\n        case \"DELETE\": {\n          await this.env.R2.delete(key);\n          return new Response(\"Deleted!\");\n        }\n        default:\n          return new Response(\"Method Not Allowed\", {\n            status: 405,\n            headers: {\n              Allow: \"PUT, GET, DELETE\",\n            },\n          });\n      }\n    }\n  };\n  js\n  export default {\n    async fetch(request, env) {\n      const url = new URL(request.url);\n      const key = url.pathname.slice(1);\n\nswitch (request.method) {\n        case \"PUT\": {\n          await this.env.R2.put(key, request.body, {\n            onlyIf: request.headers,\n            httpMetadata: request.headers,\n          });\n          return new Response(`Put ${key} successfully!`);\n        }\n        case \"GET\": {\n          const object = await this.env.R2.get(key, {\n            onlyIf: request.headers,\n            range: request.headers,\n          });\n\nif (object === null) {\n            return new Response(\"Object Not Found\", { status: 404 });\n          }\n\nconst headers = new Headers();\n          object.writeHttpMetadata(headers);\n          headers.set(\"etag\", object.httpEtag);\n\n// When no body is present, preconditions have failed\n          return new Response(\"body\" in object ? object.body : undefined, {\n            status: \"body\" in object ? 200 : 412,\n            headers,\n          });\n        }\n        case \"DELETE\": {\n          await this.env.R2.delete(key);\n          return new Response(\"Deleted!\");\n        }\n        default:\n          return new Response(\"Method Not Allowed\", {\n            status: 405,\n            headers: {\n              Allow: \"PUT, GET, DELETE\",\n            },\n          });\n      }\n    }\n  }\n  js\nconst ALLOW_LIST = [\"cat-pic.jpg\"];\n\n// Check requests for a pre-shared secret\nconst hasValidHeader = (request, env) => {\n  return request.headers.get(\"X-Custom-Auth-Key\") === env.AUTH_KEY_SECRET;\n};\n\nfunction authorizeRequest(request, env, key) {\n  switch (request.method) {\n    case \"PUT\":\n    case \"DELETE\":\n      return hasValidHeader(request, env);\n    case \"GET\":\n      return ALLOW_LIST.includes(key);\n    default:\n      return false;\n  }\n}\n\nexport default {\n  async fetch(request, env, ctx) {\n    const url = new URL(request.url);\n    const key = url.pathname.slice(1);\n\nif (!authorizeRequest(request, env, key)) {\n      return new Response(\"Forbidden\", { status: 403 });\n    }\n\n// ...\n  },\n};\nsh\nnpx wrangler secret put AUTH_KEY_SECRET\nsh\nnpx wrangler secret put AUTH_KEY_SECRET\nsh\nEnter the secret text you'd like assigned to the variable AUTH_KEY_SECRET on the script named <YOUR_WORKER_NAME>:\n*********\nðŸŒ€  Creating the secret for script name <YOUR_WORKER_NAME>\nâœ¨  Success! Uploaded secret AUTH_KEY_SECRET.\nsh\nnpx wrangler deploy\nsh",
  "code_samples": [
    {
      "code": "## State management\n\nThe stateful nature of multipart uploads does not easily map to the usage model of Workers, which are inherently stateless. In a normal multipart upload, the multipart upload is usually performed in one continuous execution of the client application. This is different from multipart uploads in a Worker, which will often be completed over multiple invocations of that Worker. This makes state management more challenging.\n\nTo overcome this, the state associated with a multipart upload, namely the `uploadId` and which parts have been uploaded, needs to be kept track of somewhere outside of the Worker.\n\nIn the example Worker and Python application described in this guide, the state of the multipart upload is tracked in the client application which sends requests to the Worker, with the necessary state contained in each request. Keeping track of the multipart state in the client application enables maximal flexibility and allows for parallel and unordered uploads of each part.\n\nWhen keeping track of this state in the client is impossible, alternative designs can be considered. For example, you could track the `uploadId` and which parts have been uploaded in a Durable Object or other database.\n\n</page>\n\n<page>\n---\ntitle: Use R2 from Workers Â· Cloudflare R2 docs\ndescription: C3 (create-cloudflare-cli) is a command-line tool designed to help\n  you set up and deploy Workers & Pages applications to Cloudflare as fast as\n  possible.\nlastUpdated: 2025-09-30T16:36:58.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/r2/api/workers/workers-api-usage/\n  md: https://developers.cloudflare.com/r2/api/workers/workers-api-usage/index.md\n---\n\n## 1. Create a new application with C3\n\nC3 (`create-cloudflare-cli`) is a command-line tool designed to help you set up and deploy Workers & Pages applications to Cloudflare as fast as possible.\n\nTo get started, open a terminal window and run:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nThen, move into your newly created directory:",
      "language": "unknown"
    },
    {
      "code": "## 2. Create your bucket\n\nCreate your bucket by running:",
      "language": "unknown"
    },
    {
      "code": "To check that your bucket was created, run:",
      "language": "unknown"
    },
    {
      "code": "After running the `list` command, you will see all bucket names, including the one you have just created.\n\n## 3. Bind your bucket to a Worker\n\nYou will need to bind your bucket to a Worker.\n\nBindings\n\nA binding is how your Worker interacts with external resources such as [KV Namespaces](https://developers.cloudflare.com/kv/concepts/kv-namespaces/), [Durable Objects](https://developers.cloudflare.com/durable-objects/), or [R2 Buckets](https://developers.cloudflare.com/r2/buckets/). A binding is a runtime variable that the Workers runtime provides to your code. You can declare a variable name in your Wrangler file that will be bound to these resources at runtime, and interact with them through this variable. Every binding's variable name and behavior is determined by you when deploying the Worker. Refer to the [Environment Variables](https://developers.cloudflare.com/workers/configuration/environment-variables/) documentation for more information.\n\nA binding is defined in the Wrangler file of your Worker project's directory.\n\nTo bind your R2 bucket to your Worker, add the following to your Wrangler file. Update the `binding` property to a valid JavaScript variable identifier and `bucket_name` to the `<YOUR_BUCKET_NAME>` you used to create your bucket in [step 2](#2-create-your-bucket):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "For more detailed information on configuring your Worker (for example, if you are using [jurisdictions](https://developers.cloudflare.com/r2/reference/data-location/#jurisdictional-restrictions)), refer to the [Wrangler Configuration documentation](https://developers.cloudflare.com/workers/wrangler/configuration/).\n\n## 4. Access your R2 bucket from your Worker\n\nWithin your Worker code, your bucket is now available under the `MY_BUCKET` variable and you can begin interacting with it.\n\nLocal Development mode in Wrangler\n\nBy default `wrangler dev` runs in local development mode. In this mode, all operations performed by your local worker will operate against local storage on your machine.\n\nIf you want the R2 operations that are performed during development to be performed against a real R2 bucket, you can set `\"remote\" : true` in the R2 binding configuration. Refer to [remote bindings documentation](https://developers.cloudflare.com/workers/development-testing/#remote-bindings) for more information.\n\nAn R2 bucket is able to READ, LIST, WRITE, and DELETE objects. You can see an example of all operations below using the Module Worker syntax. Add the following snippet into your project's `index.js` file:\n\n* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "Prevent potential errors when accessing request.body\n\nThe body of a [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) can only be accessed once. If you previously used `request.formData()` in the same request, you may encounter a TypeError when attempting to access `request.body`.\n\nTo avoid errors, create a clone of the Request object with `request.clone()` for each subsequent attempt to access a Request's body. Keep in mind that Workers have a [memory limit of 128 MB per Worker](https://developers.cloudflare.com/workers/platform/limits#worker-limits) and loading particularly large files into a Worker's memory multiple times may reach this limit. To ensure memory usage does not reach this limit, consider using [Streams](https://developers.cloudflare.com/workers/runtime-apis/streams/).\n\n## 5. Bucket access and privacy\n\nWith the above code added to your Worker, every incoming request has the ability to interact with your bucket. This means your bucket is publicly exposed and its contents can be accessed and modified by undesired actors.\n\nYou must now define authorization logic to determine who can perform what actions to your bucket. This logic lives within your Worker's code, as it is your application's job to determine user privileges. The following is a short list of resources related to access and authorization practices:\n\n1. [Basic Authentication](https://developers.cloudflare.com/workers/examples/basic-auth/): Shows how to restrict access using the HTTP Basic schema.\n2. [Using Custom Headers](https://developers.cloudflare.com/workers/examples/auth-with-headers/): Allow or deny a request based on a known pre-shared key in a header.\n\nContinuing with your newly created bucket and Worker, you will need to protect all bucket operations.\n\nFor `PUT` and `DELETE` requests, you will make use of a new `AUTH_KEY_SECRET` environment variable, which you will define later as a Wrangler secret.\n\nFor `GET` requests, you will ensure that only a specific file can be requested. All of this custom logic occurs inside of an `authorizeRequest` function, with the `hasValidHeader` function handling the custom header logic. If all validation passes, then the operation is allowed.",
      "language": "unknown"
    },
    {
      "code": "For this to work, you need to create a secret via Wrangler:",
      "language": "unknown"
    },
    {
      "code": "This command will prompt you to enter a secret in your terminal:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "This secret is now available as `AUTH_KEY_SECRET` on the `env` parameter in your Worker.\n\n## 6. Deploy your Worker\n\nWith your Worker and bucket set up, run the `npx wrangler deploy` [command](https://developers.cloudflare.com/workers/wrangler/commands/#deploy) to deploy to Cloudflare's global network:",
      "language": "unknown"
    },
    {
      "code": "You can verify your authorization logic is working through the following commands, using your deployed Worker endpoint:\n\nWarning\n\nWhen uploading files to R2 via `curl`, ensure you use **[`--data-binary`](https://everything.curl.dev/http/post/binary)** instead of `--data` or `-d`. Files will otherwise be truncated.",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "State management",
      "id": "state-management"
    },
    {
      "level": "h2",
      "text": "1. Create a new application with C3",
      "id": "1.-create-a-new-application-with-c3"
    },
    {
      "level": "h2",
      "text": "2. Create your bucket",
      "id": "2.-create-your-bucket"
    },
    {
      "level": "h2",
      "text": "3. Bind your bucket to a Worker",
      "id": "3.-bind-your-bucket-to-a-worker"
    },
    {
      "level": "h2",
      "text": "4. Access your R2 bucket from your Worker",
      "id": "4.-access-your-r2-bucket-from-your-worker"
    },
    {
      "level": "h2",
      "text": "5. Bucket access and privacy",
      "id": "5.-bucket-access-and-privacy"
    },
    {
      "level": "h2",
      "text": "6. Deploy your Worker",
      "id": "6.-deploy-your-worker"
    }
  ],
  "url": "llms-txt#configure-the-part-size-to-be-10mb.-5mb-is-the-minimum-part-size,-except-for-the-last-part",
  "links": []
}