{
  "title": "Delay any messages that are retried by 60 seconds (1 minute) by default.",
  "content": "npx wrangler@latest queues consumer http add $QUEUE-NAME --retry-delay-secs=60\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"queues\": {\n      \"producers\": [\n        {\n          \"binding\": \"<BINDING_NAME>\",\n          \"queue\": \"<QUEUE-NAME>\",\n          \"delivery_delay\": 60\n        }\n      ],\n      \"consumers\": [\n        {\n          \"queue\": \"my-queue\",\n          \"retry_delay\": 300\n        }\n      ]\n    }\n  }\n  toml\n  [[queues.producers]]\n    binding = \"<BINDING_NAME>\"\n    queue = \"<QUEUE-NAME>\"\n    delivery_delay = 60 # delay every message delivery by 1 minute\n\n[[queues.consumers]]\n    queue = \"my-queue\"\n    retry_delay = 300 # delay any retried message by 5 minutes before re-attempting delivery\n  js\n  const calculateExponentialBackoff = (attempts, baseDelaySeconds) => {\n    return baseDelaySeconds ** attempts;\n  };\n  ts\n  const calculateExponentialBackoff = (\n    attempts: number,\n    baseDelaySeconds: number,\n  ) => {\n    return baseDelaySeconds ** attempts;\n  };\n  python\n  def calculate_exponential_backoff(attempts, base_delay_seconds):\n      return base_delay_seconds ** attempts\n  js\n  const BASE_DELAY_SECONDS = 30;\n\nexport default {\n    async queue(batch, env, ctx) {\n      for (const msg of batch.messages) {\n        // Mark for retry and delay a singular message\n        // by 3600 seconds (1 hour)\n        msg.retry({\n          delaySeconds: calculateExponentialBackoff(\n            msg.attempts,\n            BASE_DELAY_SECONDS,\n          ),\n        });\n      }\n    },\n  };\n  ts\n  const BASE_DELAY_SECONDS = 30;\n\nexport default {\n    async queue(batch: MessageBatch, env: Env, ctx: ExecutionContext) {\n      for (const msg of batch.messages) {\n        // Mark for retry and delay a singular message\n        // by 3600 seconds (1 hour)\n        msg.retry({\n          delaySeconds: calculateExponentialBackoff(\n            msg.attempts,\n            BASE_DELAY_SECONDS,\n          ),\n        });\n      }\n    },\n  };\n  python\n  from workers import WorkerEntrypoint\n\nBASE_DELAY_SECONDS = 30\n\nclass Default(WorkerEntrypoint):\n      async def queue(self, batch):\n          for msg in batch.messages:\n              # Mark for retry and delay a singular message\n              # by 3600 seconds (1 hour)\n              msg.retry(\n                  delaySeconds=calculate_exponential_backoff(\n                      msg.attempts,\n                      BASE_DELAY_SECONDS,\n                  )\n              )\n  sh\nnpx wrangler queues update <QUEUE-NAME> --delivery-delay-secs 60 --message-retention-period-secs 3000\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"queues\": {\n      \"producers\": [\n        {\n          \"queue\": \"my-queue\",\n          \"binding\": \"MY_QUEUE\"\n        }\n      ]\n    }\n  }\n  toml\n  [[queues.producers]]\n    queue = \"my-queue\"\n    binding = \"MY_QUEUE\"\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"queues\": {\n      \"consumers\": [\n        {\n          \"queue\": \"my-queue\",\n          \"max_batch_size\": 10,\n          \"max_batch_timeout\": 30,\n          \"max_retries\": 10,\n          \"dead_letter_queue\": \"my-queue-dlq\"\n        }\n      ]\n    }\n  }\n  toml\n  [[queues.consumers]]\n    queue = \"my-queue\"\n    max_batch_size = 10\n    max_batch_timeout = 30\n    max_retries = 10\n    dead_letter_queue = \"my-queue-dlq\"\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"queues\": {\n      \"consumers\": [\n        {\n          \"queue\": \"my-queue\",\n          \"max_concurrency\": 1\n        }\n      ]\n    }\n  }\n  toml\n  [[queues.consumers]]\n    queue = \"my-queue\"\n    max_concurrency = 1\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"queues\": {\n      \"consumers\": [\n        {\n          \"queue\": \"my-queue\",\n          \"dead_letter_queue\": \"my-other-queue\"\n        }\n      ]\n    }\n  }\n  toml\n  [[queues.consumers]]\n    queue = \"my-queue\"\n    dead_letter_queue = \"my-other-queue\"\n  sh\nwrangler queues consumer add $QUEUE_NAME $SCRIPT_NAME --dead-letter-queue=$NAME_OF_OTHER_QUEUE\njs\n  export default {\n    async fetch(req, env) {\n      await env.MY_QUEUE.send({\n        url: req.url,\n        method: req.method,\n        headers: Object.fromEntries(req.headers),\n      });\n      return new Response(\"Sent!\");\n    },\n  };\n  ts\n  type Environment = {\n    readonly MY_QUEUE: Queue;\n  };\n\nexport default {\n    async fetch(req: Request, env: Environment): Promise<Response> {\n      await env.MY_QUEUE.send({\n        url: req.url,\n        method: req.method,\n        headers: Object.fromEntries(req.headers),\n      });\n      return new Response('Sent!');\n    },\n  };\n  python\n  from pyodide.ffi import to_js\n  from workers import Response, WorkerEntrypoint\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          await self.env.MY_QUEUE.send(to_js({\n              \"url\": request.url,\n              \"method\": request.method,\n              \"headers\": dict(request.headers),\n          }))\n          return Response(\"Sent!\")\n  js\n  const sendResultsToQueue = async (results, env) => {\n    const batch = results.map((value) => ({\n      body: JSON.stringify(value),\n    }));\n    await env.queue.sendBatch(batch);\n  };\n  ts\n  const sendResultsToQueue = async (results: Array<any>, env: Environment) => {\n    const batch: MessageSendRequest[] = results.map((value) => ({\n      body: JSON.stringify(value),\n    }));\n    await env.queue.sendBatch(batch);\n  };\n  python\n  import json\n  from pyodide.ffi import to_js\n\nasync def send_results_to_queue(results, env):\n      batch = [\n          {\"body\": json.dumps(value)}\n          for value in results\n      ]\n      await env.queue.sendBatch(to_js(batch))\n  ts\ninterface Queue<Body = unknown> {\n  send(body: Body, options?: QueueSendOptions): Promise<void>;\n  sendBatch(messages: Iterable<MessageSendRequest<Body>>, options?: QueueSendBatchOptions): Promise<void>;\n}\nts\ntype MessageSendRequest<Body = unknown> = {\n  body: Body;\n  options?: QueueSendOptions;\n};\nts\n// Default: json\ntype QueuesContentType = \"text\" | \"bytes\" | \"json\" | \"v8\";\njs\n  export default {\n    async queue(batch, env, ctx) {\n      for (const message of batch.messages) {\n        console.log(\"Received\", message);\n      }\n    },\n  };\n  ts\n  export default {\n    async queue(\n      batch: MessageBatch,\n      env: Environment,\n      ctx: ExecutionContext\n    ): Promise<void> {\n      for (const message of batch.messages) {\n        console.log('Received', message);\n      }\n    },\n  };\n  python\n  from workers import WorkerEntrypoint\n\nclass Default(WorkerEntrypoint):\n      async def queue(self, batch):\n          for message in batch.messages:\n              print(\"Received\", message)\n  js\naddEventListener('queue', (event) => {\n  event.waitUntil(handleMessages(event));\n});\nts\ninterface MessageBatch<Body = unknown> {\n  readonly queue: string;\n  readonly messages: Message<Body>[];\n  ackAll(): void;\n  retryAll(options?: QueueRetryOptions): void;\n}\nts\ninterface Message<Body = unknown> {\n  readonly id: string;\n  readonly timestamp: Date;\n  readonly body: Body;\n  readonly attempts: number;\n  ack(): void;\n  retry(options?: QueueRetryOptions): void;\n}\nts\ninterface QueueRetryOptions {\n  delaySeconds?: number;\n}\nsh\nnpx wrangler@latest dev\nsh\n------------------\nYour Worker and resources are simulated locally via Miniflare. For more information, see: https://developers.cloudflare.com/workers/testing/local-development.\n\nYour worker has access to the following bindings:\n- Queues: <QUEUE-NAME>\nplaintext\nproducer-worker/\n├── wrangler.jsonc\n├── index.ts\n└── consumer-worker/\n    ├── wrangler.jsonc\n    └── index.ts\nsh\nnpx wrangler@latest dev -c wrangler.jsonc -c consumer-worker/wrangler.jsonc --persist-to .wrangler/state\nsh\n$ npx wrangler queues pause-delivery <QUEUE-NAME>\nsh\n$ npx wrangler queues resume-delivery <QUEUE-NAME>\nsh\n$ npx wrangler queues purge <QUEUE-NAME>\n\nThis operation will permanently delete all the messages in Queue <QUEUE-NAME>. Type <QUEUE-NAME> to proceed.\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"queues\": {\n      \"consumers\": [\n        {\n          \"queue\": \"QUEUE-NAME\",\n          \"type\": \"http_pull\",\n          \"visibility_timeout_ms\": 5000,\n          \"max_retries\": 5,\n          \"dead_letter_queue\": \"SOME-OTHER-QUEUE\"\n        }\n      ]\n    }\n  }\n  toml\n  [[queues.consumers]]\n  # Required\n  queue = \"QUEUE-NAME\"\n  type = \"http_pull\"\n  # Optional\n  visibility_timeout_ms = 5000\n  max_retries = 5\n  dead_letter_queue = \"SOME-OTHER-QUEUE\"\n  sh\nnpx wrangler queues consumer http add $QUEUE-NAME\nsh\nwrangler queues consumer worker remove $QUEUE-NAME $SCRIPT_NAME\nbash\ncurl \"https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/pull\" \\\n--header \"Authorization: Bearer ${QUEUES_TOKEN}\" \\\n--header \"Content-Type: application/json\" \\\n--data '{ \"visibility_timeout\": 10000, \"batch_size\": 2 }'\njs\n  // POST /accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/pull with the timeout & batch size\n  let resp = await fetch(\n    `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/pull`,\n    {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n        authorization: `Bearer ${QUEUES_API_TOKEN}`,\n      },\n      // Optional - you can provide an empty object '{}' and the defaults will apply.\n      body: JSON.stringify({ visibility_timeout_ms: 6000, batch_size: 50 }),\n    },\n  );\n  ts\n  // POST /accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/pull with the timeout & batch size\n  let resp = await fetch(\n    `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/pull`,\n    {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n        authorization: `Bearer ${QUEUES_API_TOKEN}`,\n      },\n      // Optional - you can provide an empty object '{}' and the defaults will apply.\n      body: JSON.stringify({ visibility_timeout_ms: 6000, batch_size: 50 }),\n    },\n  );\n  python\n  import json\n  from workers import fetch\n\n# POST /accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/pull with the timeout & batch size\n  resp = await fetch(\n      f\"https://api.cloudflare.com/client/v4/accounts/{CF_ACCOUNT_ID}/queues/{QUEUE_ID}/messages/pull\",\n      method=\"POST\",\n      headers={\n          \"content-type\": \"application/json\",\n          \"authorization\": f\"Bearer {QUEUES_API_TOKEN}\",\n      },\n      # Optional - you can provide an empty object '{}' and the defaults will apply.\n      body=json.dumps({\"visibility_timeout_ms\": 6000, \"batch_size\": 50}),\n  )\n  json\n{\n  \"success\": true,\n  \"errors\": [],\n  \"messages\": [],\n  \"result\": {\n    \"message_backlog_count\": 10,\n    \"messages\": [\n      {\n        \"body\": \"hello\",\n        \"id\": \"1ad27d24c83de78953da635dc2ea208f\",\n        \"timestamp_ms\": 1689615013586,\n        \"attempts\": 2,\n        \"metadata\":{\n          \"CF-sourceMessageSource\":\"dash\",\n          \"CF-Content-Type\":\"json\"\n        },\n        \"lease_id\": \"eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIn0..NXmbr8h6tnKLsxJ_AuexHQ.cDt8oBb_XTSoKUkVKRD_Jshz3PFXGIyu7H1psTO5UwI.smxSvQ8Ue3-ymfkV6cHp5Va7cyUFPIHuxFJA07i17sc\"\n      },\n      {\n        \"body\": \"world\",\n        \"id\": \"95494c37bb89ba8987af80b5966b71a7\",\n        \"timestamp_ms\": 1689615013586,\n        \"attempts\": 2,\n        \"metadata\":{\n          \"CF-sourceMessageSource\":\"dash\",\n          \"CF-Content-Type\":\"json\"\n        },\n        \"lease_id\": \"eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIn0..QXPgHfzETsxYQ1Vd-H0hNA.mFALS3lyouNtgJmGSkTzEo_imlur95EkSiH7fIRIn2U.PlwBk14CY_EWtzYB-_5CR1k30bGuPFPUx1Nk5WIipFU\"\n      }\n    ]\n  }\n}\njs\n  // POST /accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/ack with the lease_ids\n  let resp = await fetch(\n    `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/ack`,\n    {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n        authorization: `Bearer ${QUEUES_API_TOKEN}`,\n      },\n      // If you have no messages to retry, you can specify an empty array - retries: []\n      body: JSON.stringify({\n        acks: [\n          { lease_id: \"lease_id1\" },\n          { lease_id: \"lease_id2\" },\n          { lease_id: \"etc\" },\n        ],\n        retries: [{ lease_id: \"lease_id4\" }],\n      }),\n    },\n  );\n  ts\n  // POST /accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/ack with the lease_ids\n  let resp = await fetch(\n    `https://api.cloudflare.com/client/v4/accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/ack`,\n    {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json\",\n        authorization: `Bearer ${QUEUES_API_TOKEN}`,\n      },\n      // If you have no messages to retry, you can specify an empty array - retries: []\n      body: JSON.stringify({\n        acks: [\n          { lease_id: \"lease_id1\" },\n          { lease_id: \"lease_id2\" },\n          { lease_id: \"etc\" },\n        ],\n        retries: [{ lease_id: \"lease_id4\" }],\n      }),\n    },\n  );\n  python\n  import json\n  from workers import fetch\n\n# POST /accounts/${CF_ACCOUNT_ID}/queues/${QUEUE_ID}/messages/ack with the lease_ids\n  resp = await fetch(\n      f\"https://api.cloudflare.com/client/v4/accounts/{CF_ACCOUNT_ID}/queues/{QUEUE_ID}/messages/ack\",\n      method=\"POST\",\n      headers={\n          \"content-type\": \"application/json\",\n          \"authorization\": f\"Bearer {QUEUES_API_TOKEN}\",\n      },\n      # If you have no messages to retry, you can specify an empty array - retries: []\n      body=json.dumps({\n          \"acks\": [\n              {\"lease_id\": \"lease_id1\"},\n              {\"lease_id\": \"lease_id2\"},\n              {\"lease_id\": \"etc\"},\n          ],\n          \"retries\": [{\"lease_id\": \"lease_id4\"}],\n      }),\n  )\n  json\n{\n  \"acks\": [\n    { \"lease_id\": \"lease_id1\" },\n    { \"lease_id\": \"lease_id2\" },\n    { \"lease_id\": \"lease_id3\" }\n  ],\n  \"retries\": [{ \"lease_id\": \"lease_id4\", \"delay_seconds\": 600 }]\n}\njson\n{\n  \"type\": \"cf.access.application.created\",\n  \"source\": {\n    \"type\": \"access\"\n  },\n  \"payload\": {\n    \"id\": \"app-12345678-90ab-cdef-1234-567890abcdef\",\n    \"name\": \"My Application\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.access.application.deleted\",\n  \"source\": {\n    \"type\": \"access\"\n  },\n  \"payload\": {\n    \"id\": \"app-12345678-90ab-cdef-1234-567890abcdef\",\n    \"name\": \"My Application\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.r2.bucket.created\",\n  \"source\": {\n    \"type\": \"r2\"\n  },\n  \"payload\": {\n    \"name\": \"my-bucket\",\n    \"jurisdiction\": \"default\",\n    \"location\": \"WNAM\",\n    \"storageClass\": \"Standard\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.r2.bucket.deleted\",\n  \"source\": {\n    \"type\": \"r2\"\n  },\n  \"payload\": {\n    \"name\": \"my-bucket\",\n    \"jurisdiction\": \"default\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.superSlurper.job.started\",\n  \"source\": {\n    \"type\": \"superSlurper\"\n  },\n  \"payload\": {\n    \"id\": \"job-12345678-90ab-cdef-1234-567890abcdef\",\n    \"createdAt\": \"2025-05-01T02:48:57.132Z\",\n    \"overwrite\": true,\n    \"pathPrefix\": \"migrations/\",\n    \"source\": {\n      \"provider\": \"s3\",\n      \"bucket\": \"source-bucket\",\n      \"region\": \"us-east-1\",\n      \"endpoint\": \"s3.amazonaws.com\"\n    },\n    \"destination\": {\n      \"provider\": \"r2\",\n      \"bucket\": \"destination-bucket\",\n      \"jurisdiction\": \"default\"\n    }\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.superSlurper.job.paused\",\n  \"source\": {\n    \"type\": \"superSlurper\"\n  },\n  \"payload\": {\n    \"id\": \"job-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.superSlurper.job.resumed\",\n  \"source\": {\n    \"type\": \"superSlurper\"\n  },\n  \"payload\": {\n    \"id\": \"job-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.superSlurper.job.completed\",\n  \"source\": {\n    \"type\": \"superSlurper\"\n  },\n  \"payload\": {\n    \"id\": \"job-12345678-90ab-cdef-1234-567890abcdef\",\n    \"totalObjectsCount\": 1000,\n    \"skippedObjectsCount\": 10,\n    \"migratedObjectsCount\": 980,\n    \"failedObjectsCount\": 10\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.superSlurper.job.aborted\",\n  \"source\": {\n    \"type\": \"superSlurper\"\n  },\n  \"payload\": {\n    \"id\": \"job-12345678-90ab-cdef-1234-567890abcdef\",\n    \"totalObjectsCount\": 1000,\n    \"skippedObjectsCount\": 100,\n    \"migratedObjectsCount\": 500,\n    \"failedObjectsCount\": 50\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.superSlurper.job.object.migrated\",\n  \"source\": {\n    \"type\": \"superSlurper.job\",\n    \"jobId\": \"job-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"payload\": {\n    \"key\": \"migrations/file.txt\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.vectorize.index.created\",\n  \"source\": {\n    \"type\": \"vectorize\"\n  },\n  \"payload\": {\n    \"name\": \"my-vector-index\",\n    \"description\": \"Index for embeddings\",\n    \"createdAt\": \"2025-05-01T02:48:57.132Z\",\n    \"modifiedAt\": \"2025-05-01T02:48:57.132Z\",\n    \"dimensions\": 1536,\n    \"metric\": \"cosine\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.vectorize.index.deleted\",\n  \"source\": {\n    \"type\": \"vectorize\"\n  },\n  \"payload\": {\n    \"name\": \"my-vector-index\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workersAi.model.batch.queued\",\n  \"source\": {\n    \"type\": \"workersAi.model\",\n    \"modelName\": \"@cf/baai/bge-base-en-v1.5\"\n  },\n  \"payload\": {\n    \"requestId\": \"req-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workersAi.model.batch.succeeded\",\n  \"source\": {\n    \"type\": \"workersAi.model\",\n    \"modelName\": \"@cf/baai/bge-base-en-v1.5\"\n  },\n  \"payload\": {\n    \"requestId\": \"req-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workersAi.model.batch.failed\",\n  \"source\": {\n    \"type\": \"workersAi.model\",\n    \"modelName\": \"@cf/baai/bge-base-en-v1.5\"\n  },\n  \"payload\": {\n    \"requestId\": \"req-12345678-90ab-cdef-1234-567890abcdef\",\n    \"message\": \"Model execution failed\",\n    \"internalCode\": 5001,\n    \"httpCode\": 500\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workersBuilds.worker.build.started\",\n  \"source\": {\n    \"type\": \"workersBuilds.worker\",\n    \"workerName\": \"my-worker\"\n  },\n  \"payload\": {\n    \"buildUuid\": \"build-12345678-90ab-cdef-1234-567890abcdef\",\n    \"status\": \"running\",\n    \"buildOutcome\": null,\n    \"createdAt\": \"2025-05-01T02:48:57.132Z\",\n    \"initializingAt\": \"2025-05-01T02:48:58.132Z\",\n    \"runningAt\": \"2025-05-01T02:48:59.132Z\",\n    \"stoppedAt\": null,\n    \"buildTriggerMetadata\": {\n      \"buildTriggerSource\": \"push_event\",\n      \"branch\": \"main\",\n      \"commitHash\": \"abc123def456\",\n      \"commitMessage\": \"Fix bug in authentication\",\n      \"author\": \"developer@example.com\",\n      \"buildCommand\": \"npm run build\",\n      \"deployCommand\": \"wrangler deploy\",\n      \"rootDirectory\": \"/\",\n      \"repoName\": \"my-worker-repo\",\n      \"providerAccountName\": \"github-user\",\n      \"providerType\": \"github\"\n    }\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workersBuilds.worker.build.failed\",\n  \"source\": {\n    \"type\": \"workersBuilds.worker\",\n    \"workerName\": \"my-worker\"\n  },\n  \"payload\": {\n    \"buildUuid\": \"build-12345678-90ab-cdef-1234-567890abcdef\",\n    \"status\": \"failed\",\n    \"buildOutcome\": \"failure\",\n    \"createdAt\": \"2025-05-01T02:48:57.132Z\",\n    \"initializingAt\": \"2025-05-01T02:48:58.132Z\",\n    \"runningAt\": \"2025-05-01T02:48:59.132Z\",\n    \"stoppedAt\": \"2025-05-01T02:50:00.132Z\",\n    \"buildTriggerMetadata\": {\n      \"buildTriggerSource\": \"push_event\",\n      \"branch\": \"main\",\n      \"commitHash\": \"abc123def456\",\n      \"commitMessage\": \"Fix bug in authentication\",\n      \"author\": \"developer@example.com\",\n      \"buildCommand\": \"npm run build\",\n      \"deployCommand\": \"wrangler deploy\",\n      \"rootDirectory\": \"/\",\n      \"repoName\": \"my-worker-repo\",\n      \"providerAccountName\": \"github-user\",\n      \"providerType\": \"github\"\n    }\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workersBuilds.worker.build.canceled\",\n  \"source\": {\n    \"type\": \"workersBuilds.worker\",\n    \"workerName\": \"my-worker\"\n  },\n  \"payload\": {\n    \"buildUuid\": \"build-12345678-90ab-cdef-1234-567890abcdef\",\n    \"status\": \"canceled\",\n    \"buildOutcome\": \"canceled\",\n    \"createdAt\": \"2025-05-01T02:48:57.132Z\",\n    \"initializingAt\": \"2025-05-01T02:48:58.132Z\",\n    \"runningAt\": \"2025-05-01T02:48:59.132Z\",\n    \"stoppedAt\": \"2025-05-01T02:49:30.132Z\",\n    \"buildTriggerMetadata\": {\n      \"buildTriggerSource\": \"push_event\",\n      \"branch\": \"main\",\n      \"commitHash\": \"abc123def456\",\n      \"commitMessage\": \"Fix bug in authentication\",\n      \"author\": \"developer@example.com\",\n      \"buildCommand\": \"npm run build\",\n      \"deployCommand\": \"wrangler deploy\",\n      \"rootDirectory\": \"/\",\n      \"repoName\": \"my-worker-repo\",\n      \"providerAccountName\": \"github-user\",\n      \"providerType\": \"github\"\n    }\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workersBuilds.worker.build.succeeded\",\n  \"source\": {\n    \"type\": \"workersBuilds.worker\",\n    \"workerName\": \"my-worker\"\n  },\n  \"payload\": {\n    \"buildUuid\": \"build-12345678-90ab-cdef-1234-567890abcdef\",\n    \"status\": \"success\",\n    \"buildOutcome\": \"success\",\n    \"createdAt\": \"2025-05-01T02:48:57.132Z\",\n    \"initializingAt\": \"2025-05-01T02:48:58.132Z\",\n    \"runningAt\": \"2025-05-01T02:48:59.132Z\",\n    \"stoppedAt\": \"2025-05-01T02:50:15.132Z\",\n    \"buildTriggerMetadata\": {\n      \"buildTriggerSource\": \"push_event\",\n      \"branch\": \"main\",\n      \"commitHash\": \"abc123def456\",\n      \"commitMessage\": \"Fix bug in authentication\",\n      \"author\": \"developer@example.com\",\n      \"buildCommand\": \"npm run build\",\n      \"deployCommand\": \"wrangler deploy\",\n      \"rootDirectory\": \"/\",\n      \"repoName\": \"my-worker-repo\",\n      \"providerAccountName\": \"github-user\",\n      \"providerType\": \"github\"\n    }\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.kv.namespace.created\",\n  \"source\": {\n    \"type\": \"kv\"\n  },\n  \"payload\": {\n    \"id\": \"ns-12345678-90ab-cdef-1234-567890abcdef\",\n    \"name\": \"my-kv-namespace\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.kv.namespace.deleted\",\n  \"source\": {\n    \"type\": \"kv\"\n  },\n  \"payload\": {\n    \"id\": \"ns-12345678-90ab-cdef-1234-567890abcdef\",\n    \"name\": \"my-kv-namespace\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workflows.workflow.instance.queued\",\n  \"source\": {\n    \"type\": \"workflows.workflow\",\n    \"workflowName\": \"my-workflow\"\n  },\n  \"payload\": {\n    \"versionId\": \"v1\",\n    \"instanceId\": \"inst-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workflows.workflow.instance.started\",\n  \"source\": {\n    \"type\": \"workflows.workflow\",\n    \"workflowName\": \"my-workflow\"\n  },\n  \"payload\": {\n    \"versionId\": \"v1\",\n    \"instanceId\": \"inst-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workflows.workflow.instance.paused\",\n  \"source\": {\n    \"type\": \"workflows.workflow\",\n    \"workflowName\": \"my-workflow\"\n  },\n  \"payload\": {\n    \"versionId\": \"v1\",\n    \"instanceId\": \"inst-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workflows.workflow.instance.errored\",\n  \"source\": {\n    \"type\": \"workflows.workflow\",\n    \"workflowName\": \"my-workflow\"\n  },\n  \"payload\": {\n    \"versionId\": \"v1\",\n    \"instanceId\": \"inst-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workflows.workflow.instance.terminated\",\n  \"source\": {\n    \"type\": \"workflows.workflow\",\n    \"workflowName\": \"my-workflow\"\n  },\n  \"payload\": {\n    \"versionId\": \"v1\",\n    \"instanceId\": \"inst-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\njson\n{\n  \"type\": \"cf.workflows.workflow.instance.completed\",\n  \"source\": {\n    \"type\": \"workflows.workflow\",\n    \"workflowName\": \"my-workflow\"\n  },\n  \"payload\": {\n    \"versionId\": \"v1\",\n    \"instanceId\": \"inst-12345678-90ab-cdef-1234-567890abcdef\"\n  },\n  \"metadata\": {\n    \"accountId\": \"f9f79265f388666de8122cfb508d7776\",\n    \"eventSubscriptionId\": \"1830c4bb612e43c3af7f4cada31fbf3f\",\n    \"eventSchemaVersion\": 1,\n    \"eventTimestamp\": \"2025-05-01T02:48:57.132Z\"\n  }\n}\nbash\nnpx wrangler queues subscription create <queue-name> --source <source-type> --events <event1,event2> --<source-specific-option> <value>\nbash\nnpx wrangler queues subscription list <queue-name>\nbash\nnpx wrangler queues subscription delete <queue-name> --id <subscription-id>\nsh",
  "code_samples": [
    {
      "code": "Delays can also be configured in the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/#queues) with the `delivery_delay` setting for producers (when sending) and/or the `retry_delay` (when retrying) per-consumer:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "If you use both the `wrangler` CLI and the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) to change the settings associated with a queue or a queue consumer, the most recent configuration change will take effect.\n\nRefer to the [Queues REST API documentation](https://developers.cloudflare.com/api/resources/queues/subresources/consumers/methods/get/) to learn how to configure message delays and retry delays programmatically.\n\n### Message delay precedence\n\nMessages can be delayed by default at the queue level, or per-message (or batch).\n\n* Per-message/batch delay settings take precedence over queue-level settings.\n* Setting `delaySeconds: 0` on a message when sending or retrying will ignore any queue-level delays and cause the message to be delivered in the next batch.\n* A message sent or retried with `delaySeconds: <any positive integer>` to a queue with a shorter default delay will still respect the message-level setting.\n\n### Apply a backoff algorithm\n\nYou can apply a backoff algorithm to increasingly delay messages based on the current number of attempts to deliver the message.\n\nEach message delivered to a consumer includes an `attempts` property that tracks the number of delivery attempts made.\n\nFor example, to generate an [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff) for a message, you can create a helper function that calculates this for you:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "In your consumer, you then pass the value of `msg.attempts` and your desired delay factor as the argument to `delaySeconds` when calling `retry()` on an individual message:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "## Related\n\n* Review the [JavaScript API](https://developers.cloudflare.com/queues/configuration/javascript-apis/) documentation for Queues.\n* Learn more about [How Queues Works](https://developers.cloudflare.com/queues/reference/how-queues-works/).\n* Understand the [metrics available](https://developers.cloudflare.com/queues/observability/metrics/) for your queues, including backlog and delayed message counts.\n\n</page>\n\n<page>\n---\ntitle: Cloudflare Queues - Configuration · Cloudflare Queues docs\ndescription: Cloudflare Queues can be configured using Wrangler, the\n  command-line interface for Cloudflare's Developer Platform, which includes\n  Workers, R2, and other developer products.\nlastUpdated: 2025-08-11T15:14:33.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/configure-queues/\n  md: https://developers.cloudflare.com/queues/configuration/configure-queues/index.md\n---\n\nCloudflare Queues can be configured using [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), the command-line interface for Cloudflare's Developer Platform, which includes [Workers](https://developers.cloudflare.com/workers/), [R2](https://developers.cloudflare.com/r2/), and other developer products.\n\nEach Producer and Consumer Worker has a [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) that specifies environment variables, triggers, and resources, such as a queue. To enable Worker-to-resource communication, you must set up a [binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/) in your Worker project's Wrangler file.\n\nUse the options below to configure your queue.\n\nNote\n\nBelow are options for queues, refer to the Wrangler documentation for a full reference of the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).\n\n## Queue configuration\n\nThe following queue level settings can be configured using Wrangler:",
      "language": "unknown"
    },
    {
      "code": "* `--delivery-delay-secs` number optional\n\n  * How long a published message is delayed for, before it is delivered to consumers.\n  * Must be between 0 and 43200 (12 hours).\n  * Defaults to 0.\n\n* `--message-retention-period-secs` number optional\n\n  * How long messages are retained on the Queue.\n  * Defaults to 345600 (4 days).\n  * Must be between 60 and 1209600 (14 days)\n\n## Producer Worker configuration\n\nA producer is a [Cloudflare Worker](https://developers.cloudflare.com/workers/) that writes to one or more queues. A producer can accept messages over HTTP, asynchronously write messages when handling requests, and/or write to a queue from within a [Durable Object](https://developers.cloudflare.com/durable-objects/). Any Worker can write to a queue.\n\nTo produce to a queue, set up a binding in your Wrangler file. These options should be used when a Worker wants to send messages to a queue.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "- `queue` string\n  * The name of the queue.\n- `binding` string\n  * The name of the binding, which is a JavaScript variable.\n\n## Consumer Worker Configuration\n\nTo consume messages from one or more queues, set up a binding in your Wrangler file. These options should be used when a Worker wants to receive messages from a queue.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Refer to [Limits](https://developers.cloudflare.com/queues/platform/limits) to review the maximum values for each of these options.\n\n* `queue` string\n  * The name of the queue.\n\n* `max_batch_size` number optional\n\n  * The maximum number of messages allowed in each batch.\n  * Defaults to `10` messages.\n\n* `max_batch_timeout` number optional\n\n  * The maximum number of seconds to wait until a batch is full.\n  * Defaults to `5` seconds.\n\n* `max_retries` number optional\n\n  * The maximum number of retries for a message, if it fails or [`retryAll()`](https://developers.cloudflare.com/queues/configuration/javascript-apis/#messagebatch) is invoked.\n  * Defaults to `3` retries.\n\n* `dead_letter_queue` string optional\n\n  * The name of another queue to send a message if it fails processing at least `max_retries` times.\n  * If a `dead_letter_queue` is not defined, messages that repeatedly fail processing will eventually be discarded.\n  * If there is no queue with the specified name, it will be created automatically.\n\n* `max_concurrency` number optional\n\n  * The maximum number of concurrent consumers allowed to run at once. Leaving this unset will mean that the number of invocations will scale to the [currently supported maximum](https://developers.cloudflare.com/queues/platform/limits/).\n  * Refer to [Consumer concurrency](https://developers.cloudflare.com/queues/configuration/consumer-concurrency/) for more information on how consumers autoscale, particularly when messages are retried.\n\n## Pull-based\n\nA queue can have a HTTP-based consumer that pulls from the queue. This consumer can be any HTTP-speaking service that can communicate over the Internet. Review [Pull consumers](https://developers.cloudflare.com/queues/configuration/pull-consumers/) to learn how to configure a pull-based consumer.\n\n</page>\n\n<page>\n---\ntitle: Consumer concurrency · Cloudflare Queues docs\ndescription: Consumer concurrency allows a consumer Worker processing messages\n  from a queue to automatically scale out horizontally to keep up with the rate\n  that messages are being written to a queue.\nlastUpdated: 2025-09-04T11:41:09.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/consumer-concurrency/\n  md: https://developers.cloudflare.com/queues/configuration/consumer-concurrency/index.md\n---\n\nConsumer concurrency allows a [consumer Worker](https://developers.cloudflare.com/queues/reference/how-queues-works/#consumers) processing messages from a queue to automatically scale out horizontally to keep up with the rate that messages are being written to a queue.\n\nIn many systems, the rate at which you write messages to a queue can easily exceed the rate at which a single consumer can read and process those same messages. This is often because your consumer might be parsing message contents, writing to storage or a database, or making third-party (upstream) API calls.\n\nNote that queue producers are always scalable, up to the [maximum supported messages-per-second](https://developers.cloudflare.com/queues/platform/limits/) (per queue) limit.\n\n## Enable concurrency\n\nBy default, all queues have concurrency enabled. Queue consumers will automatically scale up [to the maximum concurrent invocations](https://developers.cloudflare.com/queues/platform/limits/) as needed to manage a queue's backlog and/or error rates.\n\n## How concurrency works\n\nAfter processing a batch of messages, Queues will check to see if the number of concurrent consumers should be adjusted. The number of concurrent consumers invoked for a queue will autoscale based on several factors, including:\n\n* The number of messages in the queue (backlog) and its rate of growth.\n* The ratio of failed (versus successful) invocations. A failed invocation is when your `queue()` handler returns an uncaught exception instead of `void` (nothing).\n* The value of `max_concurrency` set for that consumer.\n\nWhere possible, Queues will optimize for keeping your backlog from growing exponentially, in order to minimize scenarios where the backlog of messages in a queue grows to the point that they would reach the [message retention limit](https://developers.cloudflare.com/queues/platform/limits/) before being processed.\n\nConsumer concurrency and retried messages\n\n[Retrying messages with `retry()`](https://developers.cloudflare.com/queues/configuration/batching-retries/#explicit-acknowledgement-and-retries) or calling `retryAll()` on a batch will **not** count as a failed invocation.\n\n### Example\n\nIf you are writing 100 messages/second to a queue with a single concurrent consumer that takes 5 seconds to process a batch of 100 messages, the number of messages in-flight will continue to grow at a rate faster than your consumer can keep up.\n\nIn this scenario, Queues will notice the growing backlog and will scale the number of concurrent consumer Workers invocations up to a steady-state of (approximately) five (5) until the rate of incoming messages decreases, the consumer processes messages faster, or the consumer begins to generate errors.\n\n### Why are my consumers not autoscaling?\n\nIf your consumers are not autoscaling, there are a few likely causes:\n\n* `max_concurrency` has been set to 1.\n* Your consumer Worker is returning errors rather than processing messages. Inspect your consumer to make sure it is healthy.\n* A batch of messages is being processed. Queues checks if it should autoscale consumers only after processing an entire batch of messages, so it will not autoscale while a batch is being processed. Consider reducing batch sizes or refactoring your consumer to process messages faster.\n\n## Limit concurrency\n\nRecommended concurrency setting\n\nCloudflare recommends leaving the maximum concurrency unset, which will allow your queue consumer to scale up as much as possible. Setting a fixed number means that your consumer will only ever scale up to that maximum, even as Queues increases the maximum supported invocations over time.\n\nIf you have a workflow that is limited by an upstream API and/or system, you may prefer for your backlog to grow, trading off increased overall latency in order to avoid overwhelming an upstream system.\n\nYou can configure the concurrency of your consumer Worker in two ways:\n\n1. Set concurrency settings in the Cloudflare dashboard\n2. Set concurrency settings via the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/)\n\n### Set concurrency settings in the Cloudflare dashboard\n\nTo configure the concurrency settings for your consumer Worker from the dashboard:\n\n1. In the Cloudflare dashboard, go to the **Queues** page.\n\n   [Go to **Queues**](https://dash.cloudflare.com/?to=/:account/workers/queues)\n\n2. Select your queue > **Settings**.\n\n3. Select **Edit Consumer** under Consumer details.\n\n4. Set **Maximum consumer invocations** to a value between `1` and `250`. This value represents the maximum number of concurrent consumer invocations available to your queue.\n\nTo remove a fixed maximum value, select **auto (recommended)**.\n\nNote that if you are writing messages to a queue faster than you can process them, messages may eventually reach the [maximum retention period](https://developers.cloudflare.com/queues/platform/limits/) set for that queue. Individual messages that reach that limit will expire from the queue and be deleted.\n\n### Set concurrency settings in the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/)\n\nNote\n\nEnsure you are using the latest version of [wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/). Support for configuring the maximum concurrency of a queue consumer is only supported in wrangler [`2.13.0`](https://github.com/cloudflare/workers-sdk/releases/tag/wrangler%402.13.0) or greater.\n\nTo set a fixed maximum number of concurrent consumer invocations for a given queue, configure a `max_concurrency` in your Wrangler file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "To remove the limit, remove the `max_concurrency` setting from the `[[queues.consumers]]` configuration for a given queue and call `npx wrangler deploy` to push your configuration update.\n\n## Billing\n\nWhen multiple consumer Workers are invoked, each Worker invocation incurs [CPU time costs](https://developers.cloudflare.com/workers/platform/pricing/#workers).\n\n* If you intend to process all messages written to a queue, *the effective overall cost is the same*, even with concurrency enabled.\n* Enabling concurrency simply brings those costs forward, and can help prevent messages from reaching the [message retention limit](https://developers.cloudflare.com/queues/platform/limits/).\n\nBilling for consumers follows the [Workers standard usage model](https://developers.cloudflare.com/workers/platform/pricing/#example-pricing) meaning a developer is billed for the request and for CPU time used in the request.\n\n### Example\n\nA consumer Worker that takes 2 seconds to process a batch of messages will incur the same overall costs to process 50 million (50,000,000) messages, whether it does so concurrently (faster) or individually (slower).\n\n</page>\n\n<page>\n---\ntitle: Dead Letter Queues · Cloudflare Queues docs\ndescription: A Dead Letter Queue (DLQ) is a common concept in a messaging\n  system, and represents where messages are sent when a delivery failure occurs\n  with a consumer after max_retries is reached. A Dead Letter Queue is like any\n  other queue, and can be produced to and consumed from independently.\nlastUpdated: 2025-01-29T12:28:42.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/dead-letter-queues/\n  md: https://developers.cloudflare.com/queues/configuration/dead-letter-queues/index.md\n---\n\nA Dead Letter Queue (DLQ) is a common concept in a messaging system, and represents where messages are sent when a delivery failure occurs with a consumer after `max_retries` is reached. A Dead Letter Queue is like any other queue, and can be produced to and consumed from independently.\n\nWith Cloudflare Queues, a Dead Letter Queue is defined within your [consumer configuration](https://developers.cloudflare.com/queues/configuration/configure-queues/). Messages are delivered to the DLQ when they reach the configured retry limit for the consumer. Without a DLQ configured, messages that reach the retry limit are deleted permanently.\n\nFor example, the following consumer configuration would send messages to our DLQ named `\"my-other-queue\"` after retrying delivery (by default, 3 times):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "You can also configure a DLQ when creating a consumer from the command-line using `wrangler`:",
      "language": "unknown"
    },
    {
      "code": "To process messages placed on your DLQ, you need to [configure a consumer](https://developers.cloudflare.com/queues/configuration/configure-queues/) for that queue as you would with any other queue.\n\nMessages delivered to a DLQ without an active consumer will persist for four (4) days before being deleted from the queue.\n\n</page>\n\n<page>\n---\ntitle: R2 Event Notifications · Cloudflare Queues docs\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/event-notifications/\n  md: https://developers.cloudflare.com/queues/configuration/event-notifications/index.md\n---\n\n\n</page>\n\n<page>\n---\ntitle: Cloudflare Queues - JavaScript APIs · Cloudflare Queues docs\ndescription: Cloudflare Queues is integrated with Cloudflare Workers. To send\n  and receive messages, you must use a Worker.\nlastUpdated: 2025-12-09T12:49:27.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/javascript-apis/\n  md: https://developers.cloudflare.com/queues/configuration/javascript-apis/index.md\n---\n\nCloudflare Queues is integrated with [Cloudflare Workers](https://developers.cloudflare.com/workers). To send and receive messages, you must use a Worker.\n\nA Worker that can send messages to a Queue is a producer Worker, while a Worker that can receive messages from a Queue is a consumer Worker. It is possible for the same Worker to be a producer and consumer, if desired.\n\nIn the future, we expect to support other APIs, such as HTTP endpoints to send or receive messages. To report bugs or request features, go to the [Cloudflare Community Forums](https://community.cloudflare.com/c/developers/workers/40). To give feedback, go to the [`#queues`](https://discord.cloudflare.com) Discord channel.\n\n## Producer\n\nThese APIs allow a producer Worker to send messages to a Queue.\n\nAn example of writing a single message to a Queue:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "The Queues API also supports writing multiple messages at once:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "### `Queue`\n\nA binding that allows a producer to send messages to a Queue.",
      "language": "unknown"
    },
    {
      "code": "* `send(bodyunknown, options?{ contentType?: QueuesContentType })` Promise\\<void>\n\n  * Sends a message to the Queue. The body can be any type supported by the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types), as long as its size is less than 128 KB.\n  * When the promise resolves, the message is confirmed to be written to disk.\n\n* `sendBatch(bodyIterable<MessageSendRequest<unknown>>)` Promise\\<void>\n\n  * Sends a batch of messages to the Queue. Each item in the provided [Iterable](https://www.typescriptlang.org/docs/handbook/iterators-and-generators.html) must be supported by the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types). A batch can contain up to 100 messages, though items are limited to 128 KB each, and the total size of the array cannot exceed 256 KB.\n  * When the promise resolves, the messages are confirmed to be written to disk.\n\n### `MessageSendRequest`\n\nA wrapper type used for sending message batches.",
      "language": "unknown"
    },
    {
      "code": "* `body` unknown\n\n  * The body of the message.\n  * The body can be any type supported by the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types), as long as its size is less than 128 KB.\n\n* `options` QueueSendOptions\n  * Options to apply to the current message, including content type and message delay settings.\n\n### `QueueSendOptions`\n\nOptional configuration that applies when sending a message to a queue.\n\n* `contentType` QueuesContentType\n\n  * The explicit content type of a message so it can be previewed correctly with the [List messages from the dashboard](https://developers.cloudflare.com/queues/examples/list-messages-from-dash/) feature. Optional argument.\n  * As of now, this option is for internal use. In the future, `contentType` will be used by alternative consumer types to explicitly mark messages as serialized so they can be consumed in the desired type.\n  * See [QueuesContentType](#queuescontenttype) for possible values.\n\n* `delaySeconds` number\n\n  * The number of seconds to [delay a message](https://developers.cloudflare.com/queues/configuration/batching-retries/) for within the queue, before it can be delivered to a consumer.\n  * Must be an integer between 0 and 43200 (12 hours). Setting this value to zero will explicitly prevent the message from being delayed, even if there is a global (default) delay at the queue level.\n\n### `QueueSendBatchOptions`\n\nOptional configuration that applies when sending a batch of messages to a queue.\n\n* `delaySeconds` number\n\n  * The number of seconds to [delay messages](https://developers.cloudflare.com/queues/configuration/batching-retries/) for within the queue, before it can be delivered to a consumer.\n  * Must be a positive integer.\n\n### `QueuesContentType`\n\nA union type containing valid message content types.",
      "language": "unknown"
    },
    {
      "code": "* Use `\"json\"` to send a JavaScript object that can be JSON-serialized. This content type can be previewed from the [Cloudflare dashboard](https://dash.cloudflare.com). The `json` content type is the default.\n* Use `\"text\"` to send a `String`. This content type can be previewed with the [List messages from the dashboard](https://developers.cloudflare.com/queues/examples/list-messages-from-dash/) feature.\n* Use `\"bytes\"` to send an `ArrayBuffer`. This content type cannot be previewed from the [Cloudflare dashboard](https://dash.cloudflare.com) and will display as Base64-encoded.\n* Use `\"v8\"` to send a JavaScript object that cannot be JSON-serialized but is supported by [structured clone](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types) (for example `Date` and `Map`). This content type cannot be previewed from the [Cloudflare dashboard](https://dash.cloudflare.com) and will display as Base64-encoded.\n\nNote\n\nThe default content type for Queues changed to `json` (from `v8`) to improve compatibility with pull-based consumers for any Workers with a [compatibility date](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#queues-send-messages-in-json-format) after `2024-03-18`.\n\nIf you specify an invalid content type, or if your specified content type does not match the message content's type, the send operation will fail with an error.\n\n## Consumer\n\nThese APIs allow a consumer Worker to consume messages from a Queue.\n\nTo define a consumer Worker, add a `queue()` function to the default export of the Worker. This will allow it to receive messages from the Queue.\n\nBy default, all messages in the batch will be acknowledged as soon as all of the following conditions are met:\n\n1. The `queue()` function has returned.\n2. If the `queue()` function returned a promise, the promise has resolved.\n3. Any promises passed to `waitUntil()` have resolved.\n\nIf the `queue()` function throws, or the promise returned by it or any of the promises passed to `waitUntil()` were rejected, then the entire batch will be considered a failure and will be retried according to the consumer's retry settings.\n\nNote\n\n`waitUntil()` is the only supported method to run tasks (such as logging or metrics calls) that resolve after a queue handler has completed. Promises that have not resolved by the time the queue handler returns may not complete and will not block completion of execution.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "The `env` and `ctx` fields are as [documented in the Workers documentation](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/).\n\nOr alternatively, a queue consumer can be written using the (deprecated) service worker syntax:",
      "language": "unknown"
    },
    {
      "code": "In service worker syntax, `event` provides the same fields and methods as `MessageBatch`, as defined below, in addition to [`waitUntil()`](https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent/waitUntil).\n\nNote\n\nWhen performing asynchronous tasks in your queue handler that iterates through messages, use an asynchronous version of iterating through your messages. For example, `for (const m of batch.messages)`or `await Promise.all(batch.messages.map(work))` allow for waiting for the results of asynchronous calls. `batch.messages.forEach()` does not.\n\n### `MessageBatch`\n\nA batch of messages that are sent to a consumer Worker.",
      "language": "unknown"
    },
    {
      "code": "* `queue` string\n  * The name of the Queue that belongs to this batch.\n\n* `messages` Message\\[]\n  * An array of messages in the batch. Ordering of messages is best effort -- not guaranteed to be exactly the same as the order in which they were published. If you are interested in guaranteed FIFO ordering, please [email the Queues team](mailto:queues@cloudflare.com).\n\n* `ackAll()` void\n  * Marks every message as successfully delivered, regardless of whether your `queue()` consumer handler returns successfully or not.\n\n* `retryAll(options?: QueueRetryOptions)` void\n\n  * Marks every message to be retried in the next batch.\n  * Supports an optional `options` object.\n\n### `Message`\n\nA message that is sent to a consumer Worker.",
      "language": "unknown"
    },
    {
      "code": "* `id` string\n  * A unique, system-generated ID for the message.\n\n* `timestamp` Date\n  * A timestamp when the message was sent.\n\n* `body` unknown\n\n  * The body of the message.\n  * The body can be any type supported by the [structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#supported_types), as long as its size is less than 128 KB.\n\n* `attempts` number\n  * The number of times the consumer has attempted to process this message. Starts at 1.\n\n* `ack()` void\n  * Marks a message as successfully delivered, regardless of whether your `queue()` consumer handler returns successfully or not.\n\n* `retry(options?: QueueRetryOptions)` void\n\n  * Marks a message to be retried in the next batch.\n  * Supports an optional `options` object.\n\n### `QueueRetryOptions`\n\nOptional configuration when marking a message or a batch of messages for retry.",
      "language": "unknown"
    },
    {
      "code": "* `delaySeconds` number\n\n  * The number of seconds to [delay a message](https://developers.cloudflare.com/queues/configuration/batching-retries/) for within the queue, before it can be delivered to a consumer.\n  * Must be a positive integer.\n\n</page>\n\n<page>\n---\ntitle: Local Development · Cloudflare Queues docs\ndescription: Queues support local development workflows using Wrangler, the\n  command-line interface for Workers. Wrangler runs the same version of Queues\n  as Cloudflare runs globally.\nlastUpdated: 2025-04-25T19:19:43.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/local-development/\n  md: https://developers.cloudflare.com/queues/configuration/local-development/index.md\n---\n\nQueues support local development workflows using [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), the command-line interface for Workers. Wrangler runs the same version of Queues as Cloudflare runs globally.\n\n## Prerequisites\n\nTo develop locally with Queues, you will need:\n\n* [Wrangler v3.1.0](https://blog.cloudflare.com/wrangler3/) or later.\n\n* Node.js version of `18.0.0` or later. Consider using a Node version manager like [Volta](https://volta.sh/) or [nvm](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node versions.\n\n* If you are new to Queues and/or Cloudflare Workers, refer to the [Queues tutorial](https://developers.cloudflare.com/queues/get-started/) to install `wrangler` and deploy their first Queue.\n\n## Start a local development session\n\nOpen your terminal and run the following commands to start a local development session:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "Local development sessions create a standalone, local-only environment that mirrors the production environment Queues runs in so you can test your Workers *before* you deploy to production.\n\nRefer to the [`wrangler dev` documentation](https://developers.cloudflare.com/workers/wrangler/commands/#dev) to learn more about how to configure a local development session.\n\n## Separating producer & consumer Workers\n\nWrangler supports running multiple Workers simultaneously with a single command. If your architecture separates the producer and consumer into distinct Workers, you can use this functionality to test the entire message flow locally.\n\nWarning\n\nSupport for running multiple Workers at once with one Wrangler command is experimental, and subject to change as we work on the experience. If you run into bugs or have any feedback, [open an issue on the workers-sdk repository](https://github.com/cloudflare/workers-sdk/issues/new)\n\nFor example, if your project has the following directory structure:",
      "language": "unknown"
    },
    {
      "code": "You can start development servers for both workers with the following command:",
      "language": "unknown"
    },
    {
      "code": "When the producer Worker sends messages to the queue, the consumer Worker will automatically be invoked to handle them.\n\nNote\n\n[Consumer concurrency](https://developers.cloudflare.com/queues/configuration/consumer-concurrency/) is not supported while running locally.\n\n## Known Issues\n\n* Queues does not support Wrangler remote mode (`wrangler dev --remote`).\n\n</page>\n\n<page>\n---\ntitle: Pause and Purge · Cloudflare Queues docs\ndescription: You can pause delivery of messages from your queue to any connected\n  consumers. Pausing a queue is useful when managing downtime (for example, if\n  your consumer Worker is unhealthy) without losing any messages.\nlastUpdated: 2025-08-05T14:31:44.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/pause-purge/\n  md: https://developers.cloudflare.com/queues/configuration/pause-purge/index.md\n---\n\n## Pause Delivery\n\nYou can pause delivery of messages from your queue to any connected consumers. Pausing a queue is useful when managing downtime (for example, if your consumer Worker is unhealthy) without losing any messages.\n\nQueues continue to receive and store messages even while delivery is paused. Messages in a paused queue are still subject to expiry, if the messages become older than the queue message retention period.\n\nPausing affects both [push-based consumer Workers](https://developers.cloudflare.com/queues/reference/how-queues-works#consumers) and [pull based consumers](https://developers.cloudflare.com/queues/configuration/pull-consumers).\n\n### Pause and resume delivery using Wrangler\n\nThe following command will pause message delivery from your queue:",
      "language": "unknown"
    },
    {
      "code": "* `queue-name` string required\n  * The name of the queue for which delivery should be paused.\n\nThe following command will resume message delivery:",
      "language": "unknown"
    },
    {
      "code": "* `queue-name` string required\n  * The name of the queue for which delivery should be resumed.\n\n### What happens to HTTP Pull consumers with a paused queue?\n\nWhen a queue is paused, messages cannot be pulled by an [HTTP pull based consumer](https://developers.cloudflare.com/queues/configuration/pull-consumers). Requests to pull messages will receive a `409` response, along with an error message stating `queue_delivery_paused`.\n\n## Purge queue\n\nPurging a queue permanently deletes any messages currently stored in the Queue. Purging is useful while developing a new application, especially to clear out any test data. It can also be useful in production to handle scenarios when a batch of bad messages have been sent to a Queue.\n\nNote that any in flight messages, which are currently being processed by consumers, might still be processed. Messages sent to a queue during a purge operation might not be purged. Any delayed messages will also be deleted from the queue.\n\nWarning\n\nPurging a queue is an irreversible operation. Make sure to use this operation carefully.\n\n### Purge queue using Wrangler\n\nThe following command will purge messages from your queue. You will be prompted to enter the queue name to confirm the operation.",
      "language": "unknown"
    },
    {
      "code": "### Does purging a Queue affect my bill?\n\nPurging a queue counts as a single billable operation, regardless of how many messages are deleted. For example, if you purge a queue which has 100 messages, all 100 messages will be permanently deleted, and you will be billed for 1 billable operation. Refer to the [pricing](https://developers.cloudflare.com/queues/platform/pricing) page for more information about how Queues is billed.\n\n</page>\n\n<page>\n---\ntitle: Cloudflare Queues - Pull consumers · Cloudflare Queues docs\ndescription: A pull-based consumer allows you to pull from a queue over HTTP\n  from any environment and/or programming language outside of Cloudflare\n  Workers. A pull-based consumer can be useful when your message consumption\n  rate is limited by upstream infrastructure or long-running tasks.\nlastUpdated: 2025-12-09T12:49:27.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/pull-consumers/\n  md: https://developers.cloudflare.com/queues/configuration/pull-consumers/index.md\n---\n\nA pull-based consumer allows you to pull from a queue over HTTP from any environment and/or programming language outside of Cloudflare Workers. A pull-based consumer can be useful when your message consumption rate is limited by upstream infrastructure or long-running tasks.\n\n## How to choose between push or pull consumer\n\nDeciding whether to configure a push-based consumer or a pull-based consumer will depend on how you are using your queues, as well as the configuration of infrastructure upstream from your queue consumer.\n\n* **Starting with a [push-based consumer](https://developers.cloudflare.com/queues/reference/how-queues-works/#consumers) is the easiest way to get started and consume from a queue**. A push-based consumer runs on Workers, and by default, will automatically scale up and consume messages as they are written to the queue.\n* Use a pull-based consumer if you need to consume messages from existing infrastructure outside of Cloudflare Workers, and/or where you need to carefully control how fast messages are consumed. A pull-based consumer must explicitly make a call to pull (and then acknowledge) messages from the queue, only when it is ready to do so.\n\nYou can remove and attach a new consumer on a queue at any time, allowing you to change from a pull-based to a push-based consumer if your requirements change.\n\nRetrieve an API bearer token\n\nTo configure a pull-based consumer, create [an API token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/) with both the `queues#read` and `queues#write` permissions. A consumer must be able to write to a queue to acknowledge messages.\n\nTo configure a pull-based consumer and receive messages from a queue, you need to:\n\n1. Enable HTTP pull for the queue.\n2. Create a valid authentication token for the HTTP client.\n3. Pull message batches from the queue.\n4. Acknowledge and/or retry messages within a batch.\n\n## 1. Enable HTTP pull\n\nYou can enable HTTP pull or change a queue from push-based to pull-based via the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/), the `wrangler` CLI, or via the [Cloudflare dashboard](https://dash.cloudflare.com/).\n\n### Wrangler configuration file\n\nA HTTP consumer can be configured in the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) by setting `type = \"http_pull\"` in the consumer configuration:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Omitting the `type` property will default the queue to push-based.\n\n### wrangler CLI\n\nYou can enable a pull-based consumer on any existing queue by using the `wrangler queues consumer http` sub-commands and providing a queue name.",
      "language": "unknown"
    },
    {
      "code": "If you have an existing push-based consumer, you will need to remove that first. `wrangler` will return an error if you attempt to call `consumer http add` on a queue with an existing consumer configuration:",
      "language": "unknown"
    },
    {
      "code": "Note\n\nIf you remove the Worker consumer with `wrangler` but do not delete the `[[queues.consumer]]` configuration from your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/), subsequent deployments of your Worker will fail when they attempt to add a conflicting consumer configuration.\n\nEnsure you remove the consumer configuration first.\n\n## 2. Consumer authentication\n\nHTTP Pull consumers require an [API token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/) with the `com.cloudflare.api.account.queues_read` and `com.cloudflare.api.account.queues_write` permissions.\n\nBoth read *and* write are required as a pull-based consumer needs to write to the queue state to acknowledge the messages it receives. Consuming messages mutates the queue.\n\nAPI tokens are presented as Bearer tokens in the `Authorization` header of a HTTP request in the format `Authorization: Bearer $YOUR_TOKEN_HERE`. The following example shows how to pass an API token using the `curl` HTTP client:",
      "language": "unknown"
    },
    {
      "code": "You may authenticate and run multiple concurrent pull-based consumers against a single queue.\n\n### Create API tokens\n\nTo create an API token:\n\n1. Log in to the [Cloudflare dashboard](https://dash.cloudflare.com).\n2. Go to **My Profile** > [API Tokens](https://dash.cloudflare.com/profile/api-tokens).\n3. Select **Create Token**.\n4. Scroll to the bottom of the page and select **Create Custom Token**.\n5. Give the token a name. For example, `queue-pull-token`.\n6. Under the **Permissions** section, choose **Account** and then **Queues**. Ensure you have selected **Edit** (read+write).\n7. (Optional) Select **All accounts** (default) or a specific account to scope the token to.\n8. Select **Continue to summary** and then **Create token**.\n\nYou will need to note the token down: it will only be displayed once.\n\n## 3. Pull messages\n\nTo pull a message, make a HTTP POST request to the [Queues REST API](https://developers.cloudflare.com/api/resources/queues/subresources/messages/methods/pull/) with a JSON-encoded body that optionally specifies a `visibility_timeout` and a `batch_size`, or an empty JSON object (`{}`):\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "This will return an array of messages (up to the specified `batch_size`) in the below format:",
      "language": "unknown"
    },
    {
      "code": "Pull consumers follow a \"short polling\" approach: if there are messages available to be delivered, Queues will return a response immediately with messages up to the configured `batch_size`. If there are no messages to deliver, Queues will return an empty response. Queues does not hold an open connection (often referred to as \"long polling\") if there are no messages to deliver.\n\nNote\n\nThe [`pull`](https://developers.cloudflare.com/api/resources/queues/subresources/messages/methods/pull/) and [`ack`](https://developers.cloudflare.com/api/resources/queues/subresources/messages/methods/ack/) endpoints use the new `/queues/queue_id/messages/{action}` API format, as defined in the Queues API documentation.\n\nThe undocumented `/queues/queue_id/{action}` endpoints are not supported and will be deprecated as of June 30th, 2024.\n\nEach message object has five fields:\n\n1. `body` - this may be base64 encoded based on the [content-type the message was published as](#content-types).\n2. `id` - a unique, read-only ephemeral identifier for the message.\n3. `timestamp_ms` - when the message was published to the queue in milliseconds since the [Unix epoch](https://en.wikipedia.org/wiki/Unix_time). This allows you to determine how old a message is by subtracting it from the current timestamp.\n4. `attempts` - how many times the message has been attempted to be delivered in full. When this reaches the value of `max_retries`, the message will not be re-delivered and will be deleted from the queue permanently.\n5. `lease_id` - the encoded lease ID of the message. The `lease_id` is used to explicitly acknowledge or retry the message.\n\nThe `lease_id` allows your pull consumer to explicitly acknowledge some, none or all messages in the batch or mark them for retry. If messages are not acknowledged or marked for retry by the consumer, then they will be marked for re-delivery once the `visibility_timeout` is reached. A `lease_id` is no longer valid once this timeout has been reached.\n\nYou can configure both `batch_size` and `visibility_timeout` when pulling from a queue:\n\n* `batch_size` (defaults to 5; max 100) - how many messages are returned to the consumer in each pull.\n* `visibility_timeout` (defaults to 30 second; max 12 hours) - defines how long the consumer has to explicitly acknowledge messages delivered in the batch based on their `lease_id`. Once this timeout expires, messages are assumed unacknowledged and queued for re-delivery again.\n\n### Concurrent consumers\n\nYou may have multiple HTTP clients pulling from the same queue concurrently: each client will receive a unique batch of messages and retain the \"lease\" on those messages up until the `visibility_timeout` expires, or until those messages are marked for retry.\n\nMessages marked for retry will be put back into the queue and can be delivered to any consumer. Messages are *not* tied to a specific consumer, as consumers do not have an identity and to avoid a slow or stuck consumer from holding up processing of messages in a queue.\n\nMultiple consumers can be useful in cases where you have multiple upstream resources (for example, GPU infrastructure), where you want to autoscale based on the [backlog](https://developers.cloudflare.com/queues/observability/metrics/) of a queue, and/or cost.\n\n## 4. Acknowledge messages\n\nMessages pulled by a consumer need to be either acknowledged or marked for retry.\n\nTo acknowledge and/or mark messages to be retried, make a HTTP `POST` request to `/ack` endpoint of your queue per the [Queues REST API](https://developers.cloudflare.com/api/resources/queues/subresources/messages/methods/ack/) by providing an array of `lease_id` objects to acknowledge and/or retry:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "You may optionally specify the number of seconds to delay a message for when marking it for retry by providing a `{ lease_id: string, delay_seconds: number }` object in the `retries` array:",
      "language": "unknown"
    },
    {
      "code": "Additionally:\n\n* You should provide every `lease_id` in the request to the `/ack` endpoint if you are processing those messages in your consumer. If you do not acknowledge a message, it will be marked for re-delivery (put back in the queue).\n* You can optionally mark messages to be retried: for example, if there is an error processing the message or you have upstream resource pressure. Explicitly marking a message for retry will place it back into the queue immediately, instead of waiting for a (potentially long) `visibility_timeout` to be reached.\n* You can make multiple calls to the `/ack` endpoint as you make progress through a batch of messages, but we recommend grouping acknowledgements to reduce the number of API calls required.\n\nQueues aims to be permissive when it comes to lease IDs: if a consumer acknowledges a message by its lease ID *after* the visibility timeout is reached, Queues will still accept that acknowledgment. If the message was delivered to another consumer during the intervening period, it will also be able to acknowledge the message without an error.\n\n## Content types\n\nWarning\n\nWhen attaching a pull-based consumer to a queue, you should ensure that messages are sent with only a `text`, `bytes` or `json` [content type](https://developers.cloudflare.com/queues/configuration/javascript-apis/#queuescontenttype).\n\nThe default content type is `json`.\n\nPull-based consumers cannot decode the `v8` content type as it is specific to the Workers runtime.\n\nWhen publishing to a queue that has an external consumer, you should be aware that certain content types may be encoded in a way that allows them to be safely serialized within a JSON object.\n\nFor both the `json` and `bytes` content types, this means that they will be base64-encoded ([RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648)). The `text` type will be sent as a plain UTF-8 encoded string.\n\nYour consumer will need to decode the `json` and `bytes` types before operating on the data.\n\n## Next steps\n\n* Review the [REST API documentation](https://developers.cloudflare.com/api/resources/queues/subresources/consumers/methods/create/) and schema for Queues.\n* Learn more about [how to make API calls](https://developers.cloudflare.com/fundamentals/api/how-to/make-api-calls/) to the Cloudflare API.\n* Understand [what limit apply](https://developers.cloudflare.com/queues/platform/limits/) when consuming and writing to a queue.\n\n</page>\n\n<page>\n---\ntitle: Events & schemas · Cloudflare Queues docs\ndescription: This page provides a comprehensive reference of available event\n  sources and their corresponding events with schemas for event subscriptions.\n  All events include common metadata fields and follow a consistent structure.\nlastUpdated: 2025-11-07T21:41:51.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/event-subscriptions/events-schemas/\n  md: https://developers.cloudflare.com/queues/event-subscriptions/events-schemas/index.md\n---\n\nThis page provides a comprehensive reference of available event sources and their corresponding events with schemas for [event subscriptions](https://developers.cloudflare.com/queues/event-subscriptions/). All events include common metadata fields and follow a consistent structure.\n\n## Sources\n\n### Access\n\n#### `application.created`\n\nTriggered when an application is created.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `application.deleted`\n\nTriggered when an application is deleted.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "### R2\n\n#### `bucket.created`\n\nTriggered when a bucket is created.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `bucket.deleted`\n\nTriggered when a bucket is deleted.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "### Super Slurper\n\n#### `job.started`\n\nTriggered when a migration job starts.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `job.paused`\n\nTriggered when a migration job pauses.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `job.resumed`\n\nTriggered when a migration job resumes.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `job.completed`\n\nTriggered when a migration job finishes.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `job.aborted`\n\nTriggered when a migration job is manually aborted.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `job.object.migrated`\n\nTriggered when an object is migrated.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "### Vectorize\n\n#### `index.created`\n\nTriggered when an index is created.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `index.deleted`\n\nTriggered when an index is deleted.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "### Workers AI\n\n#### `batch.queued`\n\nTriggered when a batch request is queued.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `batch.succeeded`\n\nTriggered when a batch request has completed.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `batch.failed`\n\nTriggered when a batch request has failed.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "### Workers Builds\n\n#### `build.started`\n\nTriggered when a build starts.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `build.failed`\n\nTriggered when a build fails.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `build.canceled`\n\nTriggered when a build is canceled.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `build.succeeded`\n\nTriggered when a build succeeds.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "### Workers KV\n\n#### `namespace.created`\n\nTriggered when a namespace is created.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `namespace.deleted`\n\nTriggered when a namespace is deleted.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "### Workflows\n\n#### `instance.queued`\n\nTriggered when an instance was created and is awaiting execution.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `instance.started`\n\nTriggered when an instance starts or resumes execution.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `instance.paused`\n\nTriggered when an instance pauses execution.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `instance.errored`\n\nTriggered when an instance step throws an error.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `instance.terminated`\n\nTriggered when an instance is manually terminated.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "#### `instance.completed`\n\nTriggered when an instance finishes execution successfully.\n\n**Example:**",
      "language": "unknown"
    },
    {
      "code": "## Common schema fields\n\nAll events include these common fields:\n\n| Field | Type | Description |\n| - | - | - |\n| `type` | string | The event type identifier |\n| `source` | object | Contains source-specific information like IDs and names |\n| `metadata.accountId` | string | Your Cloudflare account ID |\n| `metadata.eventSubscriptionId` | string | The subscription that triggered this event |\n| `metadata.eventSchemaVersion` | number | The version of the event schema |\n| `metadata.eventTimestamp` | string | The ISO 8601 timestamp when the event occurred |\n| `payload` | object | The event-specific data containing details about what happened |\n\n</page>\n\n<page>\n---\ntitle: Manage event subscriptions · Cloudflare Queues docs\ndescription: Learn how to create, view, and delete event subscriptions for your queues.\nlastUpdated: 2025-09-04T16:11:18.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/event-subscriptions/manage-event-subscriptions/\n  md: https://developers.cloudflare.com/queues/event-subscriptions/manage-event-subscriptions/index.md\n---\n\nLearn how to:\n\n* Create event subscriptions to receive messages from Cloudflare services.\n* View existing subscriptions on your queues.\n* Delete subscriptions you no longer need.\n\n## Create subscription\n\nCreating a subscription allows your queue to receive messages when events occur in Cloudflare services. You can specify which source and events you want to subscribe to.\n\n### Dashboard\n\n1. In the Cloudflare dashboard, go to the **Queues** page.\n\n   [Go to **Queues**](https://dash.cloudflare.com/?to=/:account/workers/queues)\n\n2. Select the queue you want to add a subscription to.\n\n3. Switch to the **Subscriptions** tab.\n\n4. Select **Subscribe to events**.\n\n5. Name your subscription, and select the desired source and events.\n\n6. Select **Subscribe**.\n\n### Wrangler CLI\n\nTo create a subscription using Wrangler, run the [`queues subscription create command`](https://developers.cloudflare.com/queues/reference/wrangler-commands/#queues-subscription-create):",
      "language": "unknown"
    },
    {
      "code": "To learn more about which sources and events you can subscribe to, refer to [Events & schemas](https://developers.cloudflare.com/queues/event-subscriptions/events-schemas/).\n\n## View existing subscriptions\n\nYou can view all subscriptions configured for a queue to see what events it is currently receiving.\n\n### Dashboard\n\n1. In the Cloudflare dashboard, go to the **Queues** page.\n\n   [Go to **Queues**](https://dash.cloudflare.com/?to=/:account/workers/queues)\n\n2. Select the queue you want to view subscriptions for.\n\n3. Switch to the **Subscriptions** tab.\n\n### Wrangler CLI\n\nTo list subscriptions for a queue, run the [`queues subscription list command`](https://developers.cloudflare.com/queues/reference/wrangler-commands/#queues-subscription-list):",
      "language": "unknown"
    },
    {
      "code": "## Delete subscription\n\nWhen you delete a subscription, your queue will stop receiving messages for those events immediately.\n\n### Dashboard\n\n1. In the Cloudflare dashboard, go to the **Queues** page.\n\n   [Go to **Queues**](https://dash.cloudflare.com/?to=/:account/workers/queues)\n\n2. Select the queue containing the subscription you want to delete.\n\n3. Switch to the **Subscriptions** tab.\n\n4. Select **...** for the subscription you want to delete.\n\n5. Select **Delete subscription**.\n\n### Wrangler CLI\n\nTo delete a subscription, run the [`queues subscription delete command`](https://developers.cloudflare.com/queues/reference/wrangler-commands/#queues-subscription-delete):",
      "language": "unknown"
    },
    {
      "code": "## Learn more\n\n[Events & schemas ](https://developers.cloudflare.com/queues/event-subscriptions/events-schemas/)Explore available event sources and types that you can subscribe to.\n\n</page>\n\n<page>\n---\ntitle: Cloudflare Queues - Listing and acknowledging messages from the dashboard\n  · Cloudflare Queues docs\ndescription: Use the dashboard to fetch and acknowledge the messages currently in a queue.\nlastUpdated: 2025-09-04T16:11:18.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/examples/list-messages-from-dash/\n  md: https://developers.cloudflare.com/queues/examples/list-messages-from-dash/index.md\n---\n\n## List messages from the dashboard\n\nListing messages from the dashboard allows you to debug Queues or queue producers without a consumer Worker. Fetching a batch of messages to preview will not acknowledge or retry the message or affect its position in the queue. The queue can still be consumed normally by a consumer Worker.\n\nTo list messages in the dashboard:\n\n1. In the Cloudflare dashboard, go to the **Queues** page.\n\n   [Go to **Queues**](https://dash.cloudflare.com/?to=/:account/workers/queues)\n\n2. Select the queue to preview messages from.\n\n3. Select the **Messages** tab.\n\n4. Select **List**.\n\n5. When the list of messages loads, select the blue arrow to the right of each row to expand the message preview.\n\nThis will preview a batch of messages currently in the Queue.\n\n## Acknowledge messages from the dashboard\n\nAcknowledging messages from the [Cloudflare dashboard](https://dash.cloudflare.com) will permanently remove them from the queue, with equivalent behavior as `ack()` in a Worker.\n\n1. Select the checkbox to the left of each row to select the message for acknowledgement, or select the checkbox in the table header to select all messages.\n2. Select **Acknowledge messages**.\n3. Confirm you want to acknowledge the messages, and select **Acknowledge messages**.\n\nThis will remove the selected messages from the queue and prevent consumers from processing them further.\n\nRefer to the [Get Started guide](https://developers.cloudflare.com/queues/get-started/) to learn how to process and acknowledge messages from a queue in a Worker.\n\n</page>\n\n<page>\n---\ntitle: Queues - Publish Directly via HTTP · Cloudflare Queues docs\ndescription: Publish to a Queue directly via HTTP and Workers.\nlastUpdated: 2025-07-24T21:01:05.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/examples/publish-to-a-queue-via-http/\n  md: https://developers.cloudflare.com/queues/examples/publish-to-a-queue-via-http/index.md\n---\n\nThe following example shows you how to publish messages to a Queue from any HTTP client, using a Cloudflare API token to authenticate.\n\nThis allows you to write to a Queue from any service or programming language that supports HTTP, including Go, Rust, Python or even a Bash script.\n\n## Prerequisites\n\n* A [queue created](https://developers.cloudflare.com/queues/get-started/#3-create-a-queue) via the [Cloudflare dashboard](https://dash.cloudflare.com) or the [wrangler CLI](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n* A Cloudflare API token with the `Queues Edit` permission.\n\n### 1. Send a test message\n\nTo make sure you successfully authenticate and write a message to your queue, use `curl` on the command line:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h3",
      "text": "Message delay precedence",
      "id": "message-delay-precedence"
    },
    {
      "level": "h3",
      "text": "Apply a backoff algorithm",
      "id": "apply-a-backoff-algorithm"
    },
    {
      "level": "h2",
      "text": "Related",
      "id": "related"
    },
    {
      "level": "h2",
      "text": "Queue configuration",
      "id": "queue-configuration"
    },
    {
      "level": "h2",
      "text": "Producer Worker configuration",
      "id": "producer-worker-configuration"
    },
    {
      "level": "h2",
      "text": "Consumer Worker Configuration",
      "id": "consumer-worker-configuration"
    },
    {
      "level": "h2",
      "text": "Pull-based",
      "id": "pull-based"
    },
    {
      "level": "h2",
      "text": "Enable concurrency",
      "id": "enable-concurrency"
    },
    {
      "level": "h2",
      "text": "How concurrency works",
      "id": "how-concurrency-works"
    },
    {
      "level": "h3",
      "text": "Example",
      "id": "example"
    },
    {
      "level": "h3",
      "text": "Why are my consumers not autoscaling?",
      "id": "why-are-my-consumers-not-autoscaling?"
    },
    {
      "level": "h2",
      "text": "Limit concurrency",
      "id": "limit-concurrency"
    },
    {
      "level": "h3",
      "text": "Set concurrency settings in the Cloudflare dashboard",
      "id": "set-concurrency-settings-in-the-cloudflare-dashboard"
    },
    {
      "level": "h3",
      "text": "Set concurrency settings in the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/)",
      "id": "set-concurrency-settings-in-the-[wrangler-configuration-file](https://developers.cloudflare.com/workers/wrangler/configuration/)"
    },
    {
      "level": "h2",
      "text": "Billing",
      "id": "billing"
    },
    {
      "level": "h3",
      "text": "Example",
      "id": "example"
    },
    {
      "level": "h2",
      "text": "Producer",
      "id": "producer"
    },
    {
      "level": "h3",
      "text": "`Queue`",
      "id": "`queue`"
    },
    {
      "level": "h3",
      "text": "`MessageSendRequest`",
      "id": "`messagesendrequest`"
    },
    {
      "level": "h3",
      "text": "`QueueSendOptions`",
      "id": "`queuesendoptions`"
    },
    {
      "level": "h3",
      "text": "`QueueSendBatchOptions`",
      "id": "`queuesendbatchoptions`"
    },
    {
      "level": "h3",
      "text": "`QueuesContentType`",
      "id": "`queuescontenttype`"
    },
    {
      "level": "h2",
      "text": "Consumer",
      "id": "consumer"
    },
    {
      "level": "h3",
      "text": "`MessageBatch`",
      "id": "`messagebatch`"
    },
    {
      "level": "h3",
      "text": "`Message`",
      "id": "`message`"
    },
    {
      "level": "h3",
      "text": "`QueueRetryOptions`",
      "id": "`queueretryoptions`"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "Start a local development session",
      "id": "start-a-local-development-session"
    },
    {
      "level": "h2",
      "text": "Separating producer & consumer Workers",
      "id": "separating-producer-&-consumer-workers"
    },
    {
      "level": "h2",
      "text": "Known Issues",
      "id": "known-issues"
    },
    {
      "level": "h2",
      "text": "Pause Delivery",
      "id": "pause-delivery"
    },
    {
      "level": "h3",
      "text": "Pause and resume delivery using Wrangler",
      "id": "pause-and-resume-delivery-using-wrangler"
    },
    {
      "level": "h3",
      "text": "What happens to HTTP Pull consumers with a paused queue?",
      "id": "what-happens-to-http-pull-consumers-with-a-paused-queue?"
    },
    {
      "level": "h2",
      "text": "Purge queue",
      "id": "purge-queue"
    },
    {
      "level": "h3",
      "text": "Purge queue using Wrangler",
      "id": "purge-queue-using-wrangler"
    },
    {
      "level": "h3",
      "text": "Does purging a Queue affect my bill?",
      "id": "does-purging-a-queue-affect-my-bill?"
    },
    {
      "level": "h2",
      "text": "How to choose between push or pull consumer",
      "id": "how-to-choose-between-push-or-pull-consumer"
    },
    {
      "level": "h2",
      "text": "1. Enable HTTP pull",
      "id": "1.-enable-http-pull"
    },
    {
      "level": "h3",
      "text": "Wrangler configuration file",
      "id": "wrangler-configuration-file"
    },
    {
      "level": "h3",
      "text": "wrangler CLI",
      "id": "wrangler-cli"
    },
    {
      "level": "h2",
      "text": "2. Consumer authentication",
      "id": "2.-consumer-authentication"
    },
    {
      "level": "h3",
      "text": "Create API tokens",
      "id": "create-api-tokens"
    },
    {
      "level": "h2",
      "text": "3. Pull messages",
      "id": "3.-pull-messages"
    },
    {
      "level": "h3",
      "text": "Concurrent consumers",
      "id": "concurrent-consumers"
    },
    {
      "level": "h2",
      "text": "4. Acknowledge messages",
      "id": "4.-acknowledge-messages"
    },
    {
      "level": "h2",
      "text": "Content types",
      "id": "content-types"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Sources",
      "id": "sources"
    },
    {
      "level": "h3",
      "text": "Access",
      "id": "access"
    },
    {
      "level": "h3",
      "text": "R2",
      "id": "r2"
    },
    {
      "level": "h3",
      "text": "Super Slurper",
      "id": "super-slurper"
    },
    {
      "level": "h3",
      "text": "Vectorize",
      "id": "vectorize"
    },
    {
      "level": "h3",
      "text": "Workers AI",
      "id": "workers-ai"
    },
    {
      "level": "h3",
      "text": "Workers Builds",
      "id": "workers-builds"
    },
    {
      "level": "h3",
      "text": "Workers KV",
      "id": "workers-kv"
    },
    {
      "level": "h3",
      "text": "Workflows",
      "id": "workflows"
    },
    {
      "level": "h2",
      "text": "Common schema fields",
      "id": "common-schema-fields"
    },
    {
      "level": "h2",
      "text": "Create subscription",
      "id": "create-subscription"
    },
    {
      "level": "h3",
      "text": "Dashboard",
      "id": "dashboard"
    },
    {
      "level": "h3",
      "text": "Wrangler CLI",
      "id": "wrangler-cli"
    },
    {
      "level": "h2",
      "text": "View existing subscriptions",
      "id": "view-existing-subscriptions"
    },
    {
      "level": "h3",
      "text": "Dashboard",
      "id": "dashboard"
    },
    {
      "level": "h3",
      "text": "Wrangler CLI",
      "id": "wrangler-cli"
    },
    {
      "level": "h2",
      "text": "Delete subscription",
      "id": "delete-subscription"
    },
    {
      "level": "h3",
      "text": "Dashboard",
      "id": "dashboard"
    },
    {
      "level": "h3",
      "text": "Wrangler CLI",
      "id": "wrangler-cli"
    },
    {
      "level": "h2",
      "text": "Learn more",
      "id": "learn-more"
    },
    {
      "level": "h2",
      "text": "List messages from the dashboard",
      "id": "list-messages-from-the-dashboard"
    },
    {
      "level": "h2",
      "text": "Acknowledge messages from the dashboard",
      "id": "acknowledge-messages-from-the-dashboard"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h3",
      "text": "1. Send a test message",
      "id": "1.-send-a-test-message"
    }
  ],
  "url": "llms-txt#delay-any-messages-that-are-retried-by-60-seconds-(1-minute)-by-default.",
  "links": []
}