{
  "title": "Test GET request",
  "content": "curl https://private-s3-gateway.workers.dev\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"services\": [\n      {\n        \"binding\": \"WORKFLOW_SERVICE\",\n        \"service\": \"workflows-starter\"\n      }\n    ]\n  }\n  toml\n  services = [\n  { binding = \"WORKFLOW_SERVICE\", service = \"workflows-starter\" }\n  ]\n  js\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\nexport default class WorkflowsService extends WorkerEntrypoint {\n    // Currently, entrypoints without a named handler are not supported\n    async fetch() {\n      return new Response(null, { status: 404 });\n    }\n\nasync createInstance(payload) {\n      let instance = await this.env.MY_WORKFLOW.create({\n        params: payload,\n      });\n\nreturn Response.json({\n        id: instance.id,\n        details: await instance.status(),\n      });\n    }\n  }\n  ts\n  import { WorkerEntrypoint } from \"cloudflare:workers\";\n\ninterface Env {\n    MY_WORKFLOW: Workflow;\n  }\n\ntype Payload = {\n    hello: string;\n  };\n\nexport default class WorkflowsService extends WorkerEntrypoint<Env> {\n    // Currently, entrypoints without a named handler are not supported\n    async fetch() {\n      return new Response(null, { status: 404 });\n    }\n\nasync createInstance(payload: Payload) {\n      let instance = await this.env.MY_WORKFLOW.create({\n        params: payload,\n      });\n\nreturn Response.json({\n        id: instance.id,\n        details: await instance.status(),\n      });\n    }\n  }\n  js\n  export const onRequest = async (context) => {\n    // This payload could be anything from within your app or from your frontend\n    let payload = { hello: \"world\" };\n    return context.env.WORKFLOWS_SERVICE.createInstance(payload);\n  };\n  ts\n  interface Env {\n    WORKFLOW_SERVICE: Service;\n  }\n\nexport const onRequest: PagesFunction<Env> = async (context) => {\n    // This payload could be anything from within your app or from your frontend\n    let payload = { hello: \"world\" };\n    return context.env.WORKFLOWS_SERVICE.createInstance(payload);\n  };\n  js\n  // This is in the same file as your Workflow definition\n  export default {\n    async fetch(req, env) {\n      let instance = await env.MY_WORKFLOW.create({\n        params: payload,\n      });\n      return Response.json({\n        id: instance.id,\n        details: await instance.status(),\n      });\n    },\n  };\n  ts\n  // This is in the same file as your Workflow definition\n  export default {\n    async fetch(req: Request, env: Env): Promise<Response> {\n      let instance = await env.MY_WORKFLOW.create({\n        params: payload,\n      });\n      return Response.json({\n        id: instance.id,\n        details: await instance.status(),\n      });\n    },\n  };\n  js\n  export const onRequest = async (context) => {\n    // Other code\n    let payload = { hello: \"world\" };\n    const instanceStatus = await fetch(\"https://YOUR_WORKER.workers.dev/\", {\n      method: \"POST\",\n      body: JSON.stringify(payload), // Send a payload for our Worker to pass to the Workflow\n    });\n\nreturn Response.json(instanceStatus);\n  };\n  ts\n  export const onRequest: PagesFunction<Env> = async (context) => {\n    // Other code\n    let payload = { hello: \"world\" };\n    const instanceStatus = await fetch(\"https://YOUR_WORKER.workers.dev/\", {\n      method: \"POST\",\n      body: JSON.stringify(payload), // Send a payload for our Worker to pass to the Workflow\n    });\n\nreturn Response.json(instanceStatus);\n  };\n  js\n  export default {\n    async fetch(req, env) {\n      let someEvent = { url: req.url, createdTimestamp: Date.now() };\n      // Trigger our Workflow\n      // Pass our event as the second parameter to the `create` method\n      // on our Workflow binding.\n      let instance = await env.MY_WORKFLOW.create({\n        id: crypto.randomUUID(),\n        params: someEvent,\n      });\n\nreturn Response.json({\n        id: instance.id,\n        details: await instance.status(),\n      });\n    },\n  };\n  ts\n  export default {\n    async fetch(req: Request, env: Env) {\n      let someEvent = { url: req.url, createdTimestamp: Date.now() };\n      // Trigger our Workflow\n      // Pass our event as the second parameter to the `create` method\n      // on our Workflow binding.\n      let instance = await env.MY_WORKFLOW.create({\n        id: crypto.randomUUID(),\n        params: someEvent,\n      });\n\nreturn Response.json({\n        id: instance.id,\n        details: await instance.status(),\n      });\n    },\n  };\n  sh\nnpx wrangler@latest workflows trigger workflows-starter '{\"some\":\"data\"}'\nsh\nðŸš€ Workflow instance \"57c7913b-8e1d-4a78-a0dd-dce5a0b7aa30\" has been queued successfully\njs\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // Other steps in your Workflow\n      let event = await step.waitForEvent(\n        \"receive invoice paid webhook from Stripe\",\n        { type: \"stripe-webhook\", timeout: \"1 hour\" },\n      );\n      // Rest of your Workflow\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // Other steps in your Workflow\n      let event = await step.waitForEvent<IncomingStripeWebhook>(\n        \"receive invoice paid webhook from Stripe\",\n        { type: \"stripe-webhook\", timeout: \"1 hour\" },\n      );\n      // Rest of your Workflow\n    }\n  }\n  js\n  let event = await step.waitForEvent(\"wait for human approval\", {\n    type: \"approval-flow\",\n    timeout: \"15 minutes\",\n  });\n  ts\n  let event = await step.waitForEvent(\n      \"wait for human approval\",\n      { type: \"approval-flow\", timeout: \"15 minutes\" },\n    );\n  js\n  try {\n    const event = await step.waitForEvent(\"wait for approval\", {\n      type: \"approval\",\n      timeout: \"1 hour\",\n    });\n    // Handle the received event\n  } catch (e) {\n    // Timeout occurred - handle the case where no event was received\n    console.log(\"No approval received, proceeding with default action\");\n  }\n  ts\n  try {\n    const event = await step.waitForEvent(\"wait for approval\", {\n      type: \"approval\",\n      timeout: \"1 hour\",\n    });\n    // Handle the received event\n  } catch (e) {\n    // Timeout occurred - handle the case where no event was received\n    console.log(\"No approval received, proceeding with default action\");\n  }\n  js\n  export default {\n    async fetch(req, env) {\n      const instanceId = new URL(req.url).searchParams.get(\"instanceId\");\n      const webhookPayload = await req.json();\n\nlet instance = await env.MY_WORKFLOW.get(instanceId);\n      // Send our event, with `type` matching the event type defined in\n      // our step.waitForEvent call\n      await instance.sendEvent({\n        type: \"stripe-webhook\",\n        payload: webhookPayload,\n      });\n\nreturn Response.json({\n        status: await instance.status(),\n      });\n    },\n  };\n  ts\n  export default {\n    async fetch(req: Request, env: Env) {\n      const instanceId = new URL(req.url).searchParams.get(\"instanceId\");\n      const webhookPayload = await req.json<Payload>();\n\nlet instance = await env.MY_WORKFLOW.get(instanceId);\n      // Send our event, with `type` matching the event type defined in\n      // our step.waitForEvent call\n      await instance.sendEvent({\n        type: \"stripe-webhook\",\n        payload: webhookPayload,\n      });\n\nreturn Response.json({\n        status: await instance.status(),\n      });\n    },\n  };\n  ts\nexport type WorkflowEvent<T> = {\n  // The data passed as the parameter when the Workflow instance was triggered\n  payload: T;\n  // The timestamp that the Workflow was triggered\n  timestamp: Date;\n  // ID of the current Workflow instance\n  instanceId: string;\n};\nts\n// Define a type that conforms to the events your Workflow instance is\n// instantiated with\ninterface YourEventType {\n  userEmail: string;\n  createdTimestamp: number;\n  metadata?: Record<string, string>;\n}\nts\n// Import the Workflow definition\nimport { WorkflowEntrypoint, WorkflowStep, WorkflowEvent} from 'cloudflare:workers';\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    // Pass your type as a type parameter to WorkflowEvent\n    // The 'payload' property will have the type of your parameter.\n    async run(event: WorkflowEvent<YourEventType>, step: WorkflowStep) {\n        let state = step.do(\"my first step\", async () => {\n          // Access your properties via event.payload\n          let userEmail = event.payload.userEmail\n          let createdTimestamp = event.payload.createdTimestamp\n        })\n\nstep.do(\"my second step\", async () => { /* your code here */ )\n    }\n}\njs\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      const customer_id = 123456;\n      // âœ… Good: Non-idempotent API/Binding calls are always done **after** checking if the operation is\n      // still needed.\n      await step.do(\n        `charge ${customer_id} for its monthly subscription`,\n        async () => {\n          // API call to check if customer was already charged\n          const subscription = await fetch(\n            `https://payment.processor/subscriptions/${customer_id}`,\n          ).then((res) => res.json());\n\n// return early if the customer was already charged, this can happen if the destination service dies\n          // in the middle of the request but still commits it, or if the Workflows Engine restarts.\n          if (subscription.charged) {\n            return;\n          }\n\n// non-idempotent call, this operation can fail and retry but still commit in the payment\n          // processor - which means that, on retry, it would mischarge the customer again if the above checks\n          // were not in place.\n          return await fetch(\n            `https://payment.processor/subscriptions/${customer_id}`,\n            {\n              method: \"POST\",\n              body: JSON.stringify({ amount: 10.0 }),\n            },\n          );\n        },\n      );\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      const customer_id = 123456;\n      // âœ… Good: Non-idempotent API/Binding calls are always done **after** checking if the operation is\n      // still needed.\n      await step.do(\n        `charge ${customer_id} for its monthly subscription`,\n        async () => {\n          // API call to check if customer was already charged\n          const subscription = await fetch(\n            `https://payment.processor/subscriptions/${customer_id}`,\n          ).then((res) => res.json());\n\n// return early if the customer was already charged, this can happen if the destination service dies\n          // in the middle of the request but still commits it, or if the Workflows Engine restarts.\n          if (subscription.charged) {\n            return;\n          }\n\n// non-idempotent call, this operation can fail and retry but still commit in the payment\n          // processor - which means that, on retry, it would mischarge the customer again if the above checks\n          // were not in place.\n          return await fetch(\n            `https://payment.processor/subscriptions/${customer_id}`,\n            {\n              method: \"POST\",\n              body: JSON.stringify({ amount: 10.0 }),\n            },\n          );\n        },\n      );\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // âœ… Good: Unrelated API/Binding calls are self-contained, so that in case one of them fails\n      // it can retry them individually. It also has an extra advantage: you can control retry or\n      // timeout policies for each granular step - you might not to want to overload http.cat in\n      // case of it being down.\n      const httpCat = await step.do(\"get cutest cat from KV\", async () => {\n        return await env.KV.get(\"cutest-http-cat\");\n      });\n\nconst image = await step.do(\"fetch cat image from http.cat\", async () => {\n        return await fetch(`https://http.cat/${httpCat}`);\n      });\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // âœ… Good: Unrelated API/Binding calls are self-contained, so that in case one of them fails\n      // it can retry them individually. It also has an extra advantage: you can control retry or\n      // timeout policies for each granular step - you might not to want to overload http.cat in\n      // case of it being down.\n      const httpCat = await step.do(\"get cutest cat from KV\", async () => {\n        return await env.KV.get(\"cutest-http-cat\");\n      });\n\nconst image = await step.do(\"fetch cat image from http.cat\", async () => {\n        return await fetch(`https://http.cat/${httpCat}`);\n      });\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: you are calling two separate services from within the same step. This might cause\n      // some extra calls to the first service in case the second one fails, and in some cases, makes\n      // the step non-idempotent altogether\n      const image = await step.do(\"get cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat\");\n        return fetch(`https://http.cat/${httpCat}`);\n      });\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: you are calling two separate services from within the same step. This might cause\n      // some extra calls to the first service in case the second one fails, and in some cases, makes\n      // the step non-idempotent altogether\n      const image = await step.do(\"get cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat\");\n        return fetch(`https://http.cat/${httpCat}`);\n      });\n    }\n  }\n  js\n  function getRandomInt(min, max) {\n    const minCeiled = Math.ceil(min);\n    const maxFloored = Math.floor(max);\n    return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive\n  }\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: `imageList` will be not persisted across engine's lifetimes. Which means that after hibernation,\n      // `imageList` will be empty again, even though the following two steps have already ran.\n      const imageList = [];\n\nawait step.do(\"get first cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat-1\");\n\nimageList.append(httpCat);\n      });\n\nawait step.do(\"get second cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat-2\");\n\nimageList.append(httpCat);\n      });\n\n// A long sleep can (and probably will) hibernate the engine which means that the first engine lifetime ends here\n      await step.sleep(\"ðŸ’¤ðŸ’¤ðŸ’¤ðŸ’¤\", \"3 hours\");\n\n// When this runs, it will be on the second engine lifetime - which means `imageList` will be empty.\n      await step.do(\n        \"choose a random cat from the list and download it\",\n        async () => {\n          const randomCat = imageList.at(getRandomInt(0, imageList.length));\n          // this will fail since `randomCat` is undefined because `imageList` is empty\n          return await fetch(`https://http.cat/${randomCat}`);\n        },\n      );\n    }\n  }\n  ts\n  function getRandomInt(min, max) {\n    const minCeiled = Math.ceil(min);\n    const maxFloored = Math.floor(max);\n    return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive\n  }\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: `imageList` will be not persisted across engine's lifetimes. Which means that after hibernation,\n      // `imageList` will be empty again, even though the following two steps have already ran.\n      const imageList: string[] = [];\n\nawait step.do(\"get first cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat-1\");\n\nimageList.append(httpCat);\n      });\n\nawait step.do(\"get second cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat-2\");\n\nimageList.append(httpCat);\n      });\n\n// A long sleep can (and probably will) hibernate the engine which means that the first engine lifetime ends here\n      await step.sleep(\"ðŸ’¤ðŸ’¤ðŸ’¤ðŸ’¤\", \"3 hours\");\n\n// When this runs, it will be on the second engine lifetime - which means `imageList` will be empty.\n      await step.do(\n        \"choose a random cat from the list and download it\",\n        async () => {\n          const randomCat = imageList.at(getRandomInt(0, imageList.length));\n          // this will fail since `randomCat` is undefined because `imageList` is empty\n          return await fetch(`https://http.cat/${randomCat}`);\n        },\n      );\n    }\n  }\n  js\n  function getRandomInt(min, max) {\n    const minCeiled = Math.ceil(min);\n    const maxFloored = Math.floor(max);\n    return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive\n  }\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // âœ… Good: imageList state is exclusively comprised of step returns - this means that in the event of\n      // multiple engine lifetimes, imageList will be built accordingly\n      const imageList = await Promise.all([\n        step.do(\"get first cutest cat from KV\", async () => {\n          return await env.KV.get(\"cutest-http-cat-1\");\n        }),\n\nstep.do(\"get second cutest cat from KV\", async () => {\n          return await env.KV.get(\"cutest-http-cat-2\");\n        }),\n      ]);\n\n// A long sleep can (and probably will) hibernate the engine which means that the first engine lifetime ends here\n      await step.sleep(\"ðŸ’¤ðŸ’¤ðŸ’¤ðŸ’¤\", \"3 hours\");\n\n// When this runs, it will be on the second engine lifetime - but this time, imageList will contain\n      // the two most cutest cats\n      await step.do(\n        \"choose a random cat from the list and download it\",\n        async () => {\n          const randomCat = imageList.at(getRandomInt(0, imageList.length));\n          // this will eventually succeed since `randomCat` is defined\n          return await fetch(`https://http.cat/${randomCat}`);\n        },\n      );\n    }\n  }\n  ts\n  function getRandomInt(min, max) {\n    const minCeiled = Math.ceil(min);\n    const maxFloored = Math.floor(max);\n    return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive\n  }\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // âœ… Good: imageList state is exclusively comprised of step returns - this means that in the event of\n      // multiple engine lifetimes, imageList will be built accordingly\n      const imageList: string[] = await Promise.all([\n        step.do(\"get first cutest cat from KV\", async () => {\n          return await env.KV.get(\"cutest-http-cat-1\");\n        }),\n\nstep.do(\"get second cutest cat from KV\", async () => {\n          return await env.KV.get(\"cutest-http-cat-2\");\n        }),\n      ]);\n\n// A long sleep can (and probably will) hibernate the engine which means that the first engine lifetime ends here\n      await step.sleep(\"ðŸ’¤ðŸ’¤ðŸ’¤ðŸ’¤\", \"3 hours\");\n\n// When this runs, it will be on the second engine lifetime - but this time, imageList will contain\n      // the two most cutest cats\n      await step.do(\n        \"choose a random cat from the list and download it\",\n        async () => {\n          const randomCat = imageList.at(getRandomInt(0, imageList.length));\n          // this will eventually succeed since `randomCat` is defined\n          return await fetch(`https://http.cat/${randomCat}`);\n        },\n      );\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: creating instances outside of steps\n      // This might get called more than once creating more instances than expected\n      const myNewInstance = await this.env.ANOTHER_WORKFLOW.create();\n\n// ðŸ”´ Bad: using non-deterministic functions outside of steps\n      // this will produce different results if the instance has to restart, different runs of the same instance\n      // might go through different paths\n      const myRandom = Math.random();\n\nif (myRandom > 0) {\n        // do some stuff\n      }\n\n// âš ï¸ Warning: This log may happen many times\n      console.log(\"This might be logged more than once\");\n\nawait step.do(\"do some stuff and have a log for when it runs\", async () => {\n        // do some stuff\n\n// this log will only appear once\n        console.log(\"successfully did stuff\");\n      });\n\n// âœ… Good: wrap non-deterministic function in a step\n      // after running successfully will not run again\n      const myRandom = await step.do(\"create a random number\", async () => {\n        return Math.random();\n      });\n\n// âœ… Good: calls that have no side effects can be done outside of steps\n      const db = createDBConnection(this.env.DB_URL, this.env.DB_TOKEN);\n\n// âœ… Good: run funtions with side effects inside of a step\n      // after running successfully will not run again\n      const myNewInstance = await step.do(\n        \"good step that returns state\",\n        async () => {\n          const myNewInstance = await this.env.ANOTHER_WORKFLOW.create();\n\nreturn myNewInstance;\n        },\n      );\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: creating instances outside of steps\n      // This might get called more than once creating more instances than expected\n      const myNewInstance = await this.env.ANOTHER_WORKFLOW.create();\n\n// ðŸ”´ Bad: using non-deterministic functions outside of steps\n      // this will produce different results if the instance has to restart, different runs of the same instance\n      // might go through different paths\n      const myRandom = Math.random();\n\nif (myRandom > 0) {\n        // do some stuff\n      }\n\n// âš ï¸ Warning: This log may happen many times\n      console.log(\"This might be logged more than once\");\n\nawait step.do(\"do some stuff and have a log for when it runs\", async () => {\n        // do some stuff\n\n// this log will only appear once\n        console.log(\"successfully did stuff\");\n      });\n\n// âœ… Good: wrap non-deterministic function in a step\n      // after running successfully will not run again\n      const myRandom = await step.do(\"create a random number\", async () => {\n        return Math.random();\n      });\n\n// âœ… Good: calls that have no side effects can be done outside of steps\n      const db = createDBConnection(this.env.DB_URL, this.env.DB_TOKEN);\n\n// âœ… Good: run funtions with side effects inside of a step\n      // after running successfully will not run again\n      const myNewInstance = await step.do(\n        \"good step that returns state\",\n        async () => {\n          const myNewInstance = await this.env.ANOTHER_WORKFLOW.create();\n\nreturn myNewInstance;\n        },\n      );\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: Mutating the event\n      // This will not be persisted across steps and `event.payload` will\n      // take on its original value.\n      await step.do(\"bad step that mutates the incoming event\", async () => {\n        let userData = await env.KV.get(event.payload.user);\n        event.payload = userData;\n      });\n\n// âœ… Good: persist data by returning it as state from your step\n      // Use that state in subsequent steps\n      let userData = await step.do(\"good step that returns state\", async () => {\n        return await env.KV.get(event.payload.user);\n      });\n\nlet someOtherData = await step.do(\n        \"following step that uses that state\",\n        async () => {\n          // Access to userData here\n          // Will always be the same if this step is retried\n        },\n      );\n    }\n  }\n  ts\n  interface MyEvent {\n    user: string;\n    data: string;\n  }\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<MyEvent>, step: WorkflowStep) {\n      // ðŸ”´ Bad: Mutating the event\n      // This will not be persisted across steps and `event.payload` will\n      // take on its original value.\n      await step.do(\"bad step that mutates the incoming event\", async () => {\n        let userData = await env.KV.get(event.payload.user);\n        event.payload = userData;\n      });\n\n// âœ… Good: persist data by returning it as state from your step\n      // Use that state in subsequent steps\n      let userData = await step.do(\"good step that returns state\", async () => {\n        return await env.KV.get(event.payload.user);\n      });\n\nlet someOtherData = await step.do(\n        \"following step that uses that state\",\n        async () => {\n          // Access to userData here\n          // Will always be the same if this step is retried\n        },\n      );\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: Naming the step non-deterministically prevents it from being cached\n      // This will cause the step to be re-run if subsequent steps fail.\n      await step.do(`step #1 running at: ${Date.now()}`, async () => {\n        let userData = await env.KV.get(event.payload.user);\n        // Do not mutate event.payload\n        event.payload = userData;\n      });\n\n// âœ… Good: give steps a deterministic name.\n      // Return dynamic values in your state, or log them instead.\n      let state = await step.do(\"fetch user data from KV\", async () => {\n        let userData = await env.KV.get(event.payload.user);\n        console.log(`fetched at ${Date.now}`);\n        return userData;\n      });\n\n// âœ… Good: steps that are dynamically named are constructed in a deterministic way.\n      // In this case, `catList` is a step output, which is stable, and `catList` is\n      // traversed in a deterministic fashion (no shuffles or random accesses) so,\n      // it's fine to dynamically name steps (e.g: create a step per list entry).\n      let catList = await step.do(\"get cat list from KV\", async () => {\n        return await env.KV.get(\"cat-list\");\n      });\n\nfor (const cat of catList) {\n        await step.do(`get cat: ${cat}`, async () => {\n          return await env.KV.get(cat);\n        });\n      }\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: Naming the step non-deterministically prevents it from being cached\n      // This will cause the step to be re-run if subsequent steps fail.\n      await step.do(`step #1 running at: ${Date.now()}`, async () => {\n        let userData = await env.KV.get(event.payload.user);\n        // Do not mutate event.payload\n        event.payload = userData;\n      });\n\n// âœ… Good: give steps a deterministic name.\n      // Return dynamic values in your state, or log them instead.\n      let state = await step.do(\"fetch user data from KV\", async () => {\n        let userData = await env.KV.get(event.payload.user);\n        console.log(`fetched at ${Date.now}`);\n        return userData;\n      });\n\n// âœ… Good: steps that are dynamically named are constructed in a deterministic way.\n      // In this case, `catList` is a step output, which is stable, and `catList` is\n      // traversed in a deterministic fashion (no shuffles or random accesses) so,\n      // it's fine to dynamically name steps (e.g: create a step per list entry).\n      let catList = await step.do(\"get cat list from KV\", async () => {\n        return await env.KV.get(\"cat-list\");\n      });\n\nfor (const cat of catList) {\n        await step.do(`get cat: ${cat}`, async () => {\n          return await env.KV.get(cat);\n        });\n      }\n    }\n  }\n  js\n  // helper sleep method\n  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: The `Promise.race` is not surrounded by a `step.do`, which may cause undeterministic caching behavior.\n      const race_return = await Promise.race([\n        step.do(\"Promise first race\", async () => {\n          await sleep(1000);\n          return \"first\";\n        }),\n        step.do(\"Promise second race\", async () => {\n          return \"second\";\n        }),\n      ]);\n\nawait step.sleep(\"Sleep step\", \"2 hours\");\n\nreturn await step.do(\"Another step\", async () => {\n        // This step will return `first`, even though the `Promise.race` first returned `second`.\n        return race_return;\n      });\n    }\n  }\n  ts\n  // helper sleep method\n  const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: The `Promise.race` is not surrounded by a `step.do`, which may cause undeterministic caching behavior.\n      const race_return = await Promise.race([\n        step.do(\"Promise first race\", async () => {\n          await sleep(1000);\n          return \"first\";\n        }),\n        step.do(\"Promise second race\", async () => {\n          return \"second\";\n        }),\n      ]);\n\nawait step.sleep(\"Sleep step\", \"2 hours\");\n\nreturn await step.do(\"Another step\", async () => {\n        // This step will return `first`, even though the `Promise.race` first returned `second`.\n        return race_return;\n      });\n    }\n  }\n  js\n  // helper sleep method\n  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // âœ… Good: The `Promise.race` is surrounded by a `step.do`, ensuring deterministic caching behavior.\n      const race_return = await step.do(\"Promise step\", async () => {\n        return await Promise.race([\n          step.do(\"Promise first race\", async () => {\n            await sleep(1000);\n            return \"first\";\n          }),\n          step.do(\"Promise second race\", async () => {\n            return \"second\";\n          }),\n        ]);\n      });\n\nawait step.sleep(\"Sleep step\", \"2 hours\");\n\nreturn await step.do(\"Another step\", async () => {\n        // This step will return `second` because the `Promise.race` was surround by the `step.do` method.\n        return race_return;\n      });\n    }\n  }\n  ts\n  // helper sleep method\n  const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // âœ… Good: The `Promise.race` is surrounded by a `step.do`, ensuring deterministic caching behavior.\n      const race_return = await step.do(\"Promise step\", async () => {\n        return await Promise.race([\n          step.do(\"Promise first race\", async () => {\n            await sleep(1000);\n            return \"first\";\n          }),\n          step.do(\"Promise second race\", async () => {\n            return \"second\";\n          }),\n        ]);\n      });\n\nawait step.sleep(\"Sleep step\", \"2 hours\");\n\nreturn await step.do(\"Another step\", async () => {\n        // This step will return `second` because the `Promise.race` was surround by the `step.do` method.\n        return race_return;\n      });\n    }\n  }\n  js\n  // This is in the same file as your Workflow definition\n  export default {\n    async fetch(req, env) {\n      // ðŸ”´ Bad: Use an ID that isn't unique across future Workflow invocations\n      let userId = getUserId(req); // Returns the userId\n      let badInstance = await env.MY_WORKFLOW.create({\n        id: userId,\n        params: payload,\n      });\n\n// âœ… Good: use an ID that is unique\n      // e.g. a transaction ID, order ID, or task ID are good options\n      let instanceId = getTransactionId(); // e.g. assuming transaction IDs are unique\n      // or: compose a composite ID and store it in your database\n      // so that you can track all instances associated with a specific user or merchant.\n      instanceId = `${getUserId(req)}-${crypto.randomUUID().slice(0, 6)}`;\n      let { result } = await addNewInstanceToDB(userId, instanceId);\n      let goodInstance = await env.MY_WORKFLOW.create({\n        id: instanceId,\n        params: payload,\n      });\n\nreturn Response.json({\n        id: goodInstance.id,\n        details: await goodInstance.status(),\n      });\n    },\n  };\n  ts\n  // This is in the same file as your Workflow definition\n  export default {\n    async fetch(req: Request, env: Env): Promise<Response> {\n      // ðŸ”´ Bad: Use an ID that isn't unique across future Workflow invocations\n      let userId = getUserId(req); // Returns the userId\n      let badInstance = await env.MY_WORKFLOW.create({\n        id: userId,\n        params: payload,\n      });\n\n// âœ… Good: use an ID that is unique\n      // e.g. a transaction ID, order ID, or task ID are good options\n      let instanceId = getTransactionId(); // e.g. assuming transaction IDs are unique\n      // or: compose a composite ID and store it in your database\n      // so that you can track all instances associated with a specific user or merchant.\n      instanceId = `${getUserId(req)}-${crypto.randomUUID().slice(0, 6)}`;\n      let { result } = await addNewInstanceToDB(userId, instanceId);\n      let goodInstance = await env.MY_WORKFLOW.create({\n        id: instanceId,\n        params: payload,\n      });\n\nreturn Response.json({\n        id: goodInstance.id,\n        details: await goodInstance.status(),\n      });\n    },\n  };\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: The step isn't await'ed, and any state or errors is swallowed before it returns.\n      const issues = step.do(`fetch issues from GitHub`, async () => {\n        // The step will return before this call is done\n        let issues = await getIssues(event.payload.repoName);\n        return issues;\n      });\n\n// âœ… Good: The step is correctly await'ed.\n      const issues = await step.do(`fetch issues from GitHub`, async () => {\n        let issues = await getIssues(event.payload.repoName);\n        return issues;\n      });\n\n// Rest of your Workflow goes here!\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: The step isn't await'ed, and any state or errors is swallowed before it returns.\n      const issues = step.do(`fetch issues from GitHub`, async () => {\n        // The step will return before this call is done\n        let issues = await getIssues(event.payload.repoName);\n        return issues;\n      });\n\n// âœ… Good: The step is correctly await'ed.\n      const issues = await step.do(`fetch issues from GitHub`, async () => {\n        let issues = await getIssues(event.payload.repoName);\n        return issues;\n      });\n\n// Rest of your Workflow goes here!\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      const config = await step.do(\"fetch config\", async () => {\n        return await this.env.KV.get(\"feature-flags\", { type: \"json\" });\n      });\n\n// âœ… Good: Condition based on step output (deterministic)\n      if (config.enableEmailNotifications) {\n        await step.do(\"send email\", async () => {\n          // Send email logic\n        });\n      }\n\n// âœ… Good: Condition based on event payload (deterministic)\n      if (event.payload.userType === \"premium\") {\n        await step.do(\"premium processing\", async () => {\n          // Premium-only logic\n        });\n      }\n\n// ðŸ”´ Bad: Condition based on non-deterministic value outside a step\n      // This could behave differently if the Workflow restarts\n      if (Math.random() > 0.5) {\n        await step.do(\"maybe do something\", async () => {});\n      }\n\n// âœ… Good: Wrap non-deterministic values in a step\n      const shouldProcess = await step.do(\"decide randomly\", async () => {\n        return Math.random() > 0.5;\n      });\n      if (shouldProcess) {\n        await step.do(\"conditionally do something\", async () => {});\n      }\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      const config = await step.do(\"fetch config\", async () => {\n        return await this.env.KV.get(\"feature-flags\", { type: \"json\" });\n      });\n\n// âœ… Good: Condition based on step output (deterministic)\n      if (config.enableEmailNotifications) {\n        await step.do(\"send email\", async () => {\n          // Send email logic\n        });\n      }\n\n// âœ… Good: Condition based on event payload (deterministic)\n      if (event.payload.userType === \"premium\") {\n        await step.do(\"premium processing\", async () => {\n          // Premium-only logic\n        });\n      }\n\n// ðŸ”´ Bad: Condition based on non-deterministic value outside a step\n      // This could behave differently if the Workflow restarts\n      if (Math.random() > 0.5) {\n        await step.do(\"maybe do something\", async () => {});\n      }\n\n// âœ… Good: Wrap non-deterministic values in a step\n      const shouldProcess = await step.do(\"decide randomly\", async () => {\n        return Math.random() > 0.5;\n      });\n      if (shouldProcess) {\n        await step.do(\"conditionally do something\", async () => {});\n      }\n    }\n  }\n  js\n  export default {\n    async fetch(req, env) {\n      let instances = [\n        { id: \"user1\", params: { name: \"John\" } },\n        { id: \"user2\", params: { name: \"Jane\" } },\n        { id: \"user3\", params: { name: \"Alice\" } },\n        { id: \"user4\", params: { name: \"Bob\" } },\n      ];\n\n// ðŸ”´ Bad: Create them one by one, which is more likely to hit creation rate limits.\n      for (let instance of instances) {\n        await env.MY_WORKFLOW.create({\n          id: instance.id,\n          params: instance.params,\n        });\n      }\n\n// âœ… Good: Batch calls together\n      // This improves throughput.\n      let instances = await env.MY_WORKFLOW.createBatch(instances);\n      return Response.json({ instances });\n    },\n  };\n  ts\n  export default {\n    async fetch(req: Request, env: Env): Promise<Response> {\n      let instances = [\n        { id: \"user1\", params: { name: \"John\" } },\n        { id: \"user2\", params: { name: \"Jane\" } },\n        { id: \"user3\", params: { name: \"Alice\" } },\n        { id: \"user4\", params: { name: \"Bob\" } },\n      ];\n\n// ðŸ”´ Bad: Create them one by one, which is more likely to hit creation rate limits.\n      for (let instance of instances) {\n        await env.MY_WORKFLOW.create({\n          id: instance.id,\n          params: instance.params,\n        });\n      }\n\n// âœ… Good: Batch calls together\n      // This improves throughput.\n      let instances = await env.MY_WORKFLOW.createBatch(instances);\n      return Response.json({ instances });\n    },\n  };\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: Returning a large response that may exceed 1 MiB\n      const largeData = await step.do(\"fetch large dataset\", async () => {\n        const response = await fetch(\"https://api.example.com/large-dataset\");\n        return await response.json(); // Could exceed 1 MiB\n      });\n\n// âœ… Good: Store large data externally and return a reference\n      const dataRef = await step.do(\"fetch and store large dataset\", async () => {\n        const response = await fetch(\"https://api.example.com/large-dataset\");\n        const data = await response.json();\n        // Store in R2 and return a reference\n        await this.env.MY_BUCKET.put(\"dataset-123\", JSON.stringify(data));\n        return { key: \"dataset-123\" };\n      });\n\n// Retrieve the data in a later step when needed\n      const data = await step.do(\"process dataset\", async () => {\n        const stored = await this.env.MY_BUCKET.get(dataRef.key);\n        return processData(await stored.json());\n      });\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: Returning a large response that may exceed 1 MiB\n      const largeData = await step.do(\"fetch large dataset\", async () => {\n        const response = await fetch(\"https://api.example.com/large-dataset\");\n        return await response.json(); // Could exceed 1 MiB\n      });\n\n// âœ… Good: Store large data externally and return a reference\n      const dataRef = await step.do(\"fetch and store large dataset\", async () => {\n        const response = await fetch(\"https://api.example.com/large-dataset\");\n        const data = await response.json();\n        // Store in R2 and return a reference\n        await this.env.MY_BUCKET.put(\"dataset-123\", JSON.stringify(data));\n        return { key: \"dataset-123\" };\n      });\n\n// Retrieve the data in a later step when needed\n      const data = await step.do(\"process dataset\", async () => {\n        const stored = await this.env.MY_BUCKET.get(dataRef.key);\n        return processData(await stored.json());\n      });\n    }\n  }\n  sh",
  "code_samples": [
    {
      "code": "## Next steps\n\n* Add [authentication and authorization](https://developers.cloudflare.com/workers/examples/auth-with-headers/)\n* Implement [rate limiting](https://developers.cloudflare.com/durable-objects/api/)\n* Set up [monitoring and alerting](https://developers.cloudflare.com/analytics/analytics-engine/)\n* Explore [other examples](https://developers.cloudflare.com/workers-vpc/examples/)\n\n</page>\n\n<page>\n---\ntitle: Limits Â· Cloudflare Workers VPC\ndescription: Standard Workers limits apply for request size, timeout, and subrequests.\nlastUpdated: 2025-11-04T21:03:20.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers-vpc/reference/limits/\n  md: https://developers.cloudflare.com/workers-vpc/reference/limits/index.md\n---\n\n## Service limits\n\n| Resource | Limit |\n| - | - |\n| VPC Services per account | 1000 |\n\nStandard Workers limits apply for request size, timeout, and subrequests.\n\nNote\n\nWorkers VPC is currently in beta. Features and APIs may change before general availability. While in beta, Workers VPC is available for free to all Workers plans.\n\n</page>\n\n<page>\n---\ntitle: Pricing Â· Cloudflare Workers VPC\ndescription: Workers VPC requires a Workers plan. See Workers pricing for current rates.\nlastUpdated: 2025-11-04T21:03:20.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers-vpc/reference/pricing/\n  md: https://developers.cloudflare.com/workers-vpc/reference/pricing/index.md\n---\n\nWorkers VPC requires a Workers plan. See [Workers pricing](https://developers.cloudflare.com/workers/platform/pricing/) for current rates.\n\nFree during Open Beta\n\nWorkers VPC is free during the open beta period. Standard Workers pricing applies for compute time and requests.\n\n</page>\n\n<page>\n---\ntitle: Troubleshoot and debug Â· Cloudflare Workers VPC\ndescription: Troubleshoot and debug errors commonly associated with Workers VPC.\nlastUpdated: 2025-11-14T21:25:44.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers-vpc/reference/troubleshooting/\n  md: https://developers.cloudflare.com/workers-vpc/reference/troubleshooting/index.md\n---\n\nTroubleshoot and debug errors commonly associated with Workers VPC.\n\n## Connection errors\n\nWorkers VPC may return errors at runtime when connecting to private services through Cloudflare Tunnel.\n\n### Tunnel errors\n\n| Error Message | Details | Recommended fixes |\n| - | - | - |\n| `Error: ProxyError: dns_error` | DNS resolution failed when attempting to connect to your private service through the tunnel. | This error may occur if your `cloudflared` version is outdated. Ensure you are running `cloudflared` version 2025.7.0 or later (latest version recommended). See [Cloudflare Tunnel update instructions](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/downloads/update-cloudflared/). |\n| `Error: ProxyError: dns_error` | Cloudflare Tunnel may be configured with `http2` protocol (`TUNNEL_TRANSPORT_PROTOCOL:http2`), which works for Cloudflare Zero Trust [(see note)](https://developers.cloudflare.com/workers-vpc/configuration/tunnel/#create-and-run-tunnel-cloudflared) traffic but prevents DNS resolution from Workers VPC. | Workers VPC requires Cloudflare Tunnel to connect using the [QUIC transport protocol](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/configure-tunnels/cloudflared-parameters/run-parameters/#protocol). Ensure outbound UDP traffic on port 7844 is allowed through your firewall. |\n| Requests not staying within VPC | Worker requests using `.fetch()` with a public hostname are routing out of the VPC to the hostname configured for the VPC Service. | Ensure your Worker code and the VPC Service use the internal VPC hostname for backend services, not a public hostname. |\n\n</page>\n\n<page>\n---\ntitle: Call Workflows from Pages Â· Cloudflare Workflows docs\ndescription: You can bind and trigger Workflows from Pages Functions by\n  deploying a Workers project with your Workflow definition and then invoking\n  that Worker using service bindings or a standard fetch() call.\nlastUpdated: 2025-12-03T14:33:51.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/build/call-workflows-from-pages/\n  md: https://developers.cloudflare.com/workflows/build/call-workflows-from-pages/index.md\n---\n\nUse Static Assets\n\nTo call Workflows from Pages, you are required to deploy a separate Worker containing your Workflows. We recommend using [**Static Assets**](https://developers.cloudflare.com/workers/static-assets/) instead, as this allows you to add your Workflows directly to your Static Assets Worker.\n\nIf you wish to migrate your Pages project to Static Assets, follow this [guide](https://developers.cloudflare.com/workers/static-assets/migration-guides/migrate-from-pages/).\n\n***\n\nYou can bind and trigger Workflows from [Pages Functions](https://developers.cloudflare.com/pages/functions/) by deploying a Workers project with your Workflow definition and then invoking that Worker using [service bindings](https://developers.cloudflare.com/pages/functions/bindings/#service-bindings) or a standard `fetch()` call.\n\nNote\n\nYou will need to deploy your Workflow as a standalone Workers project first before your Pages Function can call it. If you have not yet deployed a Workflow, refer to the Workflows [get started guide](https://developers.cloudflare.com/workflows/get-started/guide/).\n\n### Use Service Bindings\n\n[Service Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/) allow you to call a Worker from another Worker or a Pages Function without needing to expose it directly.\n\nTo do this, you will need to:\n\n1. Deploy your Workflow in a Worker\n2. Create a Service Binding to that Worker in your Pages project\n3. Call the Worker remotely using the binding\n\nFor example, if you have a Worker called `workflows-starter`, you would create a new Service Binding in your Pages project as follows, ensuring that the `service` name matches the name of the Worker your Workflow is defined in:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Your Worker can expose a specific method (or methods) that only other Workers or Pages Functions can call over the Service Binding.\n\nIn the following example, we expose a specific `createInstance` method that accepts our `Payload` and returns the [`InstanceStatus`](https://developers.cloudflare.com/workflows/build/workers-api/#instancestatus) from the Workflows API:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Your Pages Function would resemble the following:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "To learn more about binding to resources from Pages Functions, including how to bind via the Cloudflare dashboard, refer to the [bindings documentation for Pages Functions](https://developers.cloudflare.com/pages/functions/bindings/#service-bindings).\n\n### Using fetch\n\nService Bindings vs. fetch\n\nWe recommend using [Service Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/) when calling a Worker in your own account.\n\nService Bindings don't require you to expose a public endpoint from your Worker, don't require you to configure authentication, and allow you to call methods on your Worker directly, avoiding the overhead of managing HTTP requests and responses.\n\nAn alternative to setting up a Service Binding is to call the Worker over HTTP by using the Workflows [Workers API](https://developers.cloudflare.com/workflows/build/workers-api/#workflow) to `create` a new Workflow instance for each incoming HTTP call to the Worker:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Your [Pages Function](https://developers.cloudflare.com/pages/functions/get-started/) can then make a regular `fetch` call to the Worker:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "You can also choose to authenticate these requests by passing a shared secret in a header and validating that in your Worker.\n\n### Next steps\n\n* Learn more about how to programatically call and trigger Workflows from the [Workers API](https://developers.cloudflare.com/workflows/build/workers-api/)\n* Understand how to send [events and parameters](https://developers.cloudflare.com/workflows/build/events-and-parameters/) when triggering a Workflow\n* Review the [Rules of Workflows](https://developers.cloudflare.com/workflows/build/rules-of-workflows/) and best practices for writing Workflows\n\n</page>\n\n<page>\n---\ntitle: Events and parameters Â· Cloudflare Workflows docs\ndescription: When a Workflow is triggered, it can receive an optional event.\n  This event can include data that your Workflow can act on, including request\n  details, user data fetched from your database (such as D1 or KV) or from a\n  webhook, or messages from a Queue consumer.\nlastUpdated: 2025-12-12T19:04:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/build/events-and-parameters/\n  md: https://developers.cloudflare.com/workflows/build/events-and-parameters/index.md\n---\n\nWhen a Workflow is triggered, it can receive an optional event. This event can include data that your Workflow can act on, including request details, user data fetched from your database (such as D1 or KV) or from a webhook, or messages from a Queue consumer.\n\nEvents are a powerful part of a Workflow, as you often want a Workflow to act on data. Because a given Workflow instance executes durably, events are a useful way to provide a Workflow with data that should be immutable (not changing) and/or represents data the Workflow needs to operate on at that point in time.\n\n## Pass data to a Workflow\n\nYou can pass parameters to a Workflow in three ways:\n\n* As an optional argument to the `create` method on a [Workflow binding](https://developers.cloudflare.com/workers/wrangler/commands/#trigger) when triggering a Workflow from a Worker.\n* Via the `--params` flag when using the `wrangler` CLI to trigger a Workflow.\n* Via the `step.waitForEvent` API, which allows a Workflow instance to wait for an event (and optional data) to be received *while it is running*. Workflow instances can be sent events from external services over HTTP or via the Workers API for Workflows.\n\nYou can pass any JSON-serializable object as a parameter.\n\nWarning\n\nA `WorkflowEvent` and its associated `payload` property are effectively *immutable*: any changes to an event are not persisted across the steps of a Workflow. This includes both cases when a Workflow is progressing normally, and in cases where a Workflow has to be restarted due to a failure.\n\nStore state durably by returning it from your `step.do` callbacks.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "To pass parameters via the `wrangler` command-line interface, pass a JSON string as the second parameter to the `workflows trigger` sub-command:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### Wait for events\n\nA running Workflow can wait for an event (or events) by calling `step.waitForEvent` within the Workflow, which allows you to send events to the Workflow in one of two ways:\n\n1. Via the [Workers API binding](https://developers.cloudflare.com/workflows/build/workers-api/): call `instance.sendEvent` to send events to specific workflow instances.\n2. Using the REST API (HTTP API)'s [Events endpoint](https://developers.cloudflare.com/api/resources/workflows/subresources/instances/subresources/events/methods/create/).\n\nBecause `waitForEvent` is part of the `WorkflowStep` API, you can call it multiple times within a Workflow, and use control flow to conditionally wait for an event.\n\nCalling `waitForEvent` requires you to specify an `type` (up to 100 characters [1](#user-content-fn-1)), which is used to match the corresponding `type` when sending an event to a Workflow instance.\n\nFor example, to wait for billing webhook:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "The above example:\n\n* Calls `waitForEvent` with a `type` of `stripe-webhook` - the corresponding `sendEvent` call would thus be `await instance.sendEvent({type: \"stripe-webhook\", payload: webhookPayload})`.\n* Uses a TypeScript [type parameter](https://www.typescriptlang.org/docs/handbook/2/generics.html) to type the return value of `step.waitForEvent` as our `IncomingStripeWebhook`.\n* Continues on with the rest of the Workflow.\n\nThe default timeout for a `waitForEvent` call is 24 hours, which can be changed by passing `{ timeout: WorkflowTimeoutDuration }` as the second argument to your `waitForEvent` call.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "You can specify a timeout between 1 second and up to 365 days.\n\nTimeout behavior\n\nWhen `waitForEvent` times out, the Workflow will throw an error and the instance will fail. If you want your Workflow to continue even if the event is not received, wrap the `waitForEvent` call in a try-catch block:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Send events to running workflows\n\nWorkflow instances that are waiting on events using the `waitForEvent` API can be sent events using the `instance.sendEvent` API:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "- Similar to the [`waitForEvent`](#wait-for-events) example in this guide, the `type` property in our `waitForEvent` and `sendEvent` fields must match.\n- To send multiple events to a Workflow that has multiple `waitForEvent` calls, call `sendEvent` with the corresponding `type` property set (up to 100 characters [1](#user-content-fn-1)).\n- Events can also be sent using the REST API (HTTP API)'s [Events endpoint](https://developers.cloudflare.com/api/resources/workflows/subresources/instances/subresources/events/methods/create/).\n\nEvent timing\n\nYou can send an event to a Workflow instance *before* it reaches the corresponding `waitForEvent` call, as long as the instance has been created. The event will be buffered and delivered when the Workflow reaches the `waitForEvent` step with the matching `type`.\n\n## TypeScript and type parameters\n\nBy default, the `WorkflowEvent` passed to the `run` method of your Workflow definition has a type that conforms to the following, with `payload` (your data), `timestamp`, and `instanceId` properties:",
      "language": "unknown"
    },
    {
      "code": "You can optionally type these events by defining your own type and passing it as a [type parameter](https://www.typescriptlang.org/docs/handbook/2/generics.html#working-with-generic-type-variables) to the `WorkflowEvent`:",
      "language": "unknown"
    },
    {
      "code": "When you pass your `YourEventType` to `WorkflowEvent` as a type parameter, the `event.payload` property now has the type `YourEventType` throughout your workflow definition:",
      "language": "unknown"
    },
    {
      "code": "Warning\n\nProviding a type parameter does *not* validate that the incoming event matches your type definition. In TypeScript, properties (fields) that do not exist or conform to the type you provided will be dropped. If you need to validate incoming events, we recommend a library such as [zod](https://zod.dev/) or your own validator logic.\n\nYou can also provide a type parameter to the `Workflows` type when creating (triggering) a Workflow instance using the `create` method of the [Workers API](https://developers.cloudflare.com/workflows/build/workers-api/#workflow). Note that this does *not* propagate type information into the Workflow itself, as TypeScript types are a build-time construct. To provide the type of an incoming `WorkflowEvent`, refer to the [TypeScript and type parameters](https://developers.cloudflare.com/workflows/build/events-and-parameters/#typescript-and-type-parameters) section of the Workflows documentation.\n\n## Footnotes\n\n1. Match pattern: `^[a-zA-Z0-9_][a-zA-Z0-9-_]*$` [â†©](#user-content-fnref-1) [â†©2](#user-content-fnref-1-2)\n\n</page>\n\n<page>\n---\ntitle: Rules of Workflows Â· Cloudflare Workflows docs\ndescription: A Workflow contains one or more steps. Each step is a\n  self-contained, individually retriable component of a Workflow. Steps may emit\n  (optional) state that allows a Workflow to persist and continue from that\n  step, even if a Workflow fails due to a network or infrastructure issue.\nlastUpdated: 2025-12-12T19:04:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/build/rules-of-workflows/\n  md: https://developers.cloudflare.com/workflows/build/rules-of-workflows/index.md\n---\n\nA Workflow contains one or more steps. Each step is a self-contained, individually retriable component of a Workflow. Steps may emit (optional) state that allows a Workflow to persist and continue from that step, even if a Workflow fails due to a network or infrastructure issue.\n\nThis is a small guidebook on how to build more resilient and correct Workflows.\n\n### Ensure API/Binding calls are idempotent\n\nBecause a step might be retried multiple times, your steps should (ideally) be idempotent. For context, idempotency is a logical property where the operation (in this case a step), can be applied multiple times without changing the result beyond the initial application.\n\nAs an example, let us assume you have a Workflow that charges your customers, and you really do not want to charge them twice by accident. Before charging them, you should check if they were already charged:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Note\n\nGuaranteeing idempotency might be optional in your specific use-case and implementation, but we recommend that you always try to guarantee it.\n\n### Make your steps granular\n\nSteps should be as self-contained as possible. This allows your own logic to be more durable in case of failures in third-party APIs, network errors, and so on.\n\nYou can also think of it as a transaction, or a unit of work.\n\n* âœ… Minimize the number of API/binding calls per step (unless you need multiple calls to prove idempotency).\n\n- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "Otherwise, your entire Workflow might not be as durable as you might think, and you may encounter some undefined behaviour. You can avoid them by following the rules below:\n\n* ðŸ”´ Do not encapsulate your entire logic in one single step.\n* ðŸ”´ Do not call separate services in the same step (unless you need it to prove idempotency).\n* ðŸ”´ Do not make too many service calls in the same step (unless you need it to prove idempotency).\n* ðŸ”´ Do not do too much CPU-intensive work inside a single step - sometimes the engine may have to restart, and it will start over from the beginning of that step.\n\n- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Do not rely on state outside of a step\n\nWorkflows may hibernate and lose all in-memory state. This will happen when engine detects that there is no pending work and can hibernate until it needs to wake-up (because of a sleep, retry, or event).\n\nThis means that you should not store state outside of a step:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Instead, you should build top-level state exclusively comprised of `step.do` returns:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Avoid doing side effects outside of a `step.do`\n\nIt is not recommended to write code with any side effects outside of steps, unless you would like it to be repeated, because the Workflow engine may restart while an instance is running. If the engine restarts, the step logic will be preserved, but logic outside of the steps may be duplicated.\n\nFor example, a `console.log()` outside of workflow steps may cause the logs to print twice when the engine restarts.\n\nHowever, logic involving non-serializable resources, like a database connection, should be executed outside of steps. Operations ouside of a `step.do` might be repeated more than once, due to the nature of the Workflows' instance lifecycle.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Do not mutate your incoming events\n\nThe `event` passed to your Workflow's `run` method is immutable: changes you make to the event are not persisted across steps and/or Workflow restarts.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Name steps deterministically\n\nSteps should be named deterministically (that is, not using the current date/time, randomness, etc). This ensures that their state is cached, and prevents the step from being rerun unnecessarily. Step names act as the \"cache key\" in your Workflow.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Take care with `Promise.race()` and `Promise.any()`\n\nWorkflows allows the usage steps within the `Promise.race()` or `Promise.any()` methods as a way to achieve concurrent steps execution. However, some considerations must be taken.\n\nDue to the nature of Workflows' instance lifecycle, and given that a step inside a Promise will run until it finishes, the step that is returned during the first passage may not be the actual cached step, as [steps are cached by their names](#name-steps-deterministically).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "To ensure consistency, we suggest to surround the `Promise.race()` or `Promise.any()` within a `step.do()`, as this will ensure caching consistency across multiple passages.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Instance IDs are unique\n\nWorkflow [instance IDs](https://developers.cloudflare.com/workflows/build/workers-api/#workflowinstance) are unique per Workflow. The ID is the unique identifier that associates logs, metrics, state and status of a run to a specific instance, even after completion. Allowing ID re-use would make it hard to understand if a Workflow instance ID referred to an instance that run yesterday, last week or today.\n\nIt would also present a problem if you wanted to run multiple different Workflow instances with different [input parameters](https://developers.cloudflare.com/workflows/build/events-and-parameters/) for the same user ID, as you would immediately need to determine a new ID mapping.\n\nIf you need to associate multiple instances with a specific user, merchant or other \"customer\" ID in your system, consider using a composite ID or using randomly generated IDs and storing the mapping in a database like [D1](https://developers.cloudflare.com/d1/).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### `await` your steps\n\nWhen calling `step.do` or `step.sleep`, use `await` to avoid introducing bugs and race conditions into your Workflow code.\n\nIf you don't call `await step.do` or `await step.sleep`, you create a dangling Promise. This occurs when a Promise is created but not properly `await`ed, leading to potential bugs and race conditions.\n\nThis happens when you do not use the `await` keyword or fail to chain `.then()` methods to handle the result of a Promise. For example, calling `fetch(GITHUB_URL)` without awaiting its response will cause subsequent code to execute immediately, regardless of whether the fetch completed. This can cause issues like premature logging, exceptions being swallowed (and not terminating the Workflow), and lost return values (state).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Use conditional logic carefully\n\nYou can use `if` statements, loops, and other control flow outside of steps. However, conditions must be based on **deterministic values** â€” either values from `event.payload` or return values from previous steps. Non-deterministic conditions (such as `Math.random()` or `Date.now()`) outside of steps can cause unexpected behavior if the Workflow restarts.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Batch multiple Workflow invocations\n\nWhen creating multiple Workflow instances, use the [`createBatch`](https://developers.cloudflare.com/workflows/build/workers-api/#createBatch) method to batch the invocations together. This allows you to create multiple Workflow instances in a single request, which will reduce the number of requests made to the Workflows API and increase the number of instances you can create per minute.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Keep step return values under 1 MiB\n\nEach step can persist up to 1 MiB (2^20 bytes) of state. If your step returns data exceeding this limit, the step will fail. This is a common issue when fetching large API responses or processing large files.\n\nTo work around this limit, store large data externally (for example, in R2 or KV) and return only a reference:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Local Development Â· Cloudflare Workflows docs\ndescription: Workflows support local development using Wrangler, the\n  command-line interface for Workers. Wrangler runs an emulated version of\n  Workflows compared to the one that Cloudflare runs globally.\nlastUpdated: 2025-09-18T22:01:54.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/build/local-development/\n  md: https://developers.cloudflare.com/workflows/build/local-development/index.md\n---\n\nWorkflows support local development using [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), the command-line interface for Workers. Wrangler runs an emulated version of Workflows compared to the one that Cloudflare runs globally.\n\n## Prerequisites\n\nTo develop locally with Workflows, you will need:\n\n* [Wrangler v3.89.0](https://blog.cloudflare.com/wrangler3/) or later.\n\n* Node.js version of `18.0.0` or later. Consider using a Node version manager like [Volta](https://volta.sh/) or [nvm](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node versions.\n\n* If you are new to Workflows and/or Cloudflare Workers, refer to the [Workflows Guide](https://developers.cloudflare.com/workflows/get-started/guide/) to install `wrangler` and deploy their first Workflows.\n\n## Start a local development session\n\nOpen your terminal and run the following commands to start a local development session:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Service limits",
      "id": "service-limits"
    },
    {
      "level": "h2",
      "text": "Connection errors",
      "id": "connection-errors"
    },
    {
      "level": "h3",
      "text": "Tunnel errors",
      "id": "tunnel-errors"
    },
    {
      "level": "h3",
      "text": "Use Service Bindings",
      "id": "use-service-bindings"
    },
    {
      "level": "h3",
      "text": "Using fetch",
      "id": "using-fetch"
    },
    {
      "level": "h3",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Pass data to a Workflow",
      "id": "pass-data-to-a-workflow"
    },
    {
      "level": "h3",
      "text": "Wait for events",
      "id": "wait-for-events"
    },
    {
      "level": "h3",
      "text": "Send events to running workflows",
      "id": "send-events-to-running-workflows"
    },
    {
      "level": "h2",
      "text": "TypeScript and type parameters",
      "id": "typescript-and-type-parameters"
    },
    {
      "level": "h2",
      "text": "Footnotes",
      "id": "footnotes"
    },
    {
      "level": "h3",
      "text": "Ensure API/Binding calls are idempotent",
      "id": "ensure-api/binding-calls-are-idempotent"
    },
    {
      "level": "h3",
      "text": "Make your steps granular",
      "id": "make-your-steps-granular"
    },
    {
      "level": "h3",
      "text": "Do not rely on state outside of a step",
      "id": "do-not-rely-on-state-outside-of-a-step"
    },
    {
      "level": "h3",
      "text": "Avoid doing side effects outside of a `step.do`",
      "id": "avoid-doing-side-effects-outside-of-a-`step.do`"
    },
    {
      "level": "h3",
      "text": "Do not mutate your incoming events",
      "id": "do-not-mutate-your-incoming-events"
    },
    {
      "level": "h3",
      "text": "Name steps deterministically",
      "id": "name-steps-deterministically"
    },
    {
      "level": "h3",
      "text": "Take care with `Promise.race()` and `Promise.any()`",
      "id": "take-care-with-`promise.race()`-and-`promise.any()`"
    },
    {
      "level": "h3",
      "text": "Instance IDs are unique",
      "id": "instance-ids-are-unique"
    },
    {
      "level": "h3",
      "text": "`await` your steps",
      "id": "`await`-your-steps"
    },
    {
      "level": "h3",
      "text": "Use conditional logic carefully",
      "id": "use-conditional-logic-carefully"
    },
    {
      "level": "h3",
      "text": "Batch multiple Workflow invocations",
      "id": "batch-multiple-workflow-invocations"
    },
    {
      "level": "h3",
      "text": "Keep step return values under 1 MiB",
      "id": "keep-step-return-values-under-1-mib"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "Start a local development session",
      "id": "start-a-local-development-session"
    }
  ],
  "url": "llms-txt#test-get-request",
  "links": []
}