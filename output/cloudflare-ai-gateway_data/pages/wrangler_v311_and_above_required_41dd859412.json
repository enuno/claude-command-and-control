{
  "title": "wrangler v3.11 and above required",
  "content": "npx wrangler hyperdrive create my-first-hyperdrive --connection-string=\"postgres://user:password@database.host.example.com:5432/databasenamehere\"\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"compatibility_date\": \"2024-09-23\",\n    \"hyperdrive\": [\n      {\n        \"binding\": \"HYPERDRIVE\",\n        \"id\": \"<your-hyperdrive-id-here>\"\n      }\n    ]\n  }\n  toml\n  # required for database drivers to function\n  compatibility_flags = [\"nodejs_compat\"]\n  compatibility_date = \"2024-09-23\"\n\n[[hyperdrive]]\n  binding = \"HYPERDRIVE\"\n  id = \"<your-hyperdrive-id-here>\"\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"compatibility_date\": \"2024-09-23\"\n  }\n  toml\n  compatibility_flags = [ \"nodejs_compat\" ]\n  compatibility_date = \"2024-09-23\"\n  sh\n  npm i pg@>8.16.3\n  sh\n  yarn add pg@>8.16.3\n  sh\n  pnpm add pg@>8.16.3\n  sh\n  npm i -D @types/pg\n  sh\n  yarn add -D @types/pg\n  sh\n  pnpm add -D @types/pg\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"compatibility_date\": \"2024-09-23\",\n    \"hyperdrive\": [\n      {\n        \"binding\": \"HYPERDRIVE\",\n        \"id\": \"<your-hyperdrive-id-here>\"\n      }\n    ]\n  }\n  toml\n  # required for database drivers to function\n  compatibility_flags = [\"nodejs_compat\"]\n  compatibility_date = \"2024-09-23\"\n\n[[hyperdrive]]\n  binding = \"HYPERDRIVE\"\n  id = \"<your-hyperdrive-id-here>\"\n  ts\n// filepath: src/index.ts\nimport { Client } from \"pg\";\n\nexport default {\n  async fetch(\n    request: Request,\n    env: Env,\n    ctx: ExecutionContext,\n  ): Promise<Response> {\n    // Create a new client instance for each request.\n    const client = new Client({\n      connectionString: env.HYPERDRIVE.connectionString,\n    });\n\ntry {\n      // Connect to the database\n      await client.connect();\n      console.log(\"Connected to PostgreSQL database\");\n\n// Perform a simple query\n      const result = await client.query(\"SELECT * FROM pg_tables\");\n\nreturn Response.json({\n        success: true,\n        result: result.rows,\n      });\n    } catch (error: any) {\n      console.error(\"Database error:\", error.message);\n\nnew Response(\"Internal error occurred\", { status: 500 });\n    }\n  },\n};\nsh\n  npm i postgres@>3.4.5\n  sh\n  yarn add postgres@>3.4.5\n  sh\n  pnpm add postgres@>3.4.5\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"compatibility_date\": \"2024-09-23\",\n    \"hyperdrive\": [\n      {\n        \"binding\": \"HYPERDRIVE\",\n        \"id\": \"<your-hyperdrive-id-here>\"\n      }\n    ]\n  }\n  toml\n  # required for database drivers to function\n  compatibility_flags = [\"nodejs_compat\"]\n  compatibility_date = \"2024-09-23\"\n\n[[hyperdrive]]\n  binding = \"HYPERDRIVE\"\n  id = \"<your-hyperdrive-id-here>\"\n  ts\n// filepath: src/index.ts\nimport postgres from \"postgres\";\n\nexport default {\n  async fetch(\n    request: Request,\n    env: Env,\n    ctx: ExecutionContext,\n  ): Promise<Response> {\n    // Create a database client that connects to your database via Hyperdrive\n    // using the Hyperdrive credentials\n    const sql = postgres(env.HYPERDRIVE.connectionString, {\n      // Limit the connections for the Worker request to 5 due to Workers' limits on concurrent external connections\n      max: 5,\n      // If you are not using array types in your Postgres schema, disable `fetch_types` to avoid an additional round-trip (unnecessary latency)\n      fetch_types: false,\n\n// This is set to true by default, but certain query generators such as Kysely or queries using sql.unsafe() will set this to false. Hyperdrive will not cache prepared statements when this option is set to false and will require additional round-trips.\n      prepare: true,\n    });\n\ntry {\n      // A very simple test query\n      const result = await sql`select * from pg_tables`;\n\n// Return result rows as JSON\n      return Response.json({ success: true, result: result });\n    } catch (e: any) {\n      console.error(\"Database error:\", e.message);\n\nreturn Response.error();\n    }\n  },\n} satisfies ExportedHandler<Env>;\ngraphql\nquery HyperdriveQueries(\n  $accountTag: string!\n  $configId: string!\n  $datetimeStart: Time!\n  $datetimeEnd: Time!\n) {\n  viewer {\n    accounts(filter: { accountTag: $accountTag }) {\n      hyperdriveQueriesAdaptiveGroups(\n        limit: 10000\n        filter: {\n          configId: $configId\n          datetime_geq: $datetimeStart\n          datetime_leq: $datetimeEnd\n        }\n      ) {\n        count\n        dimensions {\n          cacheStatus\n        }\n      }\n    }\n  }\n}\ngraphql\nquery AverageHyperdriveLatencies(\n  $accountTag: string!\n  $configId: string!\n  $datetimeStart: Time!\n  $datetimeEnd: Time!\n) {\n  viewer {\n    accounts(filter: { accountTag: $accountTag }) {\n      hyperdriveQueriesAdaptiveGroups(\n        limit: 10000\n        filter: {\n          configId: $configId\n          eventStatus: \"complete\"\n          datetime_geq: $datetimeStart\n          datetime_leq: $datetimeEnd\n        }\n      ) {\n        avg {\n          connectionLatency\n          queryLatency\n        }\n      }\n    }\n  }\n}\ngraphql\nquery HyperdriveQueryAndResultBytesForSuccessfulQueries(\n  $accountTag: string!\n  $configId: string!\n  $datetimeStart: Date!\n  $datetimeEnd: Date!\n) {\n  viewer {\n    accounts(filter: { accountTag: $accountTag }) {\n      hyperdriveQueriesAdaptiveGroups(\n        limit: 10000\n        filter: {\n          configId: $configId\n          datetime_geq: $datetimeStart\n          datetime_leq: $datetimeEnd\n        }\n      ) {\n        sum {\n          queryBytes\n          resultBytes\n        }\n      }\n    }\n  }\n}\nsh\n  npx wrangler hyperdrive create [NAME]\n  sh\n  pnpm wrangler hyperdrive create [NAME]\n  sh\n  yarn wrangler hyperdrive create [NAME]\n  sh\n  npx wrangler hyperdrive delete [ID]\n  sh\n  pnpm wrangler hyperdrive delete [ID]\n  sh\n  yarn wrangler hyperdrive delete [ID]\n  sh\n  npx wrangler hyperdrive get [ID]\n  sh\n  pnpm wrangler hyperdrive get [ID]\n  sh\n  yarn wrangler hyperdrive get [ID]\n  sh\n  npx wrangler hyperdrive list\n  sh\n  pnpm wrangler hyperdrive list\n  sh\n  yarn wrangler hyperdrive list\n  sh\n  npx wrangler hyperdrive update [ID]\n  sh\n  pnpm wrangler hyperdrive update [ID]\n  sh\n  yarn wrangler hyperdrive update [ID]\n  sh\n  npm create cloudflare@latest -- timescale-api\n  sh\n  yarn create cloudflare timescale-api\n  sh\n  pnpm create cloudflare@latest timescale-api\n  sh\ncd timescale-api\ntxt\npostgres://tsdbadmin:YOURPASSWORD@...\nsh\npsql <SERVICEURL>\nsql\nCREATE TABLE readings(\n  ts timestamptz DEFAULT now() NOT NULL,\n  sensor UUID NOT NULL,\n  metadata jsonb,\n  value numeric NOT NULL\n );\n\nSELECT create_hypertable('readings', 'ts');\nsh\nnpx wrangler hyperdrive create hyperdrive --connection-string=\"SERVICEURL\"\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"timescale-api\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2024-09-23\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"hyperdrive\": [\n      {\n        \"binding\": \"HYPERDRIVE\",\n        \"id\": \"your-id-here\"\n      }\n    ]\n  }\n  toml\n  name = \"timescale-api\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2024-09-23\"\n  compatibility_flags = [ \"nodejs_compat\"]\n\n[[hyperdrive]]\n  binding = \"HYPERDRIVE\"\n  id = \"your-id-here\"\n  sh\n  npm i pg\n  sh\n  yarn add pg\n  sh\n  pnpm add pg\n  ts\nimport { Client } from \"pg\";\n\nexport interface Env {\n  HYPERDRIVE: Hyperdrive;\n}\n\nexport default {\n  async fetch(request, env, ctx): Promise<Response> {\n    const client = new Client({\n      connectionString: env.HYPERDRIVE.connectionString,\n    });\n    await client.connect();\n\nconst url = new URL(request.url);\n    // Create a route for inserting JSON as readings\n    if (request.method === \"POST\" && url.pathname === \"/readings\") {\n      // Parse the request's JSON payload\n      const productData = await request.json();\n\n// Write the raw query. You are using jsonb_to_recordset to expand the JSON\n      // to PG INSERT format to insert all items at once, and using coalesce to\n      // insert with the current timestamp if no ts field exists\n      const insertQuery = `\n      INSERT INTO readings (ts, sensor, metadata, value)\n      SELECT coalesce(ts, now()), sensor, metadata, value FROM jsonb_to_recordset($1::jsonb)\n      AS t(ts timestamptz, sensor UUID, metadata jsonb, value numeric)\n  `;\n\nconst insertResult = await client.query(insertQuery, [\n        JSON.stringify(productData),\n      ]);\n\n// Collect the raw row count inserted to return\n      const resp = new Response(JSON.stringify(insertResult.rowCount), {\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n\n// Create a route for querying within a time-frame\n    } else if (request.method === \"GET\" && url.pathname === \"/readings\") {\n      const limit = url.searchParams.get(\"limit\");\n\n// Query the readings table using the limit param passed\n      const result = await client.query(\n        \"SELECT * FROM readings ORDER BY ts DESC LIMIT $1\",\n        [limit],\n      );\n\n// Return the result as JSON\n      const resp = new Response(JSON.stringify(result.rows), {\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n\nreturn resp;\n    }\n  },\n} satisfies ExportedHandler<Env>;\nsh\nnpx wrangler deploy\njson\n[\n  { \"sensor\": \"6f3e43a4-d1c1-4cb6-b928-0ac0efaf84a5\", \"value\": 0.3 },\n  { \"sensor\": \"d538f9fa-f6de-46e5-9fa2-d7ee9a0f0a68\", \"value\": 10.8 },\n  { \"sensor\": \"5cb674a0-460d-4c80-8113-28927f658f5f\", \"value\": 18.8 },\n  { \"sensor\": \"03307bae-d5b8-42ad-8f17-1c810e0fbe63\", \"value\": 20.0 },\n  { \"sensor\": \"64494acc-4aa5-413c-bd09-2e5b3ece8ad7\", \"value\": 13.1 },\n  { \"sensor\": \"0a361f03-d7ec-4e61-822f-2857b52b74b3\", \"value\": 1.1 },\n  { \"sensor\": \"50f91cdc-fd19-40d2-b2b0-c90db3394981\", \"value\": 10.3 }\n]\nbash\ncurl --request POST --data @- 'https://timescale-api.<YOUR_SUBDOMAIN>.workers.dev/readings' <<EOF\n[\n  { \"sensor\": \"6f3e43a4-d1c1-4cb6-b928-0ac0efaf84a5\", \"value\":0.3},\n  { \"sensor\": \"d538f9fa-f6de-46e5-9fa2-d7ee9a0f0a68\", \"value\":10.8},\n  { \"sensor\": \"5cb674a0-460d-4c80-8113-28927f658f5f\", \"value\":18.8},\n  { \"sensor\": \"03307bae-d5b8-42ad-8f17-1c810e0fbe63\", \"value\":20.0},\n  { \"sensor\": \"64494acc-4aa5-413c-bd09-2e5b3ece8ad7\", \"value\":13.1},\n  { \"sensor\": \"0a361f03-d7ec-4e61-822f-2857b52b74b3\", \"value\":1.1},\n  { \"sensor\": \"50f91cdc-fd19-40d2-b2b0-c90db3394981\", \"metadata\": {\"color\": \"blue\" }, \"value\":10.3}\n]\nEOF\nsh\ncurl \"https://timescale-api.<YOUR_SUBDOMAIN>.workers.dev/readings?limit=10\"\nbash\ncurl \"https://api.cloudflare.com/client/v4/{zone_id}/rulesets/{ruleset_id}/rules\" \\\n--header \"Authorization: Bearer <API_TOKEN>\" \\\n--header \"Content-Type: application/json\" \\\n--data '{\n  \"action\": \"skip\",\n  \"action_parameters\": {\n    \"products\": [\n      \"zoneLockdown\"\n    ]\n  },\n  \"expression\": \"http.user_agent contains \\\"1234567890abcdef\\\"\",\n  \"description\": \"bypass zone lockdown - specific healthcheck\"\n}'\njs\nconst stream = await env.AI.run(\n  \"@cf/bytedance/stable-diffusion-xl-lightning\",\n  {\n    prompt: YOUR_PROMPT_HERE\n  }\n);\n\n// Convert to AVIF\nconst image = (\n  await env.IMAGES.input(stream)\n    .output({format: \"image/avif\"})\n).response();\n\nconst fileName = \"image.avif\";\n\n// Upload to R2\nawait env.R2.put(fileName, image.body);\nts\ninterface Env {\n    BUCKET: R2Bucket,\n    NAMESPACE: KVNamespace,\n    IMAGES: ImagesBinding,\n}\nexport default {\n    async fetch(request, env, ctx): Promise<Response> {\n        const watermarkKey = \"my-watermark\";\n        const sourceKey = \"my-source-image\";\n\nconst cache = await caches.open(\"transformed-images\");\n        const cacheKey = new URL(sourceKey + \"/\" + watermarkKey, request.url);\n        const cacheResponse = await cache.match(cacheKey);\n\nif (cacheResponse) {\n            return cacheResponse;\n        }\n\nlet watermark = await env.NAMESPACE.get(watermarkKey, \"stream\");\n        let source = await env.BUCKET.get(sourceKey);\n\nif (!watermark || !source) {\n            return new Response(\"Not found\", { status: 404 });\n        }\n\nconst result = await env.IMAGES.input(source.body)\n            .draw(watermark)\n            .output({ format: \"image/jpeg\" });\n\nconst response = result.response();\n\nctx.waitUntil(cache.put(cacheKey, response.clone()));\n\nreturn result.response();\n  },\n} satisfies ExportedHandler<Env>;\nbash\ncurl --request PATCH 'https://api.cloudflare.com/client/v4/accounts/{account_id}/images/v1/config' \\\n--header \"Authorization: Bearer <API_TOKEN>\" \\\n--header \"Content-Type: application/json\" \\\n--data '{\n  \"browser_ttl\": 31536000\n}'\nbash\ncurl 'https://api.cloudflare.com/client/v4/accounts/<ACCOUNT_TAG>/images/v1/variants' \\\n--header \"Authorization: Bearer <API_TOKEN>\" \\\n--header \"Content-Type: application/json\" \\\n--data '{\n  \"id\":\"avatar\",\n  \"options\": {\n    \"width\":100,\n    \"browser_ttl\": 86400\n  }\n}'\nbash\ncurl \"https://api.cloudflare.com/client/v4/accounts/{account_id}/images/v1/variants\" \\\n--header \"Authorization: Bearer <API_TOKEN>\" \\\n--header \"Content-Type: application/json\" \\\n--data '{\"id\":\"<NAME_OF_THE_VARIANT>\",\"options\":{\"fit\":\"scale-down\",\"metadata\":\"none\",\"width\":1366,\"height\":768},\"neverRequireSignedURLs\":true}\nbash\ncurl --request DELETE https://api.cloudflare.com/client/v4/accounts/{account_id}/images/v1/{image_id} \\\n--header \"Authorization: Bearer <API_TOKEN>\"\nbash\ncurl --request DELETE https://api.cloudflare.com/client/v4/account/{account_id}/images/v1/variants/{variant_name} \\\n--header \"Authorization: Bearer <API_TOKEN>\"\nbash\ncurl --request PATCH https://api.cloudflare.com/client/v4/accounts/{account_id}/images/v1/config \\\n--header \"Authorization: Bearer <API_TOKEN>\" \\\n--header \"Content-Type: application/json\" \\\n--data '{\"flexible_variants\": true}'\ntxt\nAccept: image/avif,image/webp,image/*,*/*;q=0.8\njsonc\n  {\n    \"images\": {\n      \"binding\": \"IMAGES\", // i.e. available in your Worker on env.IMAGES\n    },\n  }\n  toml\n  [images]\n  binding = \"IMAGES\"\n  ts\n// Fetch the watermark from Workers Assets, R2, KV etc\nconst watermark: ReadableStream = ...\n\n// Fetch the main image\nconst image: ReadableStream = ...\n\nconst response = (\n  await env.IMAGES.input(image)\n    .draw(\n        env.IMAGES.input(watermark)\n          .transform({ width: 32, height: 32}),\n        { bottom: 32, right: 32 }\n    )\n    .output({ format: \"image/avif\" })\n).response()\n\nreturn response;\nts\nconst info = await env.IMAGES.info(stream);\n// stream contains a valid image, and width/height is available on the info object\n\nconst response = (\n  await env.IMAGES.input(stream)\n    .transform({ rotate: 90 })\n    .transform({ width: 128 })\n    .transform({ blur: 20 })\n    .output({ format: \"image/avif\" })\n).response();\n\nreturn response;\ntxt\nnpx wrangler dev\ntxt\nnpx wrangler dev --experimental-images-local-mode\njs\nexport default {\n  async fetch(request, env, ctx) {\n    // Here you can compute arbitrary imageURL and\n    // resizingOptions from any request data ...\n    return fetch(imageURL, { cf: { image: resizingOptions } });\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    const resizingOptions = {\n      /* resizing options will be demonstrated in the next example */\n    };\n\nconst hiddenImageOrigin = \"https://secret.example.com/hidden-directory\";\n    const requestURL = new URL(request.url);\n    // Append the request path such as \"/assets/image1.jpg\" to the hiddenImageOrigin.\n    // You could also process the path to add or remove directories, modify filenames, etc.\n    const imageURL = hiddenImageOrigin + requestURL.path;\n    // This will fetch image from the given URL, but to the website's visitors this\n    // will appear as a response to the original request. Visitor’s browser will\n    // not see this URL.\n    return fetch(imageURL, { cf: { image: resizingOptions } });\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n  const imageURL = … // detail omitted in this example, see the previous example\n\nconst requestURL = new URL(request.url)\n  const resizingOptions = {\n    width: requestURL.searchParams.get(\"width\"),\n  }\n  // If someone tries to manipulate your image URLs to reveal higher-resolution images,\n  // you can catch that and refuse to serve the request (or enforce a smaller size, etc.)\n  if (resizingOptions.width > 1000) {\n    throw Error(\"We don’t allow viewing images larger than 1000 pixels wide\")\n  }\n  return fetch(imageURL, {cf:{image:resizingOptions}})\n},};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    const requestURL = new URL(request.url);\n    const resizingOptions = {};\n\n// The regex selects the first path component after the \"images\"\n    // prefix, and the rest of the path (e.g. \"/images/first/rest\")\n    const match = requestURL.path.match(/images\\/([^/]+)\\/(.+)/);\n\n// You can require the first path component to be one of the\n    // predefined sizes only, and set actual dimensions accordingly.\n    switch (match && match[1]) {\n      case \"small\":\n        resizingOptions.width = 300;\n        break;\n      case \"medium\":\n        resizingOptions.width = 600;\n        break;\n      case \"large\":\n        resizingOptions.width = 900;\n        break;\n      default:\n        throw Error(\"invalid size\");\n    }\n\n// The remainder of the path may be used to locate the original\n    // image, e.g. here \"/images/small/image1.jpg\" would map to\n    // \"https://storage.example.com/bucket/image1.jpg\" resized to 300px.\n    const imageURL = \"https://storage.example.com/bucket/\" + match[2];\n    return fetch(imageURL, { cf: { image: resizingOptions } });\n  },\n};\njs\n// generate signed headers (application specific)\nconst signedHeaders = generatedSignedHeaders();\n\nfetch(private_url, {\n  headers: signedHeaders\n  cf: {\n    image: {\n      format: \"auto\",\n      \"origin-auth\": \"share-publicly\"\n     }\n  }\n})\nts\nmodule.exports = {\n  images: {\n    loader: 'custom',\n    loaderFile: './imageLoader.ts',\n  },\n}\nts\nimport type { ImageLoaderProps } from \"next/image\";\n\nconst normalizeSrc = (src: string) => {\n    return src.startsWith(\"/\") ? src.slice(1) : src;\n};\n\nexport default function cloudflareLoader({\n    src,\n    width,\n    quality,\n}: ImageLoaderProps) {\n    const params = [`width=${width}`];\n    if (quality) {\n      params.push(`quality=${quality}`);\n    }\n    if (process.env.NODE_ENV === \"development\") {\n      return `${src}?${params.join(\"&\")}`;\n    }\n    return `/cdn-cgi/image/${params.join(\",\")}/${normalizeSrc(src)}`;\n}\njs\nimport Image from 'next/image';\n\nconst normalizeSrc = (src) => {\n  return src.startsWith('/') ? src.slice(1) : src;\n};\n\nconst cloudflareLoader = ({ src, width, quality }) => {\n  const params = [`width=${width}`];\n  if (quality) {\n    params.push(`quality=${quality}`);\n  }\n  if (process.env.NODE_ENV === \"development\") {\n    return `${src}?${params.join(\"&\")}`;\n  }\n  return `/cdn-cgi/image/${params.join(\",\")}/${normalizeSrc(src)}`;\n};\n\nconst MyImage = (props) => {\n  return (\n    <Image\n      loader={cloudflareLoader}\n      src=\"/me.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n      {...props}\n    />\n  );\n};\njs\nfetch(imageURL, {\n  cf: {\n    image: {\n      width: 800,\n      height: 600,\n      draw: [\n        {\n          url: 'https://example.com/branding/logo.png', // draw this image\n          bottom: 5, // 5 pixels from the bottom edge\n          right: 5, // 5 pixels from the right edge\n          fit: 'contain', // make it fit within 100x50 area\n          width: 100,\n          height: 50,\n          opacity: 0.8, // 20% transparent\n        },\n      ],\n    },\n  },\n});\njs\n// Fetch image and watermark\nconst img = await fetch('https://example.com/image.png');\nconst watermark = await fetch('https://example.com/watermark.png');\n\nconst response = await env.IMAGES.input(img.body)\n  .transform({ width: 1024 })\n  .draw(watermark.body, { \"opacity\": 0.25, \"repeat\": true })\n  .output({ format: \"image/avif\" })\n  .response();\n\nreturn response;\njs\n// Fetch image and watermark\nconst response = (\n  await env.IMAGES.input(img.body)\n    .transform({ width: 1024 })\n    .draw(watermark.body, { \"opacity\": 0.25, \"repeat\": true })\n    .output({ format: \"image/avif\" })\n).response();\njs\nimage: {\n  draw: [\n    {\n      url: 'https://example.com/watermark.png',\n      repeat: true, // Tiled over entire image\n      opacity: 0.2, // and subtly blended\n    },\n  ];\n}\njs\nimage: {\n  draw: [\n    {\n      url: 'https://example.com/by-me.png', // Predefined logo/signature\n      bottom: 5, // Positioned near bottom right corner\n      right: 5,\n    },\n  ];\n}\njs\nimage: {\n  draw: [\n    {\n      url: 'https://example.com/play-button.png',\n      // Center position is the default\n    },\n  ];\n}\njs\nimage: {\n  draw: [\n    { url: 'https://example.com/watermark.png', repeat: true, opacity: 0.2 },\n    { url: 'https://example.com/play-button.png' },\n    { url: 'https://example.com/by-me.png', bottom: 5, right: 5 },\n  ];\n}\nhtml\n<img\n  src=\"/cdn-cgi/image/fit=contain,width=960/assets/product.jpg\"\n  srcset=\"/cdn-cgi/image/fit=contain,width=1920/assets/product.jpg 2x\"\n/>\nhtml\n<img\n  width=\"100%\"\n  srcset=\"\n    /cdn-cgi/image/fit=contain,width=320/assets/hero.jpg   320w,\n    /cdn-cgi/image/fit=contain,width=640/assets/hero.jpg   640w,\n    /cdn-cgi/image/fit=contain,width=960/assets/hero.jpg   960w,\n    /cdn-cgi/image/fit=contain,width=1280/assets/hero.jpg 1280w,\n    /cdn-cgi/image/fit=contain,width=2560/assets/hero.jpg 2560w\n  \"\n  src=\"/cdn-cgi/image/width=960/assets/hero.jpg\"\n/>\nhtml\n<img style=\"width: 50vw\" srcset=\"<SAME_AS_BEFORE>\" sizes=\"50vw\" />\nhtml\n<img\n  style=\"max-width: 640px\"\n  srcset=\"\n    /cdn-cgi/image/fit=contain,width=320/assets/hero.jpg   320w,\n    /cdn-cgi/image/fit=contain,width=480/assets/hero.jpg   480w,\n    /cdn-cgi/image/fit=contain,width=640/assets/hero.jpg   640w,\n    /cdn-cgi/image/fit=contain,width=1280/assets/hero.jpg 1280w\n  \"\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n/>\ntxt\n<meta http-equiv=\"Delegate-CH\" content=\"sec-ch-dpr https://example.com; sec-ch-viewport-width https://example.com\"/>\ntxt\ncritical-ch: sec-ch-viewport-width, sec-ch-dpr\n\npermissions-policy: ch-dpr=(\"https://example.com\"), ch-viewport-width=(\"https://example.com\")\ntxt\n(starts_with(http.request.uri.path, \"/images\")) and (not (any(http.request.headers[\"via\"][*] contains \"image-resizing\")))\ntxt\nconcat(\"/cdn-cgi/image\", substring(http.request.uri.path, 7))\ntxt\n(http.request.uri.path matches \"^/images/.*$\") and (not (any(http.request.headers[\"via\"][*] contains \"image-resizing\")))\ntxt\nregex_replace(http.request.uri.path, \"^/images/\", \"/cdn-cgi/image/\")\ntxt\n(http.request.uri matches \"^/(.*)\\\\?width=([0-9]+)&height=([0-9]+)$\")\ntxt\nregex_replace(\n  http.request.uri,\n  \"^/(.*)\\\\?width=([0-9]+)&height=([0-9]+)$\",\n  \"/cdn-cgi/image/width=${2},height=${3}/${1}\"\n)\ntxt\n(http.request.uri.path.extension matches \"(jpg)|(jpeg)|(png)|(gif)\") and (not (any(http.request.headers[\"via\"][*] contains \"image-resizing\")))\ntxt\nregex_replace(http.request.uri.path, \"/(.*)\", \"/cdn-cgi/image/format=auto/${1}\")\ntxt\nhttps://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>\nhtml\n<img src=\"/cdn-cgi/image/width=80,quality=75/uploads/avatar1.jpg\" />\njs\n  anim=false\n  js\n  cf: {image: {anim: false}}\n  js\n  background=%23RRGGBB\n\nbackground=rgb%28240%2C40%2C145%29\n  js\n  cf: {image: {background: \"#RRGGBB\"}}\n\ncf:{image: {background: \"rgba(240,40,145,0)\"}}\n  js\n  blur=50\n  js\n  cf: {image: {blur: 50}}\n  js\n  cf: {image: {border: {color: \"rgb(0,0,0,0)\", top: 5, right: 10, bottom: 5, left: 10}}}\n  cf: {image: {border: {color: \"#FFFFFF\", width: 10}}}\n  js\n  brightness=0.5\n  js\n  cf: {image: {brightness: 0.5}}\n  js\n  compression=fast\n  js\n  cf: {image: {compression: \"fast\"}}\n  js\n  contrast=0.5\n  js\n  cf: {image: {contrast: 0.5}}\n  js\n  dpr=1\n  js\n  cf: {image: {dpr: 1}}\n  js\n  fit=scale-down\n  js\n  cf: {image: {fit: \"scale-down\"}}\n  js\n  flip=h\n  js\n  cf: {image: {flip: \"h\"}}\n  js\n  format=auto\n  js\n  f=auto\n  js\n  cf: {image: {format: \"avif\"}}\n  js\nconst accept = request.headers.get(\"accept\");\nlet image = {};\n\nif (/image\\/avif/.test(accept)) {\n  image.format = \"avif\";\n} else if (/image\\/webp/.test(accept)) {\n  image.format = \"webp\";\n}\n\nreturn fetch(url, { cf: { image } });\njs\n  gamma=0.5\n  js\n  cf: {image: {gamma: 0.5}}\n  js\n  gravity=auto\n\ngravity=face\n  js\n  g=auto\n\ng=face\n  js\n  cf: {image: {gravity: \"auto\"}}\n\ncf: {image: {gravity: \"right\"}}\n\ncf: {image: {gravity: {x:0.5, y:0.2}}}\n\ncf: {image: {gravity: \"face\"}}\n  plaintext\njs\n  height=250\n  js\n  h=250\n  js\n  cf: {image: {height: 250}}\n  js\n  metadata=none\n  js\n  cf: {image: {metadata: \"none\"}}\n  js\n  onerror=redirect\n  js\n  quality=50\n\nquality=low\n  js\n  q=50\n\nq=medium-high\n  js\n  cf: {image: {quality: 50}}\n\ncf: {image: {quality: \"high\"}}\n  js\n  rotate=90\n  js\n  cf: {image: {rotate: 90}}\n  js\n  saturation=0.5\n  js\n  cf: {image: {saturation: 0.5}}\n  js\n  segment=foreground\n  js\n  cf: {segment: \"foreground\"}\n  js\n  sharpen=2\n  js\n  cf: {image: {sharpen: 2}}\n  js\n  slow-connection-quality=50\n  js\n  scq=50\n  txt\naccept-ch: rtt, save-data, ect, downlink\njs\n  trim=20;30;20;0\n  trim.width=678\n  trim.height=678\n  trim.left=30\n  trim.top=40\n  js\n  cf: {image: {trim: {top: 12,  right: 78, bottom: 34, left: 56, width:678, height:678}}}\n  js\n  trim=border\n\ntrim.border.color=%23000000\n  trim.border.tolerance=5\n  trim.border.keep=10\n  js\n  cf: {image: {trim: \"border\"}}\n\ncf: {image: {trim: {border: {color: \"#000000\", tolerance: 5, keep: 10}}}}\n  js\n  width=250\n  js\n  w=250\n  js\n  cf: {image: {width: 250}}\n  js\n  zoom=0.1\n  js\n  zoom=0.2\n  OR\n\nface-zoom=0.2\n  js\n  cf: {image: {zoom: 0.5}}\n  txt\n/cdn-cgi/image/fit=scale-down,width=1920/<YOUR-IMAGE>\njs\n  anim=false\n  js\n  cf: {image: {anim: false}}\n  js\n  background=%23RRGGBB\n\nbackground=rgb%28240%2C40%2C145%29\n  js\n  cf: {image: {background: \"#RRGGBB\"}}\n\ncf:{image: {background: \"rgba(240,40,145,0)\"}}\n  js\n  blur=50\n  js\n  cf: {image: {blur: 50}}\n  js\n  cf: {image: {border: {color: \"rgb(0,0,0,0)\", top: 5, right: 10, bottom: 5, left: 10}}}\n  cf: {image: {border: {color: \"#FFFFFF\", width: 10}}}\n  js\n  brightness=0.5\n  js\n  cf: {image: {brightness: 0.5}}\n  js\n  compression=fast\n  js\n  cf: {image: {compression: \"fast\"}}\n  js\n  contrast=0.5\n  js\n  cf: {image: {contrast: 0.5}}\n  js\n  dpr=1\n  js\n  cf: {image: {dpr: 1}}\n  js\n  fit=scale-down\n  js\n  cf: {image: {fit: \"scale-down\"}}\n  js\n  flip=h\n  js\n  cf: {image: {flip: \"h\"}}\n  js\n  format=auto\n  js\n  f=auto\n  js\n  cf: {image: {format: \"avif\"}}\n  js\nconst accept = request.headers.get(\"accept\");\nlet image = {};\n\nif (/image\\/avif/.test(accept)) {\n  image.format = \"avif\";\n} else if (/image\\/webp/.test(accept)) {\n  image.format = \"webp\";\n}\n\nreturn fetch(url, { cf: { image } });\njs\n  gamma=0.5\n  js\n  cf: {image: {gamma: 0.5}}\n  js\n  gravity=auto\n\ngravity=face\n  js\n  g=auto\n\ng=face\n  js\n  cf: {image: {gravity: \"auto\"}}\n\ncf: {image: {gravity: \"right\"}}\n\ncf: {image: {gravity: {x:0.5, y:0.2}}}\n\ncf: {image: {gravity: \"face\"}}\n  plaintext\njs\n  height=250\n  js\n  h=250\n  js\n  cf: {image: {height: 250}}\n  js\n  metadata=none\n  js\n  cf: {image: {metadata: \"none\"}}\n  js\n  onerror=redirect\n  js\n  quality=50\n\nquality=low\n  js\n  q=50\n\nq=medium-high\n  js\n  cf: {image: {quality: 50}}\n\ncf: {image: {quality: \"high\"}}\n  js\n  rotate=90\n  js\n  cf: {image: {rotate: 90}}\n  js\n  saturation=0.5\n  js\n  cf: {image: {saturation: 0.5}}\n  js\n  segment=foreground\n  js\n  cf: {segment: \"foreground\"}\n  js\n  sharpen=2\n  js\n  cf: {image: {sharpen: 2}}\n  js\n  trim=20;30;20;0\n  trim.width=678\n  trim.height=678\n  trim.left=30\n  trim.top=40\n  js\n  cf: {image: {trim: {top: 12,  right: 78, bottom: 34, left: 56, width:678, height:678}}}\n  js\n  trim=border\n\ntrim.border.color=%23000000\n  trim.border.tolerance=5\n  trim.border.keep=10\n  js\n  cf: {image: {trim: \"border\"}}\n\ncf: {image: {trim: {border: {color: \"#000000\", tolerance: 5, keep: 10}}}}\n  js\n  width=250\n  js\n  w=250\n  js\n  cf: {image: {width: 250}}\n  js\n  zoom=0.1\n  js\n  zoom=0.2\n  OR\n\nface-zoom=0.2\n  js\n  cf: {image: {zoom: 0.5}}\n  js\nfetch(imageURL, {\n  cf: {\n    image: {\n      fit: \"scale-down\",\n      width: 800,\n      height: 600,\n    },\n  },\n});\njs\naddEventListener(\"fetch\", event => {\n  // If this request is coming from image resizing worker,\n  // avoid causing an infinite loop by resizing it again:\n  if (/image-resizing/.test(event.request.headers.get(\"via\"))) {\n    return fetch(event.request)\n  }\n\n// Now you can safely use image resizing here\n}\njs\nconst response = await fetch(imageURL, options);\n\nif (response.ok || response.redirected) {\n  // fetch() may respond with status 304\n  return response;\n} else {\n  return response.redirect(imageURL, 307);\n}\njs\nconst response = await fetch(imageURL, options);\nif (response.ok || response.redirected) {\n  return response;\n} else {\n  // Change to a URL on your server\n  return fetch(\"https://img.example.com/blank-placeholder.png\");\n}\njs\n/**\n * Fetch and log a request\n * @param {Request} request\n */\nexport default {\n  async fetch(request) {\n    // Parse request URL to get access to query string\n    let url = new URL(request.url);\n\n// Cloudflare-specific options are in the cf object.\n    let options = { cf: { image: {} } };\n\n// Copy parameters from query string to request options.\n    // You can implement various different parameters here.\n    if (url.searchParams.has(\"fit\"))\n      options.cf.image.fit = url.searchParams.get(\"fit\");\n    if (url.searchParams.has(\"width\"))\n      options.cf.image.width = url.searchParams.get(\"width\");\n    if (url.searchParams.has(\"height\"))\n      options.cf.image.height = url.searchParams.get(\"height\");\n    if (url.searchParams.has(\"quality\"))\n      options.cf.image.quality = url.searchParams.get(\"quality\");\n\n// Your Worker is responsible for automatic format negotiation. Check the Accept header.\n    const accept = request.headers.get(\"Accept\");\n    if (/image\\/avif/.test(accept)) {\n      options.cf.image.format = \"avif\";\n    } else if (/image\\/webp/.test(accept)) {\n      options.cf.image.format = \"webp\";\n    }\n\n// Get URL of the original (full size) image to resize.\n    // You could adjust the URL here, e.g., prefix it with a fixed address of your server,\n    // so that user-visible URLs are shorter and cleaner.\n    const imageURL = url.searchParams.get(\"image\");\n    if (!imageURL)\n      return new Response('Missing \"image\" value', { status: 400 });\n\ntry {\n      // TODO: Customize validation logic\n      const { hostname, pathname } = new URL(imageURL);\n\n// Optionally, only allow URLs with JPEG, PNG, GIF, or WebP file extensions\n      // @see https://developers.cloudflare.com/images/url-format#supported-formats-and-limitations\n      if (!/\\.(jpe?g|png|gif|webp)$/i.test(pathname)) {\n        return new Response(\"Disallowed file extension\", { status: 400 });\n      }\n\n// Demo: Only accept \"example.com\" images\n      if (hostname !== \"example.com\") {\n        return new Response('Must use \"example.com\" source images', {\n          status: 403,\n        });\n      }\n    } catch (err) {\n      return new Response('Invalid \"image\" value', { status: 400 });\n    }\n\n// Build a request that passes through request headers\n    const imageRequest = new Request(imageURL, {\n      headers: request.headers,\n    });\n\n// Returning fetch() with resizing options will pass through response with the resized image.\n    return fetch(imageRequest, options);\n  },\n};\nhtml\n<img src=\"example.com/cdn-cgi/width=300/image.png\" loading=\"lazy\">\nhtml\n<img src=\"example.com/cdn-cgi/width=300/image.png\" loading=\"eager\">\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"images\": {\n      \"binding\": \"IMAGES\"\n    },\n    \"r2_buckets\": [\n      {\n        \"binding\": \"R2\",\n        \"bucket_name\": \"<BUCKET>\"\n      }\n    ],\n    \"assets\": {\n      \"directory\": \"./<DIRECTORY>\",\n      \"binding\": \"ASSETS\"\n    }\n  }\n  toml\n  [images]\n  binding = \"IMAGES\"\n\n[[r2_buckets]]\n  binding = \"R2\"\n  bucket_name = \"<BUCKET>\"\n\n[assets]\n  directory = \"./<DIRECTORY>\"\n  binding = \"ASSETS\"\n  js\nconst html = `\n<!DOCTYPE html>\n        <html>\n          <head>\n            <meta charset=\"UTF-8\">\n            <title>Upload Image</title>\n          </head>\n          <body>\n            <h1>Upload an image</h1>\n            <form method=\"POST\" enctype=\"multipart/form-data\">\n              <input type=\"file\" name=\"image\" accept=\"image/*\" required />\n              <button type=\"submit\">Upload</button>\n            </form>\n          </body>\n        </html>\n`;\n\nexport default {\n  async fetch(request, env) {\n    if (request.method === \"GET\") {\n      return new Response(html, {headers:{'Content-Type':'text/html'},})\n    }\n    if (request.method ===\"POST\") {\n      // This is called when the user submits the form\n    }\n  }\n};\njs\nexport default {\n  async fetch(request, env) {\n    if (request.method === \"GET\") {\n      return new Response(html, {headers:{'Content-Type':'text/html'},})\n    }\n    if (request.method === \"POST\") {\n      try {\n        // Parse form data\n        const formData = await request.formData();\n        const file = formData.get(\"image\");\n        if (!file || typeof file.arrayBuffer !== \"function\") {\n          return new Response(\"No image file provided\", { status: 400 });\n        }\n\n// Read uploaded image as array buffer\n        const fileBuffer = await file.arrayBuffer();\n      } catch (err) {\n        console.log(err.message)\n      }\n    }\n  }\n};\njs\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\nfunction assetUrl(request, path) {\n  const url = new URL(request.url);\n  url.pathname = path;\n  return url;\n}\n__name(assetUrl, \"assetUrl\");\n\nexport default {\n  async fetch(request, env) {\n    if (request.method === \"GET\") {\n      return new Response(html, {headers:{'Content-Type':'text/html'},})\n    }\n    if (request.method === \"POST\") {\n      try {\n        // Parse form data\n        const formData = await request.formData();\n        const file = formData.get(\"image\");\n        if (!file || typeof file.arrayBuffer !== \"function\") {\n          return new Response(\"No image file provided\", { status: 400 });\n        }\n\n// Read uploaded image as array buffer\n        const fileBuffer = await file.arrayBuffer();\n\n// Fetch image as watermark\n        let watermarkStream = (await env.ASSETS.fetch(assetUrl(request, \"watermark.png\"))).body;\n      } catch (err) {\n        console.log(err.message)\n      }\n    }\n  }\n};\njs\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\nfunction assetUrl(request, path) {\n  const url = new URL(request.url);\n  url.pathname = path;\n  return url;\n}\n__name(assetUrl, \"assetUrl\");\n\nexport default {\n  async fetch(request, env) {\n    if (request.method === \"GET\") {\n      return new Response(html, {headers:{'Content-Type':'text/html'},})\n    }\n    if (request.method === \"POST\") {\n      try {\n        // Parse form data\n        const formData = await request.formData();\n        const file = formData.get(\"image\");\n        if (!file || typeof file.arrayBuffer !== \"function\") {\n          return new Response(\"No image file provided\", { status: 400 });\n        }\n\n// Read uploaded image as array buffer\n        const fileBuffer = await file.arrayBuffer();\n\n// Fetch image as watermark\n        let watermarkStream = (await env.ASSETS.fetch(assetUrl(request, \"watermark.png\"))).body;\n\n// Apply watermark and convert to AVIF\n        const imageResponse = (\n          await env.IMAGES.input(fileBuffer)\n              // Draw the watermark on top of the image\n              .draw(\n                env.IMAGES.input(watermarkStream)\n                  .transform({ width: 100, height: 100 }),\n                { bottom: 10, right: 10, opacity: 0.75 }\n              )\n              // Output the final image as AVIF\n              .output({ format: \"image/avif\" })\n          ).response();\n      } catch (err) {\n        console.log(err.message)\n      }\n    }\n  }\n};\njs\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, \"name\", { value, configurable: true });\n\nfunction assetUrl(request, path) {\n  const url = new URL(request.url);\n  url.pathname = path;\n  return url;\n}\n__name(assetUrl, \"assetUrl\");\n\nexport default {\n  async fetch(request, env) {\n    if (request.method === \"GET\") {\n      return new Response(html, {headers:{'Content-Type':'text/html'},})\n    }\n    if (request.method === \"POST\") {\n      try {\n        // Parse form data\n        const formData = await request.formData();\n        const file = formData.get(\"image\");\n        if (!file || typeof file.arrayBuffer !== \"function\") {\n          return new Response(\"No image file provided\", { status: 400 });\n        }\n\n// Read uploaded image as array buffer\n        const fileBuffer = await file.arrayBuffer();\n\n// Fetch image as watermark\n        let watermarkStream = (await env.ASSETS.fetch(assetUrl(request, \"watermark.png\"))).body;\n\n// Apply watermark and convert to AVIF\n        const imageResponse = (\n          await env.IMAGES.input(fileBuffer)\n              // Draw the watermark on top of the image\n              .draw(\n                env.IMAGES.input(watermarkStream)\n                  .transform({ width: 100, height: 100 }),\n                { bottom: 10, right: 10, opacity: 0.75 }\n              )\n              // Output the final image as AVIF\n              .output({ format: \"image/avif\" })\n          ).response();\n\n// Add timestamp to file name\n          const fileName = `image-${Date.now()}.avif`;\n\n// Upload to R2\n          await env.R2.put(fileName, imageResponse.body)\n\nreturn new Response(`Image uploaded successfully as ${fileName}`, { status: 200 });\n      } catch (err) {\n        console.log(err.message)\n      }\n    }\n  }\n};\nbash\ncurl --request POST \\\nhttps://api.cloudflare.com/client/v4/accounts/{account_id}/images/v2/direct_upload \\\n--header \"Authorization: Bearer <API_TOKEN>\" \\\n--form 'requireSignedURLs=true' \\\n--form 'metadata={\"key\":\"value\"}'\njson\n{\n  \"result\": {\n    \"id\": \"2cdc28f0-017a-49c4-9ed7-87056c83901\",\n    \"uploadURL\": \"https://upload.imagedelivery.net/Vi7wi5KSItxGFsWRG2Us6Q/2cdc28f0-017a-49c4-9ed7-87056c83901\"\n  },\n  \"result_info\": null,\n  \"success\": true,\n  \"errors\": [],\n  \"messages\": []\n}\nbash\ncurl https://api.cloudflare.com/client/v4/accounts/{account_id}/images/v1/{image_id} \\\n--header \"Authorization: Bearer <API_TOKEN>\"\njson\n{\n  \"result\": {\n    \"id\": \"2cdc28f0-017a-49c4-9ed7-87056c83901\",\n    \"metadata\": {\n      \"key\": \"value\"\n    },\n    \"uploaded\": \"2022-01-31T16:39:28.458Z\",\n    \"requireSignedURLs\": true,\n    \"variants\": [\n      \"https://imagedelivery.net/Vi7wi5KSItxGFsWRG2Us6Q/2cdc28f0-017a-49c4-9ed7-87056c83901/public\",\n      \"https://imagedelivery.net/Vi7wi5KSItxGFsWRG2Us6Q/2cdc28f0-017a-49c4-9ed7-87056c83901/thumbnail\"\n    ],\n    \"draft\": true\n  },\n  \"success\": true,\n  \"errors\": [],\n  \"messages\": []\n}\nhtml\n<!DOCTYPE html>\n<html>\n<body>\n<form\naction=\"INSERT_UPLOAD_URL_HERE\"\nmethod=\"post\"\nenctype=\"multipart/form-data\"\n>\n<input type=\"file\" id=\"myFile\" name=\"file\" />\n<input type=\"submit\" />\n</form>\n</body>\n</html>\ntxt\n--data '{\"expiry\":\"2021-09-14T16:00:00Z\"}'\ntxt\n--form 'id=this/is/my-customid'\nbash\ncurl \"https://api.cloudflare.com/client/v4/accounts/{account_id}/images/v1/batch_token\" \\\n--header \"Authorization: Bearer <API_TOKEN>\"",
  "code_samples": [
    {
      "code": "The command above will output the ID of your Hyperdrive, which you will need to set in the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) for your Workers project:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "This will allow Hyperdrive to generate a dynamic connection string within your Worker that you can pass to your existing database driver. Refer to [Driver examples](#driver-examples) to learn how to set up a database driver with Hyperdrive.\n\nRefer to the [Examples documentation](https://developers.cloudflare.com/hyperdrive/examples/) for step-by-step guides on how to set up Hyperdrive with several popular database providers.\n\n## Supported drivers\n\nHyperdrive uses Workers [TCP socket support](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/#connect) to support TCP connections to databases. The following table lists the supported database drivers and the minimum version that works with Hyperdrive:\n\n| Driver | Documentation | Minimum Version Required | Notes |\n| - | - | - | - |\n| node-postgres - `pg` (recommended) | [node-postgres - `pg` documentation](https://node-postgres.com/) | `pg@8.13.0` | `8.11.4` introduced a bug with URL parsing and will not work. `8.11.5` fixes this. Requires `compatibility_flags = [\"nodejs_compat\"]` and `compatibility_date = \"2024-09-23\"` - refer to [Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs). Requires wrangler `3.78.7` or later. |\n| Postgres.js | [Postgres.js documentation](https://github.com/porsager/postgres) | `postgres@3.4.4` | Supported in both Workers & Pages. |\n| Drizzle | [Drizzle documentation](https://orm.drizzle.team/) | `0.26.2`^ | |\n| Kysely | [Kysely documentation](https://kysely.dev/) | `0.26.3`^ | |\n| [rust-postgres](https://github.com/sfackler/rust-postgres) | [rust-postgres documentation](https://docs.rs/postgres/latest/postgres/) | `v0.19.8` | Use the [`query_typed`](https://docs.rs/postgres/latest/postgres/struct.Client.html#method.query_typed) method for best performance. |\n\n^ *The marked libraries use `node-postgres` as a dependency.*\n\nOther drivers and ORMs not listed may also be supported: this list is not exhaustive.\n\nRecommended driver\n\n[Node-postgres](https://node-postgres.com/) (`pg`) is the recommended driver for connecting to your Postgres database from JavaScript or TypeScript Workers. It has the best compatibility with Hyperdrive's caching and is commonly available with popular ORM libraries. [Postgres.js](https://github.com/porsager/postgres) is also supported.\n\n### Database drivers and Node.js compatibility\n\n[Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) is required for database drivers, including Postgres.js, and needs to be configured for your Workers project.\n\nTo enable both built-in runtime APIs and polyfills for your Worker or Pages project, add the [`nodejs_compat`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag) [compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag) to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/), and set your compatibility date to September 23rd, 2024 or later. This will enable [Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) for your Workers project.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## Driver examples\n\nThe following examples show you how to:\n\n1. Create a database client with a database driver.\n2. Pass the Hyperdrive connection string and connect to the database.\n3. Query your database via Hyperdrive.\n\n### node-postgres / pg\n\nInstall the `node-postgres` driver:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Note\n\nThe minimum version of `node-postgres` required for Hyperdrive is `8.16.3`.\n\nIf using TypeScript, install the types package:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Add the required Node.js compatibility flags and Hyperdrive binding to your `wrangler.jsonc` file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Create a new `Client` instance and pass the Hyperdrive `connectionString`:",
      "language": "unknown"
    },
    {
      "code": "### Postgres.js\n\nThe following Workers code shows you how to use [Postgres.js](https://github.com/porsager/postgres) with Hyperdrive.\n\nInstall [Postgres.js](https://github.com/porsager/postgres):\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Note\n\nThe minimum version of `postgres-js` required for Hyperdrive is `3.4.5`.\n\nAdd the required Node.js compatibility flags and Hyperdrive binding to your `wrangler.jsonc` file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Create a Worker that connects to your PostgreSQL database via Hyperdrive:",
      "language": "unknown"
    },
    {
      "code": "## Identify connections from Hyperdrive\n\nTo identify active connections to your Postgres database server from Hyperdrive:\n\n* Hyperdrive's connections to your database will show up with `Cloudflare Hyperdrive` as the `application_name` in the `pg_stat_activity` table.\n* Run `SELECT DISTINCT usename, application_name FROM pg_stat_activity WHERE application_name = 'Cloudflare Hyperdrive'` to show whether Hyperdrive is currently holding a connection (or connections) open to your database.\n\n## Next steps\n\n* Refer to the list of [supported database integrations](https://developers.cloudflare.com/workers/databases/connecting-to-databases/) to understand other ways to connect to existing databases.\n* Learn more about how to use the [Socket API](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets) in a Worker.\n* Understand the [protocols supported by Workers](https://developers.cloudflare.com/workers/reference/protocols/).\n\n</page>\n\n<page>\n---\ntitle: Metrics and analytics · Cloudflare Hyperdrive docs\ndescription: Hyperdrive exposes analytics that allow you to inspect query\n  volume, query latency and cache ratios size across all and/or each Hyperdrive\n  configuration in your account.\nlastUpdated: 2025-09-03T16:40:54.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/hyperdrive/observability/metrics/\n  md: https://developers.cloudflare.com/hyperdrive/observability/metrics/index.md\n---\n\nHyperdrive exposes analytics that allow you to inspect query volume, query latency and cache ratios size across all and/or each Hyperdrive configuration in your account.\n\n## Metrics\n\nHyperdrive currently exports the below metrics as part of the `hyperdriveQueriesAdaptiveGroups` GraphQL dataset:\n\n| Metric | GraphQL Field Name | Description |\n| - | - | - |\n| Queries | `count` | The number of queries issued against your Hyperdrive in the given time period. |\n| Cache Status | `cacheStatus` | Whether the query was cached or not. Can be one of `disabled`, `hit`, `miss`, `uncacheable`, `multiplestatements`, `notaquery`, `oversizedquery`, `oversizedresult`, `parseerror`, `transaction`, and `volatile`. |\n| Query Bytes | `queryBytes` | The size of your queries, in bytes. |\n| Result Bytes | `resultBytes` | The size of your query *results*, in bytes. |\n| Connection Latency | `connectionLatency` | The time (in milliseconds) required to establish new connections from Hyperdrive to your database, as measured from your Hyperdrive connection pool(s). |\n| Query Latency | `queryLatency` | The time (in milliseconds) required to query (and receive results) from your database, as measured from your Hyperdrive connection pool(s). |\n| Event Status | `eventStatus` | Whether a query responded successfully (`complete`) or failed (`error`). |\n\nMetrics can be queried (and are retained) for the past 31 days.\n\n## View metrics in the dashboard\n\nPer-database analytics for Hyperdrive are available in the Cloudflare dashboard. To view current and historical metrics for a Hyperdrive configuration:\n\n1. In the Cloudflare dashboard, go to the **Hyperdrive** page.\n\n   [Go to **Hyperdrive**](https://dash.cloudflare.com/?to=/:account/workers/hyperdrive)\n\n2. Select an existing Hyperdrive configuration.\n\n3. Select the **Metrics** tab.\n\nYou can optionally select a time window to query. This defaults to the last 24 hours.\n\n## Query via the GraphQL API\n\nYou can programmatically query analytics for your Hyperdrive configurations via the [GraphQL Analytics API](https://developers.cloudflare.com/analytics/graphql-api/). This API queries the same datasets as the Cloudflare dashboard, and supports GraphQL [introspection](https://developers.cloudflare.com/analytics/graphql-api/features/discovery/introspection/).\n\nHyperdrives's GraphQL datasets require an `accountTag` filter with your Cloudflare account ID. Hyperdrive exposes the `hyperdriveQueriesAdaptiveGroups` dataset.\n\n## Write GraphQL queries\n\nExamples of how to explore your Hyperdrive metrics.\n\n### Get the number of queries handled via your Hyperdrive config by cache status",
      "language": "unknown"
    },
    {
      "code": "[Run in GraphQL API Explorer](https://graphql.cloudflare.com/explorer?query=I4VwpgTgngBAElADpAJhAlgNzARXBsAZwAoAoGGAEgEMBjWgexADsAXAFWoHMAuGQ1hmZcAhOSqNmAM3RcAkij4Cho8ZRTVWYVugC2YAMqtqEVn3Z6wYius3bLAUWaKYF-WICUMAN7jM6MAB3SB9xCjpGFlYSGQAbLQg+bxgIpjZOXipUqIyYAF8vXwpimAALJFQMbDxIAMIAQQ1EHWwAcQgmRBIwkphYvXQzGABGAAZx0Z6SuISkqd7JGXkXSkXZBXmSjS0dfQB9LjBgPlsdyyMTVk3i7ft92KOT292wJxRrvPnC68i2a5RLMxCOgGEDQr0FnRSoZjKwQIQPvNPiVkflSHkgA\\&variables=N4IghgxhD2CuB2AXAKmA5iAXCAggYTwHkBVAOWQH0BJAERABoQZ4AzASzSoBMsQAlAKIAFADL4BFAOpVkACWp1GXMIgCmiNgFtVAZURgATol4AmAAwmArAFoAjCesBmM8hMnMJgJwfPALQYgymoa2gLwPNjmVnYOjrbIZgAsPj7+AL5AA)\n\n### Get the average query and connection latency for queries handled via your Hyperdrive config within a range of time, excluding queries that failed due to an error",
      "language": "unknown"
    },
    {
      "code": "[Run in GraphQL API Explorer](https://graphql.cloudflare.com/explorer?query=I4VwpgTgngBAggN0gQwOZgBJQA6QCYQCWSAMsgC5gB2AxoWAM4AUAUDDACTI00D2IVcgBU0ALhgNyRKqgCEbTnyoAzQqgCSecZOlyFHPBTDlCAWzABlcsgjlxQs2HnsDRk+YCiVLTAfn5AJQwAN4KCPQA7pAhCuzcfALkzKoANpQQ4sEw8fyCIqjiXDy5wmgwAL5Boew1MAAWOPhESACK4ESMcIbYJkgA4hD82MyxtTApZoR2MACMAAwLc6O1qemZy2NKqho+HFtqmhu1YEiCVhQgDOIARHym2CnGYNdHNYaU7mAA+ujAhe-GRznWyvdgAz5fR5-TjgxxePCvcobKqvZAIVAxMabXhUKhgGgmHFkSi0KCgmCgSBQYnUGhkrHsJFYpk1FlI8pAA\\&variables=N4IghgxhD2CuB2AXAKmA5iAXCAggYTwHkBVAOWQH0BJAERABoQZ4AzASzSoBMsQAlAKIAFADL4BFAOpVkACWp1GXMIgCmiNgFtVAZURgATol4AmAAwmArAFoAjCesBmM8hMnMJgJwfPALQYgymoa2gLwPNjmVnYOjrbIZgAsPj7+AL5AA)\n\n### Get the total amount of query and result bytes flowing through your Hyperdrive config",
      "language": "unknown"
    },
    {
      "code": "[Run in GraphQL API Explorer](https://graphql.cloudflare.com/explorer?query=I4VwpgTgngBAElADpAJhAlgNzARXNAQQDsUAlMAZxABsAXAISlsoDEB7CAZRAGMfKKAMxp5I6SgAoAUDBgASAIZ82IIrQAqCgOYAuGBVoYiWgIQz5PNkUHotASRR6DR0+bkoFzWugC2YTrQKELR6ACKeYGay7hHefgCiJGERZgCUMADe5pjiAO6QmeaySpaqtBQSNnSQehkwJSpqmrryDWXNMAC+6VmyfTAAFkioGNiiGJQEHoje2ADiECqIFUX9MNS+6CEwAIwADAd7q-1VzBC1x2uW1rYOenLXNvYol-0eXr5gAPpaYMD37zAcX8gWCrz6gOBX2ofwBsU+iReaz6nUuPXBVB8hWR-VAkCgjGYFHBsgglBoDCYlHBqORtJR5lRnSAA\\&variables=N4IghgxhD2CuB2AXAKmA5iAXCAggYTwHkBVAOWQH0BJAERABoQZ4AzASzSoBMsQAlAKIAFADL4BFAOpVkACWp1GXMIgCmiNgFtVAZURgATol4AmAAwmArAFoAjCesBmMwxDK1G7QPg9s5q3YOjrYgAL5AA)\n\n</page>\n\n<page>\n---\ntitle: Troubleshoot and debug · Cloudflare Hyperdrive docs\ndescription: Troubleshoot and debug errors commonly associated with connecting\n  to a database with Hyperdrive.\nlastUpdated: 2025-06-25T13:05:29.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/hyperdrive/observability/troubleshooting/\n  md: https://developers.cloudflare.com/hyperdrive/observability/troubleshooting/index.md\n---\n\nTroubleshoot and debug errors commonly associated with connecting to a database with Hyperdrive.\n\n## Configuration errors\n\nWhen creating a new Hyperdrive configuration, or updating the connection parameters associated with an existing configuration, Hyperdrive performs a test connection to your database in the background before creating or updating the configuration.\n\nHyperdrive will also issue an empty test query, a `;` in PostgreSQL, to validate that it can pass queries to your database.\n\n| Error Code | Details | Recommended fixes |\n| - | - | - |\n| `2008` | Bad hostname. | Hyperdrive could not resolve the database hostname. Confirm it exists in public DNS. |\n| `2009` | The hostname does not resolve to a public IP address, or the IP address is not a public address. | Hyperdrive can only connect to public IP addresses. Private IP addresses, like `10.1.5.0` or `192.168.2.1`, are not currently supported. |\n| `2010` | Cannot connect to the host:port. | Hyperdrive could not route to the hostname: ensure it has a public DNS record that resolves to a public IP address. Check that the hostname is not misspelled. |\n| `2011` | Connection refused. | A network firewall or access control list (ACL) is likely rejecting requests from Hyperdrive. Ensure you have allowed connections from the public Internet. |\n| `2012` | TLS (SSL) not supported by the database. | Hyperdrive requires TLS (SSL) to connect. Configure TLS on your database. |\n| `2013` | Invalid database credentials. | Ensure your username is correct (and exists), and the password is correct (case-sensitive). |\n| `2014` | The specified database name does not exist. | Check that the database (not table) name you provided exists on the database you are asking Hyperdrive to connect to. |\n| `2015` | Generic error. | Hyperdrive failed to connect and could not determine a reason. Open a support ticket so Cloudflare can investigate. |\n| `2016` | Test query failed. | Confirm that the user Hyperdrive is connecting as has permissions to issue read and write queries to the given database. |\n\n### Failure to connect\n\nHyperdrive may also emit `Failed to connect to the provided database` when it fails to connect to the database when attempting to create a Hyperdrive configuration. This is possible when the TLS (SSL) certificates are misconfigured. Here is a non-exhaustive table of potential failure to connect errors:\n\n| Error message | Details | Recommended fixes |\n| - | - | - |\n| Server return error and closed connection. | This message occurs when you attempt to connect to a database that has client certificate verification enabled. | Ensure you are configuring your Hyperdrive with [client certificates](https://developers.cloudflare.com/hyperdrive/configuration/tls-ssl-certificates-for-hyperdrive/) if your database requires them. |\n| TLS handshake failed: cert validation failed. | This message occurs when Hyperdrive has been configured with server CA certificates and is indicating that the certificate provided by the server has not been signed by the expected CA certificate. | Ensure you are using the expected the correct CA certificate for Hyperdrive, or ensure you are connecting to the right database. |\n\n## Connection errors\n\nHyperdrive may also return errors at runtime. This can happen during initial connection setup, or in response to a query or other wire-protocol command sent by your driver.\n\nThese errors are returned as `ErrorResponse` wire protocol messages, which are handled by most drivers by throwing from the responsible query or by triggering an error event. Hyperdrive errors that do not map 1:1 with an error message code [documented by PostgreSQL](https://www.postgresql.org/docs/current/errcodes-appendix.html) use the `58000` error code.\n\nHyperdrive may also encounter `ErrorResponse` wire protocol messages sent by your database. Hyperdrive will pass these errors through unchanged when possible.\n\n### Hyperdrive specific errors\n\n| Error Message | Details | Recommended fixes |\n| - | - | - |\n| `Internal error.` | Something is broken on our side. | Check for an ongoing incident affecting Hyperdrive, and contact Cloudflare Support. Retrying the query is appropriate, if it makes sense for your usage pattern. |\n| `Failed to acquire a connection from the pool.` | Hyperdrive timed out while waiting for a connection to your database, or cannot connect at all. | If you are seeing this error intermittently, your Hyperdrive pool is being exhausted because too many connections are being held open for too long by your worker. This can be caused by a myriad of different issues, but long-running queries/transactions are a common offender. |\n| `Server connection attempt failed: connection_refused` | Hyperdrive is unable to create new connections to your origin database. | A network firewall or access control list (ACL) is likely rejecting requests from Hyperdrive. Ensure you have allowed connections from the public Internet. Sometimes, this can be caused by your database host provider refusing incoming connections when you go over your connection limit. |\n| `Hyperdrive does not currently support MySQL COM_STMT_PREPARE messages` | Hyperdrive does not support prepared statements for MySQL databases. | Remove prepared statements from your MySQL queries. |\n\n### Node errors\n\n| Error Message | Details | Recommended fixes |\n| - | - | - |\n| `Uncaught Error: No such module \"node:<module>\"` | Your Cloudflare Workers project or a library that it imports is trying to access a Node module that is not available. | Enable [Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) for your Cloudflare Workers project to maximize compatibility. |\n\n### Driver errors\n\nIf your queries are not getting cached despite Hyperdrive having caching enabled, your driver may be configured such that your queries are not cacheable by Hyperdrive. This may happen if you are using the [Postgres.js](https://github.com/porsager/postgres) driver with [`prepare: false:`](https://github.com/porsager/postgres?tab=readme-ov-file#prepared-statements). To resolve this, enable prepared statements with `prepare: true`.\n\n| Error Message | Details | Recommended fixes |\n| - | - | - |\n| `Code generation from strings disallowed for this context` | The database driver you are using is attempting to use the `eval()` command, which is unsupported on Cloudflare Workers (common in `mysql2` driver). | Configure the database driver to not use `eval()`. See how to [configure `mysql2` to disable the usage of `eval()`](https://developers.cloudflare.com/hyperdrive/examples/connect-to-mysql/mysql-drivers-and-libraries/mysql2/). |\n\n### Improve performance\n\nHaving query traffic written as transactions can limit performance. This is because in the case of a transaction, the connection must be held for the duration of the transaction, which limits connection multiplexing. If there are multiple queries per transaction, this can be particularly impactful on connection multiplexing. Where possible, we recommend not wrapping queries in transactions to allow the connections to be shared more aggressively.\n\n</page>\n\n<page>\n---\ntitle: Limits · Cloudflare Hyperdrive docs\ndescription: The following limits apply to Hyperdrive configurations,\n  connections, and queries made to your configured origin databases.\nlastUpdated: 2025-12-27T11:04:24.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/hyperdrive/platform/limits/\n  md: https://developers.cloudflare.com/hyperdrive/platform/limits/index.md\n---\n\nThe following limits apply to Hyperdrive configurations, connections, and queries made to your configured origin databases.\n\n## Configuration limits\n\nThese limits apply when creating or updating Hyperdrive configurations.\n\n| Limit | Free | Paid |\n| - | - | - |\n| Maximum configured databases | 10 per account | 25 per account |\n| Maximum username length [1](#user-content-fn-1) | 63 characters (bytes) | 63 characters (bytes) |\n| Maximum database name length [1](#user-content-fn-1) | 63 characters (bytes) | 63 characters (bytes) |\n\n## Connection limits\n\nThese limits apply to connections between Hyperdrive and your origin database.\n\n| Limit | Free | Paid |\n| - | - | - |\n| Initial connection timeout | 15 seconds | 15 seconds |\n| Idle connection timeout | 10 minutes | 10 minutes |\n| Maximum origin database connections (per configuration) [2](#user-content-fn-2) | \\~20 connections | \\~100 connections |\n\nHyperdrive does not limit the number of concurrent client connections from your Workers. However, Hyperdrive limits connections to your origin database because most hosted databases have connection limits.\n\n### Connection errors\n\nWhen Hyperdrive cannot acquire a connection to your origin database, you may see one of the following errors:\n\n| Error message | Cause |\n| - | - |\n| `Failed to acquire a connection from the pool.` | The connection pool is exhausted because connections are held open too long. Long-running queries or transactions are a common cause. |\n| `Server connection attempt failed: connection_refused` | Your origin database is rejecting connections. This can occur when a firewall blocks Hyperdrive, or when your database provider's connection limit is exceeded. |\n\nFor a complete list of error codes, refer to [Troubleshoot and debug](https://developers.cloudflare.com/hyperdrive/observability/troubleshooting/).\n\n## Query limits\n\nThese limits apply to queries sent through Hyperdrive.\n\n| Limit | Free | Paid |\n| - | - | - |\n| Maximum query (statement) duration | 60 seconds | 60 seconds |\n| Maximum cached query response size | 50 MB | 50 MB |\n\nQueries exceeding the maximum duration are terminated. Query responses larger than 50 MB are not cached but are still returned to your Worker.\n\n## Request a limit increase\n\nYou can request adjustments to limits that conflict with your project goals by contacting Cloudflare. Not all limits can be increased.\n\nTo request an increase, submit a [Limit Increase Request form](https://forms.gle/ukpeZVLWLnKeixDu7). You can also ask questions in the Hyperdrive channel on [Cloudflare's Discord community](https://discord.cloudflare.com/).\n\n## Footnotes\n\n1. This is a limit enforced by PostgreSQL. Some database providers may enforce smaller limits. [↩](#user-content-fnref-1) [↩2](#user-content-fnref-1-2)\n\n2. Hyperdrive is a distributed system, so a client may be unable to reach an existing pool. In this scenario, a new pool is established with its own connection allocation. This prioritizes availability over strict limit enforcement, which means connection counts may occasionally exceed the listed limits. [↩](#user-content-fnref-2)\n\n</page>\n\n<page>\n---\ntitle: Pricing · Cloudflare Hyperdrive docs\ndescription: Hyperdrive is included in both the Free and Paid Workers plans.\nlastUpdated: 2025-11-12T15:17:36.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/hyperdrive/platform/pricing/\n  md: https://developers.cloudflare.com/hyperdrive/platform/pricing/index.md\n---\n\nHyperdrive is included in both the Free and Paid [Workers plans](https://developers.cloudflare.com/workers/platform/pricing/).\n\n| | Free plan[1](#user-content-fn-1) | Paid plan |\n| - | - | - |\n| Database queries[2](#user-content-fn-2) | 100,000 / day | Unlimited |\n\nFootnotes\n\n1: The Workers Free plan includes limited Hyperdrive usage. All limits reset daily at 00:00 UTC. If you exceed any one of these limits, further operations of that type will fail with an error.\n\n2: Database queries refers to any database statement made via Hyperdrive, whether a query (`SELECT`), a modification (`INSERT`,`UPDATE`, or `DELETE`) or a schema change (`CREATE`, `ALTER`, `DROP`).\n\n## Footnotes\n\n1. The Workers Free plan includes limited Hyperdrive usage. All limits reset daily at 00:00 UTC. If you exceed any one of these limits, further operations of that type will fail with an error. [↩](#user-content-fnref-1)\n\n2. Database queries refers to any database statement made via Hyperdrive, whether a query (`SELECT`), a modification (`INSERT`,`UPDATE`, or `DELETE`) or a schema change (`CREATE`, `ALTER`, `DROP`). [↩](#user-content-fnref-2)\n\nHyperdrive limits are automatically adjusted when subscribed to a Workers Paid plan. Hyperdrive's [connection pooling and query caching](https://developers.cloudflare.com/hyperdrive/concepts/how-hyperdrive-works/) are included in Workers Paid plan, so do not incur any additional charges.\n\n## Pricing FAQ\n\n### Does connection pooling or query caching incur additional charges?\n\nNo. Hyperdrive's built-in cache and connection pooling are included within the stated plans above. There are no hidden limits other than those [published](https://developers.cloudflare.com/hyperdrive/platform/limits/).\n\n### Are cached queries counted the same as uncached queries?\n\nYes, any query made through Hyperdrive, whether cached or uncached, whether query or mutation, is counted according to the limits above.\n\n### Does Hyperdrive charge for data transfer / egress?\n\nNo.\n\nNote\n\nFor questions about pricing, refer to the [pricing FAQs](https://developers.cloudflare.com/hyperdrive/reference/faq/#pricing).\n\n</page>\n\n<page>\n---\ntitle: Release notes · Cloudflare Hyperdrive docs\ndescription: Subscribe to RSS\nlastUpdated: 2025-03-11T16:58:07.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/hyperdrive/platform/release-notes/\n  md: https://developers.cloudflare.com/hyperdrive/platform/release-notes/index.md\n---\n\n[Subscribe to RSS](https://developers.cloudflare.com/hyperdrive/platform/release-notes/index.xml)\n\n## 2025-12-04\n\n**Connect to remote databases during local development with wrangler dev**\n\nThe `localConnectionString` configuration field and `CLOUDFLARE_HYPERDRIVE_LOCAL_CONNECTION_STRING_<BINDING_NAME>` environment variable now support connecting to remote databases over TLS during local development with `wrangler dev`.\n\nWhen using a remote database connection string, your Worker code runs locally on your machine while connecting directly to the remote database. Hyperdrive caching does not take effect.\n\nRefer to [Local development](https://developers.cloudflare.com/hyperdrive/configuration/local-development/) for instructions on how to configure remote database connections for local development.\n\n## 2025-07-03\n\n**Hyperdrive now supports configurable connection counts**\n\nHyperdrive configurations can now be set to use a specific number of connections to your origin database. There is a minimum of 5 connections for all configurations and a maximum according to your [Workers plan](https://developers.cloudflare.com/hyperdrive/platform/limits/).\n\nThis limit is a soft maximum. Hyperdrive may make more than this amount of connections in the event of unexpected networking issues in order to ensure high availability and resiliency.\n\n## 2025-05-05\n\n**Hyperdrive improves regional caching for prepared statements for faster cache hits**\n\nHyperdrive now better caches prepared statements closer to your Workers. This results in up to 5x faster cache hits by reducing the roundtrips needed between your Worker and Hyperdrive's connection pool.\n\n## 2025-03-07\n\n**Hyperdrive connects to your database using Cloudflare's IP address ranges**\n\nHyperdrive now uses [Cloudflare's IP address ranges](https://www.cloudflare.com/ips/) for egress.\n\nThis enables you to configure the firewall policies on your database to allow access to this limited IP address range.\n\nLearn more about [configuring your database networking for Hyperdrive](https://developers.cloudflare.com/hyperdrive/configuration/firewall-and-networking-configuration/).\n\n## 2025-03-07\n\n**Hyperdrive improves connection pool placement, decreasing query latency by up to 90%**\n\nHyperdrive now pools all database connections in one or more regions as close to your database as possible. This means that your uncached queries and new database connections have up to 90% less latency as measured from Hyperdrive connection pools.\n\nWith improved placement for Hyperdrive connection pools, Workers' Smart Placement is more effective by ensuring that your Worker and Hyperdrive database connection pool are placed as close to your database as possible.\n\nSee [the announcement](https://developers.cloudflare.com/changelog/2025-03-04-hyperdrive-pooling-near-database-and-ip-range-egress/) for more details.\n\n## 2025-01-28\n\n**Hyperdrive automatically configures your Cloudflare Tunnel to connect to your private database.**\n\nWhen creating a Hyperdrive configuration for a private database, you only need to provide your database credentials and set up a Cloudflare Tunnel within the private network where your database is accessible.\n\nHyperdrive will automatically create the Cloudflare Access, Service Token and Policies needed to secure and restrict your Cloudflare Tunnel to the Hyperdrive configuration.\n\nRefer to [documentation on how to configure Hyperdrive to connect to a private database](https://developers.cloudflare.com/hyperdrive/configuration/connect-to-private-database/).\n\n## 2024-12-11\n\n**Hyperdrive now caches queries in all Cloudflare locations decreasing cache hit latency by up to 90%**\n\nHyperdrive query caching now happens in all locations where Hyperdrive can be accessed. When making a query in a location that has cached the query result, your latency may be decreased by up to 90%.\n\nRefer to [documentation on how Hyperdrive caches query results](https://developers.cloudflare.com/hyperdrive/concepts/how-hyperdrive-works/#query-caching).\n\n## 2024-11-19\n\n**Hyperdrive now supports clear-text password authentication**\n\nWhen connecting to a database that requires secure clear-text password authentication over TLS, Hyperdrive will now support this authentication method.\n\nRefer to the documentation to see [all PostgreSQL authentication modes supported by Hyperdrive](https://developers.cloudflare.com/hyperdrive/reference/supported-databases-and-features#supported-postgresql-authentication-modes).\n\n## 2024-10-30\n\n**New Hyperdrive configurations to private databases using Tunnels are validated before creation**\n\nWhen creating a new Hyperdrive configuration to a private database using Tunnels, Hyperdrive will verify that it can connect to the database to ensure that your Tunnel and Access application have been properly configured. This makes it easier to debug connectivity issues.\n\nRefer to [documentation on connecting to private databases](https://developers.cloudflare.com/hyperdrive/configuration/connect-to-private-database/) for more information.\n\n## 2024-09-20\n\n**The \\`node-postgres\\` (pg) driver is now supported for Pages applications using Hyperdrive.**\n\nThe popular `pg` ([node-postgres](https://github.com/brianc/node-postgres) driver no longer requires the legacy `node_compat` mode, and can now be used in both Workers and Pages for connecting to Hyperdrive. This uses the new (improved) Node.js compatibility in Workers and Pages.\n\nYou can set [`compatibility_flags = [\"nodejs_compat_v2\"]`](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) in your `wrangler.toml` or via the Pages dashboard to benefit from this change. Visit the [Hyperdrive documentation on supported drivers](https://developers.cloudflare.com/hyperdrive/examples/connect-to-postgres/#supported-drivers) to learn more about the driver versions supported by Hyperdrive.\n\n## 2024-08-19\n\n**Improved caching for Postgres.js**\n\nHyperdrive now better caches [Postgres.js](https://github.com/porsager/postgres) queries to reduce queries to the origin database.\n\n## 2024-08-13\n\n**Hyperdrive audit logs now available in the Cloudflare Dashboard**\n\nActions that affect Hyperdrive configs in an account will now appear in the audit logs for that account.\n\n## 2024-05-24\n\n**Increased configuration limits**\n\nYou can now create up to 25 Hyperdrive configurations per account, up from the previous maximum of 10.\n\nRefer to [Limits](https://developers.cloudflare.com/hyperdrive/platform/limits/) to review the limits that apply to Hyperdrive.\n\n## 2024-05-22\n\n**Driver performance improvements**\n\nCompatibility improvements to how Hyperdrive interoperates with the popular [Postgres.js](https://github.com/porsager/postgres) driver have been released. These improvements allow queries made via Postgres.js to be correctly cached (when enabled) in Hyperdrive.\n\nDevelopers who had previously set `prepare: false` can remove this configuration when establishing a new Postgres.js client instance.\n\nRead the [documentation on supported drivers](https://developers.cloudflare.com/hyperdrive/examples/connect-to-postgres/#supported-drivers) to learn more about database driver interoperability with Hyperdrive.\n\n## 2024-04-01\n\n**Hyperdrive is now Generally Available**\n\nHyperdrive is now Generally Available and ready for production applications.\n\nRead the [announcement blog](https://blog.cloudflare.com/making-full-stack-easier-d1-ga-hyperdrive-queues) to learn more about the Hyperdrive and the roadmap, including upcoming support for MySQL databases.\n\n## 2024-03-19\n\n**Improved local development configuration**\n\nHyperdrive now supports a `WRANGLER_HYPERDRIVE_LOCAL_CONNECTION_STRING_<BINDING_NAME>` environmental variable for configuring local development to use a test/non-production database, in addition to the `localConnectionString` configuration in `wrangler.toml`.\n\nRefer to [Local development](https://developers.cloudflare.com/hyperdrive/configuration/local-development/) for instructions on how to configure Hyperdrive locally.\n\n## 2023-09-28\n\n**Hyperdrive now available**\n\nHyperdrive is now available in public beta to any developer with a Workers Paid plan.\n\nTo start using Hyperdrive, visit the [get started](https://developers.cloudflare.com/hyperdrive/get-started/) guide or read the [announcement blog](https://blog.cloudflare.com/hyperdrive-making-regional-databases-feel-distributed/) to learn more.\n\n</page>\n\n<page>\n---\ntitle: Choose a data or storage product · Cloudflare Hyperdrive docs\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/hyperdrive/platform/storage-options/\n  md: https://developers.cloudflare.com/hyperdrive/platform/storage-options/index.md\n---\n\n\n</page>\n\n<page>\n---\ntitle: FAQ · Cloudflare Hyperdrive docs\ndescription: Below you will find answers to our most commonly asked questions\n  regarding Hyperdrive.\nlastUpdated: 2025-11-12T15:17:36.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/hyperdrive/reference/faq/\n  md: https://developers.cloudflare.com/hyperdrive/reference/faq/index.md\n---\n\nBelow you will find answers to our most commonly asked questions regarding Hyperdrive.\n\n## Connectivity\n\n### Does Hyperdrive use specific IP addresses to connect to my database?\n\nHyperdrive connects to your database using [Cloudflare's IP address ranges](https://www.cloudflare.com/ips/). These are shared by all Hyperdrive configurations and other Cloudflare products.\n\nYou can use this to configure restrictions in your database firewall to restrict the IP addresses that can access your database.\n\n### Does Hyperdrive support connecting to D1 databases?\n\nHyperdrive does not support [D1](https://developers.cloudflare.com/d1) because D1 provides fast connectivity from Workers by design.\n\nHyperdrive is designed to speed up connectivity to traditional, regional SQL databases such as PostgreSQL. These databases are typically accessed using database drivers that communicate over TCP/IP. Unlike D1, creating a secure database connection to a traditional SQL database involves multiple round trips between the client (your Worker) and your database server. See [How Hyperdrive works](https://developers.cloudflare.com/hyperdrive/concepts/how-hyperdrive-works/) for more detail on why round trips are needed and how Hyperdrive solves this.\n\nD1 does not require round trips to create database connections. D1 is designed to be performant for access from Workers by default, without needing Hyperdrive.\n\n## Pricing\n\n### Does Hyperdrive charge for data transfer / egress?\n\nNo.\n\n### Is Hyperdrive available on the [Workers Free](https://developers.cloudflare.com/workers/platform/pricing/#workers) plan?\n\nYes. Refer to [pricing](https://developers.cloudflare.com/hyperdrive/platform/pricing/).\n\n### Does Hyperdrive charge for additional compute?\n\nHyperdrive itself does not charge for compute (CPU) or processing (wall clock) time. Workers querying Hyperdrive and computing results: for example, serializing results into JSON and/or issuing queries, are billed per [Workers pricing](https://developers.cloudflare.com/workers/platform/pricing/#workers).\n\n## Limits\n\n### Are there any limits to Hyperdrive?\n\nRefer to the published [limits](https://developers.cloudflare.com/hyperdrive/platform/limits/) documentation.\n\n</page>\n\n<page>\n---\ntitle: Supported databases and features · Cloudflare Hyperdrive docs\ndescription: The following table shows which database engines and/or specific\n  database providers are supported.\nlastUpdated: 2025-09-09T08:38:23.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/hyperdrive/reference/supported-databases-and-features/\n  md: https://developers.cloudflare.com/hyperdrive/reference/supported-databases-and-features/index.md\n---\n\n## Database support\n\nThe following table shows which database engines and/or specific database providers are supported.\n\n| Database Engine | Supported | Known supported versions | Details |\n| - | - | - | - |\n| PostgreSQL | ✅ | `9.0` to `17.x` | Both self-hosted and managed (AWS, Azure, Google Cloud, Oracle) instances are supported. |\n| MySQL | ✅ | `5.7` to `8.x` | Both self-hosted and managed (AWS, Azure, Google Cloud, Oracle) instances are supported. MariaDB is also supported. |\n| SQL Server | Not currently supported. | | |\n| MongoDB | Not currently supported. | | |\n\n## Supported database providers\n\nHyperdrive supports managed Postgres and MySQL databases provided by various providers, including AWS, Azure, and GCP. Refer to [Examples](https://developers.cloudflare.com/hyperdrive/examples/connect-to-postgres/) to see how to connect to various database providers.\n\nHyperdrive also supports databases that are compatible with the Postgres or MySQL protocol. The following is a non-exhaustive list of Postgres or MySQL-compatible database providers:\n\n| Database Engine | Supported | Known supported versions | Details |\n| - | - | - | - |\n| AWS Aurora | ✅ | All | Postgres-compatible and MySQL-compatible. Refer to AWS Aurora examples for [MySQL](https://developers.cloudflare.com/hyperdrive/examples/connect-to-mysql/mysql-database-providers/aws-rds-aurora/) and [Postgres](https://developers.cloudflare.com/hyperdrive/examples/connect-to-postgres/postgres-database-providers/aws-rds-aurora/). |\n| Neon | ✅ | All | Neon currently runs Postgres 15.x |\n| Supabase | ✅ | All | Supabase currently runs Postgres 15.x |\n| Timescale | ✅ | All | See the [Timescale guide](https://developers.cloudflare.com/hyperdrive/examples/connect-to-postgres/postgres-database-providers/timescale/) to connect. |\n| Materialize | ✅ | All | Postgres-compatible. Refer to the [Materialize guide](https://developers.cloudflare.com/hyperdrive/examples/connect-to-postgres/postgres-database-providers/materialize/) to connect. |\n| CockroachDB | ✅ | All | Postgres-compatible. Refer to the [CockroachDB](https://developers.cloudflare.com/hyperdrive/examples/connect-to-postgres/postgres-database-providers/cockroachdb/) guide to connect. |\n| PlanetScale | ✅ | All | PlanetScale provides MySQL-compatible and PostgreSQL databases |\n| MariaDB | ✅ | All | MySQL-compatible. |\n\n## Supported TLS (SSL) modes\n\nHyperdrive supports the following [PostgreSQL TLS (SSL)](https://www.postgresql.org/docs/current/libpq-ssl.html) connection modes when connecting to your origin database:\n\n| Mode | Supported | Details |\n| - | - | - |\n| `none` | No | Hyperdrive does not support insecure plain text connections. |\n| `prefer` | No (use `require`) | Hyperdrive will always use TLS. |\n| `require` | Yes (default) | TLS is required, and server certificates are validated (based on WebPKI). |\n| `verify-ca` | Yes | Verifies the server's TLS certificate is signed by a root CA on the client. This ensures the server has a certificate the client trusts. |\n| `verify-full` | Yes | Identical to `verify-ca`, but also requires the database hostname must match a Subject Alternative Name (SAN) present on the certificate. |\n\nRefer to [SSL/TLS certificates](https://developers.cloudflare.com/hyperdrive/configuration/tls-ssl-certificates-for-hyperdrive/) documentation for details on how to configure `verify-ca` or `verify-full` TLS (SSL) modes for Hyperdrive.\n\nNote\n\nHyperdrive support for `verify-ca` and `verify-full` is not available for MySQL (beta).\n\n## Supported PostgreSQL authentication modes\n\nHyperdrive supports the following [authentication modes](https://www.postgresql.org/docs/current/auth-methods.html) for connecting to PostgreSQL databases:\n\n* Password Authentication (`md5`)\n* Password Authentication (`password`) (clear-text password)\n* SASL Authentication (`SCRAM-SHA-256`)\n\n## Unsupported PostgreSQL features:\n\nHyperdrive does not support the following PostgreSQL features:\n\n* SQL-level management of prepared statements, such as using `PREPARE`, `DISCARD`, `DEALLOCATE`, or `EXECUTE`.\n* Advisory locks ([PostgreSQL documentation](https://www.postgresql.org/docs/current/explicit-locking.html#ADVISORY-LOCKS)).\n* `LISTEN` and `NOTIFY`.\n* `PREPARE` and `DEALLOCATE`.\n* Any modification to per-session state not explicitly documented as supported elsewhere.\n\n## Unsupported MySQL features:\n\nHyperdrive does not support the following MySQL features:\n\n* Non-UTF8 characters in queries\n* `USE` statements\n* Multi-statement queries\n* Prepared statement queries via SQL (using `PREPARE` and `EXECUTE` statements) and [protocol-level prepared statements](https://sidorares.github.io/node-mysql2/docs/documentation/prepared-statements).\n* `COM_INIT_DB` messages\n* [Authentication plugins](https://dev.mysql.com/doc/refman/8.4/en/authentication-plugins.html) other than `caching_sha2_password` or `mysql_native_password`\n\nIn cases where you need to issue these unsupported statements from your application, the Hyperdrive team recommends setting up a second, direct client without Hyperdrive.\n\n</page>\n\n<page>\n---\ntitle: Wrangler commands · Cloudflare Hyperdrive docs\ndescription: The following Wrangler commands apply to Hyperdrive.\nlastUpdated: 2025-08-29T13:37:42.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/hyperdrive/reference/wrangler-commands/\n  md: https://developers.cloudflare.com/hyperdrive/reference/wrangler-commands/index.md\n---\n\nThe following [Wrangler commands](https://developers.cloudflare.com/workers/wrangler/) apply to Hyperdrive.\n\n## `hyperdrive create`\n\nCreate a Hyperdrive config\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Hyperdrive config\n\n- `--connection-string` string\n\n  The connection string for the database you want Hyperdrive to connect to - ex: protocol://user:password\\@host:port/database\n\n- `--origin-host` string alias: --host\n\n  The host of the origin database\n\n- `--origin-port` number alias: --port\n\n  The port number of the origin database\n\n- `--origin-scheme` string alias: --scheme default: postgresql\n\n  The scheme used to connect to the origin database\n\n- `--database` string\n\n  The name of the database within the origin database\n\n- `--origin-user` string alias: --user\n\n  The username used to connect to the origin database\n\n- `--origin-password` string alias: --password\n\n  The password used to connect to the origin database\n\n- `--access-client-id` string\n\n  The Client ID of the Access token to use when connecting to the origin database\n\n- `--access-client-secret` string\n\n  The Client Secret of the Access token to use when connecting to the origin database\n\n- `--caching-disabled` boolean\n\n  Disables the caching of SQL responses\n\n- `--max-age` number\n\n  Specifies max duration for which items should persist in the cache, cannot be set when caching is disabled\n\n- `--swr` number\n\n  Indicates the number of seconds cache may serve the response after it becomes stale, cannot be set when caching is disabled\n\n- `--ca-certificate-id` string alias: --ca-certificate-uuid\n\n  Sets custom CA certificate when connecting to origin database. Must be valid UUID of already uploaded CA certificate.\n\n- `--mtls-certificate-id` string alias: --mtls-certificate-uuid\n\n  Sets custom mTLS client certificates when connecting to origin database. Must be valid UUID of already uploaded public/private key certificates.\n\n- `--sslmode` string\n\n  Sets CA sslmode for connecting to database.\n\n- `--origin-connection-limit` number\n\n  The (soft) maximum number of connections that Hyperdrive may establish to the origin database\n\n- `--binding` string\n\n  The binding name of this resource in your Worker\n\n- `--use-remote` boolean\n\n  Use a remote binding when adding the newly created resource to your config\n\n- `--update-config` boolean\n\n  Automatically update your config file with the newly added resource\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n## `hyperdrive delete`\n\nDelete a Hyperdrive config\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[ID]` string required\n\n  The ID of the Hyperdrive config\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n## `hyperdrive get`\n\nGet a Hyperdrive config\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[ID]` string required\n\n  The ID of the Hyperdrive config\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n## `hyperdrive list`\n\nList Hyperdrive configs\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "Global flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n## `hyperdrive update`\n\nUpdate a Hyperdrive config\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[ID]` string required\n\n  The ID of the Hyperdrive config\n\n- `--name` string\n\n  Give your config a new name\n\n- `--connection-string` string\n\n  The connection string for the database you want Hyperdrive to connect to - ex: protocol://user:password\\@host:port/database\n\n- `--origin-host` string alias: --host\n\n  The host of the origin database\n\n- `--origin-port` number alias: --port\n\n  The port number of the origin database\n\n- `--origin-scheme` string alias: --scheme\n\n  The scheme used to connect to the origin database\n\n- `--database` string\n\n  The name of the database within the origin database\n\n- `--origin-user` string alias: --user\n\n  The username used to connect to the origin database\n\n- `--origin-password` string alias: --password\n\n  The password used to connect to the origin database\n\n- `--access-client-id` string\n\n  The Client ID of the Access token to use when connecting to the origin database\n\n- `--access-client-secret` string\n\n  The Client Secret of the Access token to use when connecting to the origin database\n\n- `--caching-disabled` boolean\n\n  Disables the caching of SQL responses\n\n- `--max-age` number\n\n  Specifies max duration for which items should persist in the cache, cannot be set when caching is disabled\n\n- `--swr` number\n\n  Indicates the number of seconds cache may serve the response after it becomes stale, cannot be set when caching is disabled\n\n- `--ca-certificate-id` string alias: --ca-certificate-uuid\n\n  Sets custom CA certificate when connecting to origin database. Must be valid UUID of already uploaded CA certificate.\n\n- `--mtls-certificate-id` string alias: --mtls-certificate-uuid\n\n  Sets custom mTLS client certificates when connecting to origin database. Must be valid UUID of already uploaded public/private key certificates.\n\n- `--sslmode` string\n\n  Sets CA sslmode for connecting to database.\n\n- `--origin-connection-limit` number\n\n  The (soft) maximum number of connections that Hyperdrive may establish to the origin database\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n</page>\n\n<page>\n---\ntitle: Create a serverless, globally distributed time-series API with Timescale\n  · Cloudflare Hyperdrive docs\ndescription: In this tutorial, you will learn to build an API on Workers which\n  will ingest and query time-series data stored in Timescale.\nlastUpdated: 2025-11-12T15:17:36.000Z\nchatbotDeprioritize: false\ntags: Postgres,TypeScript,SQL\nsource_url:\n  html: https://developers.cloudflare.com/hyperdrive/tutorials/serverless-timeseries-api-with-timescale/\n  md: https://developers.cloudflare.com/hyperdrive/tutorials/serverless-timeseries-api-with-timescale/index.md\n---\n\nIn this tutorial, you will learn to build an API on Workers which will ingest and query time-series data stored in [Timescale](https://www.timescale.com/) (they make PostgreSQL faster in the cloud).\n\nYou will create and deploy a Worker function that exposes API routes for ingesting data, and use [Hyperdrive](https://developers.cloudflare.com/hyperdrive/) to proxy your database connection from the edge and maintain a connection pool to prevent us having to make a new database connection on every request.\n\nYou will learn how to:\n\n* Build and deploy a Cloudflare Worker.\n* Use Worker secrets with the Wrangler CLI.\n* Deploy a Timescale database service.\n* Connect your Worker to your Timescale database service with Hyperdrive.\n* Query your new API.\n\nYou can learn more about Timescale by reading their [documentation](https://docs.timescale.com/getting-started/latest/services/).\n\n***\n\n## 1. Create a Worker project\n\nRun the following command to create a Worker project from the command line:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `TypeScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nMake note of the URL that your application was deployed to. You will be using it when you configure your GitHub webhook.\n\nChange into the directory you just created for your Worker project:",
      "language": "unknown"
    },
    {
      "code": "## 2. Prepare your Timescale Service\n\nNote\n\nIf you have not signed up for Timescale, go to the [signup page](https://timescale.com/signup) where you can start a free 30 day trial with no credit card.\n\nIf you are creating a new service, go to the [Timescale Console](https://console.cloud.timescale.com/) and follow these steps:\n\n1. Select **Create Service** by selecting the black plus in the upper right.\n2. Choose **Time Series** as the service type.\n3. Choose your desired region and instance size. 1 CPU will be enough for this tutorial.\n4. Set a service name to replace the randomly generated one.\n5. Select **Create Service**.\n6. On the right hand side, expand the **Connection Info** dialog and copy the **Service URL**.\n7. Copy the password which is displayed. You will not be able to retrieve this again.\n8. Select **I stored my password, go to service overview**.\n\nIf you are using a service you created previously, you can retrieve your service connection information in the [Timescale Console](https://console.cloud.timescale.com/):\n\n1. Select the service (database) you want Hyperdrive to connect to.\n2. Expand **Connection info**.\n3. Copy the **Service URL**. The Service URL is the connection string that Hyperdrive will use to connect. This string includes the database hostname, port number and database name.\n\nNote\n\nIf you do not have your password stored, you will need to select **Forgot your password?** and set a new **SCRAM** password. Save this password, as Timescale will only display it once.\n\nYou should ensure that you do not break any existing clients if when you reset the password.\n\nInsert your password into the **Service URL** as follows (leaving the portion after the @ untouched):",
      "language": "unknown"
    },
    {
      "code": "This will be referred to as **SERVICEURL** in the following sections.\n\n## 3. Create your Hypertable\n\nTimescale allows you to convert regular PostgreSQL tables into [hypertables](https://docs.timescale.com/use-timescale/latest/hypertables/), tables used to deal with time-series, events, or analytics data. Once you have made this change, Timescale will seamlessly manage the hypertable's partitioning, as well as allow you to apply other features like compression or continuous aggregates.\n\nConnect to your Timescale database using the Service URL you copied in the last step (it has the password embedded).\n\nIf you are using the default PostgreSQL CLI tool [**psql**](https://www.timescale.com/blog/how-to-install-psql-on-mac-ubuntu-debian-windows/) to connect, you would run psql like below (substituting your **Service URL** from the previous step). You could also connect using a graphical tool like [PgAdmin](https://www.pgadmin.org/).",
      "language": "unknown"
    },
    {
      "code": "Once you are connected, create your table by pasting the following SQL:",
      "language": "unknown"
    },
    {
      "code": "Timescale will manage the rest for you as you ingest and query data.\n\n## 4. Create a database configuration\n\nTo create a new Hyperdrive instance you will need:\n\n* Your **SERVICEURL** from [step 2](https://developers.cloudflare.com/hyperdrive/tutorials/serverless-timeseries-api-with-timescale/#2-prepare-your-timescale-service).\n* A name for your Hyperdrive service. For this tutorial, you will use **hyperdrive**.\n\nHyperdrive uses the `create` command with the `--connection-string` argument to pass this information. Run it as follows:",
      "language": "unknown"
    },
    {
      "code": "Note\n\nHyperdrive will attempt to connect to your database with the provided credentials to verify they are correct before creating a configuration. If you encounter an error when attempting to connect, refer to Hyperdrive's [troubleshooting documentation](https://developers.cloudflare.com/hyperdrive/observability/troubleshooting/) to debug possible causes.\n\nThis command outputs your Hyperdrive ID. You can now bind your Hyperdrive configuration to your Worker in your Wrangler configuration by replacing the content with the following:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Install the Postgres driver into your Worker project:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Now copy the below Worker code, and replace the current code in `./src/index.ts`. The code below:\n\n1. Uses Hyperdrive to connect to Timescale using the connection string generated from `env.HYPERDRIVE.connectionString` directly to the driver.\n2. Creates a `POST` route which accepts an array of JSON readings to insert into Timescale in one transaction.\n3. Creates a `GET` route which takes a `limit` parameter and returns the most recent readings. This could be adapted to filter by ID or by timestamp.",
      "language": "unknown"
    },
    {
      "code": "## 5. Deploy your Worker\n\nRun the following command to redeploy your Worker:",
      "language": "unknown"
    },
    {
      "code": "Your application is now live and accessible at `timescale-api.<YOUR_SUBDOMAIN>.workers.dev`. The exact URI will be shown in the output of the wrangler command you just ran.\n\nAfter deploying, you can interact with your Timescale IoT readings database using your Cloudflare Worker. Connection from the edge will be faster because you are using Cloudflare Hyperdrive to connect from the edge.\n\nYou can now use your Cloudflare Worker to insert new rows into the `readings` table. To test this functionality, send a `POST` request to your Worker’s URL with the `/readings` path, along with a JSON payload containing the new product data:",
      "language": "unknown"
    },
    {
      "code": "This tutorial omits the `ts` (the timestamp) and `metadata` (the JSON blob) so they will be set to `now()` and `NULL` respectively.\n\nOnce you have sent the `POST` request you can also issue a `GET` request to your Worker’s URL with the `/readings` path. Set the `limit` parameter to control the amount of returned records.\n\nIf you have **curl** installed you can test with the following commands (replace `<YOUR_SUBDOMAIN>` with your subdomain from the deploy command above):",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "In this tutorial, you have learned how to create a working example to ingest and query readings from the edge with Timescale, Workers, Hyperdrive, and TypeScript.\n\n## Next steps\n\n* Learn more about [How Hyperdrive Works](https://developers.cloudflare.com/hyperdrive/concepts/how-hyperdrive-works/).\n* Learn more about [Timescale](https://timescale.com).\n* Refer to the [troubleshooting guide](https://developers.cloudflare.com/hyperdrive/observability/troubleshooting/) to debug common issues.\n\n</page>\n\n<page>\n---\ntitle: Health Checks regions · Cloudflare Health Checks docs\ndescription: Cloudflare has data centers in hundreds of cities worldwide. Health\n  checks do not run from every single of these data centers as this would result\n  in numerous requests to your servers. Instead, you are able to choose between\n  one and thirteen regions from which to run health checks. Cloudflare will run\n  Health Checks from three data centers in each region that you select.\nlastUpdated: 2025-09-17T12:18:58.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/health-checks/concepts/health-checks-regions/\n  md: https://developers.cloudflare.com/health-checks/concepts/health-checks-regions/index.md\n---\n\nCloudflare has data centers in [hundreds of cities worldwide](https://www.cloudflare.com/network/). Health checks do not run from every single of these data centers as this would result in numerous requests to your servers. Instead, you are able to choose between one and thirteen regions from which to run health checks. Cloudflare will run Health Checks from three data centers in each region that you select.\n\nNote\n\nThe exact location of these data centers are subject to change at any moment.\n\nThe Internet is not the same everywhere around the world and your users may not have the same experience on your application according to where they are. Running Health Checks from different regions lets you know the health of your application from the point of view of the Cloudflare network in each of these regions.\n\nIf you select multiple regions or choose **All Regions** (Business and Enterprise Only), you may increase traffic to your servers. Each region sends individual health checks from three data centers.\n\n</page>\n\n<page>\n---\ntitle: Health Checks notifications · Cloudflare Health Checks docs\ndescription: You can configure notification emails to be alerted when the Health\n  Check detects that there is a change in the status of your origin server.\n  Cloudflare will send you an email within seconds so you can take the necessary\n  action before customers are impacted.\nlastUpdated: 2025-10-06T13:41:54.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/health-checks/how-to/health-checks-notifications/\n  md: https://developers.cloudflare.com/health-checks/how-to/health-checks-notifications/index.md\n---\n\nYou can [configure notification emails](https://developers.cloudflare.com/health-checks/how-to/health-checks-notifications/#configure-notifications) to be alerted when the Health Check detects that there is a change in the status of your origin server. Cloudflare will send you an email within seconds so you can take the necessary action before customers are impacted.\n\nThe email provides information to determine what caused the health status change. You can evaluate when the change happened, the status of the origin server, if and why it is unhealthy, the expected response code, and the received response code.\n\n## Configure notifications\n\n1. In the Cloudflare dashboard, go to the **Health Checks** page.\n\n   [Go to **Health Checks**](https://dash.cloudflare.com/?to=/:account/:zone/traffic/health-checks)\n\n2. Select **Configure an alert**.\n\n3. Fill out the **Notification name** and **Description**.\n\n4. Add a Notification email.\n\n5. Select **Next**.\n\n6. Add health checks to include in your alerts.\n\n7. Choose the **Notification trigger**, which determines when you receive alerts.\n\n8. Select **Create**.\n\nNote\n\nA notification is only sent after a change of status in the majority of all selected region(s).\n\nFor a single region, this will be 2 of 3 data centers. With 13 regions selected, this will be 7 of 13 regions.\n\nSee [common error codes](https://developers.cloudflare.com/health-checks/health-checks-analytics/#common-error-codes) for more information regarding the cause of any changes to your Health Check.\n\nCloudflare encourages you to view your [Health Checks Analytics](https://developers.cloudflare.com/health-checks/health-checks-analytics/#common-error-codes) to get more context about the health of your servers over time.\n\n</page>\n\n<page>\n---\ntitle: Zone lockdown migration guide · Cloudflare Health Checks docs\ndescription: Currently, any Cloudflare customer on a paid plan can configure\n  Health Checks against any host or IP. Zone Lockdown specifies a list of one or\n  more IP addresses, CIDR ranges, or networks that are the only IPs allowed to\n  access a domain, subdomain, or URL. It allows multiple destinations in a\n  single rule as well as IPv4 and IPv6 addresses. IP addresses not specified in\n  the Zone Lockdown rule are denied access to the specified resources.\nlastUpdated: 2025-09-17T12:18:58.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/health-checks/how-to/zone-lockdown/\n  md: https://developers.cloudflare.com/health-checks/how-to/zone-lockdown/index.md\n---\n\nCurrently, any Cloudflare customer on a paid plan can configure Health Checks against any host or IP. [Zone Lockdown](https://developers.cloudflare.com/waf/tools/zone-lockdown/) specifies a list of one or more IP addresses, CIDR ranges, or networks that are the only IPs allowed to access a domain, subdomain, or URL. It allows multiple destinations in a single rule as well as IPv4 and IPv6 addresses. IP addresses not specified in the Zone Lockdown rule are denied access to the specified resources.\n\nCustomers who use zone lockdown and want their health checks to continue passing can use [WAF custom rules](https://developers.cloudflare.com/waf/custom-rules/create-dashboard/) to bypass zone lockdown.\n\n## Bypass zone lockdown\n\nTo bypass zone lockdown using a WAF custom rule:\n\n1. Follow the steps to [create a custom rule in the dashboard](https://developers.cloudflare.com/waf/custom-rules/create-dashboard/).\n\n2. Create a custom rule matching on **user agent**.\n\n   Cloudflare Health Checks have a user agent of the following format: `Mozilla/5.0 (compatible;Cloudflare-Healthchecks/1.0;+https://www.cloudflare.com/; healthcheck-id: XXX)` where `XXX` is replaced with the first 16 characters of the Health Check ID.\n\n   To allow a specific Health Check, verify if the user agent contains the first 16 characters of the Health Check ID.\n\n3. Set the action to *Skip* and the corresponding feature to **Zone Lockdown** under **More components to skip**.\n\n### Via the API\n\nThis example adds a new WAF custom rule to the ruleset with ID `{ruleset_id}` that skips zone lockdown for incoming requests with a user agent containing `1234567890abcdef`:",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Transcode images · Cloudflare Images docs\ndescription: Transcode an image from Workers AI before uploading to R2\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/examples/transcode-from-workers-ai/\n  md: https://developers.cloudflare.com/images/examples/transcode-from-workers-ai/index.md\n---",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Watermarks · Cloudflare Images docs\ndescription: Draw a watermark from KV on an image from R2\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/examples/watermark-from-kv/\n  md: https://developers.cloudflare.com/images/examples/watermark-from-kv/index.md\n---",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Apply blur · Cloudflare Images docs\ndescription: You can apply blur to image variants by creating a specific variant\n  for this effect first or by editing a previously created variant. Note that\n  you cannot blur an SVG file.\nlastUpdated: 2025-11-17T14:08:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/manage-images/blur-variants/\n  md: https://developers.cloudflare.com/images/manage-images/blur-variants/index.md\n---\n\nYou can apply blur to image variants by creating a specific variant for this effect first or by editing a previously created variant. Note that you cannot blur an SVG file.\n\nRefer to [Resize images](https://developers.cloudflare.com/images/manage-images/create-variants/) for help creating variants. You can also refer to the API to learn how to use blur using flexible variants.\n\nTo blur an image:\n\n1. In the Cloudflare dashboard, got to the **Hosted Images** page.\n\n   [Go to **Hosted images**](https://dash.cloudflare.com/?to=/:account/images/hosted)\n\n2. Select the **Delivery** tab.\n\n3. Find the variant you want to blur and select **Edit** > **Customization Options**.\n\n4. Use the slider to adjust the blurring effect. You can use the preview image to see how strong the blurring effect will be.\n\n5. Select **Save**.\n\nThe image should now display the blurred effect.\n\n</page>\n\n<page>\n---\ntitle: Browser TTL · Cloudflare Images docs\ndescription: Browser TTL controls how long an image stays in a browser's cache\n  and specifically configures the cache-control response header.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/manage-images/browser-ttl/\n  md: https://developers.cloudflare.com/images/manage-images/browser-ttl/index.md\n---\n\nBrowser TTL controls how long an image stays in a browser's cache and specifically configures the `cache-control` response header.\n\n### Default TTL\n\nBy default, an image's TTL is set to two days to meet user needs, such as re-uploading an image under the same [Custom ID](https://developers.cloudflare.com/images/upload-images/upload-custom-path/).\n\n## Custom setting\n\nYou can use two custom settings to control the Browser TTL, an account or a named variant. To adjust how long a browser should keep an image in the cache, set the TTL in seconds, similar to how the `max-age` header is set. The value should be an interval between one hour to one year.\n\n### Browser TTL for an account\n\nSetting the Browser TTL per account overrides the default TTL.",
      "language": "unknown"
    },
    {
      "code": "When the Browser TTL is set to one year for all images, the response for the `cache-control` header is essentially `public`, `max-age=31536000`, `stale-while-revalidate=7200`.\n\n### Browser TTL for a named variant\n\nSetting the Browser TTL for a named variant is a more granular option that overrides all of the above when creating or updating an image variant, specifically the `browser_ttl` option in seconds.",
      "language": "unknown"
    },
    {
      "code": "When the Browser TTL is set to one day for images requested with this variant, the response for the `cache-control` header is essentially `public`, `max-age=86400`, `stale-while-revalidate=7200`.\n\nNote\n\n[Private images](https://developers.cloudflare.com/images/manage-images/serve-images/serve-private-images/) do not respect default or custom TTL settings. The private images cache time is set according to the expiration time and can be as short as one hour.\n\n</page>\n\n<page>\n---\ntitle: Configure webhooks · Cloudflare Images docs\ndescription: You can set up webhooks to receive notifications about your upload\n  workflow. This will send an HTTP POST request to a specified endpoint when an\n  image either successfully uploads or fails to upload.\nlastUpdated: 2025-09-05T07:54:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/manage-images/configure-webhooks/\n  md: https://developers.cloudflare.com/images/manage-images/configure-webhooks/index.md\n---\n\nYou can set up webhooks to receive notifications about your upload workflow. This will send an HTTP POST request to a specified endpoint when an image either successfully uploads or fails to upload.\n\nCurrently, webhooks are supported only for [direct creator uploads](https://developers.cloudflare.com/images/upload-images/direct-creator-upload/).\n\nTo receive notifications for direct creator uploads:\n\n1. In the Cloudflare dashboard, go to the **Notifications** pages.\n\n   [Go to **Notifications**](https://dash.cloudflare.com/?to=/:account/notifications)\n\n2. Select **Destinations**.\n\n3. From the Webhooks card, select **Create**.\n\n4. Enter information for your webhook and select **Save and Test**. The new webhook will appear in the **Webhooks** card and can be attached to notifications.\n\n5. Next, go to **Notifications** > **All Notifications** and select **Add**.\n\n6. Under the list of products, locate **Images** and select **Select**.\n\n7. Give your notification a name and optional description.\n\n8. Under the **Webhooks** field, select the webhook that you recently created.\n\n9. Select **Save**.\n\n</page>\n\n<page>\n---\ntitle: Create variants · Cloudflare Images docs\ndescription: Variants let you specify how images should be resized for different\n  use cases. By default, images are served with a public variant, but you can\n  create up to 100 variants to fit your needs. Follow these steps to create a\n  variant.\nlastUpdated: 2025-11-17T14:08:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/manage-images/create-variants/\n  md: https://developers.cloudflare.com/images/manage-images/create-variants/index.md\n---\n\nVariants let you specify how images should be resized for different use cases. By default, images are served with a `public` variant, but you can create up to 100 variants to fit your needs. Follow these steps to create a variant.\n\nNote\n\nCloudflare Images can deliver SVG files but will not resize them because it is an inherently scalable format. Resize via the Cloudflare dashboard.\n\n1. In the Cloudflare dashboard, got to the **Hosted Images** page.\n\n   [Go to **Hosted images**](https://dash.cloudflare.com/?to=/:account/images/hosted)\n\n2. Select the **Delivery** tab.\n\n3. Select **Create variant**.\n\n4. Name your variant and select **Create**.\n\n5. Define variables for your new variant, such as resizing options, type of fit, and specific metadata options.\n\n## Resize via the API\n\nMake a `POST` request to [create a variant](https://developers.cloudflare.com/api/resources/images/subresources/v1/subresources/variants/methods/create/).",
      "language": "unknown"
    },
    {
      "code": "## Fit options\n\nThe `Fit` property describes how the width and height dimensions should be interpreted. The chart below describes each of the options.\n\n| Fit Options | Behavior |\n| - | - |\n| Scale down | The image is shrunk in size to fully fit within the given width or height, but will not be enlarged. |\n| Contain | The image is resized (shrunk or enlarged) to be as large as possible within the given width or height while preserving the aspect ratio. |\n| Cover | The image is resized to exactly fill the entire area specified by width and height and will be cropped if necessary. |\n| Crop | The image is shrunk and cropped to fit within the area specified by the width and height. The image will not be enlarged. For images smaller than the given dimensions, it is the same as `scale-down`. For images larger than the given dimensions, it is the same as `cover`. |\n| Pad | The image is resized (shrunk or enlarged) to be as large as possible within the given width or height while preserving the aspect ratio. The extra area is filled with a background color (white by default). |\n\n## Metadata options\n\nVariants allow you to choose what to do with your image’s metadata information. From the **Metadata** dropdown, choose:\n\n* Strip all metadata\n* Strip all metadata except copyright\n* Keep all metadata\n\n## Public access\n\nWhen the **Always allow public access** option is selected, particular variants will always be publicly accessible, even when images are made private through the use of [signed URLs](https://developers.cloudflare.com/images/manage-images/serve-images/serve-private-images).\n\n</page>\n\n<page>\n---\ntitle: Delete images · Cloudflare Images docs\ndescription: You can delete an image from the Cloudflare Images storage using\n  the dashboard or the API.\nlastUpdated: 2025-11-17T14:08:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/manage-images/delete-images/\n  md: https://developers.cloudflare.com/images/manage-images/delete-images/index.md\n---\n\nYou can delete an image from the Cloudflare Images storage using the dashboard or the API.\n\n## Delete images via the Cloudflare dashboard\n\n1. In the Cloudflare dashboard, go to **Transformations** page.\n\n   [Go to **Transformations**](https://dash.cloudflare.com/?to=/:account/images/transformations)\n\n2. Find the image you want to remove and select **Delete**.\n\n3. (Optional) To delete more than one image, select the checkbox next to the images you want to delete and then **Delete selected**.\n\nYour image will be deleted from your account.\n\n## Delete images via the API\n\nMake a `DELETE` request to the [delete image endpoint](https://developers.cloudflare.com/api/resources/images/subresources/v1/methods/delete/). `{image_id}` must be fully URL encoded in the API call URL.",
      "language": "unknown"
    },
    {
      "code": "After the image has been deleted, the response returns `\"success\": true`.\n\n</page>\n\n<page>\n---\ntitle: Delete variants · Cloudflare Images docs\ndescription: You can delete variants via the Images dashboard or API. The only\n  variant you cannot delete is public.\nlastUpdated: 2025-11-17T14:08:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/manage-images/delete-variants/\n  md: https://developers.cloudflare.com/images/manage-images/delete-variants/index.md\n---\n\nYou can delete variants via the Images dashboard or API. The only variant you cannot delete is public.\n\nWarning\n\nDeleting a variant is a global action that will affect other images that contain that variant.\n\n## Delete variants via the Cloudflare dashboard\n\n1. In the Cloudflare dashboard, got to the **Hosted Images** page.\n\n   [Go to **Hosted images**](https://dash.cloudflare.com/?to=/:account/images/hosted)\n\n2. Select the **Delivery** tab.\n\n3. Find the variant you want to remove and select **Delete**.\n\n## Delete variants via the API\n\nMake a `DELETE` request to the delete variant endpoint.",
      "language": "unknown"
    },
    {
      "code": "After the variant has been deleted, the response returns `\"success\": true.`\n\n</page>\n\n<page>\n---\ntitle: Edit images · Cloudflare Images docs\ndescription: \"The Edit option provides you available options to modify a\n  specific image. After choosing to edit an image, you can:\"\nlastUpdated: 2025-11-17T14:08:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/manage-images/edit-images/\n  md: https://developers.cloudflare.com/images/manage-images/edit-images/index.md\n---\n\nThe Edit option provides you available options to modify a specific image. After choosing to edit an image, you can:\n\n* Require signed URLs to use with that particular image.\n* Use a cURL command you can use as an example to access the image.\n* Use fully-formed URLs for all the variants configured in your account.\n\nTo edit an image:\n\n1. In the Cloudflare dashboard, go to the **Transformations** page.\n\n   [Go to **Transformations**](https://dash.cloudflare.com/?to=/:account/images/transformations)\n\n2. Locate the image you want to modify and select **Edit**.\n\n</page>\n\n<page>\n---\ntitle: Enable flexible variants · Cloudflare Images docs\ndescription: Flexible variants allow you to create variants with dynamic\n  resizing which can provide more options than regular variants allow. This\n  option is not enabled by default.\nlastUpdated: 2025-12-15T15:19:35.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/manage-images/enable-flexible-variants/\n  md: https://developers.cloudflare.com/images/manage-images/enable-flexible-variants/index.md\n---\n\nFlexible variants allow you to create variants with dynamic resizing which can provide more options than regular variants allow. This option is not enabled by default.\n\n## Enable flexible variants via the Cloudflare dashboard\n\n1. In the Cloudflare dashboard, got to the **Hosted Images** page.\n\n   [Go to **Hosted images**](https://dash.cloudflare.com/?to=/:account/images/hosted)\n\n2. Select the **Delivery** tab.\n\n3. Enable **Flexible variants**.\n\n## Enable flexible variants via the API\n\nMake a `PATCH` request to the [Update a variant endpoint](https://developers.cloudflare.com/api/resources/images/subresources/v1/subresources/variants/methods/edit/).",
      "language": "unknown"
    },
    {
      "code": "After activation, you can use [transformation parameters](https://developers.cloudflare.com/images/transform-images/transform-via-url/#options) on any Cloudflare image. For example,\n\n`https://imagedelivery.net/{account_hash}/{image_id}/w=400,sharpen=3`\n\nNote\n\nFlexible variants cannot be used for images that require a [signed delivery URL](https://developers.cloudflare.com/images/manage-images/serve-images/serve-private-images).\n\n</page>\n\n<page>\n---\ntitle: Export images · Cloudflare Images docs\ndescription: Cloudflare Images supports image exports via the Cloudflare\n  dashboard and API which allows you to get the original version of your image.\nlastUpdated: 2025-11-17T14:08:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/manage-images/export-images/\n  md: https://developers.cloudflare.com/images/manage-images/export-images/index.md\n---\n\nCloudflare Images supports image exports via the Cloudflare dashboard and API which allows you to get the original version of your image.\n\n## Export images via the Cloudflare dashboard\n\n1. In the Cloudflare dashboard, go to the **Transformations** page.\n\n   [Go to **Transformations**](https://dash.cloudflare.com/?to=/:account/images/transformations)\n\n2. Find the image or images you want to export.\n\n3. To export a single image, select **Export** from its menu. To export several images, select the checkbox next to each image and then select **Export selected**.\n\nYour images are downloaded to your machine.\n\n## Export images via the API\n\nMake a `GET` request as shown in the example below. `<IMAGE_ID>` must be fully URL encoded in the API call URL.\n\n`GET accounts/<ACCOUNT_ID>/images/v1/<IMAGE_ID>/blob`\n\n</page>\n\n<page>\n---\ntitle: Serve images · Cloudflare Images docs\nlastUpdated: 2024-08-30T16:09:27.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/images/manage-images/serve-images/\n  md: https://developers.cloudflare.com/images/manage-images/serve-images/index.md\n---\n\n* [Serve uploaded images](https://developers.cloudflare.com/images/manage-images/serve-images/serve-uploaded-images/)\n* [Serve images from custom domains](https://developers.cloudflare.com/images/manage-images/serve-images/serve-from-custom-domains/)\n* [Serve private images](https://developers.cloudflare.com/images/manage-images/serve-images/serve-private-images/)\n\n</page>\n\n<page>\n---\ntitle: Changelog · Cloudflare Images docs\ndescription: Subscribe to RSS\nlastUpdated: 2025-02-13T19:35:19.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/platform/changelog/\n  md: https://developers.cloudflare.com/images/platform/changelog/index.md\n---\n\n[Subscribe to RSS](https://developers.cloudflare.com/images/platform/changelog/index.xml)\n\n## 2024-04-04\n\n**Images upload widget**\n\nUse the upload widget to integrate Cloudflare Images into your application by embedding the script into a static HTML page or installing a package that works with your preferred framework. To try out the upload widget, [sign up for the closed beta](https://forms.gle/vBu47y3638k8fkGF8).\n\n## 2024-04-04\n\n**Face cropping**\n\nCrop and resize images of people's faces at scale using the existing gravity parameter and saliency detection, which sets the focal point of an image based on the most visually interesting pixels. To apply face cropping to your image optimization, [sign up for the closed beta](https://forms.gle/2bPbuijRoqGi6Qn36).\n\n## 2024-01-15\n\n**Cloudflare Images and Images Resizing merge**\n\nCloudflare Images and Images Resizing merged to create a more centralized and unified experience for Cloudflare Images. To learn more about the merge, refer to the [blog post](https://blog.cloudflare.com/merging-images-and-image-resizing/).\n\n</page>\n\n<page>\n---\ntitle: Activate Polish · Cloudflare Images docs\ndescription: Images in the cache must be purged or expired before seeing any\n  changes in Polish settings.\nlastUpdated: 2025-10-02T09:01:53.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/polish/activate-polish/\n  md: https://developers.cloudflare.com/images/polish/activate-polish/index.md\n---\n\nImages in the [cache must be purged](https://developers.cloudflare.com/cache/how-to/purge-cache/) or expired before seeing any changes in Polish settings.\n\nWarning\n\nDo not activate Polish and [image transformations](https://developers.cloudflare.com/images/transform-images/) simultaneously. Image transformations already apply lossy compression, which makes Polish redundant.\n\n1. In the Cloudflare dashboard, go to the **Account home** page.\n\n   [Go to **Account home**](https://dash.cloudflare.com/?to=/:account/home)\n\n2. Select the domain where you want to activate Polish.\n\n3. Select ****Speed** > **Settings**** > **Image Optimization**.\n\n4. Under **Polish**, select *Lossy* or *Lossless* from the drop-down menu. [*Lossy*](https://developers.cloudflare.com/images/polish/compression/#lossy) gives greater file size savings.\n\n5. (Optional) Select **WebP**. Enable this option if you want to further optimize PNG and JPEG images stored in the origin server, and serve them as WebP files to browsers that support this format.\n\nTo ensure WebP is not served from cache to a browser without WebP support, disable any WebP conversion utilities at your origin web server when using Polish.\n\nNote\n\nTo use this feature on specific hostnames - instead of across your entire zone - use a [configuration rule](https://developers.cloudflare.com/rules/configuration-rules/).\n\n</page>\n\n<page>\n---\ntitle: Cf-Polished statuses · Cloudflare Images docs\ndescription: Learn about Cf-Polished statuses in Cloudflare Images. Understand\n  how to handle missing headers, optimize image formats, and troubleshoot common\n  issues.\nlastUpdated: 2025-04-02T16:11:44.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/polish/cf-polished-statuses/\n  md: https://developers.cloudflare.com/images/polish/cf-polished-statuses/index.md\n---\n\nIf a `Cf-Polished` header is not returned, try [using single-file cache purge](https://developers.cloudflare.com/cache/how-to/purge-cache) to purge the image. The `Cf-Polished` header may also be missing if the origin is sending non-image `Content-Type`, or non-cacheable `Cache-Control`.\n\n* `input_too_large`: The input image is too large or complex to process, and needs a lower resolution. Cloudflare recommends using PNG or JPEG images that are less than 4,000 pixels in any dimension, and smaller than 20 MB.\n* `not_compressed` or `not_needed`: The image was fully optimized at the origin server and no compression was applied.\n* `webp_bigger`: Polish attempted to convert to WebP, but the WebP image was not better than the original format. Because the WebP version does not exist, the status is set on the JPEG/PNG version of the response. Refer to [the reasons why Polish chooses not to use WebP](https://developers.cloudflare.com/images/polish/no-webp/).\n* `cannot_optimize` or `internal_error`: The input image is corrupted or incomplete at the origin server. Upload a new version of the image to the origin server.\n* `format_not_supported`: The input image format is not supported (for example, BMP or TIFF) or the origin server is using additional optimization software that is not compatible with Polish. Try converting the input image to a web-compatible format (like PNG or JPEG) and/or disabling additional optimization software at the origin server.\n* `vary_header_present`: The origin web server has sent a `Vary` header with a value other than `accept-encoding`. If the origin web server is attempting to support WebP, disable WebP at the origin web server and let Polish perform the WebP conversion. Polish will still work if `accept-encoding` is the only header listed within the `Vary` header. Polish skips image URLs processed by [Cloudflare Images](https://developers.cloudflare.com/images/transform-images/).\n\n</page>\n\n<page>\n---\ntitle: Polish compression · Cloudflare Images docs\ndescription: Learn about Cloudflare's Polish compression options, including\n  Lossless, Lossy, and WebP, to optimize image file sizes while managing\n  metadata effectively.\nlastUpdated: 2025-04-02T16:11:44.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/polish/compression/\n  md: https://developers.cloudflare.com/images/polish/compression/index.md\n---\n\nWith Lossless and Lossy modes, Cloudflare attempts to strip as much metadata as possible. However, Cloudflare cannot guarantee stripping all metadata because other factors, such as caching status, might affect which metadata is finally sent in the response.\n\nWarning\n\nPolish may not be applied to origin responses that contain a `Vary` header. The only accepted `Vary` header is `Vary: Accept-Encoding`.\n\n## Compression options\n\n### Off\n\nPolish is disabled and no compression is applied. Disabling Polish does not revert previously polished images to original, until they expire or are purged from the cache.\n\n### Lossless\n\nThe Lossless option attempts to reduce file sizes without changing any of the image pixels, keeping images identical to the original. It removes most metadata, like EXIF data, and losslessly recompresses image data. JPEG images may be converted to progressive format. On average, lossless compression reduces file sizes by 21 percent compared to unoptimized image files.\n\nThe Lossless option prevents conversion of JPEG to WebP, because this is always a lossy operation.\n\n### Lossy\n\nThe Lossy option applies significantly better compression to images than the Lossless option, at a cost of small quality loss. When uncompressed, some of the redundant information from the original image is lost. On average, using Lossy mode reduces file sizes by 48 percent.\n\nThis option also removes metadata from images. The Lossy option mainly affects JPEG images, but PNG images may also be compressed in a lossy way, or converted to JPEG when this improves compression.\n\n### WebP\n\nWhen enabled, in addition to other optimizations, Polish creates versions of images converted to the WebP format.\n\nWebP compression is quite effective on PNG images, reducing file sizes by approximately 26 percent. It may reduce file sizes of JPEG images by around 17 percent, but this [depends on several factors](https://developers.cloudflare.com/images/polish/no-webp/). WebP is supported in all browsers except for Internet Explorer and KaiOS. You can learn more in our [blog post](https://blog.cloudflare.com/a-very-webp-new-year-from-cloudflare/).\n\nThe WebP version is served only when the `Accept` header from the browser includes WebP, and the WebP image is significantly smaller than the lossy or lossless recompression of the original format:",
      "language": "unknown"
    },
    {
      "code": "Polish only converts standard image formats *to* the WebP format. If the origin server serves WebP images, Polish will not convert them, and will not optimize them.\n\n#### File size, image quality, and WebP\n\nLossy formats like JPEG and WebP are able to generate files of any size, and every image could theoretically be made smaller. However, reduction in file size comes at a cost of reduction in image quality. Reduction of file sizes below each format's optimal size limit causes disproportionally large losses in quality. Re-encoding of files that are already optimized reduces their quality more than it reduces their file size.\n\nCloudflare will not convert from JPEG to WebP when the conversion would make the file bigger, or would reduce image quality by more than it would save in file size.\n\nIf you choose the Lossless Polish setting, then WebP will be used very rarely. This is due to the fact that, in this mode, WebP is only adequate for PNG images, and cannot improve compression for JPEG images.\n\nAlthough WebP compresses better than JPEG on average, there are exceptions, and in some occasions JPEG compresses better than WebP. Cloudflare tries to detect these cases and keep the JPEG format.\n\nIf you serve low-quality JPEG images at the origin (quality setting 60 or lower), it may not be beneficial to convert them to WebP. This is because low-quality JPEG images have blocky edges and noise caused by compression, and these distortions increase file size of WebP images. We recommend serving high-quality JPEG images (quality setting between 80 and 90) at your origin server to avoid this issue.\n\nIf your server or Content Management System (CMS) has a built-in image converter or optimizer, it may interfere with Polish. It does not make sense to apply lossy optimizations twice to images, because quality degradation will be larger than the savings in file size.\n\n## Polish interaction with Image optimization\n\nPolish will not be applied to URLs using image transformations. Resized images already have lossy compression applied where possible, so they do not need the optimizations provided by Polish. Use the `format=auto` option to allow use of WebP and AVIF formats.\n\n</page>\n\n<page>\n---\ntitle: WebP may be skipped · Cloudflare Images docs\ndescription: >-\n  Polish avoids converting images to the WebP format when such conversion would\n  increase the file size, or significantly degrade image quality.\n\n  Polish also optimizes JPEG images, and the WebP format is not always better\n  than a well-optimized JPEG.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/polish/no-webp/\n  md: https://developers.cloudflare.com/images/polish/no-webp/index.md\n---\n\nPolish avoids converting images to the WebP format when such conversion would increase the file size, or significantly degrade image quality. Polish also optimizes JPEG images, and the WebP format is not always better than a well-optimized JPEG.\n\nTo enhance the use of WebP in Polish, enable the [Lossy option](https://developers.cloudflare.com/images/polish/compression/#lossy). When you create new JPEG images, save them with a slightly higher quality than usually necessary. We recommend JPEG quality settings between 85 and 95, but not higher. This gives Polish enough headroom for lossy conversion to WebP and optimized JPEG.\n\n## In the **lossless** mode, it is not feasible to convert JPEG to WebP\n\nWebP is actually a name for two quite different image formats: WebP-lossless (similar to PNG) and WebP-VP8 (similar to JPEG).\n\nWhen the [Lossless option](https://developers.cloudflare.com/images/polish/compression/#lossless) is enabled, Polish will not perform any optimizations that change image pixels. This allows Polish to convert only between lossless image formats, such as PNG, GIF, and WebP-lossless. JPEG images will not be converted though, because the WebP-VP8 format does not support the conversion from JPEG without quality loss, and the WebP-lossless format does not compress images as heavily as JPEG.\n\nIn the lossless mode, Polish can still apply lossless optimizations to JPEG images. This is a unique feature of the JPEG format that does not have an equivalent in WebP.\n\n## Low-quality JPEG images do not convert well to WebP\n\nWhen JPEG files are already heavily compressed (for example, saved with a low quality setting like `q=50`, or re-saved many times), the conversion to WebP may not be beneficial, and may actually increase the file size. This is because lossy formats add distortions to images (for example, JPEG makes images blocky and adds noise around sharp edges), and the WebP format can not tell the difference between details of the image it needs to preserve and unwanted distortions caused by a previous compression. This forces WebP to wastefully use bytes on keeping the added noise and blockyness, which increases the file size, and makes compression less beneficial overall.\n\nPolish never makes files larger. When we see that the conversion to WebP increases the file size, we skip it, and keep the smaller original file format.\n\n## For some images conversion to WebP can degrade quality too much\n\nThe WebP format, in its more efficient VP8 mode, always loses some quality when compressing images. This means that the conversion from JPEG always makes WebP images look slightly worse. Polish ensures that file size savings from the conversion outweigh the quality loss.\n\nLossy WebP has a significant limitation: it can only keep one shade of color per 4 pixels. The color information is always stored at half of the image resolution. In high-resolution photos this degradation is rarely noticeable. However, in images with highly saturated colors and sharp edges, this limitation can result in the WebP format having noticeably pixelated or smudged edges.\n\nAdditionally, the WebP format applies smoothing to images. This feature hides blocky distortions that are a characteristic of low-quality JPEG images, but on the other hand it can cause loss of fine textures and details in high-quality images, making them look airbrushed.\n\nPolish tries to avoid degrading images for too little gain. Polish keeps the JPEG format when it has about the same size as WebP, but better quality.\n\n## Sometimes older formats are better than WebP\n\nThe WebP format has an advantage over JPEG when saving images with soft or blurry content, and when using low quality settings. WebP has fewer advantages when storing high-quality images with fine textures or noise. Polish applies optimizations to JPEG images too, and sometimes well-optimized JPEG is simply better than WebP, and gives a better quality and smaller file size at the same time. We try to detect these cases, and keep the JPEG format when it works better. Sometimes animations with little motion are more efficient as GIF than animated WebP.\n\nThe WebP format does not support progressive rendering. With [HTTP/2 prioritization](https://developers.cloudflare.com/speed/optimization/protocol/enhanced-http2-prioritization/) enabled, progressive JPEG images may appear to load quicker, even if their file sizes are larger.\n\n## Beware of compression that is not better, only more of the same\n\nWith a lossy format like JPEG or WebP, it is always possible to take an existing image, save it with a slightly lower quality, and get an image that looks *almost* the same, but has a smaller file size. It is the [heap paradox](https://en.wikipedia.org/wiki/Sorites_paradox): you can remove a grain of sand from a heap, and still have a heap of sand. There is no point when you can not make the heap smaller, except when there is no sand left. It is always possible to make an image with a slightly lower quality, all the way until all the accumulated losses degrade the image beyond recognition.\n\nAvoid applying multiple lossy optimization tools to images, before or after Polish. Multiple lossy operations degrade quality disproportionally more than what they save in file sizes.\n\nFor this reason Polish will not create the smallest possible file sizes. Instead, Polish aims to maximize the quality to file size ratio, to create the smallest possible files while preserving good quality. The quality level we stop at is carefully chosen to minimize visual distortion, while still having a high compression ratio.\n\n</page>\n\n<page>\n---\ntitle: Troubleshooting · Cloudflare Images docs\ndescription: \"Does the response have a Cf-Resized header? If not, then resizing\n  has not been attempted. Possible causes:\"\nlastUpdated: 2025-10-30T11:07:38.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/reference/troubleshooting/\n  md: https://developers.cloudflare.com/images/reference/troubleshooting/index.md\n---\n\n## Requests without resizing enabled\n\nDoes the response have a `Cf-Resized` header? If not, then resizing has not been attempted. Possible causes:\n\n* The feature is not enabled in the Cloudflare Dashboard.\n* There is another Worker running on the same request. Resizing is \"forgotten\" as soon as one Worker calls another. Do not use Workers scoped to the entire domain `/*`.\n* Preview in the Editor in Cloudflare Dashboard does not simulate image resizing. You must deploy the Worker and test from another browser tab instead.\n\n***\n\n## Error responses from resizing\n\nWhen resizing fails, the response body contains an error message explaining the reason, as well as the `Cf-Resized` header containing `err=code`:\n\n* 9401 — The required arguments in `{cf:image{…}}` options are missing or are invalid. Try again. Refer to [Fetch options](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options) for supported arguments.\n* 9402 — The image was too large or the connection was interrupted. Refer to [Supported formats and limitations](https://developers.cloudflare.com/images/transform-images/) for more information.\n* 9403 — A [request loop](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#prevent-request-loops) occurred because the image was already resized or the Worker fetched its own URL. Verify your Worker path and image path on the server do not overlap.\n* 9406 & 9419 — The image URL is a non-HTTPS URL or the URL has spaces or unescaped Unicode. Check your URL and try again.\n* 9407 — A lookup error occurred with the origin server's domain name. Check your DNS settings and try again.\n* 9404 — The image does not exist on the origin server or the URL used to resize the image is wrong. Verify the image exists and check the URL.\n* 9408 — The origin server returned an HTTP 4xx status code and may be denying access to the image. Confirm your image settings and try again.\n* 9509 — The origin server returned an HTTP 5xx status code. This is most likely a problem with the origin server-side software, not the resizing.\n* 9412 — The origin server returned a non-image, for example, an HTML page. This usually happens when an invalid URL is specified or server-side software has printed an error or presented a login page.\n* 9413 — The image exceeds the maximum image area of 100 megapixels. Use a smaller image and try again.\n* 9420 — The origin server redirected to an invalid URL. Confirm settings at your origin and try again.\n* 9421 — The origin server redirected too many times. Confirm settings at your origin and try again.\n* 9422 - The transformation request is rejected because the usage limit was reached. If you need to request more than 5,000 unique transformations, upgrade to an Images Paid plan.\n* 9432 — The Images Binding is not available using legacy billing. Your account is using the legacy Image Resizing subscription. To bind Images to your Worker, you will need to update your plan to the Images subscription in the dashboard.\n* 9504, 9505, & 9510 — The origin server could not be contacted because the origin server may be down or overloaded. Try again later.\n* 9523 — The `/cdn-cgi/image/` resizing service could not perform resizing. This may happen when an image has invalid format. Use correctly formatted image and try again.\n* 9524 — The `/cdn-cgi/image/` resizing service could not perform resizing. This may happen when an image URL is intercepted by a Worker. As an alternative you can [resize within the Worker](https://developers.cloudflare.com/images/transform-images/transform-via-workers/). This can also happen when using a `pages.dev` URL of a [Cloudflare Pages](https://developers.cloudflare.com/pages/) project. In that case, you can use a [Custom Domain](https://developers.cloudflare.com/pages/configuration/custom-domains/) instead.\n* 9520 — The image format is not supported. Refer to [Supported formats and limitations](https://developers.cloudflare.com/images/transform-images/) to learn about supported input and output formats.\n* 9522 — The image exceeded the processing limit. This may happen briefly after purging an entire zone or when files with very large dimensions are requested. If the problem persists, contact support.\n* 9529 - The image timed out while processing. This may happen when files with very large dimensions are requested or the server is overloaded.\n* 9422, 9424, 9516, 9517, 9518, 9522 & 9523 — Internal errors. Please contact support if you encounter these errors.\n\n***\n\n## Limits\n\nThese are the limits for images that are stored outside of Images:\n\n* Maximum image size is 100 megapixels (for example, 10,000×10,000 pixels large). Maximum file size is 70 megabytes (MB). GIF/WebP animations are limited to 50 megapixels total (sum of sizes of all frames).\n* Image Resizing is not compatible with [Bring Your Own IP (BYOIP)](https://developers.cloudflare.com/byoip/).\n* When Polish can't optimize an image the Response Header `Warning: cf-images 299 \"original is smaller\"` is returned.\n\n***\n\n## Authorization and cookies are not supported\n\nImage requests to the origin will be anonymized (no cookies, no auth, no custom headers). This is because we have to have one public cache for resized images, and it would be unsafe to share images that are personalized for individual visitors.\n\nHowever, in cases where customers agree to store such images in public cache, Cloudflare supports resizing images through Workers [on authenticated origins](https://developers.cloudflare.com/images/transform-images/transform-via-workers/).\n\n***\n\n## Caching and purging\n\nChanges to image dimensions or other resizing options always take effect immediately — no purging necessary.\n\nImage requests consists of two parts: running Worker code, and image processing. The Worker code is always executed and uncached. Results of image processing are cached for one hour or longer if origin server's `Cache-Control` header allows. Source image is cached using regular caching rules. Resizing follows redirects internally, so the redirects are cached too.\n\nBecause responses from Workers themselves are not cached at the edge, purging of *Worker URLs* does nothing. Resized image variants are cached together under their source’s URL. When purging, use the (full-size) source image’s URL, rather than URLs of the Worker that requested resizing.\n\nIf the origin server sends an `Etag` HTTP header, the resized images will have an `Etag` HTTP header that has a format `cf-<gibberish>:<etag of the original image>`. You can compare the second part with the `Etag` header of the source image URL to check if the resized image is up to date.\n\n</page>\n\n<page>\n---\ntitle: Security · Cloudflare Images docs\ndescription: To further ensure the security and efficiency of image optimization\n  services, you can adopt Cloudflare products that safeguard against malicious\n  activities.\nlastUpdated: 2025-04-03T20:17:30.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/reference/security/\n  md: https://developers.cloudflare.com/images/reference/security/index.md\n---\n\nTo further ensure the security and efficiency of image optimization services, you can adopt Cloudflare products that safeguard against malicious activities.\n\nCloudflare security products like [Cloudflare WAF](https://developers.cloudflare.com/waf/), [Cloudflare Bot Management](https://developers.cloudflare.com/bots/get-started/bot-management/) and [Cloudflare Rate Limiting](https://developers.cloudflare.com/waf/rate-limiting-rules/) can enhance the protection of your image optimization requests against abuse. This proactive approach ensures a reliable and efficient experience for all legitimate users.\n\n</page>\n\n<page>\n---\ntitle: Bind to Workers API · Cloudflare Images docs\ndescription: A binding connects your Worker to external resources on the\n  Developer Platform, like Images, R2 buckets, or KV Namespaces.\nlastUpdated: 2025-07-24T15:34:32.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/transform-images/bindings/\n  md: https://developers.cloudflare.com/images/transform-images/bindings/index.md\n---\n\nA [binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/) connects your [Worker](https://developers.cloudflare.com/workers/) to external resources on the Developer Platform, like [Images](https://developers.cloudflare.com/images/transform-images/transform-via-workers/), [R2 buckets](https://developers.cloudflare.com/r2/buckets/), or [KV Namespaces](https://developers.cloudflare.com/kv/concepts/kv-namespaces/).\n\nYou can bind the Images API to your Worker to transform, resize, and encode images without requiring them to be accessible through a URL.\n\nFor example, when you allow Workers to interact with Images, you can:\n\n* Transform an image, then upload the output image directly into R2 without serving to the browser.\n* Optimize an image stored in R2 by passing the blob of bytes representing the image, instead of fetching the public URL for the image.\n* Resize an image, overlay the output over a second image as a watermark, then resize this output into a final result.\n\nBindings can be configured in the Cloudflare dashboard for your Worker or in the `wrangler.toml` file in your project's directory.\n\n## Setup\n\nThe Images binding is enabled on a per-Worker basis.\n\nYou can define variables in the `wrangler.toml` file of your Worker project's directory. These variables are bound to external resources at runtime, and you can then interact with them through this variable.\n\nTo bind Images to your Worker, add the following to the end of your `wrangler.toml` file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Within your Worker code, you can interact with this binding by using `env.IMAGES.input()` to build an object that can manipulate the image (passed as a `ReadableStream`).\n\n## Methods\n\n### `.transform()`\n\n* Defines how an image should be optimized and manipulated through [parameters](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options) such as `width`, `height`, and `blur`.\n\n### `.draw()`\n\n* Allows [drawing an image](https://developers.cloudflare.com/images/transform-images/draw-overlays/) over another image.\n* The drawn image can be a stream, or another image returned from `.input()` that has been manipulated.\n* The overlaid image can be manipulated using `opacity`, `repeat`, `top`, `left`, `bottom`, and `right`. To apply other parameters, you can pass a child `.transform()` function inside this method.\n\nFor example, to draw a resized watermark on an image:",
      "language": "unknown"
    },
    {
      "code": "### `.output()`\n\n* Defines the [output format](https://developers.cloudflare.com/images/transform-images/) for the transformed image such as AVIF, WebP, and JPEG.\n* Image [quality](https://developers.cloudflare.com/images/transform-images/transform-via-url/#quality) can be altered by specifying `quality` on a 1-100 scale.\n\nFor example, to rotate, resize, and blur an image, then output the image as AVIF:",
      "language": "unknown"
    },
    {
      "code": "### `.info()`\n\n* Outputs information about the image, such as `format`, `fileSize`, `width`, and `height`.\n\nResponses from the Images binding are not automatically cached. Workers lets you interact directly with the Cache API to customize cache behavior using Workers. You can implement logic in your script to store transformations in Cloudflare’s cache.\n\n## Interact with your Images binding locally\n\nThe Images API can be used in local development through [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), the command-line interface for Workers. Using the Images binding in local development will not incur usage charges.\n\nWrangler supports two different versions of the Images API:\n\n* A high-fidelity version that supports all features that are available through the Images API. This is the same version that Cloudflare runs globally in production.\n* A low-fidelity offline version that supports only a subset of features, such as resizing and rotation.\n\nTo test the high-fidelity version of Images, you can run `wrangler dev`:",
      "language": "unknown"
    },
    {
      "code": "This creates a local-only environment that mirrors the production environment where Cloudflare runs the Images API. You can test your Worker with all available transformation features before deploying to production.\n\nTo test the low-fidelity offline version of Images, add the `--experimental-images-local-mode` flag:",
      "language": "unknown"
    },
    {
      "code": "Currently, this version supports only `width`, `height`, `rotate`, and `format`.\n\nWhen testing with the [Workers Vitest integration](https://developers.cloudflare.com/workers/testing/vitest-integration/), the low-fidelity offline version is used by default, to avoid hitting the Cloudflare API in tests.\n\n</page>\n\n<page>\n---\ntitle: Control origin access · Cloudflare Images docs\ndescription: You can serve resized images without giving access to the original\n  image. Images can be hosted on another server outside of your zone, and the\n  true source of the image can be entirely hidden. The origin server may require\n  authentication to disclose the original image, without needing visitors to be\n  aware of it. Access to the full-size image may be prevented by making it\n  impossible to manipulate resizing parameters.\nlastUpdated: 2025-10-24T20:47:24.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/transform-images/control-origin-access/\n  md: https://developers.cloudflare.com/images/transform-images/control-origin-access/index.md\n---\n\nYou can serve resized images without giving access to the original image. Images can be hosted on another server outside of your zone, and the true source of the image can be entirely hidden. The origin server may require authentication to disclose the original image, without needing visitors to be aware of it. Access to the full-size image may be prevented by making it impossible to manipulate resizing parameters.\n\nAll these behaviors are completely customizable, because they are handled by custom code of a script running [on the edge in a Cloudflare Worker](https://developers.cloudflare.com/images/transform-images/transform-via-workers/).",
      "language": "unknown"
    },
    {
      "code": "This code will be run for every request, but the source code will not be accessible to website visitors. This allows the code to perform security checks and contain secrets required to access the images in a controlled manner.\n\nThe examples below are only suggestions, and do not have to be followed exactly. You can compute image URLs and resizing options in many other ways.\n\nWarning\n\nWhen testing image transformations, make sure you deploy the script and test it from a regular web browser window. The preview in the dashboard does not simulate transformations.\n\n## Hiding the image server",
      "language": "unknown"
    },
    {
      "code": "## Preventing access to full-size images\n\nOn top of protecting the original image URL, you can also validate that only certain image sizes are allowed:",
      "language": "unknown"
    },
    {
      "code": "## Avoid image dimensions in URLs\n\nYou do not have to include actual pixel dimensions in the URL. You can embed sizes in the Worker script, and select the size in some other way — for example, by naming a preset in the URL:",
      "language": "unknown"
    },
    {
      "code": "## Authenticated origin\n\nCloudflare image transformations cache resized images to aid performance. Images stored with restricted access are generally not recommended for resizing because sharing images customized for individual visitors is unsafe. However, in cases where the customer agrees to store such images in public cache, Cloudflare supports resizing images through Workers. At the moment, this is supported on authenticated AWS, Azure, Google Cloud, SecureAuth origins and origins behind Cloudflare Access.",
      "language": "unknown"
    },
    {
      "code": "When using this code, the following headers are passed through to the origin, and allow your request to be successful:\n\n* `Authorization`\n* `Cookie`\n* `x-amz-content-sha256`\n* `x-amz-date`\n* `x-ms-date`\n* `x-ms-version`\n* `x-sa-date`\n* `cf-access-client-id`\n* `cf-access-client-secret`\n\nFor more information, refer to:\n\n* [AWS docs](https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html)\n* [Azure docs](https://docs.microsoft.com/en-us/rest/api/storageservices/List-Containers2#request-headers)\n* [Google Cloud docs](https://cloud.google.com/storage/docs/aws-simple-migration)\n* [Cloudflare Zero Trust docs](https://developers.cloudflare.com/cloudflare-one/access-controls/service-credentials/service-tokens/)\n* [SecureAuth docs](https://docs.secureauth.com/2104/en/authentication-api-guide.html)\n\n</page>\n\n<page>\n---\ntitle: Integrate with frameworks · Cloudflare Images docs\ndescription: Image transformations can be used automatically with the Next.js\n  <Image /> component.\nlastUpdated: 2025-11-20T15:35:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/transform-images/integrate-with-frameworks/\n  md: https://developers.cloudflare.com/images/transform-images/integrate-with-frameworks/index.md\n---\n\n## Next.js\n\nImage transformations can be used automatically with the Next.js [`<Image />` component](https://nextjs.org/docs/api-reference/next/image).\n\nTo use image transformations, define a global image loader or multiple custom loaders for each `<Image />` component.\n\nNext.js will request the image with the correct parameters for width and quality.\n\nImage transformations will be responsible for caching and serving an optimal format to the client.\n\n### Global Loader\n\nTo use Images with **all** your app's images, define a global [loaderFile](https://nextjs.org/docs/pages/api-reference/components/image#loaderfile) for your app.\n\nAdd the following settings to the **next.config.js** file located at the root our your Next.js application.",
      "language": "unknown"
    },
    {
      "code": "Next, create the `imageLoader.ts` file in the specified path (relative to the root of your Next.js application).",
      "language": "unknown"
    },
    {
      "code": "### Custom Loaders\n\nAlternatively, define a loader for each `<Image />` component.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nFor local development, you can enable [Resize images from any origin checkbox](https://developers.cloudflare.com/images/get-started/) for your zone. Then, replace `/cdn-cgi/image/${paramsString}/${normalizeSrc(src)}` with an absolute URL path:\n\n`https://<YOUR_DOMAIN.COM>/cdn-cgi/image/${paramsString}/${normalizeSrc(src)}`\n\n</page>\n\n<page>\n---\ntitle: Draw overlays and watermarks · Cloudflare Images docs\ndescription: You can draw additional images on top of a resized image, with\n  transparency and blending effects. This enables adding of watermarks, logos,\n  signatures, vignettes, and other effects to resized images.\nlastUpdated: 2025-04-07T16:12:42.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/transform-images/draw-overlays/\n  md: https://developers.cloudflare.com/images/transform-images/draw-overlays/index.md\n---\n\nYou can draw additional images on top of a resized image, with transparency and blending effects. This enables adding of watermarks, logos, signatures, vignettes, and other effects to resized images.\n\nThis feature is available only in [Workers](https://developers.cloudflare.com/images/transform-images/transform-via-workers/). To draw overlay images, add an array of drawing commands to options of `fetch()` requests. The drawing options are nested in `options.cf.image.draw`, like in the following example:",
      "language": "unknown"
    },
    {
      "code": "## Draw options\n\nThe `draw` property is an array. Overlays are drawn in the order they appear in the array (the last array entry is the topmost layer). Each item in the `draw` array is an object, which can have the following properties:\n\n* `url`\n\n  * Absolute URL of the image file to use for the drawing. It can be any of the supported file formats. For drawing watermarks or non-rectangular overlays, Cloudflare recommends that you use PNG or WebP images.\n\n* `width` and `height`\n\n  * Maximum size of the overlay image, in pixels. It must be an integer.\n\n* `fit` and `gravity`\n\n  * Affects interpretation of `width` and `height`. Same as [for the main image](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options).\n\n* `opacity`\n\n  * Floating-point number between `0` (transparent) and `1` (opaque). For example, `opacity: 0.5` makes overlay semitransparent.\n\n* `repeat`\n\n  * If set to `true`, the overlay image will be tiled to cover the entire area. This is useful for stock-photo-like watermarks.\n  * If set to `\"x\"`, the overlay image will be tiled horizontally only (form a line).\n  * If set to `\"y\"`, the overlay image will be tiled vertically only (form a line).\n\n* `top`, `left`, `bottom`, `right`\n\n  * Position of the overlay image relative to a given edge. Each property is an offset in pixels. `0` aligns exactly to the edge. For example, `left: 10` positions left side of the overlay 10 pixels from the left edge of the image it is drawn over. `bottom: 0` aligns bottom of the overlay with bottom of the background image.\n\n    Setting both `left` and `right`, or both `top` and `bottom` is an error.\n\n    If no position is specified, the image will be centered.\n\n* `background`\n\n  * Background color to add underneath the overlay image. Same as [for the main image](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options).\n\n* `rotate`\n\n  * Number of degrees to rotate the overlay image by. Same as [for the main image](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#fetch-options).\n\n## Draw using the Images binding\n\nWhen [interacting with Images through a binding](https://developers.cloudflare.com/images/transform-images/bindings/), the Images API supports a `.draw()` method.\n\nThe accepted options for the overlaid image are `opacity`, `repeat`, `top`, `left`, `bottom`, and `right`.",
      "language": "unknown"
    },
    {
      "code": "To apply [parameters](https://developers.cloudflare.com/images/transform-images/transform-via-workers/) to the overlaid image, you can pass a child `.transform()` function inside the `.draw()` request.\n\nIn the example below, the watermark is manipulated with `rotate` and `width` before being drawn over the base image with the `opacity` and `rotate` options.",
      "language": "unknown"
    },
    {
      "code": "## Examples\n\n### Stock Photo Watermark",
      "language": "unknown"
    },
    {
      "code": "### Signature",
      "language": "unknown"
    },
    {
      "code": "### Centered icon",
      "language": "unknown"
    },
    {
      "code": "### Combined\n\nMultiple operations can be combined in one image:",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Make responsive images · Cloudflare Images docs\ndescription: Learn how to serve responsive images using HTML srcset and\n  width=auto for optimal display on various devices. Ideal for high-DPI and\n  fluid layouts.\nlastUpdated: 2025-04-07T16:12:42.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/transform-images/make-responsive-images/\n  md: https://developers.cloudflare.com/images/transform-images/make-responsive-images/index.md\n---\n\nYou can serve responsive images in two different ways:\n\n* Use the HTML `srcset` feature to allow browsers to choose the most optimal image. This is the most reliable solution to serve responsive images.\n* Use the `width=auto` option to serve the most optimal image based on the available browser and device information. This is a server-side solution that is supported only by Chromium-based browsers.\n\n## Transform with HTML `srcset`\n\nThe `srcset` [feature of HTML](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images) allows browsers to automatically choose an image that is best suited for user’s screen resolution.\n\n`srcset` requires providing multiple resized versions of every image, and with Cloudflare’s image transformations this is an easy task to accomplish.\n\nThere are two different scenarios where it is useful to use `srcset`:\n\n* Images with a fixed size in terms of CSS pixels, but adapting to high-DPI screens (also known as Retina displays). These images take the same amount of space on the page regardless of screen size, but are sharper on high-resolution displays. This is appropriate for icons, thumbnails, and most images on pages with fixed-width layouts.\n* Responsive images that stretch to fill a certain percentage of the screen (usually full width). This is best for hero images and pages with fluid layouts, including pages using media queries to adapt to various screen sizes.\n\n### `srcset` for high-DPI displays\n\nFor high-DPI display you need two versions of every image. One for `1x` density, suitable for typical desktop displays (such as HD/1080p monitors or low-end laptops), and one for `2x` high-density displays used by almost all mobile phones, high-end laptops, and 4K desktop displays. Some mobile phones have very high-DPI displays and could use even a `3x` resolution. However, while the jump from `1x` to `2x` is a clear improvement, there are diminishing returns from increasing the resolution further. The difference between `2x` and `3x` is visually insignificant, but `3x` files are two times larger than `2x` files.\n\nAssuming you have an image `product.jpg` in the `assets` folder and you want to display it at a size of `960px`, the code is as follows:",
      "language": "unknown"
    },
    {
      "code": "In the URL path used in this example, the `src` attribute is for images with the usual \"1x\" density. `/cdn-cgi/image/` is a special path for resizing images. This is followed by `width=960` which resizes the image to have a width of 960 pixels. `/assets/product.jpg` is a URL to the source image on the server.\n\nThe `srcset` attribute adds another, high-DPI image. The browser will automatically select between the images in the `src` and `srcset`. In this case, specifying `width=1920` (two times 960 pixels) and adding `2x` at the end, informs the browser that this is a double-density image. It will be displayed at the same size as a 960 pixel image, but with double the number of pixels which will make it look twice as sharp on high-DPI displays.\n\nNote that it does not make sense to scale images up for use in `srcset`. That would only increase file sizes without improving visual quality. The source images you should use with `srcset` must be high resolution, so that they are only scaled down for `1x` displays, and displayed as-is or also scaled down for `2x` displays.\n\n### `srcset` for responsive images\n\nWhen you want to display an image that takes a certain percentage of the window or screen width, the image should have dimensions that are appropriate for a visitor’s screen size. Screen sizes vary a lot, typically from 320 pixels to 3840 pixels, so there is not a single image size that fits all cases. With `<img srcset>` you can offer the browser several possible sizes and let it choose the most appropriate size automatically.\n\nBy default, the browser assumes the image will be stretched to the full width of the screen, and will pick a size that is closest to a visitor’s screen size. In the `src` attribute the browser will pick any size that is a good fallback for older browsers that do not understand `srcset`.",
      "language": "unknown"
    },
    {
      "code": "In the previous case, the number followed by `x` described *screen* density. In this case the number followed by `w` describes the *image* size. There is no need to specify screen density here (`2x`, etc.), because the browser automatically takes it into account and picks a higher-resolution image when necessary.\n\nIf the image is not displayed at full width of the screen (or browser window), you have two options:\n\n* If the image is displayed at full width of a fixed-width column, use the first technique that uses one specific image size.\n* If it takes a specific percentage of the screen, or stretches to full width only sometimes (using CSS media queries), then add the `sizes` attribute as described below.\n\n#### The `sizes` attribute\n\nIf the image takes 50% of the screen (or window) width:",
      "language": "unknown"
    },
    {
      "code": "The `vw` unit is a percentage of the viewport (screen or window) width. If the image can have a different size depending on media queries or other CSS properties, such as `max-width`, then specify all the conditions in the `sizes` attribute:",
      "language": "unknown"
    },
    {
      "code": "In this example, `sizes` says that for screens smaller than 640 pixels the image is displayed at full viewport width; on all larger screens the image stays at 640px. Note that one of the options in `srcset` is 1280 pixels, because an image displayed at 640 CSS pixels may need twice as many image pixels on a high-dpi (`2x`) display.\n\n## WebP images\n\n`srcset` is useful for pixel-based formats such as PNG, JPEG, and WebP. It is unnecessary for vector-based SVG images.\n\nHTML also [supports the `<picture>` element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture) that can optionally request an image in the WebP format, but you do not need it. Cloudflare can serve WebP images automatically whenever you use `/cdn-cgi/image/format=auto` URLs in `src` or `srcset`.\n\nIf you want to use WebP images, but do not need resizing, you have two options:\n\n* You can enable the automatic [WebP conversion in Polish](https://developers.cloudflare.com/images/polish/activate-polish/). This will convert all images on the site.\n* Alternatively, you can change specific image paths on the site to start with `/cdn-cgi/image/format=auto/`. For example, change `https://example.com/assets/hero.jpg` to `https://example.com/cdn-cgi/image/format=auto/assets/hero.jpg`.\n\n## Transform with `width` parameter\n\nWhen setting up a [transformation URL](https://developers.cloudflare.com/images/transform-images/transform-via-url/#width), you can apply the `width=auto` option to serve the most optimal image based on the available information about the user's browser and device.\n\nThis method can serve multiple sizes from a single URL. Currently, images will be served in one of four sizes:\n\n* 1200 (large desktop/monitor)\n* 960 (desktop)\n* 768 (tablet)\n* 320 (mobile)\n\nEach width is counted as a separate transformation. For example, if you use `width=auto` and the image is delivered with a width of 320px to one user and 960px to another user, then this counts as two unique transformations.\n\nBy default, this feature uses information from the user agent, which detects the platform type (for example, iOS or Android) and browser.\n\n### Client hints\n\nFor more accurate results, you can use client hints to send the user's browser information as request headers.\n\nThis method currently works only on Chromium-based browsers such as Chrome, Edge, and Opera.\n\nYou can enable client hints via HTML by adding the following tag in the `<head>` tag of your page before any other elements:",
      "language": "unknown"
    },
    {
      "code": "Replace `https://example.com` with your Cloudflare zone where transformations are enabled.\n\nAlternatively, you can enable client hints via HTTP by adding the following headers to your HTML page's response:",
      "language": "unknown"
    },
    {
      "code": "Replace `https://example.com` with your Cloudflare zone where transformations are enabled.\n\n</page>\n\n<page>\n---\ntitle: Preserve Content Credentials · Cloudflare Images docs\ndescription: Content Credentials (or C2PA metadata) are a type of metadata that\n  includes the full provenance chain of a digital asset. This provides\n  information about an image's creation, authorship, and editing flow. This data\n  is cryptographically authenticated and can be verified using an open-source\n  verification service.\nlastUpdated: 2025-02-03T14:37:08.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/transform-images/preserve-content-credentials/\n  md: https://developers.cloudflare.com/images/transform-images/preserve-content-credentials/index.md\n---\n\n[Content Credentials](https://contentcredentials.org/) (or C2PA metadata) are a type of metadata that includes the full provenance chain of a digital asset. This provides information about an image's creation, authorship, and editing flow. This data is cryptographically authenticated and can be verified using an [open-source verification service](https://contentcredentials.org/verify).\n\nYou can preserve Content Credentials when optimizing images stored in remote sources.\n\n## Enable\n\nYou can configure how Content Credentials are handled for each zone where transformations are served.\n\nIn the Cloudflare dashboard under **Images** > **Transformations**, navigate to a specific zone and enable the toggle to preserve Content Credentials:\n\n![Enable Preserving Content Credentials in the dashboard](https://developers.cloudflare.com/_astro/preserve-content-credentials.BDptgOn0_1TjaGK.webp)\n\nThe behavior of this setting is determined by the [`metadata`](https://developers.cloudflare.com/images/transform-images/transform-via-url/#metadata) parameter for each transformation.\n\nFor example, if a transformation specifies `metadata=copyright`, then the EXIF copyright tag and all Content Credentials will be preserved in the resulting image and all other metadata will be discarded.\n\nWhen Content Credentials are preserved in a transformation, Cloudflare will keep any existing Content Credentials embedded in the source image and automatically append and cryptographically sign additional actions.\n\nWhen this setting is disabled, any existing Content Credentials will always be discarded.\n\n</page>\n\n<page>\n---\ntitle: Serve images from custom paths · Cloudflare Images docs\ndescription: You can use Transform Rules to rewrite URLs for every image that\n  you transform through Images.\nlastUpdated: 2025-09-11T13:39:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/transform-images/serve-images-custom-paths/\n  md: https://developers.cloudflare.com/images/transform-images/serve-images-custom-paths/index.md\n---\n\nYou can use Transform Rules to rewrite URLs for every image that you transform through Images.\n\nThis page covers examples for the following scenarios:\n\n* Serve images from custom paths\n* Modify existing URLs to be compatible with transformations in Images\n* Transform every image requested on your zone with Images\n\nTo create a rule:\n\n1. In the Cloudflare dashboard, go to the **Rules Overview** page.\n\n   [Go to **Overview**](https://dash.cloudflare.com/?to=/:account/:zone/rules/overview)\n\n2. Select **Create rule** next to **URL Rewrite Rules**.\n\n## Before you start\n\nEvery rule runs before and after the transformation request.\n\nIf the path for the request matches the path where the original images are stored on your server, this may cause the request to fetch the original image to loop.\n\nTo direct the request to the origin server, you can check for the string `image-resizing` in the `Via` header:\n\n`...and (not (any(http.request.headers[\"via\"][*] contains \"image-resizing\")))`\n\n## Serve images from custom paths\n\nBy default, requests to transform images through Images are served from the `/cdn-cgi/image/` path. You can use Transform Rules to rewrite URLs.\n\n### Basic version\n\nFree and Pro plans support string matching rules (including wildcard operations) that do not require regular expressions.\n\nThis example lets you rewrite a request from `example.com/images` to `example.com/cdn-cgi/image/`:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### Advanced version\n\nNote\n\nThis feature requires a Business or Enterprise plan to enable regex in Transform Rules. Refer to [Cloudflare Transform Rules Availability](https://developers.cloudflare.com/rules/transform/#availability) for more information.\n\nThere is an advanced version of Transform Rules supporting regular expressions.\n\nThis example lets you rewrite a request from `example.com/images` to `example.com/cdn-cgi/image/`:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## Modify existing URLs to be compatible with transformations in Images\n\nNote\n\nThis feature requires a Business or Enterprise plan to enable regex in Transform Rules. Refer to [Cloudflare Transform Rules Availability](https://developers.cloudflare.com/rules/transform/#availability) for more information.\n\nThis example lets you rewrite your URL parameters to be compatible with Images:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "Leave the **Query** > **Rewrite to** > *Static* field empty.\n\n## Pass every image requested on your zone through Images\n\nNote\n\nThis feature requires a Business or Enterprise plan to enable regular expressions in Transform Rules. Refer to [Cloudflare Transform Rules Availability](https://developers.cloudflare.com/rules/transform/#availability) for more information.\n\nThis example lets you transform every image that is requested on your zone with the `format=auto` option:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Define source origin · Cloudflare Images docs\ndescription: When optimizing remote images, you can specify which origins can be\n  used as the source for transformed images. By default, Cloudflare accepts only\n  source images from the zone where your transformations are served.\nlastUpdated: 2025-03-11T13:51:28.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/transform-images/sources/\n  md: https://developers.cloudflare.com/images/transform-images/sources/index.md\n---\n\nWhen optimizing remote images, you can specify which origins can be used as the source for transformed images. By default, Cloudflare accepts only source images from the zone where your transformations are served.\n\nOn this page, you will learn how to define and manage the origins for the source images that you want to optimize.\n\nNote\n\nThe allowed origins setting applies to requests from Cloudflare Workers.\n\nIf you use a Worker to optimize remote images via a `fetch()` subrequest, then this setting may conflict with existing logic that handles source images.\n\n## How it works\n\nIn the Cloudflare dashboard, go to **Images** > **Transformations** and select the zone where you want to serve transformations.\n\nTo get started, you must have [transformations enabled on your zone](https://developers.cloudflare.com/images/get-started/#enable-transformations-on-your-zone).\n\nIn **Sources**, you can configure the origins for transformations on your zone.\n\n![Enable allowed origins from the Cloudflare dashboard](https://developers.cloudflare.com/_astro/allowed-origins.4hu5lHws_1geX4Q.webp)\n\n## Allow source images only from allowed origins\n\nYou can restrict source images to **allowed origins**, which applies transformations only to source images from a defined list.\n\nBy default, your accepted sources are set to **allowed origins**. Cloudflare will always allow source images from the same zone where your transformations are served.\n\nIf you request a transformation with a source image from outside your **allowed origins**, then the image will be rejected. For example, if you serve transformations on your zone `a.com` and do not define any additional origins, then `a.com/image.png` can be used as a source image, but `b.com/image.png` will return an error.\n\nTo define a new origin:\n\n1. From **Sources**, select **Add origin**.\n2. Under **Domain**, specify the domain for the source image. Only valid web URLs will be accepted.\n\n![Add the origin for source images in the Cloudflare dashboard](https://developers.cloudflare.com/_astro/add-origin.BtfOyoOS_1qwksq.webp)\n\nWhen you add a root domain, subdomains are not accepted. In other words, if you add `b.com`, then source images from `media.b.com` will be rejected.\n\nTo support individual subdomains, define an additional origin such as `media.b.com`. If you add only `media.b.com` and not the root domain, then source images from the root domain (`b.com`) and other subdomains (`cdn.b.com`) will be rejected.\n\nTo support all subdomains, use the `*` wildcard at the beginning of the root domain. For example, `*.b.com` will accept source images from the root domain (like `b.com/image.png`) as well as from subdomains (like `media.b.com/image.png` or `cdn.b.com/image.png`).\n\n1. Optionally, you can specify the **Path** for the source image. If no path is specified, then source images from all paths on this domain are accepted.\n\nCloudflare checks whether the defined path is at the beginning of the source path. If the defined path is not present at the beginning of the path, then the source image will be rejected.\n\nFor example, if you define an origin with domain `b.com` and path `/themes`, then `b.com/themes/image.png` will be accepted but `b.com/media/themes/image.png` will be rejected.\n\n1. Select **Add**. Your origin will now appear in your list of allowed origins.\n2. Select **Save**. These changes will take effect immediately.\n\nWhen you configure **allowed origins**, only the initial URL of the source image is checked. Any redirects, including URLs that leave your zone, will be followed, and the resulting image will be transformed.\n\nIf you change your accepted sources to **any origin**, then your list of sources will be cleared and reset to default.\n\n## Allow source images from any origin\n\nWhen your accepted sources are set to **any origin**, any publicly available image can be used as the source image for transformations on this zone.\n\n**Any origin** is less secure and may allow third parties to serve transformations on your zone.\n\n</page>\n\n<page>\n---\ntitle: Transform via URL · Cloudflare Images docs\ndescription: \"You can convert and resize images by requesting them via a\n  specially-formatted URL. This way you do not need to write any code, only\n  change HTML markup of your website to use the new URLs. The format is:\"\nlastUpdated: 2025-08-28T12:51:13.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/transform-images/transform-via-url/\n  md: https://developers.cloudflare.com/images/transform-images/transform-via-url/index.md\n---\n\nYou can convert and resize images by requesting them via a specially-formatted URL. This way you do not need to write any code, only change HTML markup of your website to use the new URLs. The format is:",
      "language": "unknown"
    },
    {
      "code": "Here is a breakdown of each part of the URL:\n\n* `<ZONE>`\n\n  * Your domain name on Cloudflare. Unlike other third-party image resizing services, image transformations do not use a separate domain name for an API. Every Cloudflare zone with image transformations enabled can handle resizing itself. In URLs used on your website this part can be omitted, so that URLs start with `/cdn-cgi/image/`.\n\n* `/cdn-cgi/image/`\n\n  * A fixed prefix that identifies that this is a special path handled by Cloudflare's built-in Worker.\n\n* `<OPTIONS>`\n\n  * A comma-separated list of options such as `width`, `height`, and `quality`.\n\n* `<SOURCE-IMAGE>`\n\n  * An absolute path on the origin server, or an absolute URL (starting with `https://` or `http://`), pointing to an image to resize. The path is not URL-encoded, so the resizing URL can be safely constructed by concatenating `/cdn-cgi/image/options` and the original image URL. For example: `/cdn-cgi/image/width=100/https://s3.example.com/bucket/image.png`.\n\nHere is an example of an URL with `<OPTIONS>` set to `width=80,quality=75` and a `<SOURCE-IMAGE>` of `uploads/avatar1.jpg`:",
      "language": "unknown"
    },
    {
      "code": "Note\n\nYou can use image transformations to sanitize SVGs, but not to resize them. Refer to [Resize with Workers](https://developers.cloudflare.com/images/transform-images/transform-via-workers/) for more information.\n\n## Options\n\nYou must specify at least one option. Options are comma-separated (spaces are not allowed anywhere). Names of options can be specified in full or abbreviated.\n\n### `anim`\n\nWhether to preserve animation frames from input files. Default is `true`. Setting it to `false` reduces animations to still images. This setting is recommended when enlarging images or processing arbitrary user content, because large GIF animations can weigh tens or even hundreds of megabytes. It is also useful to set `anim:false` when using `format:\"json\"` to get the response quicker without the number of frames.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `background`\n\nBackground color to add underneath the image. Applies to images with transparency (for example, PNG) and images resized with `fit=pad`. Accepts any CSS color using CSS4 modern syntax, such as `rgb(255 255 0)` and `rgba(255 255 0 100)`.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `blur`\n\nBlur radius between `1` (slight blur) and `250` (maximum). Be aware that you cannot use this option to reliably obscure image content, because savvy users can modify an image's URL and remove the blur option. Use Workers to control which options can be set.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `border`\n\nAdds a border around the image. The border is added after resizing. Border width takes `dpr` into account, and can be specified either using a single `width` property, or individually for each side.\n\n* Workers",
      "language": "unknown"
    },
    {
      "code": "### `brightness`\n\nIncrease brightness by a factor. A value of `1.0` equals no change, a value of `0.5` equals half brightness, and a value of `2.0` equals twice as bright. `0` is ignored.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `compression`\n\nSlightly reduces latency on a cache miss by selecting a quickest-to-compress file format, at a cost of increased file size and lower image quality. It will usually override the `format` option and choose JPEG over WebP or AVIF. We do not recommend using this option, except in unusual circumstances like resizing uncacheable dynamically-generated images.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `contrast`\n\nIncrease contrast by a factor. A value of `1.0` equals no change, a value of `0.5` equals low contrast, and a value of `2.0` equals high contrast. `0` is ignored.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `dpr`\n\nDevice Pixel Ratio. Default is `1`. Multiplier for `width`/`height` that makes it easier to specify higher-DPI sizes in `<img srcset>`.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `fit`\n\nAffects interpretation of `width` and `height`. All resizing modes preserve aspect ratio. Used as a string in Workers integration. Available modes are:\n\n* `scale-down`\\\n  Similar to `contain`, but the image is never enlarged. If the image is larger than given `width` or `height`, it will be resized. Otherwise its original size will be kept.\n* `contain`\\\n  Image will be resized (shrunk or enlarged) to be as large as possible within the given `width` or `height` while preserving the aspect ratio. If you only provide a single dimension (for example, only `width`), the image will be shrunk or enlarged to exactly match that dimension.\n* `cover`\\\n  Resizes (shrinks or enlarges) to fill the entire area of `width` and `height`. If the image has an aspect ratio different from the ratio of `width` and `height`, it will be cropped to fit.\n* `crop`\\\n  Image will be shrunk and cropped to fit within the area specified by `width` and `height`. The image will not be enlarged. For images smaller than the given dimensions, it is the same as `scale-down`. For images larger than the given dimensions, it is the same as `cover`. See also [`trim`](#trim)\n* `pad`\\\n  Resizes to the maximum size that fits within the given `width` and `height`, and then fills the remaining area with a `background` color (white by default). This mode is not recommended, since you can achieve the same effect more efficiently with the `contain` mode and the CSS `object-fit: contain` property.\n* `squeeze` Resizes the image to the exact width and height specified. This mode does not preserve the original aspect ratio and will cause the image to appear stretched or squashed.\n\n- URL format",
      "language": "unknown"
    },
    {
      "code": "- Workers",
      "language": "unknown"
    },
    {
      "code": "### `flip`\n\nFlips the image horizontally, vertically, or both. Can be used with the `rotate` parameter to set the orientation of an image.\n\nFlipping is performed before rotation. For example, if you apply `flip=h,rotate=90,` then the image will be flipped horizontally, then rotated by 90 degrees.\n\nAvailable options are:\n\n* `h`: Flips the image horizontally.\n* `v`: Flips the image vertically.\n* `hv`: Flips the image vertically and horizontally.\n\n- URL format",
      "language": "unknown"
    },
    {
      "code": "- Workers",
      "language": "unknown"
    },
    {
      "code": "### `format`\n\nThe `auto` option will serve the WebP or AVIF format to browsers that support it. If this option is not specified, a standard format like JPEG or PNG will be used. Cloudflare will default to JPEG when possible due to the large size of PNG files.\n\nOther supported options:\n\n* `avif`: Generate images in AVIF format if possible (with WebP as a fallback).\n* `webp`: Generate images in Google WebP format. Set the quality to `100` to get the WebP lossless format.\n* `jpeg`: Generate images in interlaced progressive JPEG format, in which data is compressed in multiple passes of progressively higher detail.\n* `baseline-jpeg`: Generate images in baseline sequential JPEG format. It should be used in cases when target devices don't support progressive JPEG or other modern file formats.\n* `json`: Instead of generating an image, outputs information about the image in JSON format. The JSON object will contain data such as image size (before and after resizing), source image's MIME type, and file size.\n\n- URL format",
      "language": "unknown"
    },
    {
      "code": "- URL format alias",
      "language": "unknown"
    },
    {
      "code": "- Workers",
      "language": "unknown"
    },
    {
      "code": "For the `format:auto` option to work with a custom Worker, you need to parse the `Accept` header. Refer to [this example Worker](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#an-example-worker) for a complete overview of how to set up an image transformation Worker.",
      "language": "unknown"
    },
    {
      "code": "### `gamma`\n\nIncrease exposure by a factor. A value of `1.0` equals no change, a value of `0.5` darkens the image, and a value of `2.0` lightens the image. `0` is ignored.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `gravity`\n\nSpecifies how an image should be cropped when used with `fit=cover` and `fit=crop`. Available options are `auto`, `face`, a side (`left`, `right`, `top`, `bottom`), and relative coordinates (`XxY` with a valid range of `0.0` to `1.0`):\n\n* `auto`\\\n  Selects focal point based on saliency detection (using maximum symmetric surround algorithm).\n\n* `side`\\\n  A side (`\"left\"`, `\"right\"`, `\"top\"`, `\"bottom\"`) or coordinates specified on a scale from `0.0` (top or left) to `1.0` (bottom or right), `0.5` being the center. The X and Y coordinates are separated by lowercase `x` in the URL format. For example, `0x1` means left and bottom, `0.5x0.5` is the center, `0.5x0.33` is a point in the top third of the image.\n\n  For the Workers integration, use an object `{x, y}` to specify coordinates. It contains focal point coordinates in the original image expressed as fractions ranging from `0.0` (top or left) to `1.0` (bottom or right), with `0.5` being the center. `{fit: \"cover\", gravity: {x:0.5, y:0.2}}` will crop each side to preserve as much as possible around a point at 20% of the height of the source image.\n\nNote\n\nYou must subtract the height of the image before you calculate the focal point.\n\n* `face`\\\n  Automatically sets the focal point based on detected faces in an image. This can be combined with the `zoom` parameter to specify how closely the image should be cropped towards the faces.\n\n  The new focal point is determined by a minimum bounding box that surrounds all detected faces. If no faces are found, then the focal point will fall back to the center of the image.\n\n  This feature uses an open-source model called RetinaFace through WorkersAI. Our model pipeline is limited only to facial detection, or identifying the pixels that represent a human face. We do not support facial identification or recognition. Read more about Cloudflare's [approach to responsible AI](https://www.cloudflare.com/trust-hub/responsible-ai/).\n\n- URL format",
      "language": "unknown"
    },
    {
      "code": "- URL format alias",
      "language": "unknown"
    },
    {
      "code": "- Workers",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### `height`\n\nSpecifies maximum height of the image in pixels. Exact behavior depends on the `fit` mode (described below).\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* URL format alias",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `metadata`\n\nControls amount of invisible metadata (EXIF data) that should be preserved.\n\nColor profiles and EXIF rotation are applied to the image even if the metadata is discarded. Content Credentials (C2PA metadata) may be preserved if the [setting is enabled](https://developers.cloudflare.com/images/transform-images/preserve-content-credentials).\n\nAvailable options are `copyright`, `keep`, and `none`. The default for all JPEG images is `copyright`. WebP and PNG output formats will always discard EXIF metadata.\n\nNote\n\n* If [Polish](https://developers.cloudflare.com/images/polish/) is enabled, then all metadata may already be removed and this option will have no effect.\n* Even when choosing to keep EXIF metadata, Cloudflare will modify JFIF data (potentially invalidating it) to avoid the known incompatibility between the two standards. For more details, refer to [JFIF Compatibility](https://en.wikipedia.org/wiki/JPEG_File_Interchange_Format#Compatibility).\n\nOptions include:\n\n* `copyright`\\\n  Discards all EXIF metadata except copyright tag. If C2PA metadata preservation is enabled, then this option will preserve all Content Credentials.\n* `keep`\\\n  Preserves most of EXIF metadata, including GPS location if present. If C2PA metadata preservation is enabled, then this option will preserve all Content Credentials.\n* `none`\\\n  Discards all invisible EXIF and C2PA metadata. If the output format is WebP or PNG, then all metadata will be discarded.\n\n- URL format",
      "language": "unknown"
    },
    {
      "code": "- Workers",
      "language": "unknown"
    },
    {
      "code": "### `onerror`\n\nNote\n\nThis setting only works directly with [image transformations](https://developers.cloudflare.com/images/transform-images/) and does not support resizing with Cloudflare Workers.\n\nIn case of a [fatal error](https://developers.cloudflare.com/images/reference/troubleshooting/#error-responses-from-resizing) that prevents the image from being resized, redirects to the unresized source image URL. This may be useful in case some images require user authentication and cannot be fetched anonymously via Worker. This option should not be used if there is a chance the source image is very large. This option is ignored if the image is from another domain, but you can use it with subdomains.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "### `quality`\n\nSpecifies quality for images in JPEG, WebP, and AVIF formats. The quality is in a 1-100 scale, but useful values are between `50` (low quality, small file size) and `90` (high quality, large file size). `85` is the default. When using the PNG format, an explicit quality setting allows use of PNG8 (palette) variant of the format. Use the `format=auto` option to allow use of WebP and AVIF formats.\n\nWe also allow setting one of the perceptual quality levels `high|medium-high|medium-low|low`\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* URL format alias",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `rotate`\n\nNumber of degrees (`90`, `180`, or `270`) to rotate the image by. `width` and `height` options refer to axes after rotation.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `saturation`\n\nIncreases saturation by a factor. A value of `1.0` equals no change, a value of `0.5` equals half saturation, and a value of `2.0` equals twice as saturated. A value of `0` will convert the image to grayscale.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `segment`\n\nAutomatically isolates the subject of an image by replacing the background with transparent pixels.\n\nThis feature uses an open-source model called BiRefNet through Workers AI. Read more about Cloudflare's [approach to responsible AI](https://www.cloudflare.com/trust-hub/responsible-ai/).\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `sharpen`\n\nSpecifies strength of sharpening filter to apply to the image. The value is a floating-point number between `0` (no sharpening, default) and `10` (maximum). `1` is a recommended value for downscaled images.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `slow-connection-quality`\n\nAllows overriding `quality` value whenever a slow connection is detected.\n\nAvailable options are same as [quality](https://developers.cloudflare.com/images/transform-images/transform-via-url/#quality).\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* URL format alias",
      "language": "unknown"
    },
    {
      "code": "Detecting slow connections is currently only supported on Chromium-based browsers such as Chrome, Edge, and Opera.\n\nYou can enable any of the following client hints via HTTP in a header",
      "language": "unknown"
    },
    {
      "code": "slow-connection-quality applies whenever any of the following is true and the client hint is present:\n\n* [rtt](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/RTT): Greater than 150ms.\n\n* [save-data](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Save-Data): Value is \"on\".\n\n* [ect](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/ECT): Value is one of `slow-2g|2g|3g`.\n\n* [downlink](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Downlink): Less than 5Mbps.\n\n### `trim`\n\nSpecifies a number of pixels to cut off on each side. Allows removal of borders or cutting out a specific fragment of an image. Trimming is performed before resizing or rotation. Takes `dpr` into account. For image transformations and Cloudflare Images, use as four numbers in pixels separated by a semicolon, in the form of `top;right;bottom;left` or via separate values `trim.width`,`trim.height`, `trim.left`,`trim.top`. For the Workers integration, specify an object with properties: `{top, right, bottom, left, width, height}`.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "The API also supports automatic border removal based on color. This can be enabled by setting `trim=border` for automatic color detection, or customized with the parameters below.\n\n`trim.border.color` The border color to trim. Accepts any CSS color using CSS4 modern syntax, such as `rgb(255 255 0)`. If omitted, the color is detected automatically.\n\n`trim.border.tolerance` The matching tolerance for the color, on a scale of 0 to 255.\n\n`trim.border.keep` The number of pixels of the original border to leave untrimmed.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `width`\n\nSpecifies maximum width of the image. Exact behavior depends on the `fit` mode; use the `fit=scale-down` option to ensure that the image will not be enlarged unnecessarily.\n\nAvailable options are a specified width in pixels or `auto`.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* URL format alias",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "Ideally, image sizes should match the exact dimensions at which they are displayed on the page. If the page contains thumbnails with markup such as `<img width=\"200\">`, then you can resize the image by applying `width=200`.\n\n[To serve responsive images](https://developers.cloudflare.com/images/transform-images/make-responsive-images/#transform-with-html-srcset), you can use the HTML `srcset` element and apply width parameters.\n\n`auto` - Automatically serves the image in the most optimal width based on available information about the browser and device. This method is supported only by Chromium browsers. For more information about this works, refer to [Transform width parameter](https://developers.cloudflare.com/images/transform-images/make-responsive-images/#transform-with-width-parameter).\n\n### `zoom`\n\nSpecifies how closely the image is cropped toward the face when combined with the `gravity=face` option. Valid range is from `0` (includes as much of the background as possible) to `1` (crops the image as closely to the face as possible), decimals allowed. The default is `0`.\n\nThis controls the threshold for how much of the surrounding pixels around the face will be included in the image and takes effect only if face(s) are detected in the image.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* URL format alias",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "## Recommended image sizes\n\nIdeally, image sizes should match exactly the size they are displayed on the page. If the page contains thumbnails with markup such as `<img width=\"200\" …>`, then images should be resized to `width=200`. If the exact size is not known ahead of time, use the [responsive images technique](https://developers.cloudflare.com/images/manage-images/create-variants/).\n\nIf you cannot use the `<img srcset>` markup, and have to hardcode specific maximum sizes, Cloudflare recommends the following sizes:\n\n* Maximum of 1920 pixels for desktop browsers.\n* Maximum of 960 pixels for tablets.\n* Maximum of 640 pixels for mobile phones.\n\nHere is an example of markup to configure a maximum size for your image:",
      "language": "unknown"
    },
    {
      "code": "The `fit=scale-down` option ensures that the image will not be enlarged unnecessarily.\n\nYou can detect device type by enabling the `CF-Device-Type` header [via Cache Rule](https://developers.cloudflare.com/cache/how-to/cache-rules/examples/cache-device-type/).\n\n## Caching\n\nResizing causes the original image to be fetched from the origin server and cached — following the usual rules of HTTP caching, `Cache-Control` header, etc.. Requests for multiple different image sizes are likely to reuse the cached original image, without causing extra transfers from the origin server.\n\nNote\n\nIf Custom Cache Keys are used for the origin image, the origin image might not be cached and might result in more calls to the origin.\n\nResized images follow the same caching rules as the original image they were resized from, except the minimum cache time is one hour. If you need images to be updated more frequently, add `must-revalidate` to the `Cache-Control` header. Resizing supports cache revalidation, so we recommend serving images with the `Etag` header. Refer to the [Cache docs for more information](https://developers.cloudflare.com/cache/concepts/cache-control/#revalidation).\n\nCloudflare Images does not support purging resized variants individually. URLs starting with `/cdn-cgi/` cannot be purged. However, purging of the original image's URL will also purge all of its resized variants.\n\n</page>\n\n<page>\n---\ntitle: Transform via Workers · Cloudflare Images docs\ndescription: Using Cloudflare Workers to transform with a custom URL scheme\n  gives you powerful programmatic control over every image request.\nlastUpdated: 2025-08-28T12:51:13.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/transform-images/transform-via-workers/\n  md: https://developers.cloudflare.com/images/transform-images/transform-via-workers/index.md\n---\n\nUsing Cloudflare Workers to transform with a custom URL scheme gives you powerful programmatic control over every image request.\n\nHere are a few examples of the flexibility Workers give you:\n\n* **Use a custom URL scheme**. Instead of specifying pixel dimensions in image URLs, use preset names such as `thumbnail` and `large`.\n* **Hide the actual location of the original image**. You can store images in an external S3 bucket or a hidden folder on your server without exposing that information in URLs.\n* **Implement content negotiation**. This is useful to adapt image sizes, formats and quality dynamically based on the device and condition of the network.\n\nThe resizing feature is accessed via the [options](https://developers.cloudflare.com/workers/runtime-apis/request/#the-cf-property-requestinitcfproperties) of a `fetch()` [subrequest inside a Worker](https://developers.cloudflare.com/workers/runtime-apis/fetch/).\n\nNote\n\nYou can use Cloudflare Images to sanitize SVGs but not to resize them.\n\n## Fetch options\n\nThe `fetch()` function accepts parameters in the second argument inside the `{cf: {image: {…}}}` object.\n\n### `anim`\n\nWhether to preserve animation frames from input files. Default is `true`. Setting it to `false` reduces animations to still images. This setting is recommended when enlarging images or processing arbitrary user content, because large GIF animations can weigh tens or even hundreds of megabytes. It is also useful to set `anim:false` when using `format:\"json\"` to get the response quicker without the number of frames.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `background`\n\nBackground color to add underneath the image. Applies to images with transparency (for example, PNG) and images resized with `fit=pad`. Accepts any CSS color using CSS4 modern syntax, such as `rgb(255 255 0)` and `rgba(255 255 0 100)`.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `blur`\n\nBlur radius between `1` (slight blur) and `250` (maximum). Be aware that you cannot use this option to reliably obscure image content, because savvy users can modify an image's URL and remove the blur option. Use Workers to control which options can be set.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `border`\n\nAdds a border around the image. The border is added after resizing. Border width takes `dpr` into account, and can be specified either using a single `width` property, or individually for each side.\n\n* Workers",
      "language": "unknown"
    },
    {
      "code": "### `brightness`\n\nIncrease brightness by a factor. A value of `1.0` equals no change, a value of `0.5` equals half brightness, and a value of `2.0` equals twice as bright. `0` is ignored.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `compression`\n\nSlightly reduces latency on a cache miss by selecting a quickest-to-compress file format, at a cost of increased file size and lower image quality. It will usually override the `format` option and choose JPEG over WebP or AVIF. We do not recommend using this option, except in unusual circumstances like resizing uncacheable dynamically-generated images.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `contrast`\n\nIncrease contrast by a factor. A value of `1.0` equals no change, a value of `0.5` equals low contrast, and a value of `2.0` equals high contrast. `0` is ignored.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `dpr`\n\nDevice Pixel Ratio. Default is `1`. Multiplier for `width`/`height` that makes it easier to specify higher-DPI sizes in `<img srcset>`.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `fit`\n\nAffects interpretation of `width` and `height`. All resizing modes preserve aspect ratio. Used as a string in Workers integration. Available modes are:\n\n* `scale-down`\\\n  Similar to `contain`, but the image is never enlarged. If the image is larger than given `width` or `height`, it will be resized. Otherwise its original size will be kept.\n* `contain`\\\n  Image will be resized (shrunk or enlarged) to be as large as possible within the given `width` or `height` while preserving the aspect ratio. If you only provide a single dimension (for example, only `width`), the image will be shrunk or enlarged to exactly match that dimension.\n* `cover`\\\n  Resizes (shrinks or enlarges) to fill the entire area of `width` and `height`. If the image has an aspect ratio different from the ratio of `width` and `height`, it will be cropped to fit.\n* `crop`\\\n  Image will be shrunk and cropped to fit within the area specified by `width` and `height`. The image will not be enlarged. For images smaller than the given dimensions, it is the same as `scale-down`. For images larger than the given dimensions, it is the same as `cover`. See also [`trim`](#trim)\n* `pad`\\\n  Resizes to the maximum size that fits within the given `width` and `height`, and then fills the remaining area with a `background` color (white by default). This mode is not recommended, since you can achieve the same effect more efficiently with the `contain` mode and the CSS `object-fit: contain` property.\n* `squeeze` Resizes the image to the exact width and height specified. This mode does not preserve the original aspect ratio and will cause the image to appear stretched or squashed.\n\n- URL format",
      "language": "unknown"
    },
    {
      "code": "- Workers",
      "language": "unknown"
    },
    {
      "code": "### `flip`\n\nFlips the image horizontally, vertically, or both. Can be used with the `rotate` parameter to set the orientation of an image.\n\nFlipping is performed before rotation. For example, if you apply `flip=h,rotate=90,` then the image will be flipped horizontally, then rotated by 90 degrees.\n\nAvailable options are:\n\n* `h`: Flips the image horizontally.\n* `v`: Flips the image vertically.\n* `hv`: Flips the image vertically and horizontally.\n\n- URL format",
      "language": "unknown"
    },
    {
      "code": "- Workers",
      "language": "unknown"
    },
    {
      "code": "### `format`\n\nThe `auto` option will serve the WebP or AVIF format to browsers that support it. If this option is not specified, a standard format like JPEG or PNG will be used. Cloudflare will default to JPEG when possible due to the large size of PNG files.\n\nOther supported options:\n\n* `avif`: Generate images in AVIF format if possible (with WebP as a fallback).\n* `webp`: Generate images in Google WebP format. Set the quality to `100` to get the WebP lossless format.\n* `jpeg`: Generate images in interlaced progressive JPEG format, in which data is compressed in multiple passes of progressively higher detail.\n* `baseline-jpeg`: Generate images in baseline sequential JPEG format. It should be used in cases when target devices don't support progressive JPEG or other modern file formats.\n* `json`: Instead of generating an image, outputs information about the image in JSON format. The JSON object will contain data such as image size (before and after resizing), source image's MIME type, and file size.\n\n- URL format",
      "language": "unknown"
    },
    {
      "code": "- URL format alias",
      "language": "unknown"
    },
    {
      "code": "- Workers",
      "language": "unknown"
    },
    {
      "code": "For the `format:auto` option to work with a custom Worker, you need to parse the `Accept` header. Refer to [this example Worker](https://developers.cloudflare.com/images/transform-images/transform-via-workers/#an-example-worker) for a complete overview of how to set up an image transformation Worker.",
      "language": "unknown"
    },
    {
      "code": "### `gamma`\n\nIncrease exposure by a factor. A value of `1.0` equals no change, a value of `0.5` darkens the image, and a value of `2.0` lightens the image. `0` is ignored.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `gravity`\n\nSpecifies how an image should be cropped when used with `fit=cover` and `fit=crop`. Available options are `auto`, `face`, a side (`left`, `right`, `top`, `bottom`), and relative coordinates (`XxY` with a valid range of `0.0` to `1.0`):\n\n* `auto`\\\n  Selects focal point based on saliency detection (using maximum symmetric surround algorithm).\n\n* `side`\\\n  A side (`\"left\"`, `\"right\"`, `\"top\"`, `\"bottom\"`) or coordinates specified on a scale from `0.0` (top or left) to `1.0` (bottom or right), `0.5` being the center. The X and Y coordinates are separated by lowercase `x` in the URL format. For example, `0x1` means left and bottom, `0.5x0.5` is the center, `0.5x0.33` is a point in the top third of the image.\n\n  For the Workers integration, use an object `{x, y}` to specify coordinates. It contains focal point coordinates in the original image expressed as fractions ranging from `0.0` (top or left) to `1.0` (bottom or right), with `0.5` being the center. `{fit: \"cover\", gravity: {x:0.5, y:0.2}}` will crop each side to preserve as much as possible around a point at 20% of the height of the source image.\n\nNote\n\nYou must subtract the height of the image before you calculate the focal point.\n\n* `face`\\\n  Automatically sets the focal point based on detected faces in an image. This can be combined with the `zoom` parameter to specify how closely the image should be cropped towards the faces.\n\n  The new focal point is determined by a minimum bounding box that surrounds all detected faces. If no faces are found, then the focal point will fall back to the center of the image.\n\n  This feature uses an open-source model called RetinaFace through WorkersAI. Our model pipeline is limited only to facial detection, or identifying the pixels that represent a human face. We do not support facial identification or recognition. Read more about Cloudflare's [approach to responsible AI](https://www.cloudflare.com/trust-hub/responsible-ai/).\n\n- URL format",
      "language": "unknown"
    },
    {
      "code": "- URL format alias",
      "language": "unknown"
    },
    {
      "code": "- Workers",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### `height`\n\nSpecifies maximum height of the image in pixels. Exact behavior depends on the `fit` mode (described below).\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* URL format alias",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `metadata`\n\nControls amount of invisible metadata (EXIF data) that should be preserved.\n\nColor profiles and EXIF rotation are applied to the image even if the metadata is discarded. Content Credentials (C2PA metadata) may be preserved if the [setting is enabled](https://developers.cloudflare.com/images/transform-images/preserve-content-credentials).\n\nAvailable options are `copyright`, `keep`, and `none`. The default for all JPEG images is `copyright`. WebP and PNG output formats will always discard EXIF metadata.\n\nNote\n\n* If [Polish](https://developers.cloudflare.com/images/polish/) is enabled, then all metadata may already be removed and this option will have no effect.\n* Even when choosing to keep EXIF metadata, Cloudflare will modify JFIF data (potentially invalidating it) to avoid the known incompatibility between the two standards. For more details, refer to [JFIF Compatibility](https://en.wikipedia.org/wiki/JPEG_File_Interchange_Format#Compatibility).\n\nOptions include:\n\n* `copyright`\\\n  Discards all EXIF metadata except copyright tag. If C2PA metadata preservation is enabled, then this option will preserve all Content Credentials.\n* `keep`\\\n  Preserves most of EXIF metadata, including GPS location if present. If C2PA metadata preservation is enabled, then this option will preserve all Content Credentials.\n* `none`\\\n  Discards all invisible EXIF and C2PA metadata. If the output format is WebP or PNG, then all metadata will be discarded.\n\n- URL format",
      "language": "unknown"
    },
    {
      "code": "- Workers",
      "language": "unknown"
    },
    {
      "code": "### `onerror`\n\nNote\n\nThis setting only works directly with [image transformations](https://developers.cloudflare.com/images/transform-images/) and does not support resizing with Cloudflare Workers.\n\nIn case of a [fatal error](https://developers.cloudflare.com/images/reference/troubleshooting/#error-responses-from-resizing) that prevents the image from being resized, redirects to the unresized source image URL. This may be useful in case some images require user authentication and cannot be fetched anonymously via Worker. This option should not be used if there is a chance the source image is very large. This option is ignored if the image is from another domain, but you can use it with subdomains.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "### `quality`\n\nSpecifies quality for images in JPEG, WebP, and AVIF formats. The quality is in a 1-100 scale, but useful values are between `50` (low quality, small file size) and `90` (high quality, large file size). `85` is the default. When using the PNG format, an explicit quality setting allows use of PNG8 (palette) variant of the format. Use the `format=auto` option to allow use of WebP and AVIF formats.\n\nWe also allow setting one of the perceptual quality levels `high|medium-high|medium-low|low`\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* URL format alias",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `rotate`\n\nNumber of degrees (`90`, `180`, or `270`) to rotate the image by. `width` and `height` options refer to axes after rotation.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `saturation`\n\nIncreases saturation by a factor. A value of `1.0` equals no change, a value of `0.5` equals half saturation, and a value of `2.0` equals twice as saturated. A value of `0` will convert the image to grayscale.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `segment`\n\nAutomatically isolates the subject of an image by replacing the background with transparent pixels.\n\nThis feature uses an open-source model called BiRefNet through Workers AI. Read more about Cloudflare's [approach to responsible AI](https://www.cloudflare.com/trust-hub/responsible-ai/).\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `sharpen`\n\nSpecifies strength of sharpening filter to apply to the image. The value is a floating-point number between `0` (no sharpening, default) and `10` (maximum). `1` is a recommended value for downscaled images.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `trim`\n\nSpecifies a number of pixels to cut off on each side. Allows removal of borders or cutting out a specific fragment of an image. Trimming is performed before resizing or rotation. Takes `dpr` into account. For image transformations and Cloudflare Images, use as four numbers in pixels separated by a semicolon, in the form of `top;right;bottom;left` or via separate values `trim.width`,`trim.height`, `trim.left`,`trim.top`. For the Workers integration, specify an object with properties: `{top, right, bottom, left, width, height}`.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "The API also supports automatic border removal based on color. This can be enabled by setting `trim=border` for automatic color detection, or customized with the parameters below.\n\n`trim.border.color` The border color to trim. Accepts any CSS color using CSS4 modern syntax, such as `rgb(255 255 0)`. If omitted, the color is detected automatically.\n\n`trim.border.tolerance` The matching tolerance for the color, on a scale of 0 to 255.\n\n`trim.border.keep` The number of pixels of the original border to leave untrimmed.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "### `width`\n\nSpecifies maximum width of the image. Exact behavior depends on the `fit` mode; use the `fit=scale-down` option to ensure that the image will not be enlarged unnecessarily.\n\nAvailable options are a specified width in pixels or `auto`.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* URL format alias",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "Ideally, image sizes should match the exact dimensions at which they are displayed on the page. If the page contains thumbnails with markup such as `<img width=\"200\">`, then you can resize the image by applying `width=200`.\n\n[To serve responsive images](https://developers.cloudflare.com/images/transform-images/make-responsive-images/#transform-with-html-srcset), you can use the HTML `srcset` element and apply width parameters.\n\n`auto` - Automatically serves the image in the most optimal width based on available information about the browser and device. This method is supported only by Chromium browsers. For more information about this works, refer to [Transform width parameter](https://developers.cloudflare.com/images/transform-images/make-responsive-images/#transform-with-width-parameter).\n\n### `zoom`\n\nSpecifies how closely the image is cropped toward the face when combined with the `gravity=face` option. Valid range is from `0` (includes as much of the background as possible) to `1` (crops the image as closely to the face as possible), decimals allowed. The default is `0`.\n\nThis controls the threshold for how much of the surrounding pixels around the face will be included in the image and takes effect only if face(s) are detected in the image.\n\n* URL format",
      "language": "unknown"
    },
    {
      "code": "* URL format alias",
      "language": "unknown"
    },
    {
      "code": "* Workers",
      "language": "unknown"
    },
    {
      "code": "In your worker, where you would fetch the image using `fetch(request)`, add options like in the following example:",
      "language": "unknown"
    },
    {
      "code": "These typings are also available in [our Workers TypeScript definitions library](https://github.com/cloudflare/workers-types).\n\n## Configure a Worker\n\nCreate a new script in the Workers section of the Cloudflare dashboard. Scope your Worker script to a path dedicated to serving assets, such as `/images/*` or `/assets/*`. Only supported image formats can be resized. Attempting to resize any other type of resource (CSS, HTML) will result in an error.\n\nWarning\n\nDo not set up the Image Resizing worker for the entire zone (`/*`). This will block all non-image requests and make your website inaccessible.\n\nIt is best to keep the path handled by the Worker separate from the path to original (unresized) images, to avoid request loops caused by the image resizing worker calling itself. For example, store your images in `example.com/originals/` directory, and handle resizing via `example.com/thumbnails/*` path that fetches images from the `/originals/` directory. If source images are stored in a location that is handled by a Worker, you must prevent the Worker from creating an infinite loop.\n\n### Prevent request loops\n\nTo perform resizing and optimizations, the Worker must be able to fetch the original, unresized image from your origin server. If the path handled by your Worker overlaps with the path where images are stored on your server, it could cause an infinite loop by the Worker trying to request images from itself.\n\nYou must detect which requests must go directly to the origin server. When the `image-resizing` string is present in the `Via` header, it means that it is a request coming from another Worker and should be directed to the origin server:",
      "language": "unknown"
    },
    {
      "code": "## Lack of preview in the dashboard\n\nNote\n\nImage transformations are not simulated in the preview of in the Workers dashboard editor.\n\nThe script preview of the Worker editor ignores `fetch()` options, and will always fetch unresized images. To see the effect of image transformations you must deploy the Worker script and use it outside of the editor.\n\n## Error handling\n\nWhen an image cannot be resized — for example, because the image does not exist or the resizing parameters were invalid — the response will have an HTTP status indicating an error (for example, `400`, `404`, or `502`).\n\nBy default, the error will be forwarded to the browser, but you can decide how to handle errors. For example, you can redirect the browser to the original, unresized image instead:",
      "language": "unknown"
    },
    {
      "code": "Keep in mind that if the original images on your server are very large, it may be better not to display failing images at all, than to fall back to overly large images that could use too much bandwidth, memory, or break page layout.\n\nYou can also replace failed images with a placeholder image:",
      "language": "unknown"
    },
    {
      "code": "## An example worker\n\nAssuming you [set up a Worker](https://developers.cloudflare.com/workers/get-started/guide/) on `https://example.com/image-resizing` to handle URLs like `https://example.com/image-resizing?width=80&image=https://example.com/uploads/avatar1.jpg`:",
      "language": "unknown"
    },
    {
      "code": "When testing image resizing, please deploy the script first. Resizing will not be active in the online editor in the dashboard.\n\n## Warning about `cacheKey`\n\nResized images are always cached. They are cached as additional variants under a cache entry for the URL of the full-size source image in the `fetch` subrequest. Do not worry about using many different Workers or many external URLs — they do not influence caching of resized images, and you do not need to do anything for resized images to be cached correctly.\n\nIf you use the `cacheKey` fetch option to unify the caches of multiple source URLs, do not include any resizing options in the `cacheKey`. Doing so will fragment the cache and hurt caching performance. The `cacheKey` should reference only the full-size source image URL, not any of its resized versions.\n\n</page>\n\n<page>\n---\ntitle: Optimize mobile viewing · Cloudflare Images docs\ndescription: Lazy loading is an easy way to optimize the images on your webpages\n  for mobile devices, with faster page load times and lower costs.\nlastUpdated: 2025-07-22T11:05:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/tutorials/optimize-mobile-viewing/\n  md: https://developers.cloudflare.com/images/tutorials/optimize-mobile-viewing/index.md\n---\n\nYou can use lazy loading to optimize the images on your webpages for mobile viewing. This helps address common challenges of mobile viewing, like slow network connections or weak processing capabilities.\n\nLazy loading has two main advantages:\n\n* **Faster page load times** — Images are loaded as the user scrolls down the page, instead of all at once when the page is opened.\n* **Lower costs for image delivery** — When using Cloudflare Images, you only pay to load images that the user actually sees. With lazy loading, images that are not scrolled into view do not count toward your billable Images requests.\n\nLazy loading is natively supported on all Chromium-based browsers like Chrome, Safari, Firefox, Opera, and Edge.\n\nNote\n\nIf you use older methods, involving custom JavaScript or a JavaScript library, lazy loading may increase the initial load time of the page since the browser needs to download, parse, and execute JavaScript.\n\n## Modify your loading attribute\n\nWithout modifying your loading attribute, most browsers will fetch all images on a page, prioritizing the images that are closest to the viewport by default. You can override this by modifying your `loading` attribute.\n\nThere are two possible `loading` attributes for your `<img>` tags: `lazy` and `eager`.\n\n### Lazy loading\n\nLazy loading is recommended for most images. With Lazy loading, resources like images are deferred until they reach a certain distance from the viewport. If an image does not reach the threshold, then it does not get loaded.\n\nExample of modifying the `loading` attribute of your `<img>` tags to be `\"lazy\"`:",
      "language": "unknown"
    },
    {
      "code": "### Eager loading\n\nIf you have images that are in the viewport, eager loading, instead of lazy loading, is recommended. Eager loading loads the asset at the initial page load, regardless of its location on the page.\n\nExample of modifying the `loading` attribute of your `<img>` tags to be `\"eager\"`:",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Transform user-uploaded images before uploading to R2 · Cloudflare Images docs\ndescription: Set up bindings to connect Images, R2, and Assets to your Worker\nlastUpdated: 2025-04-28T16:08:27.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/tutorials/optimize-user-uploaded-image/\n  md: https://developers.cloudflare.com/images/tutorials/optimize-user-uploaded-image/index.md\n---\n\nIn this guide, you will build an app that accepts image uploads, overlays the image with a visual watermark, then stores the transformed image in your R2 bucket.\n\n***\n\nWith Images, you have the flexibility to choose where your original images are stored. You can transform images that are stored outside of the Images product, like in [R2](https://developers.cloudflare.com/r2/).\n\nWhen you store user-uploaded media in R2, you may want to optimize or manipulate images before they are uploaded to your R2 bucket.\n\nYou will learn how to connect Developer Platform services to your Worker through bindings, as well as use various optimization features in the Images API.\n\n## Prerequisites\n\nBefore you begin, you will need to do the following:\n\n* Add an [Images Paid](https://developers.cloudflare.com/images/pricing/#images-paid) subscription to your account. This allows you to bind the Images API to your Worker.\n* Create an [R2 bucket](https://developers.cloudflare.com/r2/get-started/#2-create-a-bucket), where the transformed images will be uploaded.\n* Create a new Worker project.\n\nIf you are new, review how to [create your first Worker](https://developers.cloudflare.com/workers/get-started/guide/).\n\n## 1: Set up your Worker project\n\nTo start, you will need to set up your project to use the following resources on the Developer Platform:\n\n* [Images](https://developers.cloudflare.com/images/transform-images/bindings/) to transform, resize, and encode images directly from your Worker.\n* [R2](https://developers.cloudflare.com/r2/api/workers/workers-api-usage/) to connect the bucket for storing transformed images.\n* [Assets](https://developers.cloudflare.com/workers/static-assets/binding/) to access a static image that will be used as the visual watermark.\n\n### Add the bindings to your Wrangler configuration\n\nConfigure your `wrangler.toml` file to add the Images, R2, and Assets bindings:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Replace `<BUCKET>` with the name of the R2 bucket where you will upload the images after they are transformed. In your Worker code, you will be able to refer to this bucket using `env.R2.`\n\nReplace `./<DIRECTORY>` with the name of the project's directory where the overlay image will be stored. In your Worker code, you will be able to refer to these assets using `env.ASSETS`.\n\n### Set up your assets directory\n\nBecause we want to apply a visual watermark to every uploaded image, you need a place to store the overlay image.\n\nThe assets directory of your project lets you upload static assets as part of your Worker. When you deploy your project, these uploaded files, along with your Worker code, are deployed to Cloudflare's infrastructure in a single operation.\n\nAfter you configure your Wrangler file, upload the overlay image to the specified directory. In our example app, the directory `./assets` contains the overlay image.\n\n## 2: Build your frontend\n\nYou will need to build the interface for the app that lets users upload images.\n\nIn this example, the frontend is rendered directly from the Worker script.\n\nTo do this, make a new `html` variable, which contains a `form` element for accepting uploads. In `fetch`, construct a new `Response` with a `Content-Type: text/html` header to serve your static HTML site to the client:",
      "language": "unknown"
    },
    {
      "code": "## 3: Read the uploaded image\n\nAfter you have a `form`, you need to make sure you can transform the uploaded images.\n\nBecause the `form` lets users upload directly from their disk, you cannot use `fetch()` to get an image from a URL. Instead, you will operate on the body of the image as a stream of bytes.\n\nTo do this, parse the data from the `form` as an array buffer:",
      "language": "unknown"
    },
    {
      "code": "Prevent potential errors when accessing request.body\n\nThe body of a [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) can only be accessed once. If you previously used `request.formData()` in the same request, you may encounter a TypeError when attempting to access `request.body`.\n\nTo avoid errors, create a clone of the Request object with `request.clone()` for each subsequent attempt to access a Request's body. Keep in mind that Workers have a [memory limit of 128 MB per Worker](https://developers.cloudflare.com/workers/platform/limits#worker-limits) and loading particularly large files into a Worker's memory multiple times may reach this limit. To ensure memory usage does not reach this limit, consider using [Streams](https://developers.cloudflare.com/workers/runtime-apis/streams/).\n\n## 4: Transform the image\n\nFor every uploaded image, you want to perform the following actions:\n\n* Overlay the visual watermark that we added to our assets directory.\n* Transcode the image — with its watermark — to `AVIF`. This compresses the image and reduces its file size.\n* Upload the transformed image to R2.\n\n### Set up the overlay image\n\nTo fetch the overlay image from the assets directory, create a function `assetUrl` then use `env.ASSETS` to retrieve the `watermark.png` image:",
      "language": "unknown"
    },
    {
      "code": "### Watermark and transcode the image\n\nYou can interact with the Images binding through `env.IMAGES`.\n\nThis is where you will put all of the optimization operations you want to perform on the image. Here, you will use the `.draw()` function to apply a visual watermark over the uploaded image, then use `.output()` to encode the image as AVIF:",
      "language": "unknown"
    },
    {
      "code": "## 5: Upload to R2\n\nUpload the transformed image to R2.\n\nBy creating a `fileName` variable, you can specify the name of the transformed image. In this example, you append the date to the name of the original image before uploading to R2.\n\nHere is the full code for the example:",
      "language": "unknown"
    },
    {
      "code": "## Next steps\n\nIn this tutorial, you learned how to connect your Worker to various resources on the Developer Platform to build an app that accepts image uploads, transform images, and uploads the output to R2.\n\nNext, you can [set up a transformation URL](https://developers.cloudflare.com/images/transform-images/transform-via-url/) to dynamically optimize images that are stored in R2.\n\n</page>\n\n<page>\n---\ntitle: Accept user-uploaded images · Cloudflare Images docs\ndescription: The Direct Creator Upload feature in Cloudflare Images lets your\n  users upload images with a one-time upload URL without exposing your API key\n  or token to the client. Using a direct creator upload also eliminates the need\n  for an intermediary storage bucket and the storage/egress costs associated\n  with it.\nlastUpdated: 2024-12-20T15:30:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/upload-images/direct-creator-upload/\n  md: https://developers.cloudflare.com/images/upload-images/direct-creator-upload/index.md\n---\n\nThe Direct Creator Upload feature in Cloudflare Images lets your users upload images with a one-time upload URL without exposing your API key or token to the client. Using a direct creator upload also eliminates the need for an intermediary storage bucket and the storage/egress costs associated with it.\n\nYou can set up [webhooks](https://developers.cloudflare.com/images/manage-images/configure-webhooks/) to receive notifications on your direct creator upload workflow.\n\n## Request a one-time upload URL\n\nMake a `POST` request to the `direct_upload` endpoint using the example below as reference.\n\nNote\n\nThe `metadata` included in the request is never shared with end users.",
      "language": "unknown"
    },
    {
      "code": "After a successful request, you will receive a response similar to the example below. The `id` field is a future image identifier that will be uploaded by a creator.",
      "language": "unknown"
    },
    {
      "code": "After calling the endpoint, a new draft image record is created, but the image will not appear in the list of images. If you want to check the status of the image record, you can make a request to the one-time upload URL using the `direct_upload` endpoint.\n\n## Check the image record status\n\nTo check the status of a new draft image record, use the one-time upload URL as shown in the example below.",
      "language": "unknown"
    },
    {
      "code": "After a successful request, you should receive a response similar to the example below. The `draft` field is set to `true` until a creator uploads an image. After an image is uploaded, the draft field is removed.",
      "language": "unknown"
    },
    {
      "code": "The backend endpoint should return the `uploadURL` property to the client, which uploads the image without needing to pass any authentication information with it.\n\nBelow is an example of an HTML page that takes a one-time upload URL and uploads any image the user selects.",
      "language": "unknown"
    },
    {
      "code": "By default, the `uploadURL` expires after 30 minutes if unused. To override this option, add the following argument to the cURL command:",
      "language": "unknown"
    },
    {
      "code": "The expiry value must be a minimum of two minutes and maximum of six hours in the future.\n\n## Direct Creator Upload with custom ID\n\nYou can specify a [custom ID](https://developers.cloudflare.com/images/upload-images/upload-custom-path/) when you first request a one-time upload URL, instead of using the automatically generated ID for your image. Note that images with a custom ID cannot be made private with the [signed URL tokens](https://developers.cloudflare.com/images/manage-images/serve-images/serve-private-images) feature (`--requireSignedURLs=true`).\n\nTo specify a custom ID, pass a form field with the name ID and corresponding custom ID value as shown in the example below.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Upload via batch API · Cloudflare Images docs\ndescription: The Images batch API lets you make several requests in sequence\n  while bypassing Cloudflare’s global API rate limits.\nlastUpdated: 2025-02-10T14:44:19.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/images/upload-images/images-batch/\n  md: https://developers.cloudflare.com/images/upload-images/images-batch/index.md\n---\n\nThe Images batch API lets you make several requests in sequence while bypassing Cloudflare’s global API rate limits.\n\nTo use the Images batch API, you will need to obtain a batch token and use the token to make several requests. The requests authorized by this batch token are made to a separate endpoint and do not count toward the global API rate limits. Each token is subject to a rate limit of 200 requests per second. You can use multiple tokens if you require higher throughput to the Cloudflare Images API.\n\nTo obtain a token, you can use the new `images/v1/batch_token` endpoint as shown in the example below.",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Supported drivers",
      "id": "supported-drivers"
    },
    {
      "level": "h3",
      "text": "Database drivers and Node.js compatibility",
      "id": "database-drivers-and-node.js-compatibility"
    },
    {
      "level": "h2",
      "text": "Driver examples",
      "id": "driver-examples"
    },
    {
      "level": "h3",
      "text": "node-postgres / pg",
      "id": "node-postgres-/-pg"
    },
    {
      "level": "h3",
      "text": "Postgres.js",
      "id": "postgres.js"
    },
    {
      "level": "h2",
      "text": "Identify connections from Hyperdrive",
      "id": "identify-connections-from-hyperdrive"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Metrics",
      "id": "metrics"
    },
    {
      "level": "h2",
      "text": "View metrics in the dashboard",
      "id": "view-metrics-in-the-dashboard"
    },
    {
      "level": "h2",
      "text": "Query via the GraphQL API",
      "id": "query-via-the-graphql-api"
    },
    {
      "level": "h2",
      "text": "Write GraphQL queries",
      "id": "write-graphql-queries"
    },
    {
      "level": "h3",
      "text": "Get the number of queries handled via your Hyperdrive config by cache status",
      "id": "get-the-number-of-queries-handled-via-your-hyperdrive-config-by-cache-status"
    },
    {
      "level": "h3",
      "text": "Get the average query and connection latency for queries handled via your Hyperdrive config within a range of time, excluding queries that failed due to an error",
      "id": "get-the-average-query-and-connection-latency-for-queries-handled-via-your-hyperdrive-config-within-a-range-of-time,-excluding-queries-that-failed-due-to-an-error"
    },
    {
      "level": "h3",
      "text": "Get the total amount of query and result bytes flowing through your Hyperdrive config",
      "id": "get-the-total-amount-of-query-and-result-bytes-flowing-through-your-hyperdrive-config"
    },
    {
      "level": "h2",
      "text": "Configuration errors",
      "id": "configuration-errors"
    },
    {
      "level": "h3",
      "text": "Failure to connect",
      "id": "failure-to-connect"
    },
    {
      "level": "h2",
      "text": "Connection errors",
      "id": "connection-errors"
    },
    {
      "level": "h3",
      "text": "Hyperdrive specific errors",
      "id": "hyperdrive-specific-errors"
    },
    {
      "level": "h3",
      "text": "Node errors",
      "id": "node-errors"
    },
    {
      "level": "h3",
      "text": "Driver errors",
      "id": "driver-errors"
    },
    {
      "level": "h3",
      "text": "Improve performance",
      "id": "improve-performance"
    },
    {
      "level": "h2",
      "text": "Configuration limits",
      "id": "configuration-limits"
    },
    {
      "level": "h2",
      "text": "Connection limits",
      "id": "connection-limits"
    },
    {
      "level": "h3",
      "text": "Connection errors",
      "id": "connection-errors"
    },
    {
      "level": "h2",
      "text": "Query limits",
      "id": "query-limits"
    },
    {
      "level": "h2",
      "text": "Request a limit increase",
      "id": "request-a-limit-increase"
    },
    {
      "level": "h2",
      "text": "Footnotes",
      "id": "footnotes"
    },
    {
      "level": "h2",
      "text": "Footnotes",
      "id": "footnotes"
    },
    {
      "level": "h2",
      "text": "Pricing FAQ",
      "id": "pricing-faq"
    },
    {
      "level": "h3",
      "text": "Does connection pooling or query caching incur additional charges?",
      "id": "does-connection-pooling-or-query-caching-incur-additional-charges?"
    },
    {
      "level": "h3",
      "text": "Are cached queries counted the same as uncached queries?",
      "id": "are-cached-queries-counted-the-same-as-uncached-queries?"
    },
    {
      "level": "h3",
      "text": "Does Hyperdrive charge for data transfer / egress?",
      "id": "does-hyperdrive-charge-for-data-transfer-/-egress?"
    },
    {
      "level": "h2",
      "text": "2025-12-04",
      "id": "2025-12-04"
    },
    {
      "level": "h2",
      "text": "2025-07-03",
      "id": "2025-07-03"
    },
    {
      "level": "h2",
      "text": "2025-05-05",
      "id": "2025-05-05"
    },
    {
      "level": "h2",
      "text": "2025-03-07",
      "id": "2025-03-07"
    },
    {
      "level": "h2",
      "text": "2025-03-07",
      "id": "2025-03-07"
    },
    {
      "level": "h2",
      "text": "2025-01-28",
      "id": "2025-01-28"
    },
    {
      "level": "h2",
      "text": "2024-12-11",
      "id": "2024-12-11"
    },
    {
      "level": "h2",
      "text": "2024-11-19",
      "id": "2024-11-19"
    },
    {
      "level": "h2",
      "text": "2024-10-30",
      "id": "2024-10-30"
    },
    {
      "level": "h2",
      "text": "2024-09-20",
      "id": "2024-09-20"
    },
    {
      "level": "h2",
      "text": "2024-08-19",
      "id": "2024-08-19"
    },
    {
      "level": "h2",
      "text": "2024-08-13",
      "id": "2024-08-13"
    },
    {
      "level": "h2",
      "text": "2024-05-24",
      "id": "2024-05-24"
    },
    {
      "level": "h2",
      "text": "2024-05-22",
      "id": "2024-05-22"
    },
    {
      "level": "h2",
      "text": "2024-04-01",
      "id": "2024-04-01"
    },
    {
      "level": "h2",
      "text": "2024-03-19",
      "id": "2024-03-19"
    },
    {
      "level": "h2",
      "text": "2023-09-28",
      "id": "2023-09-28"
    },
    {
      "level": "h2",
      "text": "Connectivity",
      "id": "connectivity"
    },
    {
      "level": "h3",
      "text": "Does Hyperdrive use specific IP addresses to connect to my database?",
      "id": "does-hyperdrive-use-specific-ip-addresses-to-connect-to-my-database?"
    },
    {
      "level": "h3",
      "text": "Does Hyperdrive support connecting to D1 databases?",
      "id": "does-hyperdrive-support-connecting-to-d1-databases?"
    },
    {
      "level": "h2",
      "text": "Pricing",
      "id": "pricing"
    },
    {
      "level": "h3",
      "text": "Does Hyperdrive charge for data transfer / egress?",
      "id": "does-hyperdrive-charge-for-data-transfer-/-egress?"
    },
    {
      "level": "h3",
      "text": "Is Hyperdrive available on the [Workers Free](https://developers.cloudflare.com/workers/platform/pricing/#workers) plan?",
      "id": "is-hyperdrive-available-on-the-[workers-free](https://developers.cloudflare.com/workers/platform/pricing/#workers)-plan?"
    },
    {
      "level": "h3",
      "text": "Does Hyperdrive charge for additional compute?",
      "id": "does-hyperdrive-charge-for-additional-compute?"
    },
    {
      "level": "h2",
      "text": "Limits",
      "id": "limits"
    },
    {
      "level": "h3",
      "text": "Are there any limits to Hyperdrive?",
      "id": "are-there-any-limits-to-hyperdrive?"
    },
    {
      "level": "h2",
      "text": "Database support",
      "id": "database-support"
    },
    {
      "level": "h2",
      "text": "Supported database providers",
      "id": "supported-database-providers"
    },
    {
      "level": "h2",
      "text": "Supported TLS (SSL) modes",
      "id": "supported-tls-(ssl)-modes"
    },
    {
      "level": "h2",
      "text": "Supported PostgreSQL authentication modes",
      "id": "supported-postgresql-authentication-modes"
    },
    {
      "level": "h2",
      "text": "Unsupported PostgreSQL features:",
      "id": "unsupported-postgresql-features:"
    },
    {
      "level": "h2",
      "text": "Unsupported MySQL features:",
      "id": "unsupported-mysql-features:"
    },
    {
      "level": "h2",
      "text": "`hyperdrive create`",
      "id": "`hyperdrive-create`"
    },
    {
      "level": "h2",
      "text": "`hyperdrive delete`",
      "id": "`hyperdrive-delete`"
    },
    {
      "level": "h2",
      "text": "`hyperdrive get`",
      "id": "`hyperdrive-get`"
    },
    {
      "level": "h2",
      "text": "`hyperdrive list`",
      "id": "`hyperdrive-list`"
    },
    {
      "level": "h2",
      "text": "`hyperdrive update`",
      "id": "`hyperdrive-update`"
    },
    {
      "level": "h2",
      "text": "1. Create a Worker project",
      "id": "1.-create-a-worker-project"
    },
    {
      "level": "h2",
      "text": "2. Prepare your Timescale Service",
      "id": "2.-prepare-your-timescale-service"
    },
    {
      "level": "h2",
      "text": "3. Create your Hypertable",
      "id": "3.-create-your-hypertable"
    },
    {
      "level": "h2",
      "text": "4. Create a database configuration",
      "id": "4.-create-a-database-configuration"
    },
    {
      "level": "h2",
      "text": "5. Deploy your Worker",
      "id": "5.-deploy-your-worker"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Configure notifications",
      "id": "configure-notifications"
    },
    {
      "level": "h2",
      "text": "Bypass zone lockdown",
      "id": "bypass-zone-lockdown"
    },
    {
      "level": "h3",
      "text": "Via the API",
      "id": "via-the-api"
    },
    {
      "level": "h3",
      "text": "Default TTL",
      "id": "default-ttl"
    },
    {
      "level": "h2",
      "text": "Custom setting",
      "id": "custom-setting"
    },
    {
      "level": "h3",
      "text": "Browser TTL for an account",
      "id": "browser-ttl-for-an-account"
    },
    {
      "level": "h3",
      "text": "Browser TTL for a named variant",
      "id": "browser-ttl-for-a-named-variant"
    },
    {
      "level": "h2",
      "text": "Resize via the API",
      "id": "resize-via-the-api"
    },
    {
      "level": "h2",
      "text": "Fit options",
      "id": "fit-options"
    },
    {
      "level": "h2",
      "text": "Metadata options",
      "id": "metadata-options"
    },
    {
      "level": "h2",
      "text": "Public access",
      "id": "public-access"
    },
    {
      "level": "h2",
      "text": "Delete images via the Cloudflare dashboard",
      "id": "delete-images-via-the-cloudflare-dashboard"
    },
    {
      "level": "h2",
      "text": "Delete images via the API",
      "id": "delete-images-via-the-api"
    },
    {
      "level": "h2",
      "text": "Delete variants via the Cloudflare dashboard",
      "id": "delete-variants-via-the-cloudflare-dashboard"
    },
    {
      "level": "h2",
      "text": "Delete variants via the API",
      "id": "delete-variants-via-the-api"
    },
    {
      "level": "h2",
      "text": "Enable flexible variants via the Cloudflare dashboard",
      "id": "enable-flexible-variants-via-the-cloudflare-dashboard"
    },
    {
      "level": "h2",
      "text": "Enable flexible variants via the API",
      "id": "enable-flexible-variants-via-the-api"
    },
    {
      "level": "h2",
      "text": "Export images via the Cloudflare dashboard",
      "id": "export-images-via-the-cloudflare-dashboard"
    },
    {
      "level": "h2",
      "text": "Export images via the API",
      "id": "export-images-via-the-api"
    },
    {
      "level": "h2",
      "text": "2024-04-04",
      "id": "2024-04-04"
    },
    {
      "level": "h2",
      "text": "2024-04-04",
      "id": "2024-04-04"
    },
    {
      "level": "h2",
      "text": "2024-01-15",
      "id": "2024-01-15"
    },
    {
      "level": "h2",
      "text": "Compression options",
      "id": "compression-options"
    },
    {
      "level": "h3",
      "text": "Off",
      "id": "off"
    },
    {
      "level": "h3",
      "text": "Lossless",
      "id": "lossless"
    },
    {
      "level": "h3",
      "text": "Lossy",
      "id": "lossy"
    },
    {
      "level": "h3",
      "text": "WebP",
      "id": "webp"
    },
    {
      "level": "h2",
      "text": "Polish interaction with Image optimization",
      "id": "polish-interaction-with-image-optimization"
    },
    {
      "level": "h2",
      "text": "In the **lossless** mode, it is not feasible to convert JPEG to WebP",
      "id": "in-the-**lossless**-mode,-it-is-not-feasible-to-convert-jpeg-to-webp"
    },
    {
      "level": "h2",
      "text": "Low-quality JPEG images do not convert well to WebP",
      "id": "low-quality-jpeg-images-do-not-convert-well-to-webp"
    },
    {
      "level": "h2",
      "text": "For some images conversion to WebP can degrade quality too much",
      "id": "for-some-images-conversion-to-webp-can-degrade-quality-too-much"
    },
    {
      "level": "h2",
      "text": "Sometimes older formats are better than WebP",
      "id": "sometimes-older-formats-are-better-than-webp"
    },
    {
      "level": "h2",
      "text": "Beware of compression that is not better, only more of the same",
      "id": "beware-of-compression-that-is-not-better,-only-more-of-the-same"
    },
    {
      "level": "h2",
      "text": "Requests without resizing enabled",
      "id": "requests-without-resizing-enabled"
    },
    {
      "level": "h2",
      "text": "Error responses from resizing",
      "id": "error-responses-from-resizing"
    },
    {
      "level": "h2",
      "text": "Limits",
      "id": "limits"
    },
    {
      "level": "h2",
      "text": "Authorization and cookies are not supported",
      "id": "authorization-and-cookies-are-not-supported"
    },
    {
      "level": "h2",
      "text": "Caching and purging",
      "id": "caching-and-purging"
    },
    {
      "level": "h2",
      "text": "Setup",
      "id": "setup"
    },
    {
      "level": "h2",
      "text": "Methods",
      "id": "methods"
    },
    {
      "level": "h3",
      "text": "`.transform()`",
      "id": "`.transform()`"
    },
    {
      "level": "h3",
      "text": "`.draw()`",
      "id": "`.draw()`"
    },
    {
      "level": "h3",
      "text": "`.output()`",
      "id": "`.output()`"
    },
    {
      "level": "h3",
      "text": "`.info()`",
      "id": "`.info()`"
    },
    {
      "level": "h2",
      "text": "Interact with your Images binding locally",
      "id": "interact-with-your-images-binding-locally"
    },
    {
      "level": "h2",
      "text": "Hiding the image server",
      "id": "hiding-the-image-server"
    },
    {
      "level": "h2",
      "text": "Preventing access to full-size images",
      "id": "preventing-access-to-full-size-images"
    },
    {
      "level": "h2",
      "text": "Avoid image dimensions in URLs",
      "id": "avoid-image-dimensions-in-urls"
    },
    {
      "level": "h2",
      "text": "Authenticated origin",
      "id": "authenticated-origin"
    },
    {
      "level": "h2",
      "text": "Next.js",
      "id": "next.js"
    },
    {
      "level": "h3",
      "text": "Global Loader",
      "id": "global-loader"
    },
    {
      "level": "h3",
      "text": "Custom Loaders",
      "id": "custom-loaders"
    },
    {
      "level": "h2",
      "text": "Draw options",
      "id": "draw-options"
    },
    {
      "level": "h2",
      "text": "Draw using the Images binding",
      "id": "draw-using-the-images-binding"
    },
    {
      "level": "h2",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h3",
      "text": "Stock Photo Watermark",
      "id": "stock-photo-watermark"
    },
    {
      "level": "h3",
      "text": "Signature",
      "id": "signature"
    },
    {
      "level": "h3",
      "text": "Centered icon",
      "id": "centered-icon"
    },
    {
      "level": "h3",
      "text": "Combined",
      "id": "combined"
    },
    {
      "level": "h2",
      "text": "Transform with HTML `srcset`",
      "id": "transform-with-html-`srcset`"
    },
    {
      "level": "h3",
      "text": "`srcset` for high-DPI displays",
      "id": "`srcset`-for-high-dpi-displays"
    },
    {
      "level": "h3",
      "text": "`srcset` for responsive images",
      "id": "`srcset`-for-responsive-images"
    },
    {
      "level": "h2",
      "text": "WebP images",
      "id": "webp-images"
    },
    {
      "level": "h2",
      "text": "Transform with `width` parameter",
      "id": "transform-with-`width`-parameter"
    },
    {
      "level": "h3",
      "text": "Client hints",
      "id": "client-hints"
    },
    {
      "level": "h2",
      "text": "Enable",
      "id": "enable"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "Serve images from custom paths",
      "id": "serve-images-from-custom-paths"
    },
    {
      "level": "h3",
      "text": "Basic version",
      "id": "basic-version"
    },
    {
      "level": "h3",
      "text": "Advanced version",
      "id": "advanced-version"
    },
    {
      "level": "h2",
      "text": "Modify existing URLs to be compatible with transformations in Images",
      "id": "modify-existing-urls-to-be-compatible-with-transformations-in-images"
    },
    {
      "level": "h2",
      "text": "Pass every image requested on your zone through Images",
      "id": "pass-every-image-requested-on-your-zone-through-images"
    },
    {
      "level": "h2",
      "text": "How it works",
      "id": "how-it-works"
    },
    {
      "level": "h2",
      "text": "Allow source images only from allowed origins",
      "id": "allow-source-images-only-from-allowed-origins"
    },
    {
      "level": "h2",
      "text": "Allow source images from any origin",
      "id": "allow-source-images-from-any-origin"
    },
    {
      "level": "h2",
      "text": "Options",
      "id": "options"
    },
    {
      "level": "h3",
      "text": "`anim`",
      "id": "`anim`"
    },
    {
      "level": "h3",
      "text": "`background`",
      "id": "`background`"
    },
    {
      "level": "h3",
      "text": "`blur`",
      "id": "`blur`"
    },
    {
      "level": "h3",
      "text": "`border`",
      "id": "`border`"
    },
    {
      "level": "h3",
      "text": "`brightness`",
      "id": "`brightness`"
    },
    {
      "level": "h3",
      "text": "`compression`",
      "id": "`compression`"
    },
    {
      "level": "h3",
      "text": "`contrast`",
      "id": "`contrast`"
    },
    {
      "level": "h3",
      "text": "`dpr`",
      "id": "`dpr`"
    },
    {
      "level": "h3",
      "text": "`fit`",
      "id": "`fit`"
    },
    {
      "level": "h3",
      "text": "`flip`",
      "id": "`flip`"
    },
    {
      "level": "h3",
      "text": "`format`",
      "id": "`format`"
    },
    {
      "level": "h3",
      "text": "`gamma`",
      "id": "`gamma`"
    },
    {
      "level": "h3",
      "text": "`gravity`",
      "id": "`gravity`"
    },
    {
      "level": "h3",
      "text": "`height`",
      "id": "`height`"
    },
    {
      "level": "h3",
      "text": "`metadata`",
      "id": "`metadata`"
    },
    {
      "level": "h3",
      "text": "`onerror`",
      "id": "`onerror`"
    },
    {
      "level": "h3",
      "text": "`quality`",
      "id": "`quality`"
    },
    {
      "level": "h3",
      "text": "`rotate`",
      "id": "`rotate`"
    },
    {
      "level": "h3",
      "text": "`saturation`",
      "id": "`saturation`"
    },
    {
      "level": "h3",
      "text": "`segment`",
      "id": "`segment`"
    },
    {
      "level": "h3",
      "text": "`sharpen`",
      "id": "`sharpen`"
    },
    {
      "level": "h3",
      "text": "`slow-connection-quality`",
      "id": "`slow-connection-quality`"
    },
    {
      "level": "h3",
      "text": "`trim`",
      "id": "`trim`"
    },
    {
      "level": "h3",
      "text": "`width`",
      "id": "`width`"
    },
    {
      "level": "h3",
      "text": "`zoom`",
      "id": "`zoom`"
    },
    {
      "level": "h2",
      "text": "Recommended image sizes",
      "id": "recommended-image-sizes"
    },
    {
      "level": "h2",
      "text": "Caching",
      "id": "caching"
    },
    {
      "level": "h2",
      "text": "Fetch options",
      "id": "fetch-options"
    },
    {
      "level": "h3",
      "text": "`anim`",
      "id": "`anim`"
    },
    {
      "level": "h3",
      "text": "`background`",
      "id": "`background`"
    },
    {
      "level": "h3",
      "text": "`blur`",
      "id": "`blur`"
    },
    {
      "level": "h3",
      "text": "`border`",
      "id": "`border`"
    },
    {
      "level": "h3",
      "text": "`brightness`",
      "id": "`brightness`"
    },
    {
      "level": "h3",
      "text": "`compression`",
      "id": "`compression`"
    },
    {
      "level": "h3",
      "text": "`contrast`",
      "id": "`contrast`"
    },
    {
      "level": "h3",
      "text": "`dpr`",
      "id": "`dpr`"
    },
    {
      "level": "h3",
      "text": "`fit`",
      "id": "`fit`"
    },
    {
      "level": "h3",
      "text": "`flip`",
      "id": "`flip`"
    },
    {
      "level": "h3",
      "text": "`format`",
      "id": "`format`"
    },
    {
      "level": "h3",
      "text": "`gamma`",
      "id": "`gamma`"
    },
    {
      "level": "h3",
      "text": "`gravity`",
      "id": "`gravity`"
    },
    {
      "level": "h3",
      "text": "`height`",
      "id": "`height`"
    },
    {
      "level": "h3",
      "text": "`metadata`",
      "id": "`metadata`"
    },
    {
      "level": "h3",
      "text": "`onerror`",
      "id": "`onerror`"
    },
    {
      "level": "h3",
      "text": "`quality`",
      "id": "`quality`"
    },
    {
      "level": "h3",
      "text": "`rotate`",
      "id": "`rotate`"
    },
    {
      "level": "h3",
      "text": "`saturation`",
      "id": "`saturation`"
    },
    {
      "level": "h3",
      "text": "`segment`",
      "id": "`segment`"
    },
    {
      "level": "h3",
      "text": "`sharpen`",
      "id": "`sharpen`"
    },
    {
      "level": "h3",
      "text": "`trim`",
      "id": "`trim`"
    },
    {
      "level": "h3",
      "text": "`width`",
      "id": "`width`"
    },
    {
      "level": "h3",
      "text": "`zoom`",
      "id": "`zoom`"
    },
    {
      "level": "h2",
      "text": "Configure a Worker",
      "id": "configure-a-worker"
    },
    {
      "level": "h3",
      "text": "Prevent request loops",
      "id": "prevent-request-loops"
    },
    {
      "level": "h2",
      "text": "Lack of preview in the dashboard",
      "id": "lack-of-preview-in-the-dashboard"
    },
    {
      "level": "h2",
      "text": "Error handling",
      "id": "error-handling"
    },
    {
      "level": "h2",
      "text": "An example worker",
      "id": "an-example-worker"
    },
    {
      "level": "h2",
      "text": "Warning about `cacheKey`",
      "id": "warning-about-`cachekey`"
    },
    {
      "level": "h2",
      "text": "Modify your loading attribute",
      "id": "modify-your-loading-attribute"
    },
    {
      "level": "h3",
      "text": "Lazy loading",
      "id": "lazy-loading"
    },
    {
      "level": "h3",
      "text": "Eager loading",
      "id": "eager-loading"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1: Set up your Worker project",
      "id": "1:-set-up-your-worker-project"
    },
    {
      "level": "h3",
      "text": "Add the bindings to your Wrangler configuration",
      "id": "add-the-bindings-to-your-wrangler-configuration"
    },
    {
      "level": "h3",
      "text": "Set up your assets directory",
      "id": "set-up-your-assets-directory"
    },
    {
      "level": "h2",
      "text": "2: Build your frontend",
      "id": "2:-build-your-frontend"
    },
    {
      "level": "h2",
      "text": "3: Read the uploaded image",
      "id": "3:-read-the-uploaded-image"
    },
    {
      "level": "h2",
      "text": "4: Transform the image",
      "id": "4:-transform-the-image"
    },
    {
      "level": "h3",
      "text": "Set up the overlay image",
      "id": "set-up-the-overlay-image"
    },
    {
      "level": "h3",
      "text": "Watermark and transcode the image",
      "id": "watermark-and-transcode-the-image"
    },
    {
      "level": "h2",
      "text": "5: Upload to R2",
      "id": "5:-upload-to-r2"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Request a one-time upload URL",
      "id": "request-a-one-time-upload-url"
    },
    {
      "level": "h2",
      "text": "Check the image record status",
      "id": "check-the-image-record-status"
    },
    {
      "level": "h2",
      "text": "Direct Creator Upload with custom ID",
      "id": "direct-creator-upload-with-custom-id"
    }
  ],
  "url": "llms-txt#wrangler-v3.11-and-above-required",
  "links": []
}