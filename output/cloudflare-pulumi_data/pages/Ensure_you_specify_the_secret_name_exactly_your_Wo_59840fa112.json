{
  "title": "Ensure you specify the secret name exactly: your Worker will need to reference it later.",
  "content": "npx wrangler secret put LIBSQL_DB_AUTH_TOKEN\nsh\n? Enter a secret value: â€º <paste your token here>\nsh\n  npm i @libsql/client itty-router\n  sh\n  yarn add @libsql/client itty-router\n  sh\n  pnpm add @libsql/client itty-router\n  ts\nimport { Client as LibsqlClient, createClient } from \"@libsql/client/web\";\nimport { Router, RouterType } from \"itty-router\";\n\nexport interface Env {\n  // The environment variable containing your the URL for your Turso database.\n  LIBSQL_DB_URL?: string;\n  // The Secret that contains the authentication token for your Turso database.\n  LIBSQL_DB_AUTH_TOKEN?: string;\n\n// These objects are created before first use, then stashed here\n  // for future use\n  router?: RouterType;\n}\n\nexport default {\n  async fetch(request, env): Promise<Response> {\n    if (env.router === undefined) {\n      env.router = buildRouter(env);\n    }\n\nreturn env.router.fetch(request);\n  },\n} satisfies ExportedHandler<Env>;\n\nfunction buildLibsqlClient(env: Env): LibsqlClient {\n  const url = env.LIBSQL_DB_URL?.trim();\n  if (url === undefined) {\n    throw new Error(\"LIBSQL_DB_URL env var is not defined\");\n  }\n\nconst authToken = env.LIBSQL_DB_AUTH_TOKEN?.trim();\n  if (authToken === undefined) {\n    throw new Error(\"LIBSQL_DB_AUTH_TOKEN env var is not defined\");\n  }\n\nreturn createClient({ url, authToken });\n}\n\nfunction buildRouter(env: Env): RouterType {\n  const router = Router();\n\nrouter.get(\"/users\", async () => {\n    const client = buildLibsqlClient(env);\n    const rs = await client.execute(\"select * from example_users\");\n    return Response.json(rs);\n  });\n\nrouter.get(\"/add-user\", async (request) => {\n    const client = buildLibsqlClient(env);\n    const email = request.query.email;\n    if (email === undefined) {\n      return new Response(\"Missing email\", { status: 400 });\n    }\n    if (typeof email !== \"string\") {\n      return new Response(\"email must be a single string\", { status: 400 });\n    }\n    if (email.length === 0) {\n      return new Response(\"email length must be > 0\", { status: 400 });\n    }\n\ntry {\n      await client.execute({\n        sql: \"insert into example_users values (?)\",\n        args: [email],\n      });\n    } catch (e) {\n      console.error(e);\n      return new Response(\"database insert failed\");\n    }\n\nreturn new Response(\"Added\");\n  });\n\nrouter.all(\"*\", () => new Response(\"Not Found.\", { status: 404 }));\n\nreturn router;\n}\nsh\nnpx wrangler dev\ntxt\nYour worker has access to the following bindings:\n- Vars:\n  - LIBSQL_DB_URL: \"your-url\"\nâ” Starting a local server...\nâ•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®\nâ”‚ [b] open a browser, [d] open Devtools, [l] turn off local mode, [c] clear console, [x] to exit                                                                    â”‚\nâ•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯\nDebugger listening on ws://127.0.0.1:61918/1064babd-bc9d-4bed-b171-b35dab3b7680\nFor help, see: https://nodejs.org/en/docs/inspector\nDebugger attached.\n[mf:inf] Worker reloaded! (40.25KiB)\n[mf:inf] Listening on 0.0.0.0:8787\n[mf:inf] - http://127.0.0.1:8787\n[mf:inf] - http://192.168.1.136:8787\n[mf:inf] Updated `Request.cf` object cache!\njson\n{\n  \"columns\": [\"email\"],\n  \"rows\": [{ \"email\": \"foo@bar.com\" }],\n  \"rowsAffected\": 0\n}\nsh\nnpx wrangler deploy\ntxt\nYour worker has access to the following bindings:\n- Vars:\n  - LIBSQL_DB_URL: \"your-url\"\n...\nPublished worker-turso-ts (0.19 sec)\n  https://worker-turso-ts.<your-Workers-subdomain>.workers.dev\nCurrent Deployment ID: f9e6b48f-5aac-40bd-8f44-8a40be2212ff\nsh\n  npm create cloudflare@latest -- finetune-chatgpt-model\n  sh\n  yarn create cloudflare finetune-chatgpt-model\n  sh\n  pnpm create cloudflare@latest finetune-chatgpt-model\n  sh\ncd finetune-chatgpt-model\nsh\nnpx wrangler r2 bucket create <BUCKET_NAME>\nsh\nnpx wrangler r2 object put <PATH> -f <FILE_NAME>\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"r2_buckets\": [\n      {\n        \"binding\": \"MY_BUCKET\",\n        \"bucket_name\": \"<YOUR_BUCKET_NAME>\"\n      }\n    ]\n  }\n  toml\n  [[r2_buckets]]\n  binding = 'MY_BUCKET' # <~ valid JavaScript variable name\n  bucket_name = '<YOUR_BUCKET_NAME>'\n  sh\n  npm i hono\n  sh\n  yarn add hono\n  sh\n  pnpm add hono\n  sh\n  npm i openai\n  sh\n  yarn add openai\n  sh\n  pnpm add openai\n  typescript\nimport { Context, Hono } from \"hono\";\nimport OpenAI from \"openai\";\n\ntype Bindings = {\n  <MY_BUCKET>: R2Bucket\n  OPENAI_API_KEY: string\n}\n\ntype Variables = {\n  openai: OpenAI\n}\n\nconst app = new Hono<{ Bindings: Bindings, Variables: Variables }>()\n\napp.use('*', async (c, next) => {\n  const openai = new OpenAI({\n    apiKey: c.env.OPENAI_API_KEY,\n  })\n  c.set(\"openai\", openai)\n  await next()\n})\n\napp.onError((err, c) => {\n  return c.text(err.message, 500)\n})\n\nexport default app;\ntypescript\n// New import added at beginning of file\nimport { toFile } from 'openai/uploads'\n\nconst createFile = async (c: Context, r2Object: R2ObjectBody) => {\n  const openai: OpenAI = c.get(\"openai\")\n\nconst blob = await r2Object.blob()\n  const file = await toFile(blob, r2Object.key)\n\nconst uploadedFile = await openai.files.create({\n    file,\n    purpose: \"fine-tune\",\n  })\n\nreturn uploadedFile\n}\n\napp.get('/files', async c => {\n  const fileQueryParam = c.req.query(\"file\")\n  if (!fileQueryParam) return c.text(\"Missing file query param\", 400)\n\nconst file = await c.env.<MY_BUCKET>.get(fileQueryParam)\n  if (!file) return c.text(\"Couldn't find file\", 400)\n\nconst uploadedFile = await createFile(c, file)\n  return c.json(uploadedFile)\n})\ntypescript\nconst createModel = async (c: Context, fileId: string) => {\n  const openai: OpenAI = c.get(\"openai\");\n\nconst body = {\n    training_file: fileId,\n    model: \"gpt-4o-mini\",\n  };\n\nreturn openai.fineTuning.jobs.create(body);\n};\n\napp.get(\"/models\", async (c) => {\n  const fileId = c.req.query(\"file_id\");\n  if (!fileId) return c.text(\"Missing file ID query param\", 400);\n\nconst model = await createModel(c, fileId);\n  return c.json(model);\n});\ntypescript\nconst getJobs = async (c: Context) => {\n  const openai: OpenAI = c.get(\"openai\");\n  const resp = await openai.fineTuning.jobs.list();\n  return resp.data;\n};\n\napp.get(\"/jobs\", async (c) => {\n  const jobs = await getJobs(c);\n  return c.json(jobs);\n});\nsh\nnpx wrangler secret put OPENAI_API_KEY\nsh\nnpx wrangler deploy\nsh\ncurl https://your-worker-url.com/files?file=finetune.jsonl\nsh\ncurl https://your-worker-url.com/models?file_id=file-abc123\njavascript\nopenai.chat.completions.create({\n  messages: [{ role: \"system\", content: \"You are a helpful assistant.\" }],\n  model: \"ft:gpt-4o-mini:my-org:custom_suffix:id\",\n});\nsh\ngit clone https://github.com/cloudflare/workers-chat-demo.git\nsh\nnpx wrangler login\nsh\nnpx wrangler deploy\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"routes\": [\n      {\n        \"pattern\": \"example.com/about\",\n        \"zone_id\": \"<YOUR_ZONE_ID>\"\n      }\n    ]\n  }\n  toml\n  [[routes]]\n  pattern = \"example.com/about\"\n  zone_id = \"<YOUR_ZONE_ID>\"\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"routes\": [\n      {\n        \"pattern\": \"subdomain.example.com\",\n        \"custom_domain\": true\n      }\n    ]\n  }\n  toml\n  [[routes]]\n  pattern = \"subdomain.example.com\"\n  custom_domain = true\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"durable_objects\": {\n      \"bindings\": []\n    },\n    \"migrations\": [\n      {\n        \"tag\": \"v1\",\n        \"new_sqlite_classes\": [\n          \"ChatRoom\",\n          \"RateLimiter\"\n        ]\n      },\n      {\n        \"tag\": \"v2\",\n        \"deleted_classes\": [\n          \"ChatRoom\",\n          \"RateLimiter\"\n        ]\n      }\n    ]\n  }\n  toml\n  [durable_objects]\n  bindings = [\n  ]\n\n# Indicate that you want the ChatRoom and RateLimiter classes to be callable as Durable Objects.\n  [[migrations]]\n  tag = \"v1\" # Should be unique for each entry\n  new_sqlite_classes = [\"ChatRoom\", \"RateLimiter\"]\n\n[[migrations]]\n  tag = \"v2\"\n  deleted_classes = [\"ChatRoom\", \"RateLimiter\"]\n  sh\n  npm create cloudflare@latest -- express-d1-app\n  sh\n  yarn create cloudflare express-d1-app\n  sh\n  pnpm create cloudflare@latest express-d1-app\n  sh\ncd express-d1-app\nsh\n  npm i express @types/express\n  sh\n  yarn add express @types/express\n  sh\n  pnpm add express @types/express\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ]\n  }\n  toml\n  compatibility_flags = [\"nodejs_compat\"]\n  sh\nnpx wrangler d1 create members-db\nsh\n â›…ï¸ wrangler 4.44.0\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâœ… Successfully created DB 'members-db' in region WNAM\nCreated your new D1 database.\n\nTo access your new D1 Database in your Worker, add the following snippet to your configuration file:\n{\n  \"d1_databases\": [\n    {\n      \"binding\": \"members_db\",\n      \"database_name\": \"members-db\",\n      \"database_id\": \"<unique-ID-for-your-database>\"\n    }\n  ]\n}\nâœ” Would you like Wrangler to add it on your behalf? â€¦ yes\nâœ” What binding name would you like to use? â€¦ DB\nâœ” For local dev, do you want to connect to the remote resource instead of a local resource? â€¦ no\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"d1_databases\": [\n      {\n        \"binding\": \"DB\",\n        \"database_name\": \"members-db\",\n        \"database_id\": \"<unique-ID-for-your-database>\"\n      }\n    ]\n  }\n  toml\n  [[d1_databases]]\n  binding = \"DB\"\n  database_name = \"members-db\"\n  database_id = \"<unique-ID-for-your-database>\"\n  sql\nDROP TABLE IF EXISTS members;\nCREATE TABLE IF NOT EXISTS members (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  name TEXT NOT NULL,\n  email TEXT NOT NULL UNIQUE,\n  joined_date TEXT NOT NULL\n);\n\n-- Insert sample data\nINSERT INTO members (name, email, joined_date) VALUES\n  ('Alice Johnson', 'alice@example.com', '2024-01-15'),\n  ('Bob Smith', 'bob@example.com', '2024-02-20'),\n  ('Carol Williams', 'carol@example.com', '2024-03-10');\nsh\nnpx wrangler d1 execute members-db --file=./schemas/schema.sql\nts\nimport { env } from \"cloudflare:workers\";\nimport { httpServerHandler } from \"cloudflare:node\";\nimport express from \"express\";\n\nconst app = express();\n\n// Middleware to parse JSON bodies\napp.use(express.json());\n\n// Health check endpoint\napp.get(\"/\", (req, res) => {\n  res.json({ message: \"Express.js running on Cloudflare Workers!\" });\n});\n\napp.listen(3000);\nexport default httpServerHandler({ port: 3000 });\nsh\nnpm run cf-typegen\ntypescript\n// GET all members\napp.get('/api/members', async (req, res) => {\n  try {\n    const { results } = await env.DB.prepare('SELECT * FROM members ORDER BY joined_date DESC').all();\n\nres.json({ success: true, members: results });\n  } catch (error) {\n    res.status(500).json({ success: false, error: 'Failed to fetch members' });\n  }\n});\n\n// GET a single member by ID\napp.get('/api/members/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n\nconst { results } = await env.DB.prepare('SELECT * FROM members WHERE id = ?').bind(id).all();\n\nif (results.length === 0) {\n      return res.status(404).json({ success: false, error: 'Member not found' });\n    }\n\nres.json({ success: true, member: results[0] });\n  } catch (error) {\n    res.status(500).json({ success: false, error: 'Failed to fetch member' });\n  }\n});\ntypescript\n// POST - Create a new member\napp.post(\"/api/members\", async (req, res) => {\n  try {\n    const { name, email } = req.body;\n\n// Validate input\n    if (!name || !email) {\n      return res.status(400).json({\n        success: false,\n        error: \"Name and email are required\",\n      });\n    }\n\n// Basic email validation (simplified for tutorial purposes)\n    // For production, consider using a validation library or more comprehensive checks\n    if (!email.includes(\"@\") || !email.includes(\".\")) {\n      return res.status(400).json({\n        success: false,\n        error: \"Invalid email format\",\n      });\n    }\n\nconst joined_date = new Date().toISOString().split(\"T\")[0];\n\nconst result = await env.DB.prepare(\n      \"INSERT INTO members (name, email, joined_date) VALUES (?, ?, ?)\"\n    )\n      .bind(name, email, joined_date)\n      .run();\n\nif (result.success) {\n      res.status(201).json({\n        success: true,\n        message: \"Member created successfully\",\n        id: result.meta.last_row_id,\n      });\n    } else {\n      res\n        .status(500)\n        .json({ success: false, error: \"Failed to create member\" });\n    }\n  } catch (error: any) {\n    // Handle unique constraint violation\n    if (error.message?.includes(\"UNIQUE constraint failed\")) {\n      return res.status(409).json({\n        success: false,\n        error: \"Email already exists\",\n      });\n    }\n    res.status(500).json({ success: false, error: \"Failed to create member\" });\n  }\n});\ntypescript\napp.put(\"/api/members/:id\", async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { name, email } = req.body;\n\n// Validate input\n    if (!name && !email) {\n      return res.status(400).json({\n        success: false,\n        error: \"At least one field (name or email) is required\",\n      });\n    }\n\n// Basic email validation if provided (simplified for tutorial purposes)\n    // For production, consider using a validation library or more comprehensive checks\n    if (email && (!email.includes(\"@\") || !email.includes(\".\"))) {\n      return res.status(400).json({\n        success: false,\n        error: \"Invalid email format\",\n      });\n    }\n\n// Build dynamic update query\n    const updates: string[] = [];\n    const values: any[] = [];\n\nif (name) {\n      updates.push(\"name = ?\");\n      values.push(name);\n    }\n    if (email) {\n      updates.push(\"email = ?\");\n      values.push(email);\n    }\n\nconst result = await env.DB.prepare(\n      `UPDATE members SET ${updates.join(\", \")} WHERE id = ?`\n    )\n      .bind(...values)\n      .run();\n\nif (result.meta.changes === 0) {\n      return res\n        .status(404)\n        .json({ success: false, error: \"Member not found\" });\n    }\n\nres.json({ success: true, message: \"Member updated successfully\" });\n  } catch (error: any) {\n    if (error.message?.includes(\"UNIQUE constraint failed\")) {\n      return res.status(409).json({\n        success: false,\n        error: \"Email already exists\",\n      });\n    }\n    res.status(500).json({ success: false, error: \"Failed to update member\" });\n  }\n});\ntypescript\n// DELETE - Delete a member\napp.delete(\"/api/members/:id\", async (req, res) => {\n  try {\n    const { id } = req.params;\n\nconst result = await env.DB.prepare(\"DELETE FROM members WHERE id = ?\")\n      .bind(id)\n      .run();\n\nif (result.meta.changes === 0) {\n      return res\n        .status(404)\n        .json({ success: false, error: \"Member not found\" });\n    }\n\nres.json({ success: true, message: \"Member deleted successfully\" });\n  } catch (error) {\n    res.status(500).json({ success: false, error: \"Failed to delete member\" });\n  }\n});\nsh\nnpm run dev\nsh\ncurl http://localhost:8787/api/members\njson\n{\n  \"success\": true,\n  \"members\": [\n    {\n      \"id\": 1,\n      \"name\": \"Alice Johnson\",\n      \"email\": \"alice@example.com\",\n      \"joined_date\": \"2024-01-15\"\n    },\n    {\n      \"id\": 2,\n      \"name\": \"Bob Smith\",\n      \"email\": \"bob@example.com\",\n      \"joined_date\": \"2024-02-20\"\n    },\n    {\n      \"id\": 3,\n      \"name\": \"Carol Williams\",\n      \"email\": \"carol@example.com\",\n      \"joined_date\": \"2024-03-10\"\n    }\n  ]\n}\nsh\ncurl -X POST http://localhost:8787/api/members \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"David Brown\", \"email\": \"david@example.com\"}'\njson\n{\n  \"success\": true,\n  \"message\": \"Member created successfully\",\n  \"id\": 4\n}\nsh\ncurl http://localhost:8787/api/members/1\nsh\ncurl -X PUT http://localhost:8787/api/members/1 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"Alice Cooper\"}'\nsh\ncurl -X DELETE http://localhost:8787/api/members/4\nsh\nnpx wrangler d1 execute members-db --remote --file=./schemas/schema.sql\nsh\nnpm run deploy\nsh\nâ›…ï¸ wrangler 4.44.0\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTotal Upload: 1743.64 KiB / gzip: 498.65 KiB\nWorker Startup Time: 48 ms\nYour Worker has access to the following bindings:\nBinding                  Resource\nenv.DB (members-db)      D1 Database\n\nUploaded express-d1-app (2.99 sec)\nDeployed express-d1-app triggers (5.26 sec)\n  https://<your-subdomain>.workers.dev\nCurrent Version ID: <version-id>\nsh\ncurl https://<your-worker-url>/api/members\nsh\ncurl -X POST https://<your-worker-url>/api/members \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"name\": \"Eva Martinez\", \"email\": \"eva@example.com\"}'\nsh\ncurl --request POST \\\n --url https://api.cloudflare.com/client/v4/accounts/<ACCOUNT_ID>/images/v1 \\\n --header 'Authorization: Bearer <API_TOKEN>' \\\n --form 'url=<PATH_TO_IMAGE>' \\\n --form 'metadata={\"key\":\"value\"}' \\\n --form 'requireSignedURLs=false'\njson\n{\n  \"result\": {\n    \"id\": \"2cdc28f0-017a-49c4-9ed7-87056c83901\",\n    \"filename\": \"image.jpeg\",\n    \"metadata\": {\n      \"key\": \"value\"\n    },\n    \"uploaded\": \"2022-01-31T16:39:28.458Z\",\n    \"requireSignedURLs\": false,\n    \"variants\": [\n      \"https://imagedelivery.net/Vi7wi5KSItxGFsWRG2Us6Q/2cdc28f0-017a-49c4-9ed7-87056c83901/public\",\n      \"https://imagedelivery.net/Vi7wi5KSItxGFsWRG2Us6Q/2cdc28f0-017a-49c4-9ed7-87056c83901/thumbnail\"\n    ]\n  },\n  \"success\": true,\n  \"errors\": [],\n  \"messages\": []\n}\nsh\n  cargo install cargo-generate\n  sh\ncargo generate https://github.com/cloudflare/rustwasm-worker-template\nrs\nuse worker::*;\nmod utils;\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _ctx: worker::Context) -> Result<Response> {\n   // Optionally, get more helpful error messages written to the console in the case of a panic.\n   utils::set_panic_hook();\n\nlet router = Router::new();\n   router\n       .get(\"/\", |_, _| Response::ok(\"Hello from Workers!\"))\n       .run(req, env)\n       .await\n}\nsh\ncargo add text-to-png@0.2.0\nrs\nuse text_to_png::{TextPng, TextRenderer};\nuse worker::*;\nmod utils;\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _ctx: worker::Context) -> Result<Response> {\n   // Optionally, get more helpful error messages written to the console in the case of a panic.\n   utils::set_panic_hook();\n\nlet router = Router::new();\n   router\n       .get(\"/\", |_, _| Response::ok(\"Hello from Workers!\"))\n       .run(req, env)\n       .await\n}\nrs\nuse text_to_png::{TextPng, TextRenderer};\nuse worker::*;\nmod utils;\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _ctx: worker::Context) -> Result<Response> {\n   // Optionally, get more helpful error messages written to the console in the case of a panic.\n   utils::set_panic_hook();\n\nlet router = Router::new();\n   router\n       .get(\"/\", |_, _| Response::ok(\"Hello from Workers!\"))\n       .run(req, env)\n       .await\n}\n\nasync fn handle_slash(text: String) -> Result<Response> {}\nrs\nuse text_to_png::{TextPng, TextRenderer};\nuse worker::*;\nmod utils;\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _ctx: worker::Context) -> Result<Response> {\n   // Optionally, get more helpful error messages written to the console in the case of a panic.\n   utils::set_panic_hook();\n\nlet router = Router::new();\n   router\n       .get(\"/\", |_, _| Response::ok(\"Hello from Workers!\"))\n       .run(req, env)\n       .await\n}\n\nasync fn handle_slash(text: String) -> Result<Response> {\n  let renderer = TextRenderer::try_new_with_ttf_font_data(include_bytes!(\"../assets/Inter-Bold.ttf\"))\n    .expect(\"Example font is definitely loadable\");\n\nlet text_png: TextPng = renderer.render_text_to_png_data(text.replace(\"+\", \" \"), 60, \"003682\").unwrap();\n}\nrs\nuse text_to_png::{TextPng, TextRenderer};\nuse worker::*;\nmod utils;\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _ctx: worker::Context) -> Result<Response> {\n   // Optionally, get more helpful error messages written to the console in the case of a panic.\n   utils::set_panic_hook();\n\nlet router = Router::new();\n    router\n      .get_async(\"/\", |req, _| async move {\n        if let Some(text) = req.url()?.query() {\n          handle_slash(text.into()).await\n        } else {\n          handle_slash(\"Hello Worker!\".into()).await\n        }\n      })\n      .run(req, env)\n        .await\n}\n\nasync fn handle_slash(text: String) -> Result<Response> {\n  let renderer = TextRenderer::try_new_with_ttf_font_data(include_bytes!(\"../assets/Inter-Bold.ttf\"))\n    .expect(\"Example font is definitely loadable\");\n\nlet text_png: TextPng = renderer.render_text_to_png_data(text.replace(\"+\", \" \"), 60, \"003682\").unwrap();\n}\nrs\nuse text_to_png::{TextPng, TextRenderer};\nuse worker::*;\nmod utils;\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _ctx: worker::Context) -> Result<Response> {\n   // Optionally, get more helpful error messages written to the console in the case of a panic.\n   utils::set_panic_hook();\n\nlet router = Router::new();\n    router\n      .get_async(\"/\", |req, _| async move {\n        if let Some(text) = req.url()?.query() {\n          handle_slash(text.into()).await\n        } else {\n          handle_slash(\"Hello Worker!\".into()).await\n        }\n      })\n      .run(req, env)\n        .await\n}\n\nasync fn handle_slash(text: String) -> Result<Response> {\n  let renderer = TextRenderer::try_new_with_ttf_font_data(include_bytes!(\"../assets/Inter-Bold.ttf\"))\n    .expect(\"Example font is definitely loadable\");\n\nlet text_png: TextPng = renderer.render_text_to_png_data(text.replace(\"+\", \" \"), 60, \"003682\").unwrap();\n\nlet mut headers = Headers::new();\n  headers.set(\"content-type\", \"image/png\")?;\n\nOk(Response::from_bytes(text_png.data)?.with_headers(headers))\n}\nrs\nuse text_to_png::{TextPng, TextRenderer};\nuse worker::*;\n\n#[event(fetch)]\npub async fn main(req: Request, env: Env, _ctx: worker::Context) -> Result<Response> {\n    // Optionally, get more helpful error messages written to the console in the case of a panic.\n    utils::set_panic_hook();\n\nlet router = Router::new();\n\nrouter\n        .get_async(\"/\", |req, _| async move {\n            if let Some(text) = req.url()?.query() {\n                handle_slash(text.into()).await\n            } else {\n                handle_slash(\"Hello Worker!\".into()).await\n            }\n        })\n        .run(req, env)\n        .await\n}\n\nasync fn handle_slash(text: String) -> Result<Response> {\n    let renderer = TextRenderer::try_new_with_ttf_font_data(include_bytes!(\"../assets/Inter-Bold.ttf\"))\n    .expect(\"Example font is definitely loadable\");\n\nlet text = if text.len() > 128 {\n        \"Nope\".into()\n    } else {\n        text\n    };\n\nlet text = urlencoding::decode(&text).map_err(|_| worker::Error::BadEncoding)?;\n\nlet text_png: TextPng = renderer.render_text_to_png_data(text.replace(\"+\", \" \"), 60, \"003682\").unwrap();\n\nlet mut headers = Headers::new();\n    headers.set(\"content-type\", \"image/png\")?;\n\nOk(Response::from_bytes(text_png.data)?.with_headers(headers))\n}\nsh\nnpx wrangler dev\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"worker-to-text\"\n  }\n  toml\n  name = \"worker-to-text\"\n  sh\nnpx wrangler deploy\nsh\n  npm create cloudflare@latest -- thumbnail-image\n  sh\n  yarn create cloudflare thumbnail-image\n  sh\n  pnpm create cloudflare@latest thumbnail-image\n  sh\ncd thumbnail-image\njs\nexport default {\n  async fetch(request, env) {\n    const url = new URL(request.url);\n    if (url.pathname === \"/original-image\") {\n      const image = await fetch(\n        `https://imagedelivery.net/${env.CLOUDFLARE_ACCOUNT_HASH}/${IMAGE_ID}/public`,\n      );\n      return image;\n    }\n    return new Response(\"Image Resizing with a Worker\");\n  },\n};\njs\nexport default {\n  async fetch(request, env) {\n    const url = new URL(request.url);\n    if (url.pathname === \"/original-image\") {\n      const image = await fetch(\n        `https://imagedelivery.net/${env.CLOUDFLARE_ACCOUNT_HASH}/${IMAGE_ID}/public`,\n      );\n      return image;\n    }\n\nif (url.pathname === \"/thumbnail\") {\n    }\n\nreturn new Response(\"Image Resizing with a Worker\");\n  },\n};\njs\nexport default {\n  async fetch(request, env) {\n    const url = new URL(request.url);\n\nif (url.pathname === \"/original-image\") {\n      const image = await fetch(\n        `https://imagedelivery.net/${env.CLOUDFLARE_ACCOUNT_HASH}/${IMAGE_ID}/public`,\n      );\n      return image;\n    }\n\nif (url.pathname === \"/thumbnail\") {\n      fetch(imageURL, {\n        cf: {\n          image: {},\n        },\n      });\n    }\n\nreturn new Response(\"Image Resizing with a Worker\");\n  },\n};\njs\nif (url.pathname === \"/thumbnail\") {\n  const imageURL =\n    \"https://github.com/lauragift21/social-image-demo/blob/1ed9044463b891561b7438ecdecbdd9da48cdb03/assets/cover.png?raw=true\";\n  fetch(imageURL, {\n    cf: {\n      image: {},\n    },\n  });\n}\njs\nfetch(imageURL, {\n  cf: {\n    image: {\n      width: 1280,\n      height: 720,\n      draw: [\n        {\n          url: \"https://text-to-image.examples.workers.dev\",\n          left: 40,\n        },\n      ],\n    },\n  },\n});\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"thumbnail-image\"\n  }\n  toml\n  name = \"thumbnail-image\"\n  sh\nnpx wrangler deploy\njs\nfor (const title of url.searchParams.values()) {\n  try {\n    const editedImage = await fetch(imageURL, {\n      cf: {\n        image: {\n          width: 1280,\n          height: 720,\n          draw: [\n            {\n              url: `https://text-to-image.examples.workers.dev/?${title}`,\n              left: 50,\n            },\n          ],\n        },\n      },\n    });\n    return editedImage;\n  } catch (error) {\n    console.log(error);\n  }\n}\nsh\n  npm create cloudflare@latest -- github-twilio-notifications\n  sh\n  yarn create cloudflare github-twilio-notifications\n  sh\n  pnpm create cloudflare@latest github-twilio-notifications\n  sh\ncd github-twilio-notifications\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello World!\");\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    if (request.method !== \"POST\") {\n      return new Response(\"Please send a POST request!\");\n    }\n  },\n};\njs\nasync fetch(request, env, ctx) {\n  if(request.method !== 'POST') {\n    return new Response('Please send a POST request!');\n  }\n  try {\n    const rawBody = await request.text();\n\nif (!checkSignature(rawBody, request.headers, env.GITHUB_SECRET_TOKEN)) {\n      return new Response(\"Wrong password, try again\", {status: 403});\n    }\n  } catch (e) {\n    return new Response(`Error:  ${e}`);\n  }\n},\njs\nimport { createHmac, timingSafeEqual } from \"node:crypto\";\nimport { Buffer } from \"node:buffer\";\n\nfunction checkSignature(text, headers, githubSecretToken) {\n  const hmac = createHmac(\"sha256\", githubSecretToken);\n  hmac.update(text);\n  const expectedSignature = hmac.digest(\"hex\");\n  const actualSignature = headers.get(\"x-hub-signature-256\");\n\nconst trusted = Buffer.from(`sha256=${expectedSignature}`, \"ascii\");\n  const untrusted = Buffer.from(actualSignature, \"ascii\");\n\nreturn (\n    trusted.byteLength == untrusted.byteLength &&\n    timingSafeEqual(trusted, untrusted)\n  );\n}\nsh\nnpx wrangler secret put GITHUB_SECRET_TOKEN\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ]\n  }\n  toml\n  compatibility_flags = [\"nodejs_compat\"]\n  js\nasync function sendText(accountSid, authToken, message) {\n  const endpoint = `https://api.twilio.com/2010-04-01/Accounts/${accountSid}/Messages.json`;\n\nconst encoded = new URLSearchParams({\n    To: \"%YOUR_PHONE_NUMBER%\",\n    From: \"%YOUR_TWILIO_NUMBER%\",\n    Body: message,\n  });\n\nconst token = btoa(`${accountSid}:${authToken}`);\n\nconst request = {\n    body: encoded,\n    method: \"POST\",\n    headers: {\n      Authorization: `Basic ${token}`,\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\n    },\n  };\n\nconst response = await fetch(endpoint, request);\n  const result = await response.json();\n\nreturn Response.json(result);\n}\nsh\nnpx wrangler secret put TWILIO_ACCOUNT_SID\nnpx wrangler secret put TWILIO_AUTH_TOKEN\njs\nasync fetch(request, env, ctx) {\n  if(request.method !== 'POST') {\n    return new Response('Please send a POST request!');\n  }\n  try {\n    const rawBody = await request.text();\n    if (!checkSignature(rawBody, request.headers, env.GITHUB_SECRET_TOKEN)) {\n      return new Response('Wrong password, try again', {status: 403});\n    }\n\nconst action = request.headers.get('X-GitHub-Event');\n    const json = JSON.parse(rawBody);\n    const repoName = json.repository.full_name;\n    const senderName = json.sender.login;\n\nreturn await sendText(\n      env.TWILIO_ACCOUNT_SID,\n      env.TWILIO_AUTH_TOKEN,\n      `${senderName} completed ${action} onto your repo ${repoName}`\n    );\n  } catch (e) {\n    return new Response(`Error:  ${e}`);\n  }\n};\nsh\nnpx wrangler deploy\nhtml\n<form action=\"https://workers-airtable-form.signalnerve.workers.dev/submit\" method=\"POST\">\n  <div>\n    <label for=\"first_name\">First name</label>\n    <input type=\"text\" name=\"first_name\" id=\"first_name\" autocomplete=\"given-name\" placeholder=\"Ellen\" required />\n  </div>\n\n<div>\n    <label for=\"last_name\">Last name</label>\n    <input type=\"text\" name=\"last_name\" id=\"last_name\" autocomplete=\"family-name\" placeholder=\"Ripley\" required />\n  </div>\n\n<div>\n    <label for=\"email\">Email</label>\n      <input id=\"email\" name=\"email\" type=\"email\" autocomplete=\"email\" placeholder=\"eripley@nostromo.com\" required />\n    </div>\n  </div>\n\n<div>\n    <label for=\"phone\">\n      Phone\n      <span>Optional</span>\n    </label>\n    <input type=\"text\" name=\"phone\" id=\"phone\" autocomplete=\"tel\" placeholder=\"+1 (123) 456-7890\" />\n  </div>\n\n<div>\n    <label for=\"subject\">Subject</label>\n    <input type=\"text\" name=\"subject\" id=\"subject\" placeholder=\"Your example subject\" required />\n  </div>\n\n<div>\n    <label for=\"message\">\n      Message\n      <span>Max 500 characters</span>\n    </label>\n    <textarea id=\"message\" name=\"message\" rows=\"4\" placeholder=\"Tenetur quaerat expedita vero et illo. Tenetur explicabo dolor voluptatem eveniet. Commodi est beatae id voluptatum porro laudantium. Quam placeat accusamus vel officiis vel. Et perferendis dicta ut perspiciatis quos iste. Tempore autem molestias voluptates in sapiente enim doloremque.\" required></textarea>\n  </div>\n\n<div>\n    <button type=\"submit\">\n      Submit\n    </button>\n  </div>\n</form>\nsh\n  npm create cloudflare@latest -- airtable-form-handler\n  sh\n  yarn create cloudflare airtable-form-handler\n  sh\n  pnpm create cloudflare@latest airtable-form-handler\n  sh\ncd airtable-form-handler\nsh\nnpx wrangler secret put AIRTABLE_ACCESS_TOKEN\nsh\nEnter the secret text you would like assigned to the variable AIRTABLE_ACCESS_TOKEN on the script named airtable-form-handler:\n******\nğŸŒ€  Creating the secret for script name airtable-form-handler\nâœ¨  Success! Uploaded secret AIRTABLE_ACCESS_TOKEN.\njs\nexport default {\n  async fetch(request, env) {\n    const url = new URL(request.url);\n    if (url.pathname === \"/submit\") {\n      await submitHandler(request, env);\n    }\n    return new Response(\"Not found\", { status: 404 });\n  },\n};\njs\nasync function submitHandler(request, env) {\n  if (request.method !== \"POST\") {\n    return new Response(\"Method Not Allowed\", {\n      status: 405,\n    });\n  }\n  const body = await request.formData();\n\nconst { first_name, last_name, email, phone, subject, message } =\n    Object.fromEntries(body);\n\n// The keys in \"fields\" are case-sensitive, and\n  // should exactly match the field names you set up\n  // in your Airtable table, such as \"First Name\".\n  const reqBody = {\n    fields: {\n      \"First Name\": first_name,\n      \"Last Name\": last_name,\n      Email: email,\n      \"Phone Number\": phone,\n      Subject: subject,\n      Message: message,\n    },\n  };\n  await createAirtableRecord(env, reqBody);\n}\n\n// Existing code\n// export default ...\njs\nasync function createAirtableRecord(env, body) {\n  try {\n    const result = fetch(\n      `https://api.airtable.com/v0/${env.AIRTABLE_BASE_ID}/${encodeURIComponent(env.AIRTABLE_TABLE_NAME)}`,\n      {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n          Authorization: `Bearer ${env.AIRTABLE_ACCESS_TOKEN}`,\n          \"Content-Type\": \"application/json\",\n        },\n      },\n    );\n    return result;\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// Existing code\n// async function submitHandler\n// export default ...\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"workers-airtable-form\",\n    \"main\": \"src/index.js\",\n    \"compatibility_date\": \"2023-06-13\",\n    \"vars\": {\n      \"AIRTABLE_BASE_ID\": \"exampleBaseId\",\n      \"AIRTABLE_TABLE_NAME\": \"Form Submissions\"\n    }\n  }\n  toml\n  name = \"workers-airtable-form\"\n  main = \"src/index.js\"\n  compatibility_date = \"2023-06-13\"\n\n[vars]\n  AIRTABLE_BASE_ID = \"exampleBaseId\"\n  AIRTABLE_TABLE_NAME = \"Form Submissions\"\n  sh\nnpx wrangler deploy\nhtml\n<form\n  action=\"https://workers-airtable-form.cloudflare.workers.dev/submit\"\n  method=\"POST\"\n  class=\"...\"\n>\n  <!-- The rest of your HTML form -->\n</form>\nsh\n  npm create cloudflare@latest -- mysql-tutorial\n  sh\n  yarn create cloudflare mysql-tutorial\n  sh\n  pnpm create cloudflare@latest mysql-tutorial\n  sh\ncd mysql-tutorial\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"compatibility_date\": \"2024-09-23\"\n  }\n  toml\n  compatibility_flags = [ \"nodejs_compat\" ]\n  compatibility_date = \"2024-09-23\"\n  bash\nnpx wrangler hyperdrive create <NAME_OF_HYPERDRIVE_CONFIG> --connection-string=\"mysql://user:password@HOSTNAME_OR_IP_ADDRESS:PORT/database_name\"\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"hyperdrive-example\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2024-08-21\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"hyperdrive\": [\n      {\n        \"binding\": \"HYPERDRIVE\",\n        \"id\": \"<ID OF THE CREATED HYPERDRIVE CONFIGURATION>\"\n      }\n    ]\n  }\n  toml\n  name = \"hyperdrive-example\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2024-08-21\"\n  compatibility_flags = [\"nodejs_compat\"]\n\n# Pasted from the output of `wrangler hyperdrive create <NAME_OF_HYPERDRIVE_CONFIG> --connection-string=[...]` above.\n  [[hyperdrive]]\n  binding = \"HYPERDRIVE\"\n  id = \"<ID OF THE CREATED HYPERDRIVE CONFIGURATION>\"\n  sh\n  npm i mysql2@>3.13.0\n  sh\n  yarn add mysql2@>3.13.0\n  sh\n  pnpm add mysql2@>3.13.0\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"compatibility_date\": \"2024-09-23\",\n    \"hyperdrive\": [\n      {\n        \"binding\": \"HYPERDRIVE\",\n        \"id\": \"<your-hyperdrive-id-here>\"\n      }\n    ]\n  }\n  toml\n  # required for database drivers to function\n  compatibility_flags = [\"nodejs_compat\"]\n  compatibility_date = \"2024-09-23\"\n\n[[hyperdrive]]\n  binding = \"HYPERDRIVE\"\n  id = \"<your-hyperdrive-id-here>\"\n  ts\n// mysql2 v3.13.0 or later is required\nimport { createConnection } from \"mysql2/promise\";\n\nexport default {\n  async fetch(request, env, ctx): Promise<Response> {\n    // Create a connection using the mysql2 driver with the Hyperdrive credentials (only accessible from your Worker).\n    const connection = await createConnection({\n      host: env.HYPERDRIVE.host,\n      user: env.HYPERDRIVE.user,\n      password: env.HYPERDRIVE.password,\n      database: env.HYPERDRIVE.database,\n      port: env.HYPERDRIVE.port,\n\n// Required to enable mysql2 compatibility for Workers\n      disableEval: true,\n    });\n\ntry {\n      // Sample query\n      const [results, fields] = await connection.query(\"SHOW tables;\");\n\n// Clean up the client after the response is returned, before the Worker is killed\n      ctx.waitUntil(connection.end());\n\n// Return result rows as JSON\n      return Response.json({ results, fields });\n    } catch (e) {\n      console.error(e);\n    }\n  },\n} satisfies ExportedHandler<Env>;\nsh\nnpx wrangler deploy\nsh\n  npm create cloudflare@latest -- openai-function-calling-workers\n  sh\n  yarn create cloudflare openai-function-calling-workers\n  sh\n  pnpm create cloudflare@latest openai-function-calling-workers\n  sh\ncd openai-function-calling-workers\nsh\n  npm i openai cheerio\n  sh\n  yarn add openai cheerio\n  sh\n  pnpm add openai cheerio\n  js\nexport default {\n  async fetch(request, env, ctx) {\n    // Initialize OpenAI API\n    // Handle incoming requests\n    return new Response(\"Hello World!\");\n  },\n};\njs\nimport OpenAI from \"openai\";\nimport * as cheerio from \"cheerio\";\njs\nasync fetch(request, env, ctx) {\n  const openai = new OpenAI({\n    apiKey: env.OPENAI_API_KEY,\n  });\n\n// Handle incoming requests\n  return new Response('Hello World!');\n},\nsh\nnpx wrangler secret put <OPENAI_API_KEY>\ntxt\nOPENAI_API_KEY = \"<YOUR_OPENAI_API_KEY>\"\njs\nexport default {\n  async fetch(request, env, ctx) {\n    const openai = new OpenAI({\n      apiKey: env.OPENAI_API_KEY,\n    });\n\nconst url = new URL(request.url);\n    const message = url.searchParams.get(\"message\");\n\nconst messages = [\n      {\n        role: \"user\",\n        content: message ? message : \"What's in the news today?\",\n      },\n    ];\n\nconst tools = [\n      {\n        type: \"function\",\n        function: {\n          name: \"read_website_content\",\n          description: \"Read the content on a given website\",\n          parameters: {\n            type: \"object\",\n            properties: {\n              url: {\n                type: \"string\",\n                description: \"The URL to the website to read\",\n              },\n            },\n            required: [\"url\"],\n          },\n        },\n      },\n    ];\n\nconst chatCompletion = await openai.chat.completions.create({\n      model: \"gpt-4o-mini\",\n      messages: messages,\n      tools: tools,\n      tool_choice: \"auto\",\n    });\n\nconst assistantMessage = chatCompletion.choices[0].message;\n    console.log(assistantMessage);\n\n//Later you will continue handling the assistant's response here\n    return new Response(assistantMessage.content);\n  },\n};\njs\nasync function read_website_content(url) {\n  console.log(\"reading website content\");\n\nconst response = await fetch(url);\n  const body = await response.text();\n  let cheerioBody = cheerio.load(body);\n  const resp = {\n    website_body: cheerioBody(\"p\").text(),\n    url: url,\n  };\n  return JSON.stringify(resp);\n}\njs\n// ... your previous code ...\n\nif (assistantMessage.tool_calls) {\n  for (const toolCall of assistantMessage.tool_calls) {\n    if (toolCall.function.name === \"read_website_content\") {\n      const url = JSON.parse(toolCall.function.arguments).url;\n      const websiteContent = await read_website_content(url);\n      messages.push({\n        role: \"tool\",\n        tool_call_id: toolCall.id,\n        name: toolCall.function.name,\n        content: websiteContent,\n      });\n    }\n  }\n\nconst secondChatCompletion = await openai.chat.completions.create({\n    model: \"gpt-4o-mini\",\n    messages: messages,\n  });\n\nreturn new Response(secondChatCompletion.choices[0].message.content);\n} else {\n  // this is your existing return statement\n  return new Response(assistantMessage.content);\n}\nsh\nnpx wrangler deploy\nsh\n  npm create cloudflare@latest -- postgres-tutorial\n  sh\n  yarn create cloudflare postgres-tutorial\n  sh\n  pnpm create cloudflare@latest postgres-tutorial\n  sh\ncd postgres-tutorial\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"compatibility_date\": \"2024-09-23\"\n  }\n  toml\n  compatibility_flags = [ \"nodejs_compat\" ]\n  compatibility_date = \"2024-09-23\"\n  sh\n  npm i pg\n  sh\n  yarn add pg\n  sh\n  pnpm add pg\n  sh\n  npm i -D @types/pg\n  sh\n  yarn add -D @types/pg\n  sh\n  pnpm add -D @types/pg\n  plaintext\npostgresql://username:password@host:port/database\nsh\nnpx wrangler secret put DB_URL\nsh\nâœ  wrangler secret put DB_URL\n-------------------------------------------------------\n? Enter a secret value: â€º ********************\nâœ¨ Success! Uploaded secret DB_URL\ntoml\nDB_URL=\"<ENTER YOUR POSTGRESQL CONNECTION STRING>\"\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"vars\": {\n      \"DB_USERNAME\": \"postgres\",\n      \"DB_HOST\": \"ep-aged-sound-175961.us-east-2.aws.neon.tech\",\n      \"DB_PORT\": 5432,\n      \"DB_NAME\": \"productsdb\"\n    }\n  }\n  toml\n  [vars]\n  DB_USERNAME = \"postgres\"\n  # Set your password by creating a secret so it is not stored as plain text\n  DB_HOST = \"ep-aged-sound-175961.us-east-2.aws.neon.tech\"\n  DB_PORT = 5432\n  DB_NAME = \"productsdb\"\n  sh\nnpx wrangler secret put DB_PASSWORD\nsh\n-------------------------------------------------------\n? Enter a secret value: â€º ********************\nâœ¨ Success! Uploaded secret DB_PASSWORD\ntypescript\nimport { Client } from \"pg\";\ntypescript\n// create a new Client instance using the connection string\nconst sql = new Client({ connectionString: env.DB_URL });\n// connect to the PostgreSQL database\nawait sql.connect();\ntypescript\n// create a new Client instance using explicit parameters\nconst sql = new Client({\n  username: env.DB_USERNAME,\n  password: env.DB_PASSWORD,\n  host: env.DB_HOST,\n  port: env.DB_PORT,\n  database: env.DB_NAME,\n  ssl: true, // Enable SSL for secure connections\n});\n// connect to the PostgreSQL database\nawait sql.connect();\nsql\nCREATE TABLE products (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(255) NOT NULL,\n  description TEXT,\n  price DECIMAL(10, 2) NOT NULL\n);\ntypescript\nimport { Client } from \"pg\";\n\nexport default {\n  async fetch(request, env, ctx): Promise<Response> {\n    // Create a new Client instance using the connection string\n    // or explicit parameters as shown in the previous steps.\n    // Here, we are using the connection string method.\n    const sql = new Client({\n      connectionString: env.DB_URL,\n    });\n        // Connect to the PostgreSQL database\n        await sql.connect();\n\n// Query the products table\n        const result = await sql.query(\"SELECT * FROM products\");\n\n// Return the result as JSON\n        return new Response(JSON.stringify(result.rows), {\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n        });\n  },\n} satisfies ExportedHandler<Env>;\nsh\nnpx wrangler deploy\ntypescript\nimport { Client } from \"pg\";\n\nexport default {\n  async fetch(request, env, ctx): Promise<Response> {\n    // Create a new Client instance using the connection string\n    // or explicit parameters as shown in the previous steps.\n    // Here, we are using the connection string method.\n    const sql = new Client({\n      connectionString: env.DB_URL,\n    });\n        // Connect to the PostgreSQL database\n        await sql.connect();\n\nconst url = new URL(request.url);\n        if (request.method === \"POST\" && url.pathname === \"/products\") {\n            // Parse the request's JSON payload\n            const productData = (await request.json()) as {\n                name: string;\n                description: string;\n                price: number;\n            };\n\nconst name = productData.name,\n                description = productData.description,\n                price = productData.price;\n\n// Insert the new product into the products table\n            const insertResult = await sql.query(\n                `INSERT INTO products(name, description, price) VALUES($1, $2, $3)\n    RETURNING *`,\n                [name, description, price],\n            );\n\n// Return the inserted row as JSON\n            return new Response(JSON.stringify(insertResult.rows), {\n                headers: { \"Content-Type\": \"application/json\" },\n            });\n        }\n\n// Query the products table\n        const result = await sql.query(\"SELECT * FROM products\");\n\n// Return the result as JSON\n        return new Response(JSON.stringify(result.rows), {\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n        });\n  },\n} satisfies ExportedHandler<Env>;\nsh\nnpx wrangler deploy\njson\n{\n  \"name\": \"Sample Product\",\n  \"description\": \"This is a sample product\",\n  \"price\": 19.99\n}\nbash\nnpx wrangler hyperdrive create <NAME_OF_HYPERDRIVE_CONFIG> --connection-string=\"postgres://user:password@HOSTNAME_OR_IP_ADDRESS:PORT/database_name\" --caching-disabled\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"hyperdrive-example\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2024-08-21\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"hyperdrive\": [\n      {\n        \"binding\": \"HYPERDRIVE\",\n        \"id\": \"<ID OF THE CREATED HYPERDRIVE CONFIGURATION>\"\n      }\n    ]\n  }\n  toml\n  name = \"hyperdrive-example\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2024-08-21\"\n  compatibility_flags = [\"nodejs_compat\"]\n\n# Pasted from the output of `wrangler hyperdrive create <NAME_OF_HYPERDRIVE_CONFIG> --connection-string=[...]` above.\n  [[hyperdrive]]\n  binding = \"HYPERDRIVE\"\n  id = \"<ID OF THE CREATED HYPERDRIVE CONFIGURATION>\"\n  bash\nnpx wrangler types\njs\nexport default {\n  async fetch(request, env, ctx): Promise<Response> {\n    const sql = new Client({connectionString: env.HYPERDRIVE.connectionString})\n\nconst url = new URL(request.url);\n\n//rest of the routes and database queries\n  },\n} satisfies ExportedHandler<Env>;\nsh\nnpx wrangler deploy\nsh\nnpm create cloudflare@latest\nsh\nnpm create cloudflare@latest email-with-postmark -- --type=hello-world --ts=false --git=true --deploy=false\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello World!\");\n  },\n};\njsx\nexport default {\n  async fetch(request, env, ctx) {\n    return await fetch(\"https://api.postmarkapp.com/email\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Postmark-Server-Token\": \"your_postmark_api_token_here\",\n      },\n      body: JSON.stringify({\n        From: \"hello@example.com\",\n        To: \"someone@example.com\",\n        Subject: \"Hello World\",\n        HtmlBody: \"<p>Hello from Workers</p>\",\n      }),\n    });\n  },\n};\nsh\nnpm start\ntxt\nPOSTMARK_API_TOKEN=your_postmark_api_token_here\nsh\nnpx wrangler secret put POSTMARK_API_TOKEN\njsx\nexport default {\n  async fetch(request, env, ctx) {\n    return await fetch(\"https://api.postmarkapp.com/email\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Postmark-Server-Token\": env.POSTMARK_API_TOKEN,\n      },\n      body: JSON.stringify({\n        From: \"hello@example.com\",\n        To: \"someone@example.com\",\n        Subject: \"Hello World\",\n        HtmlBody: \"<p>Hello from Workers</p>\",\n      }),\n    });\n  },\n};\nsh\nnpm create cloudflare@latest\nsh\nnpm create cloudflare@latest email-with-resend -- --type=hello-world --ts=false --git=true --deploy=false\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello World!\");\n  },\n};\nsh\nnpm i resend\njsx\nimport { Resend } from \"resend\";\n\nexport default {\n  async fetch(request, env, ctx) {\n    const resend = new Resend(\"your_resend_api_key\");\n\nconst { data, error } = await resend.emails.send({\n      from: \"hello@example.com\",\n      to: \"someone@example.com\",\n      subject: \"Hello World\",\n      html: \"<p>Hello from Workers</p>\",\n    });\n\nreturn Response.json({ data, error });\n  },\n};\nsh\nnpm start\ntxt\nRESEND_API_KEY=your_resend_api_key\nsh\nnpx wrangler secret put RESEND_API_KEY\njsx\nimport { Resend } from \"resend\";\n\nexport default {\n  async fetch(request, env, ctx) {\n    const resend = new Resend(env.RESEND_API_KEY);\n\nconst { data, error } = await resend.emails.send({\n      from: \"hello@example.com\",\n      to: \"someone@example.com\",\n      subject: \"Hello World\",\n      html: \"<p>Hello from Workers</p>\",\n    });\n\nreturn Response.json({ data, error });\n  },\n};\nsh\n  npm create cloudflare@latest -- upload-r2-assets\n  sh\n  yarn create cloudflare upload-r2-assets\n  sh\n  pnpm create cloudflare@latest upload-r2-assets\n  sh\ncd upload-r2-assets\nsh\nnpx wrangler r2 bucket create <YOUR_BUCKET_NAME>\nsh\nnpx wrangler r2 bucket list\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"r2_buckets\": [\n      {\n        \"binding\": \"MY_BUCKET\",\n        \"bucket_name\": \"<YOUR_BUCKET_NAME>\"\n      }\n    ]\n  }\n  toml\n  [[r2_buckets]]\n  binding = 'MY_BUCKET'\n  bucket_name = '<YOUR_BUCKET_NAME>'\n  ts\ninterface Env {\n  MY_BUCKET: R2Bucket;\n}\nexport default {\n  async fetch(request, env): Promise<Response> {\n    // For example, the request URL my-worker.account.workers.dev/image.png\n    const url = new URL(request.url);\n    const key = url.pathname.slice(1);\n    // Retrieve the key \"image.png\"\n    const object = await env.MY_BUCKET.get(key);\n\nif (object === null) {\n      return new Response(\"Object Not Found\", { status: 404 });\n    }\n\nconst headers = new Headers();\n    object.writeHttpMetadata(headers);\n    headers.set(\"etag\", object.httpEtag);\n\nreturn new Response(object.body, {\n      headers,\n    });\n  },\n} satisfies ExportedHandler<Env>;\nsh\nnpx wrangler secret put AUTH_SECRET\nts\ninterface Env {\n  MY_BUCKET: R2Bucket;\n  AUTH_SECRET: string;\n}\nexport default {\n  async fetch(request, env): Promise<Response> {\n    if (request.method === \"PUT\") {\n      // Note that you could require authentication for all requests\n      // by moving this code to the top of the fetch function.\n      const auth = request.headers.get(\"Authorization\");\n      const expectedAuth = `Bearer ${env.AUTH_SECRET}`;\n\nif (!auth || auth !== expectedAuth) {\n        return new Response(\"Unauthorized\", { status: 401 });\n      }\n\nconst url = new URL(request.url);\n      const key = url.pathname.slice(1);\n      await env.MY_BUCKET.put(key, request.body);\n      return new Response(`Object ${key} uploaded successfully!`);\n    }\n\n// include the previous code here...\n  },\n} satisfies ExportedHandler<Env>;\nsh\nnpx wrangler deploy\nsh\nnpm create cloudflare@latest prisma-postgres-worker -- --type=hello-world --ts=true --git=true --deploy=false\nsh\ncd ./prisma-postgres-worker\nts\nexport default {\n  async fetch(request, env, ctx): Promise<Response> {\n    return new Response(\"Hello World!\");\n  },\n} satisfies ExportedHandler<Env>;\nsh\n  npm i -D prisma\n  sh\n  yarn add -D prisma\n  sh\n  pnpm add -D prisma\n  sh\n  npm i @prisma/extension-accelerate\n  sh\n  yarn add @prisma/extension-accelerate\n  sh\n  pnpm add @prisma/extension-accelerate\n  sh\n  npm i -D dotenv-cli\n  sh\n  yarn add -D dotenv-cli\n  sh\n  pnpm add -D dotenv-cli\n  sh\n  npx prisma@latest init --db\n  sh\n  yarn dlx prisma@latest init --db\n  sh\n  pnpx prisma@latest init --db\n  sh\nmv .env .dev.vars\nprisma\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\ndatasource db {\n  provider = \"postgresql\"\n  url      = env(\"DATABASE_URL\")\n}\n\nmodel User {\n  id  Int @id @default(autoincrement())\n  email String\n  name   String\n}\njson\n\"scripts\": {\n  \"migrate\": \"dotenv -e .dev.vars -- npx prisma migrate dev\",\n  \"generate\": \"dotenv -e .dev.vars -- npx prisma generate --no-engine\",\n  \"studio\": \"dotenv -e .dev.vars -- npx prisma studio\",\n  // Additional worker scripts...\n}\nsh\nnpm run migrate\nts\nimport { PrismaClient } from \"@prisma/client/edge\";\nimport { withAccelerate } from \"@prisma/extension-accelerate\";\n\nexport interface Env {\n  DATABASE_URL: string;\n}\n\nexport default {\n  async fetch(request, env, ctx): Promise<Response> {\n    const path = new URL(request.url).pathname;\n    if (path === \"/favicon.ico\")\n      return new Response(\"Resource not found\", {\n        status: 404,\n        headers: {\n          \"Content-Type\": \"text/plain\",\n        },\n      });\n\nconst prisma = new PrismaClient({\n      datasourceUrl: env.DATABASE_URL,\n    }).$extends(withAccelerate());\n\nconst user = await prisma.user.create({\n      data: {\n        email: `Jon${Math.ceil(Math.random() * 1000)}@gmail.com`,\n        name: \"Jon Doe\",\n      },\n    });\n\nconst userCount = await prisma.user.count();\n\nreturn new Response(`\\\nCreated new user: ${user.name} (${user.email}).\nNumber of users in the database: ${userCount}.\n    `);\n  },\n} satisfies ExportedHandler<Env>;\nsh\nnpm run dev\nsh\nNumber of users in the database: 1\nsh\nnpx wrangler secret put DATABASE_URL\nsh\nâœ” There doesn't seem to be a Worker called \"prisma-postgres-worker\". Do you want to create a new Worker with that name and add secrets to it? â€¦ yes\nsh\nnpm run deploy\nsh\ncargo install cargo-generate\nsh\ncargo generate cloudflare/workers-rs\nsh\nnpx wrangler kv namespace create cities\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"kv_namespaces\": [\n      {\n        \"binding\": \"cities\",\n        \"id\": \"e29b263ab50e42ce9b637fa8370175e8\"\n      }\n    ]\n  }\n  toml\n  kv_namespaces = [\n    { binding = \"cities\", id = \"e29b263ab50e42ce9b637fa8370175e8\" }\n  ]\n\n# build command...\n  rust\nuse serde::{Deserialize, Serialize};\nuse worker::*;\n\n#[event(fetch)]\nasync fn fetch(req: Request, env: Env, _ctx: Context) -> Result<Response> {\n    let router = Router::new();\n\n#[derive(Serialize, Deserialize, Debug)]\n    struct Country {\n        city: String,\n    }\n\nrouter\n        // TODO:\n        .post_async(\"/:country\", |_, _| async move { Response::empty() })\n        // TODO:\n        .get_async(\"/:country\", |_, _| async move { Response::empty() })\n        .run(req, env)\n        .await\n}\nrust\n.post_async(\"/:country\", |mut req, ctx| async move {\n    let country = ctx.param(\"country\").unwrap();\n    let city = match req.json::<Country>().await {\n        Ok(c) => c.city,\n        Err(_) => String::from(\"\"),\n    };\n    if city.is_empty() {\n        return Response::error(\"Bad Request\", 400);\n    };\n    return match ctx.kv(\"cities\")?.put(country, &city)?.execute().await {\n        Ok(_) => Response::ok(city),\n        Err(_) => Response::error(\"Bad Request\", 400),\n    };\n})\nsh\ncurl --json '{\"city\": \"Paris\"}' http://localhost:8787/France\nrust\n.get_async(\"/:country\", |_req, ctx| async move {\n    if let Some(country) = ctx.param(\"country\") {\n        return match ctx.kv(\"cities\")?.get(country).text().await? {\n            Some(city) => Response::ok(city),\n            None => Response::error(\"Country not found\", 404),\n        };\n    }\n    Response::error(\"Bad Request\", 400)\n})\nsh\ncurl http://localhost:8787/France\nrust\nuse serde::{Deserialize, Serialize};\nuse worker::*;\n\n#[event(fetch)]\nasync fn fetch(req: Request, env: Env, _ctx: Context) -> Result<Response> {\n    let router = Router::new();\n\n#[derive(Serialize, Deserialize, Debug)]\n    struct Country {\n        city: String,\n    }\n\nrouter\n        .post_async(\"/:country\", |mut req, ctx| async move {\n            let country = ctx.param(\"country\").unwrap();\n            let city = match req.json::<Country>().await {\n                Ok(c) => c.city,\n                Err(_) => String::from(\"\"),\n            };\n            if city.is_empty() {\n                return Response::error(\"Bad Request\", 400);\n            };\n            return match ctx.kv(\"cities\")?.put(country, &city)?.execute().await {\n                Ok(_) => Response::ok(city),\n                Err(_) => Response::error(\"Bad Request\", 400),\n            };\n        })\n        .get_async(\"/:country\", |_req, ctx| async move {\n            if let Some(country) = ctx.param(\"country\") {\n                return match ctx.kv(\"cities\")?.get(country).text().await? {\n                    Some(city) => Response::ok(city),\n                    None => Response::error(\"Country not found\", 404),\n                };\n            }\n            Response::error(\"Bad Request\", 400)\n        })\n        .run(req, env)\n        .await\n}\nsh\nnpx wrangler deploy\njson\n{\n  \"name\": \"cloudflare-vite-get-started\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite dev\",\n    \"build\": \"vite build\",\n    \"preview\": \"npm run build && vite preview\",\n    \"deploy\": \"npm run build && wrangler deploy\"\n  }\n}\nsh\n  npm i -D vite @cloudflare/vite-plugin wrangler\n  sh\n  yarn add -D vite @cloudflare/vite-plugin wrangler\n  sh\n  pnpm add -D vite @cloudflare/vite-plugin wrangler\n  ts\nimport { defineConfig } from \"vite\";\nimport { cloudflare } from \"@cloudflare/vite-plugin\";\n\nexport default defineConfig({\n  plugins: [cloudflare()],\n});\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"cloudflare-vite-get-started\",\n    \"compatibility_date\": \"2025-04-03\",\n    \"main\": \"./src/index.ts\"\n  }\n  toml\n  name = \"cloudflare-vite-get-started\"\n  compatibility_date = \"2025-04-03\"\n  main = \"./src/index.ts\"\n  ts\nexport default {\n  fetch() {\n    return new Response(`Running in ${navigator.userAgent}!`);\n  },\n};\nsh\n  npm create vite@latest -- cloudflare-vite-tutorial --template react-ts\n  sh\n  yarn create vite cloudflare-vite-tutorial --template react-ts\n  sh\n  pnpm create vite@latest cloudflare-vite-tutorial --template react-ts\n  sh\n  npm i -D @cloudflare/vite-plugin wrangler\n  sh\n  yarn add -D @cloudflare/vite-plugin wrangler\n  sh\n  pnpm add -D @cloudflare/vite-plugin wrangler\n  ts\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport { cloudflare } from \"@cloudflare/vite-plugin\";\n\nexport default defineConfig({\n  plugins: [react(), cloudflare()],\n});\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"cloudflare-vite-tutorial\",\n    \"compatibility_date\": \"2025-04-03\",\n    \"assets\": {\n      \"not_found_handling\": \"single-page-application\"\n    }\n  }\n  toml\n  name = \"cloudflare-vite-tutorial\"\n  compatibility_date = \"2025-04-03\"\n  assets = { not_found_handling = \"single-page-application\" }\n  txt\n.wrangler\n.dev.vars*\nsh\n  npm i -D @cloudflare/workers-types\n  sh\n  yarn add -D @cloudflare/workers-types\n  sh\n  pnpm add -D @cloudflare/workers-types\n  jsonc\n{\n  \"extends\": \"./tsconfig.node.json\",\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"./node_modules/.tmp/tsconfig.worker.tsbuildinfo\",\n    \"types\": [\"@cloudflare/workers-types/2023-07-01\", \"vite/client\"],\n  },\n  \"include\": [\"worker\"],\n}\njsonc\n{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./tsconfig.app.json\" },\n    { \"path\": \"./tsconfig.node.json\" },\n    { \"path\": \"./tsconfig.worker.json\" },\n  ],\n}\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"cloudflare-vite-tutorial\",\n    \"compatibility_date\": \"2025-04-03\",\n    \"assets\": {\n      \"not_found_handling\": \"single-page-application\"\n    },\n    \"main\": \"./worker/index.ts\"\n  }\n  toml\n  name = \"cloudflare-vite-tutorial\"\n  compatibility_date = \"2025-04-03\"\n  assets = { not_found_handling = \"single-page-application\" }\n  main = \"./worker/index.ts\"\n  ts\nexport default {\n  fetch(request) {\n    const url = new URL(request.url);\n\nif (url.pathname.startsWith(\"/api/\")) {\n      return Response.json({\n        name: \"Cloudflare\",\n      });\n    }\n\nreturn new Response(null, { status: 404 });\n  },\n} satisfies ExportedHandler;\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"cloudflare-vite-tutorial\",\n    \"compatibility_date\": \"2025-04-03\",\n    \"assets\": {\n      \"not_found_handling\": \"single-page-application\",\n      \"run_worker_first\": [\n        \"/api/*\"\n      ]\n    },\n    \"main\": \"./worker/index.ts\"\n  }\n  toml\n  name = \"cloudflare-vite-tutorial\"\n  compatibility_date = \"2025-04-03\"\n  assets = { not_found_handling = \"single-page-application\", run_worker_first = [\"/api/*\"] }\n  main = \"./worker/index.ts\"\n  tsx\nimport { useState } from \"react\";\nimport reactLogo from \"./assets/react.svg\";\nimport viteLogo from \"/vite.svg\";\nimport \"./App.css\";\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState(\"unknown\");\n\nreturn (\n    <>\n16 collapsed lines\n      <div>\n        <a href=\"https://vite.dev\" target=\"_blank\">\n          <img src={viteLogo} className=\"logo\" alt=\"Vite logo\" />\n        </a>\n        <a href=\"https://react.dev\" target=\"_blank\">\n          <img src={reactLogo} className=\"logo react\" alt=\"React logo\" />\n        </a>\n      </div>\n      <h1>Vite + React</h1>\n      <div className=\"card\">\n        <button\n          onClick={() => setCount((count) => count + 1)}\n          aria-label=\"increment\"\n        >\n          count is {count}\n        </button>\n        <p>\n          Edit <code>src/App.tsx</code> and save to test HMR\n        </p>\n      </div>\n      <div className=\"card\">\n        <button\n          onClick={() => {\n            fetch(\"/api/\")\n              .then((res) => res.json() as Promise<{ name: string }>)\n              .then((data) => setName(data.name));\n          }}\n          aria-label=\"get name\"\n        >\n          Name from API is: {name}\n        </button>\n        <p>\n          Edit <code>api/index.ts</code> to change the name\n        </p>\n      </div>\n      <p className=\"read-the-docs\">\n        Click on the Vite and React logos to learn more\n      </p>\n    </>\n  );\n}\n\nexport default App;\nsh\nnpm run build\nsh\nnpm run preview\nsh\nnpm exec wrangler deploy\njs\nimport assert from \"node:assert\";\nimport test, { after, before, describe } from \"node:test\";\nimport { unstable_startWorker } from \"wrangler\";\n\ndescribe(\"worker\", () => {\n  let worker;\n\nbefore(async () => {\n    worker = await unstable_startWorker({ config: \"wrangler.json\" });\n  });\n\ntest(\"hello world\", async () => {\n    assert.strictEqual(\n      await (await worker.fetch(\"http://example.com\")).text(),\n      \"Hello world\",\n    );\n  });\n\nafter(async () => {\n    await worker.dispose();\n  });\n});\njs\nconst worker = await unstable_dev(script, options);\njs\n  const { unstable_dev } = require(\"wrangler\");\n\ndescribe(\"Worker\", () => {\n    let worker;\n\nbeforeAll(async () => {\n      worker = await unstable_dev(\"src/index.js\", {\n        experimental: { disableExperimentalWarning: true },\n      });\n    });\n\nafterAll(async () => {\n      await worker.stop();\n    });\n\nit(\"should return Hello World\", async () => {\n      const resp = await worker.fetch();\n      const text = await resp.text();\n      expect(text).toMatchInlineSnapshot(`\"Hello World!\"`);\n    });\n  });\n  ts\n  import { unstable_dev } from \"wrangler\";\n  import type { UnstableDevWorker } from \"wrangler\";\n\ndescribe(\"Worker\", () => {\n    let worker: UnstableDevWorker;\n\nbeforeAll(async () => {\n      worker = await unstable_dev(\"src/index.ts\", {\n        experimental: { disableExperimentalWarning: true },\n      });\n    });\n\nafterAll(async () => {\n      await worker.stop();\n    });\n\nit(\"should return Hello World\", async () => {\n      const resp = await worker.fetch();\n      const text = await resp.text();\n      expect(text).toMatchInlineSnapshot(`\"Hello World!\"`);\n    });\n  });\n  js\n  import { unstable_dev } from \"wrangler\";\n\ndescribe(\"multi-worker testing\", () => {\n    let childWorker;\n    let parentWorker;\n\nbeforeAll(async () => {\n      childWorker = await unstable_dev(\"src/child-worker.js\", {\n        config: \"src/child-wrangler.toml\",\n        experimental: { disableExperimentalWarning: true },\n      });\n      parentWorker = await unstable_dev(\"src/parent-worker.js\", {\n        config: \"src/parent-wrangler.toml\",\n        experimental: { disableExperimentalWarning: true },\n      });\n    });\n\nafterAll(async () => {\n      await childWorker.stop();\n      await parentWorker.stop();\n    });\n\nit(\"childWorker should return Hello World itself\", async () => {\n      const resp = await childWorker.fetch();\n      const text = await resp.text();\n      expect(text).toMatchInlineSnapshot(`\"Hello World!\"`);\n    });\n\nit(\"parentWorker should return Hello World by invoking the child worker\", async () => {\n      const resp = await parentWorker.fetch();\n      const parsedResp = await resp.text();\n      expect(parsedResp).toEqual(\"Parent worker sees: Hello World!\");\n    });\n  });\n  ts\n  import { unstable_dev } from \"wrangler\";\n  import type { UnstableDevWorker } from \"wrangler\";\n\ndescribe(\"multi-worker testing\", () => {\n    let childWorker: UnstableDevWorker;\n    let parentWorker: UnstableDevWorker;\n\nbeforeAll(async () => {\n      childWorker = await unstable_dev(\"src/child-worker.js\", {\n        config: \"src/child-wrangler.toml\",\n        experimental: { disableExperimentalWarning: true },\n      });\n      parentWorker = await unstable_dev(\"src/parent-worker.js\", {\n        config: \"src/parent-wrangler.toml\",\n        experimental: { disableExperimentalWarning: true },\n      });\n    });\n\nafterAll(async () => {\n      await childWorker.stop();\n      await parentWorker.stop();\n    });\n\nit(\"childWorker should return Hello World itself\", async () => {\n      const resp = await childWorker.fetch();\n      const text = await resp.text();\n      expect(text).toMatchInlineSnapshot(`\"Hello World!\"`);\n    });\n\nit(\"parentWorker should return Hello World by invoking the child worker\", async () => {\n      const resp = await parentWorker.fetch();\n      const parsedResp = await resp.text();\n      expect(parsedResp).toEqual(\"Parent worker sees: Hello World!\");\n    });\n  });\n  js\nconst platform = await getPlatformProxy(options);\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"vars\": {\n      \"MY_VARIABLE\": \"test\"\n    }\n  }\n  toml\n  [vars]\n  MY_VARIABLE = \"test\"\n  js\nimport { getPlatformProxy } from \"wrangler\";\n\nconst { env } = await getPlatformProxy();\njs\nconsole.log(`MY_VARIABLE = ${env.MY_VARIABLE}`);\njsonc\n      {\n        \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n        \"durable_objects\": {\n          \"bindings\": [\n            {\n              \"name\": \"MyDurableObject\",\n              \"class_name\": \"MyDurableObject\",\n              \"script_name\": \"external-do-worker\"\n            }\n          ]\n        }\n      }\n      toml\n      [[durable_objects.bindings]]\n      name = \"MyDurableObject\"\n      class_name = \"MyDurableObject\"\n      script_name = \"external-do-worker\"\n      ts\n    export class MyDurableObject extends DurableObject {\n      // Your DO code goes here\n    }\n\nexport default {\n      fetch() {\n          // Doesn't have to do anything, but a DO cannot be the default export\n          return new Response(\"Hello, world!\");\n      },\n    };\n    jsonc\n      {\n        \"name\": \"external-do-worker\",\n        \"main\": \"src/index.ts\",\n        \"compatibility_date\": \"XXXX-XX-XX\"\n      }\n      toml\n      name = \"external-do-worker\"\n      main = \"src/index.ts\"\n      compatibility_date = \"XXXX-XX-XX\"\n      sh\n      npx wrangler pages dev -c path/to/pages/wrangler.jsonc -c path/to/external-do-worker/wrangler.jsonc\n      sh\n      yarn wrangler pages dev -c path/to/pages/wrangler.jsonc -c path/to/external-do-worker/wrangler.jsonc\n      sh\n      pnpm wrangler pages dev -c path/to/pages/wrangler.jsonc -c path/to/external-do-worker/wrangler.jsonc\n      sh\n      npx wrangler dev -c path/to/workers-assets/wrangler.jsonc -c path/to/external-do-worker/wrangler.jsonc\n      sh\n      yarn wrangler dev -c path/to/workers-assets/wrangler.jsonc -c path/to/external-do-worker/wrangler.jsonc\n      sh\n      pnpm wrangler dev -c path/to/workers-assets/wrangler.jsonc -c path/to/external-do-worker/wrangler.jsonc\n      js\nimport data from \"./example.html\"; // Where `example.html` is a file in your local directory\njs\nimport wasm from \"./example.wasm\"; // Where `example.wasm` is a file in your local directory\nconst instance = await WebAssembly.instantiate(wasm); // Instantiate Wasm modules in global scope, not within the fetch() handler\n\nexport default {\n  fetch(request) {\n    const result = instance.exports.exported_func();\n  },\n};\ntxt\nwrangler <COMMAND> <SUBCOMMAND> [PARAMETERS] [OPTIONS]\nsh\n  npx wrangler <COMMAND> <SUBCOMMAND> [PARAMETERS] [OPTIONS]\n  sh\n  yarn wrangler <COMMAND> <SUBCOMMAND> [PARAMETERS] [OPTIONS]\n  sh\n  pnpm wrangler <COMMAND> <SUBCOMMAND> [PARAMETERS] [OPTIONS]\n  json\n{\n  ...\n  \"scripts\": {\n    \"deploy\": \"wrangler deploy\",\n    \"dev\": \"wrangler dev\"\n  }\n  ...\n}\nsh\n  npm run deploy\n  sh\n  yarn run deploy\n  sh\n  pnpm run deploy\n  sh\n  npx wrangler docs [SEARCH]\n  sh\n  pnpm wrangler docs [SEARCH]\n  sh\n  yarn wrangler docs [SEARCH]\n  txt\nwrangler init [<NAME>] [OPTIONS]\ntxt\nwrangler containers build [PATH] [OPTIONS]\ntxt\nwrangler containers delete <CONTAINER_ID> [OPTIONS]\ntxt\nwrangler containers images list [OPTIONS]\ntxt\nwrangler containers images delete [IMAGE] [OPTIONS]\ntxt\nwrangler containers registries list [OPTIONS]\ntxt\nwrangler containers registries configure [DOMAIN] [OPTIONS]\ntxt\nwrangler containers registries delete [DOMAIN] [OPTIONS]\ntxt\nwrangler containers info <CONTAINER_ID> [OPTIONS]\ntxt\nwrangler containers list [OPTIONS]\ntxt\nwrangler containers push [TAG] [OPTIONS]\nsh\n  npx wrangler d1 create [NAME]\n  sh\n  pnpm wrangler d1 create [NAME]\n  sh\n  yarn wrangler d1 create [NAME]\n  sh\n  npx wrangler d1 info [NAME]\n  sh\n  pnpm wrangler d1 info [NAME]\n  sh\n  yarn wrangler d1 info [NAME]\n  sh\n  npx wrangler d1 list\n  sh\n  pnpm wrangler d1 list\n  sh\n  yarn wrangler d1 list\n  sh\n  npx wrangler d1 delete [NAME]\n  sh\n  pnpm wrangler d1 delete [NAME]\n  sh\n  yarn wrangler d1 delete [NAME]\n  sh\n  npx wrangler d1 execute [DATABASE]\n  sh\n  pnpm wrangler d1 execute [DATABASE]\n  sh\n  yarn wrangler d1 execute [DATABASE]\n  sh\n  npx wrangler d1 export [NAME]\n  sh\n  pnpm wrangler d1 export [NAME]\n  sh\n  yarn wrangler d1 export [NAME]\n  sh\n  npx wrangler d1 time-travel info [DATABASE]\n  sh\n  pnpm wrangler d1 time-travel info [DATABASE]\n  sh\n  yarn wrangler d1 time-travel info [DATABASE]\n  sh\n  npx wrangler d1 time-travel restore [DATABASE]\n  sh\n  pnpm wrangler d1 time-travel restore [DATABASE]\n  sh\n  yarn wrangler d1 time-travel restore [DATABASE]\n  sh\n  npx wrangler d1 migrations create [DATABASE] [MESSAGE]\n  sh\n  pnpm wrangler d1 migrations create [DATABASE] [MESSAGE]\n  sh\n  yarn wrangler d1 migrations create [DATABASE] [MESSAGE]\n  sh\n  npx wrangler d1 migrations list [DATABASE]\n  sh\n  pnpm wrangler d1 migrations list [DATABASE]\n  sh\n  yarn wrangler d1 migrations list [DATABASE]\n  sh\n  npx wrangler d1 migrations apply [DATABASE]\n  sh\n  pnpm wrangler d1 migrations apply [DATABASE]\n  sh\n  yarn wrangler d1 migrations apply [DATABASE]\n  sh\n  npx wrangler d1 insights [NAME]\n  sh\n  pnpm wrangler d1 insights [NAME]\n  sh\n  yarn wrangler d1 insights [NAME]\n  sh\n  npx wrangler hyperdrive create [NAME]\n  sh\n  pnpm wrangler hyperdrive create [NAME]\n  sh\n  yarn wrangler hyperdrive create [NAME]\n  sh\n  npx wrangler hyperdrive delete [ID]\n  sh\n  pnpm wrangler hyperdrive delete [ID]\n  sh\n  yarn wrangler hyperdrive delete [ID]\n  sh\n  npx wrangler hyperdrive get [ID]\n  sh\n  pnpm wrangler hyperdrive get [ID]\n  sh\n  yarn wrangler hyperdrive get [ID]\n  sh\n  npx wrangler hyperdrive list\n  sh\n  pnpm wrangler hyperdrive list\n  sh\n  yarn wrangler hyperdrive list\n  sh\n  npx wrangler hyperdrive update [ID]\n  sh\n  pnpm wrangler hyperdrive update [ID]\n  sh\n  yarn wrangler hyperdrive update [ID]\n  sh\n  npx wrangler vectorize create [NAME]\n  sh\n  pnpm wrangler vectorize create [NAME]\n  sh\n  yarn wrangler vectorize create [NAME]\n  sh\n  npx wrangler vectorize delete [NAME]\n  sh\n  pnpm wrangler vectorize delete [NAME]\n  sh\n  yarn wrangler vectorize delete [NAME]\n  sh\n  npx wrangler vectorize get [NAME]\n  sh\n  pnpm wrangler vectorize get [NAME]\n  sh\n  yarn wrangler vectorize get [NAME]\n  sh\n  npx wrangler vectorize list\n  sh\n  pnpm wrangler vectorize list\n  sh\n  yarn wrangler vectorize list\n  sh\n  npx wrangler vectorize list-vectors [NAME]\n  sh\n  pnpm wrangler vectorize list-vectors [NAME]\n  sh\n  yarn wrangler vectorize list-vectors [NAME]\n  sh\n  npx wrangler vectorize query [NAME]\n  sh\n  pnpm wrangler vectorize query [NAME]\n  sh\n  yarn wrangler vectorize query [NAME]\n  sh\n  npx wrangler vectorize insert [NAME]\n  sh\n  pnpm wrangler vectorize insert [NAME]\n  sh\n  yarn wrangler vectorize insert [NAME]\n  sh\n  npx wrangler vectorize upsert [NAME]\n  sh\n  pnpm wrangler vectorize upsert [NAME]\n  sh\n  yarn wrangler vectorize upsert [NAME]\n  sh\n  npx wrangler vectorize get-vectors [NAME]\n  sh\n  pnpm wrangler vectorize get-vectors [NAME]\n  sh\n  yarn wrangler vectorize get-vectors [NAME]\n  sh\n  npx wrangler vectorize delete-vectors [NAME]\n  sh\n  pnpm wrangler vectorize delete-vectors [NAME]\n  sh\n  yarn wrangler vectorize delete-vectors [NAME]\n  sh\n  npx wrangler vectorize info [NAME]\n  sh\n  pnpm wrangler vectorize info [NAME]\n  sh\n  yarn wrangler vectorize info [NAME]\n  sh\n  npx wrangler vectorize create-metadata-index [NAME]\n  sh\n  pnpm wrangler vectorize create-metadata-index [NAME]\n  sh\n  yarn wrangler vectorize create-metadata-index [NAME]\n  sh\n  npx wrangler vectorize list-metadata-index [NAME]\n  sh\n  pnpm wrangler vectorize list-metadata-index [NAME]\n  sh\n  yarn wrangler vectorize list-metadata-index [NAME]\n  sh\n  npx wrangler vectorize delete-metadata-index [NAME]\n  sh\n  pnpm wrangler vectorize delete-metadata-index [NAME]\n  sh\n  yarn wrangler vectorize delete-metadata-index [NAME]\n  txt\nwrangler dev [<SCRIPT>] [OPTIONS]\ntxt\nwrangler deploy [<PATH>] [OPTIONS]\ntxt\nwrangler delete [<SCRIPT>] [OPTIONS]\nsh\n  npx wrangler kv namespace create [NAMESPACE]\n  sh\n  pnpm wrangler kv namespace create [NAMESPACE]\n  sh\n  yarn wrangler kv namespace create [NAMESPACE]\n  sh\n  npx wrangler kv namespace list\n  sh\n  pnpm wrangler kv namespace list\n  sh\n  yarn wrangler kv namespace list\n  sh\n  npx wrangler kv namespace delete\n  sh\n  pnpm wrangler kv namespace delete\n  sh\n  yarn wrangler kv namespace delete\n  sh\n  npx wrangler kv namespace rename [OLD-NAME]\n  sh\n  pnpm wrangler kv namespace rename [OLD-NAME]\n  sh\n  yarn wrangler kv namespace rename [OLD-NAME]\n  sh\n  npx wrangler kv key put [KEY] [VALUE]\n  sh\n  pnpm wrangler kv key put [KEY] [VALUE]\n  sh\n  yarn wrangler kv key put [KEY] [VALUE]\n  sh\n  npx wrangler kv key list\n  sh\n  pnpm wrangler kv key list\n  sh\n  yarn wrangler kv key list\n  sh\n  npx wrangler kv key get [KEY]\n  sh\n  pnpm wrangler kv key get [KEY]\n  sh\n  yarn wrangler kv key get [KEY]\n  sh\n  npx wrangler kv key delete [KEY]\n  sh\n  pnpm wrangler kv key delete [KEY]\n  sh\n  yarn wrangler kv key delete [KEY]\n  sh\n  npx wrangler kv bulk get [FILENAME]\n  sh\n  pnpm wrangler kv bulk get [FILENAME]\n  sh\n  yarn wrangler kv bulk get [FILENAME]\n  sh\n  npx wrangler kv bulk put [FILENAME]\n  sh\n  pnpm wrangler kv bulk put [FILENAME]\n  sh\n  yarn wrangler kv bulk put [FILENAME]\n  sh\n  npx wrangler kv bulk delete [FILENAME]\n  sh\n  pnpm wrangler kv bulk delete [FILENAME]\n  sh\n  yarn wrangler kv bulk delete [FILENAME]\n  sh\n  npx wrangler r2 bucket create [NAME]\n  sh\n  pnpm wrangler r2 bucket create [NAME]\n  sh\n  yarn wrangler r2 bucket create [NAME]\n  sh\n  npx wrangler r2 bucket info [BUCKET]\n  sh\n  pnpm wrangler r2 bucket info [BUCKET]\n  sh\n  yarn wrangler r2 bucket info [BUCKET]\n  sh\n  npx wrangler r2 bucket delete [BUCKET]\n  sh\n  pnpm wrangler r2 bucket delete [BUCKET]\n  sh\n  yarn wrangler r2 bucket delete [BUCKET]\n  sh\n  npx wrangler r2 bucket list\n  sh\n  pnpm wrangler r2 bucket list\n  sh\n  yarn wrangler r2 bucket list\n  sh\n  npx wrangler r2 bucket catalog enable [BUCKET]\n  sh\n  pnpm wrangler r2 bucket catalog enable [BUCKET]\n  sh\n  yarn wrangler r2 bucket catalog enable [BUCKET]\n  sh\n  npx wrangler r2 bucket catalog disable [BUCKET]\n  sh\n  pnpm wrangler r2 bucket catalog disable [BUCKET]\n  sh\n  yarn wrangler r2 bucket catalog disable [BUCKET]\n  sh\n  npx wrangler r2 bucket catalog get [BUCKET]\n  sh\n  pnpm wrangler r2 bucket catalog get [BUCKET]\n  sh\n  yarn wrangler r2 bucket catalog get [BUCKET]\n  sh\n  npx wrangler r2 bucket catalog compaction enable [BUCKET] [NAMESPACE] [TABLE]\n  sh\n  pnpm wrangler r2 bucket catalog compaction enable [BUCKET] [NAMESPACE] [TABLE]\n  sh\n  yarn wrangler r2 bucket catalog compaction enable [BUCKET] [NAMESPACE] [TABLE]\n  bash",
  "code_samples": [
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "Select `<Enter>` on your keyboard to save the token as a secret. Both `LIBSQL_DB_URL` and `LIBSQL_DB_AUTH_TOKEN` will be available in your Worker's environment at runtime.\n\n## Install extra libraries\n\nInstall the Turso client library and a router:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "The `@libsql/client` library allows you to query a Turso database. The `itty-router` library is a lightweight router you will use to help handle incoming requests to the worker.\n\n## Write your Worker\n\nYou will now write a Worker that will:\n\n1. Handle an HTTP request.\n2. Route it to a specific handler to either list all users in our database or add a new user.\n3. Return the results and/or success.\n\nOpen `src/index.ts` and delete the existing template. Copy the below code exactly as is and paste it into the file:",
      "language": "unknown"
    },
    {
      "code": "Save your `src/index.ts` file with your changes.\n\nNote:\n\n* The libSQL client library import '@libsql/client/web' must be imported exactly as shown when working with Cloudflare workers. The non-web import will not work in the Workers environment.\n* The `Env` interface contains the environment variable and secret you defined earlier.\n* The `Env` interface also caches the libSQL client object and router, which are created on the first request to the Worker.\n* The `/users` route fetches all rows from the `example_users` table you created in the Turso shell. It simply serializes the `ResultSet` object as JSON directly to the caller.\n* The `/add-user` route inserts a new row using a value provided in the query string.\n\nWith your environment configured and your code ready, you will now test your Worker locally before you deploy.\n\n## Run the Worker locally with Wrangler\n\nTo run a local instance of our Worker (entirely on your machine), run the following command:",
      "language": "unknown"
    },
    {
      "code": "You should be able to review output similar to the following:",
      "language": "unknown"
    },
    {
      "code": "The localhost address â€” the one with `127.0.0.1` in it â€” is a web-server running locally on your machine.\n\nConnect to it and validate your Worker returns the email address you inserted when you created your `example_users` table by visiting the `/users` route in your browser: <http://127.0.0.1:8787/users>.\n\nYou should see JSON similar to the following containing the data from the `example_users` table:",
      "language": "unknown"
    },
    {
      "code": "Warning\n\nIf you see an error instead of a list of users, double check that:\n\n* You have entered the correct value for your `LIBSQL_DB_URL` in the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).\n* You have set a secret called `LIBSQL_DB_AUTH_TOKEN` with your database authentication token.\n\nBoth of these need to be present and match the variable names in your Worker's code.\n\nTest the `/add-users` route and pass it an email address to insert: [http://127.0.0.1:8787/add-user?email=test@test.com](http://127.0.0.1:8787/add-user?email=test@test.com.)\n\nYou should see the text `â€œAddedâ€`. If you load the first URL with the `/users` route again (<http://127.0.0.1:8787/users>), it will show the newly added row. You can repeat this as many times as you like. Note that due to its design, your application will not stop you from adding duplicate email addresses.\n\nQuit Wrangler by typing `q` into the shell where it was started.\n\n## Deploy to Cloudflare\n\nAfter you have validated that your Worker can connect to your Turso database, deploy your Worker. Run the following Wrangler command to deploy your Worker to the Cloudflare global network:",
      "language": "unknown"
    },
    {
      "code": "The first time you run this command, it will launch a browser, ask you to sign in with your Cloudflare account, and grant permissions to Wrangler.\n\nThe `deploy` command will output the following:",
      "language": "unknown"
    },
    {
      "code": "You have now deployed a Worker that can connect to your Turso database, query it, and insert new data.\n\n## Optional: Clean up\n\nTo clean up the resources you created as part of this tutorial:\n\n* If you do not want to keep this Worker, run `npx wrangler delete worker-turso-ts` to delete the deployed Worker.\n* You can also delete your Turso database via `turso db destroy my-db`.\n\n## Related resources\n\n* Find the [complete project source code on GitHub](https://github.com/cloudflare/workers-sdk/tree/main/templates/worker-turso-ts/).\n* Understand how to [debug your Cloudflare Worker](https://developers.cloudflare.com/workers/observability/).\n* Join the [Cloudflare Developer Discord](https://discord.cloudflare.com).\n* Join the [ChiselStrike (Turso) Discord](https://discord.com/invite/4B5D7hYwub).\n\n</page>\n\n<page>\n---\ntitle: Create a fine-tuned OpenAI model with R2 Â· Cloudflare Workers docs\ndescription: In this tutorial, you will use the OpenAI API and Cloudflare R2 to\n  create a fine-tuned model.\nlastUpdated: 2025-11-14T10:07:26.000Z\nchatbotDeprioritize: false\ntags: AI,Hono,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/create-finetuned-chatgpt-ai-models-with-r2/\n  md: https://developers.cloudflare.com/workers/tutorials/create-finetuned-chatgpt-ai-models-with-r2/index.md\n---\n\nIn this tutorial, you will use the [OpenAI](https://openai.com) API and [Cloudflare R2](https://developers.cloudflare.com/r2) to create a [fine-tuned model](https://platform.openai.com/docs/guides/fine-tuning).\n\nThis feature in OpenAI's API allows you to derive a custom model from OpenAI's various large language models based on a set of custom instructions and example answers. These instructions and example answers are written in a document, known as a fine-tune document. This document will be stored in R2 and dynamically provided to OpenAI's APIs when creating a new fine-tune model.\n\nIn order to use this feature, you will do the following tasks:\n\n1. Upload a fine-tune document to R2.\n2. Read the R2 file and upload it to OpenAI.\n3. Create a new fine-tuned model based on the document.\n\n![Demo](https://developers.cloudflare.com/_astro/finetune-example.Df8cOHyQ_Ztq1Pc.webp)\n\nTo review the completed code for this application, refer to the [GitHub repository for this tutorial](https://github.com/kristianfreeman/openai-finetune-r2-example).\n\n## Prerequisites\n\nBefore you start, make sure you have:\n\n* A Cloudflare account with access to R2. If you do not have a Cloudflare account, [sign up](https://dash.cloudflare.com/sign-up/workers-and-pages) before continuing. Then purchase R2 from your Cloudflare dashboard.\n* An OpenAI API key.\n* A fine-tune document, structured as [JSON Lines](https://jsonlines.org/). Use the [example document](https://github.com/kristianfreeman/openai-finetune-r2-example/blob/16ca53ca9c8589834abe317487eeedb8a24c7643/example_data.jsonl) in the source code.\n\n## 1. Create a Worker application\n\nFirst, use the `c3` CLI to create a new Cloudflare Workers project.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `TypeScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nThe above options will create the \"Hello World\" TypeScript project.\n\nMove into your newly created directory:",
      "language": "unknown"
    },
    {
      "code": "## 2. Upload a fine-tune document to R2\n\nNext, upload the fine-tune document to R2. R2 is a key-value store that allows you to store and retrieve files from within your Workers application. You will use [Wrangler](https://developers.cloudflare.com/workers/wrangler) to create a new R2 bucket.\n\nTo create a new R2 bucket use the [`wrangler r2 bucket create`](https://developers.cloudflare.com/workers/wrangler/commands/#r2-bucket-create) command. Note that you are logged in with your Cloudflare account. If not logged in via Wrangler, use the [`wrangler login`](https://developers.cloudflare.com/workers/wrangler/commands/#login) command.",
      "language": "unknown"
    },
    {
      "code": "Replace `<BUCKET_NAME>` with your desired bucket name. Note that bucket names must be lowercase and can only contain dashes.\n\nNext, upload a file using the [`wrangler r2 object put`](https://developers.cloudflare.com/workers/wrangler/commands/#r2-object-put) command.",
      "language": "unknown"
    },
    {
      "code": "`<PATH>` is the combined bucket and file path of the file you want to upload -- for example, `fine-tune-ai/finetune.jsonl`, where `fine-tune-ai` is the bucket name. Replace `<FILE_NAME>` with the local filename of your fine-tune document.\n\n## 3. Bind your bucket to the Worker\n\nA binding is how your Worker interacts with external resources such as the R2 bucket.\n\nTo bind the R2 bucket to your Worker, add the following to your Wrangler file. Update the binding property to a valid JavaScript variable identifier. Replace `<YOUR_BUCKET_NAME>` with the name of the bucket you created in [step 2](#2-upload-a-fine-tune-document-to-r2):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## 4. Initialize your Worker application\n\nYou will use [Hono](https://hono.dev/), a lightweight framework for building Cloudflare Workers applications. Hono provides an interface for defining routes and middleware functions. Inside your project directory, run the following command to install Hono:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "You also need to install the [OpenAI Node API library](https://www.npmjs.com/package/openai). This library provides convenient access to the OpenAI REST API in a Node.js project. To install the library, execute the following command:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Next, open the `src/index.ts` file and replace the default code with the below code. Replace `<MY_BUCKET>` with the binding name you set in Wrangler file.",
      "language": "unknown"
    },
    {
      "code": "In the above code, you first import the required packages and define the types. Then, you initialize `app` as a new Hono instance. Using the `use` middleware function, you add the OpenAI API client to the context of all routes. This middleware function allows you to access the client from within any route handler. `onError()` defines an error handler to return any errors as a JSON response.\n\n## 5. Read R2 files and upload them to OpenAI\n\nIn this section, you will define the route and function responsible for handling file uploads.\n\nIn `createFile`, your Worker reads the file from R2 and converts it to a `File` object. Your Worker then uses the OpenAI API to upload the file and return the response.\n\nThe `GET /files` route listens for `GET` requests with a query parameter `file`, representing a filename of an uploaded fine-tune document in R2. The function uses the `createFile` function to manage the file upload process.\n\nReplace `<MY_BUCKET>` with the binding name you set in Wrangler file.",
      "language": "unknown"
    },
    {
      "code": "## 6. Create fine-tuned models\n\nThis section includes the `GET /models` route and the `createModel` function. The function `createModel` takes care of specifying the details and initiating the fine-tuning process with OpenAI. The route handles incoming requests for creating a new fine-tuned model.",
      "language": "unknown"
    },
    {
      "code": "## 7. List all fine-tune jobs\n\nThis section describes the `GET /jobs` route and the corresponding `getJobs` function. The function interacts with OpenAI's API to fetch a list of all fine-tuning jobs. The route provides an interface for retrieving this information.",
      "language": "unknown"
    },
    {
      "code": "## 8. Deploy your application\n\nAfter you have created your Worker application and added the required functions, deploy the application.\n\nBefore you deploy, you must set the `OPENAI_API_KEY` [secret](https://developers.cloudflare.com/workers/configuration/secrets/) for your application. Do this by running the [`wrangler secret put`](https://developers.cloudflare.com/workers/wrangler/commands/#secret-put) command:",
      "language": "unknown"
    },
    {
      "code": "To deploy your Worker application to the Cloudflare global network:\n\n1. Make sure you are in your Worker project's directory, then run the [`wrangler deploy`](https://developers.cloudflare.com/workers/wrangler/commands/#deploy) command:",
      "language": "unknown"
    },
    {
      "code": "1. Wrangler will package and upload your code.\n\n2. After your application is deployed, Wrangler will provide you with your Worker's URL.\n\n## 9. View the fine-tune job status and use the model\n\nTo use your application, create a new fine-tune job by making a request to the `/files` with a `file` query param matching the filename you uploaded earlier:",
      "language": "unknown"
    },
    {
      "code": "When the file is uploaded, issue another request to `/models`, passing the `file_id` query parameter. This should match the `id` returned as JSON from the `/files` route:",
      "language": "unknown"
    },
    {
      "code": "Finally, visit `/jobs` to see the status of your fine-tune jobs in OpenAI. Once the fine-tune job has completed, you can see the `fine_tuned_model` value, indicating a fine-tuned model has been created.\n\n![Jobs](https://developers.cloudflare.com/_astro/finetune-jobs.BQ_jbiJu_1GbzG8.webp)\n\nVisit the [OpenAI Playground](https://platform.openai.com/playground) in order to use your fine-tune model. Select your fine-tune model from the top-left dropdown of the interface.\n\n![Demo](https://developers.cloudflare.com/_astro/finetune-example.Df8cOHyQ_Ztq1Pc.webp)\n\nUse it in any API requests you make to OpenAI's chat completions endpoints. For instance, in the below code example:",
      "language": "unknown"
    },
    {
      "code": "## Next steps\n\nTo build more with Workers, refer to [Tutorials](https://developers.cloudflare.com/workers/tutorials).\n\nIf you have any questions, need assistance, or would like to share your project, join the Cloudflare Developer community on [Discord](https://discord.cloudflare.com) to connect with other developers and the Cloudflare team.\n\n</page>\n\n<page>\n---\ntitle: Deploy a real-time chat application Â· Cloudflare Workers docs\ndescription: This tutorial shows how to deploy a serverless, real-time chat\n  application. The chat application uses a Durable Object to control each chat\n  room.\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: JavaScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/deploy-a-realtime-chat-app/\n  md: https://developers.cloudflare.com/workers/tutorials/deploy-a-realtime-chat-app/index.md\n---\n\nIn this tutorial, you will deploy a serverless, real-time chat application that runs using [Durable Objects](https://developers.cloudflare.com/durable-objects/).\n\nThis chat application uses a Durable Object to control each chat room. Users connect to the Object using WebSockets. Messages from one user are broadcast to all the other users. The chat history is also stored in durable storage. Real-time messages are relayed directly from one user to others without going through the storage layer.\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## Clone the chat application repository\n\nOpen your terminal and clone the [workers-chat-demo](https://github.com/cloudflare/workers-chat-demo) repository:",
      "language": "unknown"
    },
    {
      "code": "## Authenticate Wrangler\n\nAfter you have cloned the repository, authenticate Wrangler by running:",
      "language": "unknown"
    },
    {
      "code": "## Deploy your project\n\nWhen you are ready to deploy your application, run:",
      "language": "unknown"
    },
    {
      "code": "Your application will be deployed to your `*.workers.dev` subdomain.\n\nTo deploy your application to a custom domain within the Cloudflare dashboard, go to your Worker > **Triggers** > **Add Custom Domain**.\n\nTo deploy your application to a custom domain using Wrangler, open your project's [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).\n\nTo configure a route in your Wrangler configuration file, add the following to your environment:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "If you have specified your zone ID in the environment of your Wrangler configuration file, you will not need to write it again in object form.\n\nTo configure a subdomain in your Wrangler configuration file, add the following to your environment:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "To test your live application:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. Select your Worker > **Triggers** > **Routes** > Select the `edge-chat-demo.<SUBDOMAIN>.workers.dev` route.\n\n3. Enter a name in the **your name** field.\n\n4. Choose whether to enter a public room or create a private room.\n\n5. Send the link to other participants. You will be able to view room participants on the right side of the screen.\n\n## Uninstall your application\n\nTo uninstall your chat application, modify your Wrangler file to remove the `durable_objects` bindings and add a `deleted_classes` migration:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Then run `npx wrangler deploy`.\n\nTo delete your Worker:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. In **Overview**, select your Worker.\n\n3. Select **Manage Service** > **Delete**. For complete instructions on set up and deletion, refer to the `README.md` in your cloned repository.\n\nBy completing this tutorial, you have deployed a real-time chat application with Durable Objects and Cloudflare Workers.\n\n## Related resources\n\nContinue building with other Cloudflare Workers tutorials below.\n\n* [Build a Slackbot](https://developers.cloudflare.com/workers/tutorials/build-a-slackbot/)\n* [Create SMS notifications for your GitHub repository using Twilio](https://developers.cloudflare.com/workers/tutorials/github-sms-notifications-using-twilio/)\n* [Build a QR code generator](https://developers.cloudflare.com/workers/tutorials/build-a-qr-code-generator/)\n\n</page>\n\n<page>\n---\ntitle: Deploy an Express.js application on Cloudflare Workers Â· Cloudflare\n  Workers docs\ndescription: Learn how to deploy an Express.js application on Cloudflare Workers.\nlastUpdated: 2025-10-27T23:50:12.000Z\nchatbotDeprioritize: false\ntags: TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/deploy-an-express-app/\n  md: https://developers.cloudflare.com/workers/tutorials/deploy-an-express-app/index.md\n---\n\nIn this tutorial, you will learn how to deploy an [Express.js](https://expressjs.com/) application on Cloudflare Workers using the [Cloudflare Workers platform](https://developers.cloudflare.com/workers/) and [D1 database](https://developers.cloudflare.com/d1/). You will build a Members Registry API with basic Create, Read, Update, and Delete (CRUD) operations. You will use D1 as the database for storing and retrieving member data.\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## Quick start\n\nIf you want to skip the steps and get started quickly, select **Deploy to Cloudflare** below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/express-on-workers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers. Use this option if you are familiar with Cloudflare Workers, and wish to skip the step-by-step guidance.\n\nYou may wish to manually follow the steps if you are new to Cloudflare Workers.\n\n## 1. Create a new Cloudflare Workers project\n\nUse [C3](https://developers.cloudflare.com/learning-paths/workers/get-started/c3-and-wrangler/#c3), the command-line tool for Cloudflare's developer products, to create a new directory and initialize a new Worker project:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `TypeScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nChange into your new project directory:",
      "language": "unknown"
    },
    {
      "code": "## 2. Install Express and dependencies\n\nIn this tutorial, you will use [Express.js](https://expressjs.com/), a popular web framework for Node.js. To use Express in a Cloudflare Workers environment, install Express along with the necessary TypeScript types:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Express.js on Cloudflare Workers requires the `nodejs_compat` [compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/). This flag enables Node.js APIs and allows Express to run on the Workers runtime. Add the following to your `wrangler.toml` file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## 3. Create a D1 database\n\nYou will now create a D1 database to store member information. Use the `wrangler d1 create` command to create a new database:",
      "language": "unknown"
    },
    {
      "code": "The command will create a new D1 database and ask you the following questions:\n\n* **Would you like Wrangler to add it on your behalf?**: Type `Y`.\n* **What binding name would you like to use?**: Type `DB` and press Enter.\n* **For local dev, do you want to connect to the remote resource instead of a local resource?**: Type `N`.",
      "language": "unknown"
    },
    {
      "code": "The binding will be added to your wrangler configuration file.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## 4. Create database schema\n\nCreate a directory called `schemas` in your project root, and inside it, create a file called `schema.sql`:",
      "language": "unknown"
    },
    {
      "code": "This schema creates a `members` table with an auto-incrementing ID, name, email, and join date fields. It also inserts three sample members.\n\nExecute the schema file against your D1 database:",
      "language": "unknown"
    },
    {
      "code": "The above command creates the table in your local development database. You will deploy the schema to production later.\n\n## 5. Initialize Express application\n\nUpdate your `src/index.ts` file to set up Express with TypeScript. Replace the file content with the following:",
      "language": "unknown"
    },
    {
      "code": "This code initializes Express and creates a basic health check endpoint. The key import `import { env } from \"cloudflare:workers\"` allows you to access [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/) like your D1 database from anywhere in your code. The [httpServerHandler](https://developers.cloudflare.com/workers/runtime-apis/nodejs/http/#httpserverhandler) integrates Express with the Workers runtime, enabling your application to handle HTTP requests on Cloudflare's network.\n\nNext, execute the typegen command to generate type definitions for your Worker environment:",
      "language": "unknown"
    },
    {
      "code": "## 6. Implement read operations\n\nAdd endpoints to retrieve members from the database. Update your `src/index.ts` file by adding the following routes after the health check endpoint:",
      "language": "unknown"
    },
    {
      "code": "These routes use the D1 binding (`env.DB`) to prepare SQL statements and execute them. Since you imported `env` from `cloudflare:workers` at the top of the file, it is accessible throughout your application. The `prepare`, `bind`, and `all` methods on the D1 binding allow you to safely query the database. Refer to [D1 Workers Binding API](https://developers.cloudflare.com/d1/worker-api/) for all available methods.\n\n## 7. Implement create operation\n\nAdd an endpoint to create new members. Add the following route to your `src/index.ts` file:",
      "language": "unknown"
    },
    {
      "code": "This endpoint validates the input, checks the email format, and inserts a new member into the database. It also handles duplicate email addresses by checking for unique constraint violations.\n\n## 8. Implement update operation\n\nAdd an endpoint to update existing members. Add the following route to your `src/index.ts` file:",
      "language": "unknown"
    },
    {
      "code": "This endpoint allows updating either the name, email, or both fields of an existing member. It builds a dynamic SQL query based on the provided fields.\n\n## 9. Implement delete operation\n\nAdd an endpoint to delete members. Add the following route to your `src/index.ts` file:",
      "language": "unknown"
    },
    {
      "code": "This endpoint deletes a member by their ID and returns an error if the member does not exist.\n\n## 10. Test locally\n\nStart the development server to test your API locally:",
      "language": "unknown"
    },
    {
      "code": "The development server will start, and you can access your API at `http://localhost:8787`.\n\nOpen a new terminal window and test the endpoints using `curl`:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "Test creating a new member:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "Test getting a single member:",
      "language": "unknown"
    },
    {
      "code": "Test updating a member:",
      "language": "unknown"
    },
    {
      "code": "Test deleting a member:",
      "language": "unknown"
    },
    {
      "code": "## 11. Deploy to Cloudflare Workers\n\nBefore deploying to production, execute the schema file against your remote (production) database:",
      "language": "unknown"
    },
    {
      "code": "Now deploy your application to the Cloudflare network:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "After successful deployment, Wrangler will output your Worker's URL.\n\n## 12. Test production deployment\n\nTest your deployed API using the provided URL. Replace `<your-worker-url>` with your actual Worker URL:",
      "language": "unknown"
    },
    {
      "code": "You should see the same member data you created in the production database.\n\nCreate a new member in production:",
      "language": "unknown"
    },
    {
      "code": "Your Express.js application with D1 database is now running on Cloudflare Workers.\n\n## Conclusion\n\nIn this tutorial, you built a Members Registry API using Express.js and D1 database, then deployed it to Cloudflare Workers. You implemented full CRUD operations (Create, Read, Update, Delete) and learned how to:\n\n* Set up an Express.js application for Cloudflare Workers\n* Create and configure a D1 database with bindings\n* Implement database operations using D1's prepared statements\n* Test your API locally and in production\n\n## Next steps\n\n* Learn more about [D1 database features](https://developers.cloudflare.com/d1/)\n* Explore [Workers routing and middleware](https://developers.cloudflare.com/workers/runtime-apis/)\n* Add authentication to your API using [Workers authentication](https://developers.cloudflare.com/workers/runtime-apis/handlers/)\n* Implement pagination for large datasets using [D1 query optimization](https://developers.cloudflare.com/d1/worker-api/)\n\n</page>\n\n<page>\n---\ntitle: Generate YouTube thumbnails with Workers and Cloudflare Image Resizing Â·\n  Cloudflare Workers docs\ndescription: This tutorial explains how to programmatically generate a custom\n  YouTube thumbnail using Cloudflare Workers. You may want to customize the\n  thumbnail's design, call-to-actions and images used to encourage more viewers\n  to watch your video.\nlastUpdated: 2025-11-17T14:08:01.000Z\nchatbotDeprioritize: false\ntags: JavaScript,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/generate-youtube-thumbnails-with-workers-and-images/\n  md: https://developers.cloudflare.com/workers/tutorials/generate-youtube-thumbnails-with-workers-and-images/index.md\n---\n\nIn this tutorial, you will learn how to programmatically generate a custom YouTube thumbnail using Cloudflare Workers and Cloudflare Image Resizing. You may want to generate a custom YouTube thumbnail to customize the thumbnail's design, call-to-actions and images used to encourage more viewers to watch your video.\n\nThis tutorial will help you understand how to work with [Images](https://developers.cloudflare.com/images/),[Image Resizing](https://developers.cloudflare.com/images/transform-images/) and [Cloudflare Workers](https://developers.cloudflare.com/workers/).\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\nTo follow this tutorial, make sure you have Node, Cargo, and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/) installed on your machine.\n\n## Learning goals\n\nIn this tutorial, you will learn how to:\n\n* Upload Images to Cloudflare with the Cloudflare dashboard or API.\n* Set up a Worker project with Wrangler.\n* Manipulate images with image transformations in your Worker.\n\n## Upload your image\n\nTo generate a custom thumbnail image, you first need to upload a background image to Cloudflare Images. This will serve as the image you use for transformations to generate the thumbnails.\n\nCloudflare Images allows you to store, resize, optimize and deliver images in a fast and secure manner. To get started, upload your images to the Cloudflare dashboard or use the Upload API.\n\n### Upload with the dashboard\n\nTo upload an image using the Cloudflare dashboard:\n\n1. In the Cloudflare dashboard, go to the **Transformations** page.\n\n   [Go to **Transformations**](https://dash.cloudflare.com/?to=/:account/images/transformations)\n\n2. Use **Quick Upload** to either drag and drop an image or click to browse and choose a file from your local files.\n\n3. After the image is uploaded, view it using the generated URL.\n\n### Upload with the API\n\nTo upload your image with the [Upload via URL](https://developers.cloudflare.com/images/upload-images/upload-url/) API, refer to the example below:",
      "language": "unknown"
    },
    {
      "code": "* `ACCOUNT_ID`: The current user's account id which can be found in your account settings.\n* `API_TOKEN`: Needs to be generated to scoping Images permission.\n* `PATH_TO_IMAGE`: Indicates the URL for the image you want to upload.\n\nYou will then receive a response similar to this:",
      "language": "unknown"
    },
    {
      "code": "Now that you have uploaded your image, you will use it as the background image for your video's thumbnail.\n\n## Create a Worker to transform text to image\n\nAfter uploading your image, create a Worker that will enable you to transform text to image. This image can be used as an overlay on the background image you uploaded. Use the [rustwasm-worker-template](https://github.com/cloudflare/workers-sdk/tree/main/templates/worker-rust).\n\nYou will need the following before you begin:\n\n* A recent version of [Rust](https://rustup.rs/).\n\n* Access to the `cargo-generate` subcommand:",
      "language": "unknown"
    },
    {
      "code": "Create a new Worker project using the `worker-rust` template:",
      "language": "unknown"
    },
    {
      "code": "You will now make a few changes to the files in your project directory.\n\n1. In the `lib.rs` file, add the following code block:",
      "language": "unknown"
    },
    {
      "code": "1. Update the `Cargo.toml` file in your `worker-to-text` project directory to use [text-to-png](https://github.com/RookAndPawn/text-to-png), a Rust package for rendering text to PNG. Add the package as a dependency by running:",
      "language": "unknown"
    },
    {
      "code": "1. Import the `text_to_png` library into your `worker-to-text` project's `lib.rs` file.",
      "language": "unknown"
    },
    {
      "code": "1. Update `lib.rs` to create a `handle-slash` function that will activate the image transformation based on the text passed to the URL as a query parameter.",
      "language": "unknown"
    },
    {
      "code": "1. In the `handle-slash` function, call the `TextRenderer` by assigning it to a renderer value, specifying that you want to use a custom font. Then, use the `render_text_to_png_data` method to transform the text into image format. In this example, the custom font (`Inter-Bold.ttf`) is located in an `/assets` folder at the root of the project which will be used for generating the thumbnail. You must update this portion of the code to point to your custom font file.",
      "language": "unknown"
    },
    {
      "code": "1. Rewrite the `Router` function to call `handle_slash` when a query is passed in the URL, otherwise return the `\"Hello Worker!\"` as the response.",
      "language": "unknown"
    },
    {
      "code": "1. In your `lib.rs` file, set the headers to `content-type: image/png` so that the response is correctly rendered as a PNG image.",
      "language": "unknown"
    },
    {
      "code": "The final `lib.rs` file should look as follows. Find the full code as an example repository on [GitHub](https://github.com/cloudflare/workers-sdk/tree/main/templates/examples/worker-to-text).",
      "language": "unknown"
    },
    {
      "code": "After you have finished updating your project, start a local server for developing your Worker by running:",
      "language": "unknown"
    },
    {
      "code": "This should spin up a `localhost` instance with the image displayed:\n\n![Run wrangler dev to start a local server for your Worker](https://developers.cloudflare.com/_astro/hello-worker.ot1qb0cF_1eYJKj.webp)\n\nAdding a query parameter with custom text, you should receive:\n\n![Follow the instructions above to receive an output image](https://developers.cloudflare.com/_astro/build-serverles.BHasze4F_1ImBgz.webp)\n\nTo deploy your Worker, open your Wrangler file and update the `name` key with your project's name. Below is an example with this tutorial's project name:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Then run the `npx wrangler deploy` command to deploy your Worker.",
      "language": "unknown"
    },
    {
      "code": "A `.workers.dev` domain will be generated for your Worker after running `wrangler deploy`. You will use this domain in the main thumbnail image.\n\n## Create a Worker to display the original image\n\nCreate a Worker to serve the image you uploaded to Images by running:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nTo start developing your Worker, `cd` into your new project directory:",
      "language": "unknown"
    },
    {
      "code": "This will create a new Worker project named `thumbnail-image`. In the `src/index.js` file, add the following code block:",
      "language": "unknown"
    },
    {
      "code": "Update `env.CLOUDFLARE_ACCOUNT_HASH` with your [Cloudflare account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids/). Update `env.IMAGE_ID` with your [image ID](https://developers.cloudflare.com/images/get-started/).\n\nRun your Worker and go to the `/original-image` route to review your image.\n\n## Add custom text on your image\n\nYou will now use [Cloudflare image transformations](https://developers.cloudflare.com/images/transform-images/), with the `fetch` method, to add your dynamic text image as an overlay on top of your background image. Start by displaying the resulting image on a different route. Call the new route `/thumbnail`.",
      "language": "unknown"
    },
    {
      "code": "Next, use the `fetch` method to apply the image transformation changes on top of the background image. The overlay options are nested in `options.cf.image`.",
      "language": "unknown"
    },
    {
      "code": "The `imageURL` is the URL of the image you want to use as a background image. In the `cf.image` object, specify the options you want to apply to the background image.\n\nNote\n\nAt time of publication, Cloudflare image transformations do not allow resizing images in a Worker that is stored in Cloudflare Images. Instead of using the image you served on the `/original-image` route, you will use the same image from a different source.\n\nAdd your background image to an assets directory on GitHub and push your changes to GitHub. Copy the URL of the image upload by performing a left click on the image and selecting the **Copy Remote File Url** option.\n\nReplace the `imageURL` value with the copied remote URL.",
      "language": "unknown"
    },
    {
      "code": "Next, add overlay options in the image object. Resize the image to the preferred width and height for YouTube thumbnails and use the [draw](https://developers.cloudflare.com/images/transform-images/draw-overlays/) option to add overlay text using the deployed URL of your `text-to-image` Worker.",
      "language": "unknown"
    },
    {
      "code": "Image transformations can only be tested when you deploy your Worker.\n\nTo deploy your Worker, open your Wrangler file and update the `name` key with your project's name. Below is an example with this tutorial's project name:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Deploy your Worker by running:",
      "language": "unknown"
    },
    {
      "code": "The command deploys your Worker to custom `workers.dev` subdomain. Go to your `.workers.dev` subdomain and go to the `/thumbnail` route.\n\nYou should see the resized image with the text `Hello Workers!`.\n\n![Follow the steps above to generate your resized image.](https://developers.cloudflare.com/_astro/thumbnail.z6EOGa1__o6RTe.webp)\n\nYou will now make text applied dynamic. Making your text dynamic will allow you change the text and have it update on the image automatically.\n\nTo add dynamic text, append any text attached to the `/thumbnail` URL using query parameters and pass it down to the `text-to-image` Worker URL as a parameter.",
      "language": "unknown"
    },
    {
      "code": "This will always return the text you pass as a query string in the generated image. This example URL, <https://socialcard.cdnuptime.com/thumbnail?Getting%20Started%20With%20Cloudflare%20Images>, will generate the following image:\n\n![An example thumbnail.](https://developers.cloudflare.com/_astro/thumbnail2.Bi3AcUzr_m1Gl5.webp)\n\nBy completing this tutorial, you have successfully made a custom YouTube thumbnail generator.\n\n## Related resources\n\nIn this tutorial, you learned how to use Cloudflare Workers and Cloudflare image transformations to generate custom YouTube thumbnails. To learn more about Cloudflare Workers and image transformations, refer to [Resize an image with a Worker](https://developers.cloudflare.com/images/transform-images/transform-via-workers/).\n\n</page>\n\n<page>\n---\ntitle: GitHub SMS notifications using Twilio Â· Cloudflare Workers docs\ndescription: This tutorial shows you how to build an SMS notification system on\n  Workers to receive updates on a GitHub repository. Your Worker will send you a\n  text update using Twilio when there is new activity on your repository.\nlastUpdated: 2025-11-14T10:07:26.000Z\nchatbotDeprioritize: false\ntags: JavaScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/github-sms-notifications-using-twilio/\n  md: https://developers.cloudflare.com/workers/tutorials/github-sms-notifications-using-twilio/index.md\n---\n\nIn this tutorial, you will learn to build an SMS notification system on Workers to receive updates on a GitHub repository. Your Worker will send you a text update using Twilio when there is new activity on your repository.\n\nYou will learn how to:\n\n* Build webhooks using Workers.\n* Integrate Workers with GitHub and Twilio.\n* Use Worker secrets with Wrangler.\n\n![Animated gif of receiving a text message on your phone after pushing changes to a repository](https://developers.cloudflare.com/images/workers/tutorials/github-sms/video-of-receiving-a-text-after-pushing-to-a-repo.gif)\n\n***\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## Create a Worker project\n\nStart by using `npm create cloudflare@latest` to create a Worker project in the command line:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nMake note of the URL that your application was deployed to. You will be using it when you configure your GitHub webhook.",
      "language": "unknown"
    },
    {
      "code": "Inside of your new `github-sms-notifications` directory, `src/index.js` represents the entry point to your Cloudflare Workers application. You will configure this file for most of the tutorial.\n\nYou will also need a GitHub account and a repository for this tutorial. If you do not have either setup, [create a new GitHub account](https://github.com/join) and [create a new repository](https://docs.github.com/en/get-started/quickstart/create-a-repo) to continue with this tutorial.\n\nFirst, create a webhook for your repository to post updates to your Worker. Inside of your Worker, you will then parse the updates. Finally, you will send a `POST` request to Twilio to send a text message to you.\n\nYou can reference the finished code at this [GitHub repository](https://github.com/rickyrobinett/workers-sdk/tree/main/templates/examples/github-sms-notifications-using-twilio).\n\n***\n\n## Configure GitHub\n\nTo start, configure a GitHub webhook to post to your Worker when there is an update to the repository:\n\n1. Go to your GitHub repository's **Settings** > **Webhooks** > **Add webhook**.\n\n2. Set the Payload URL to the `/webhook` path on the Worker URL that you made note of when your application was first deployed.\n\n3. In the **Content type** dropdown, select *application/json*.\n\n4. In the **Secret** field, input a secret key of your choice.\n\n5. In **Which events would you like to trigger this webhook?**, select **Let me select individual events**. Select the events you want to get notifications for (such as **Pull requests**, **Pushes**, and **Branch or tag creation**).\n\n6. Select **Add webhook** to finish configuration.\n\n![Following instructions to set up your webhook in the GitHub webhooks settings dashboard](https://developers.cloudflare.com/_astro/github-config-screenshot.BR7flpMR_RFrhh.webp)\n\n***\n\n## Parsing the response\n\nWith your local environment set up, parse the repository update with your Worker.\n\nInitially, your generated `index.js` should look like this:",
      "language": "unknown"
    },
    {
      "code": "Use the `request.method` property of [`Request`](https://developers.cloudflare.com/workers/runtime-apis/request/) to check if the request coming to your application is a `POST` request, and send an error response if the request is not a `POST` request.",
      "language": "unknown"
    },
    {
      "code": "Next, validate that the request is sent with the right secret key. GitHub attaches a hash signature for [each payload using the secret key](https://docs.github.com/en/developers/webhooks-and-events/webhooks/securing-your-webhooks). Use a helper function called `checkSignature` on the request to ensure the hash is correct. Then, you can access data from the webhook by parsing the request as JSON.",
      "language": "unknown"
    },
    {
      "code": "The `checkSignature` function will use the Node.js crypto library to hash the received payload with your known secret key to ensure it matches the request hash. GitHub uses an HMAC hexdigest to compute the hash in the SHA-256 format. You will place this function at the top of your `index.js` file, before your export.",
      "language": "unknown"
    },
    {
      "code": "To make this work, you need to use [`wrangler secret put`](https://developers.cloudflare.com/workers/wrangler/commands/#secret-put) to set your `GITHUB_SECRET_TOKEN`. This token is the secret you picked earlier when configuring you GitHub webhook:",
      "language": "unknown"
    },
    {
      "code": "Add the nodejs\\_compat flag to your Wrangler file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "***\n\n## Sending a text with Twilio\n\nYou will send a text message to you about your repository activity using Twilio. You need a Twilio account and a phone number that can receive text messages. [Refer to the Twilio guide to get set up](https://www.twilio.com/messaging/sms). (If you are new to Twilio, they have [an interactive game](https://www.twilio.com/quest) where you can learn how to use their platform and get some free credits for beginners to the service.)\n\nYou can then create a helper function to send text messages by sending a `POST` request to the Twilio API endpoint. [Refer to the Twilio reference](https://www.twilio.com/docs/sms/api/message-resource#create-a-message-resource) to learn more about this endpoint.\n\nCreate a new function called `sendText()` that will handle making the request to Twilio:",
      "language": "unknown"
    },
    {
      "code": "To make this work, you need to set some secrets to hide your `ACCOUNT_SID` and `AUTH_TOKEN` from the source code. You can set secrets with [`wrangler secret put`](https://developers.cloudflare.com/workers/wrangler/commands/#secret-put) in your command line.",
      "language": "unknown"
    },
    {
      "code": "Modify your `githubWebhookHandler` to send a text message using the `sendText` function you just made.",
      "language": "unknown"
    },
    {
      "code": "Run the `npx wrangler deploy` command to redeploy your Worker project:",
      "language": "unknown"
    },
    {
      "code": "![Video of receiving a text after pushing to a repo](https://developers.cloudflare.com/images/workers/tutorials/github-sms/video-of-receiving-a-text-after-pushing-to-a-repo.gif)\n\nNow when you make an update (that you configured in the GitHub **Webhook** settings) to your repository, you will get a text soon after. If you have never used Git before, refer to the [GIT Push and Pull Tutorial](https://www.datacamp.com/tutorial/git-push-pull) for pushing to your repository.\n\nReference the finished code [on GitHub](https://github.com/rickyrobinett/workers-sdk/tree/main/templates/examples/github-sms-notifications-using-twilio).\n\nBy completing this tutorial, you have learned how to build webhooks using Workers, integrate Workers with GitHub and Twilio, and use Worker secrets with Wrangler.\n\n## Related resources\n\n* [Build a JAMStack app](https://developers.cloudflare.com/workers/tutorials/build-a-jamstack-app/)\n* [Build a QR code generator](https://developers.cloudflare.com/workers/tutorials/build-a-qr-code-generator/)\n\n</page>\n\n<page>\n---\ntitle: Handle form submissions with Airtable Â· Cloudflare Workers docs\ndescription: Use Cloudflare Workers and Airtable to persist form submissions\n  from a front-end user interface. Workers will handle incoming form submissions\n  and use Airtables REST API to asynchronously persist the data in an Airtable\n  base.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\ntags: Forms,JavaScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/handle-form-submissions-with-airtable/\n  md: https://developers.cloudflare.com/workers/tutorials/handle-form-submissions-with-airtable/index.md\n---\n\nIn this tutorial, you will use [Cloudflare Workers](https://developers.cloudflare.com/workers/) and [Airtable](https://airtable.com) to persist form submissions from a front-end user interface. Airtable is a free-to-use spreadsheet solution that has an approachable API for developers. Workers will handle incoming form submissions and use Airtable's [REST API](https://airtable.com/api) to asynchronously persist the data in an Airtable base (Airtable's term for a spreadsheet) for later reference.\n\n![GIF of a complete Airtable and serverless function integration](https://developers.cloudflare.com/images/workers/tutorials/airtable/example.gif)\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## 1. Create a form\n\nFor this tutorial, you will be building a Workers function that handles input from a contact form. The form this tutorial references will collect a first name, last name, email address, phone number, message subject, and a message.\n\nBuild a form\n\nIf this is your first time building a form and you would like to follow a tutorial to create a form with Cloudflare Pages, refer to the [HTML forms](https://developers.cloudflare.com/pages/tutorials/forms) tutorial.\n\nReview a simplified example of the form used in this tuttorial. Note that the `action` parameter of the `<form>` tag should point to the deployed Workers application that you will build in this tutorial.",
      "language": "unknown"
    },
    {
      "code": "## 2. Create a Worker project\n\nTo handle the form submission, create and deploy a Worker that parses the incoming form data and prepares it for submission to Airtable.\n\nCreate a new `airtable-form-handler` Worker project:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nThen, move into the newly created directory:",
      "language": "unknown"
    },
    {
      "code": "## 3. Configure an Airtable base\n\nWhen your Worker is complete, it will send data up to an Airtable base via Airtable's REST API.\n\nIf you do not have an Airtable account, create one (the free plan is sufficient to complete this tutorial). In Airtable's dashboard, create a new base by selecting **Start from scratch**.\n\nAfter you have created a new base, set it up for use with the front-end form. Delete the existing columns, and create six columns, with the following field types:\n\n| Field name | Airtable field type |\n| - | - |\n| First Name | \"Single line text\" |\n| Last Name | \"Single line text\" |\n| Email | \"Email\" |\n| Phone Number | \"Phone number\" |\n| Subject | \"Single line text\" |\n| Message | \"Long text\" |\n\nNote that the field names are case-sensitive. If you change the field names, you will need to exactly match your new field names in the API request you make to Airtable later in the tutorial. Finally, you can optionally rename your table -- by defaulte it will have a name like Table 1. In the below code, we assume the table has been renamed with a more descriptive name, like `Form Submissions`.\n\nNext, navigate to [Airtable's API page](https://airtable.com/api) and select your new base. Note that you must be logged into Airtable to see your base information. In the API documentation page, find your **Airtable base ID**.\n\nYou will also need to create a **Personal access token** that you'll use to access your Airtable base. You can do so by visiting the [Personal access tokens](https://airtable.com/create/tokens) page on Airtable's website and creating a new token. Make sure that you configure the token in the following way:\n\n* Scope: the `data.records:write` scope must be set on the token\n* Access: access should be granted to the base you have been working with in this tutorial\n\nThe results access token should now be set in your application. To make the token available in your codebase, use the [`wrangler secret`](https://developers.cloudflare.com/workers/wrangler/commands/#secret) command. The `secret` command encrypts and stores environment variables for use in your function, without revealing them to users.\n\nRun `wrangler secret put`, passing `AIRTABLE_ACCESS_TOKEN` as the name of your secret:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "Before you continue, review the keys that you should have from Airtable:\n\n1. **Airtable Table Name**: The name for your table, like Form Submissions.\n2. **Airtable Base ID**: The alphanumeric base ID found at the top of your base's API page.\n3. **Airtable Access Token**: A Personal Access Token created by the user to access information about your new Airtable base.\n\n## 4. Submit data to Airtable\n\nWith your Airtable base set up, and the keys and IDs you need to communicate with the API ready, you will now set up your Worker to persist data from your form into Airtable.\n\nIn your Worker project's `index.js` file, replace the default code with a Workers fetch handler that can respond to requests. When the URL requested has a pathname of `/submit`, you will handle a new form submission, otherwise, you will return a `404 Not Found` response.",
      "language": "unknown"
    },
    {
      "code": "The `submitHandler` has two functions. First, it will parse the form data coming from your HTML5 form. Once the data is parsed, use the Airtable API to persist a new row (a new form submission) to your table:",
      "language": "unknown"
    },
    {
      "code": "Prevent potential errors when accessing request.body\n\nThe body of a [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) can only be accessed once. If you previously used `request.formData()` in the same request, you may encounter a TypeError when attempting to access `request.body`.\n\nTo avoid errors, create a clone of the Request object with `request.clone()` for each subsequent attempt to access a Request's body. Keep in mind that Workers have a [memory limit of 128 MB per Worker](https://developers.cloudflare.com/workers/platform/limits#worker-limits) and loading particularly large files into a Worker's memory multiple times may reach this limit. To ensure memory usage does not reach this limit, consider using [Streams](https://developers.cloudflare.com/workers/runtime-apis/streams/).\n\nWhile the majority of this function is concerned with parsing the request body (the data being sent as part of the request), there are two important things to note. First, if the HTTP method sent to this function is not `POST`, you will return a new response with the status code of [`405 Method Not Allowed`](https://httpstatuses.com/405).\n\nThe variable `reqBody` represents a collection of fields, which are key-value pairs for each column in your Airtable table. By formatting `reqBody` as an object with a collection of fields, you are creating a new record in your table with a value for each field.\n\nThen you call `createAirtableRecord` (the function you will define next). The `createAirtableRecord` function accepts a `body` parameter, which conforms to the Airtable API's required format â€” namely, a JavaScript object containing key-value pairs under `fields`, representing a single record to be created on your table:",
      "language": "unknown"
    },
    {
      "code": "To make an authenticated request to Airtable, you need to provide four constants that represent data about your Airtable account, base, and table name. You have already set `AIRTABLE_ACCESS_TOKEN` using `wrangler secret`, since it is a value that should be encrypted. The **Airtable base ID** and **table name**, and `FORM_URL` are values that can be publicly shared in places like GitHub. Use Wrangler's [`vars`](https://developers.cloudflare.com/workers/wrangler/migration/v1-to-v2/wrangler-legacy/configuration/#vars) feature to pass public environment variables from your Wrangler file.\n\nAdd a `vars` table at the end of your Wrangler file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "With all these fields submitted, it is time to deploy your Workers serverless function and get your form communicating with it. First, publish your Worker:",
      "language": "unknown"
    },
    {
      "code": "Your Worker project will deploy to a unique URL â€” for example, `https://workers-airtable-form.cloudflare.workers.dev`. This represents the first part of your front-end form's `action` attribute â€” the second part is the path for your form handler, which is `/submit`. In your front-end UI, configure your `form` tag as seen below:",
      "language": "unknown"
    },
    {
      "code": "After you have deployed your new form (refer to the [HTML forms](https://developers.cloudflare.com/pages/tutorials/forms) tutorial if you need help creating a form), you should be able to submit a new form submission and see the value show up immediately in Airtable:\n\n![Example GIF of complete Airtable and serverless function integration](https://developers.cloudflare.com/images/workers/tutorials/airtable/example.gif)\n\n## Conclusion\n\nWith this tutorial completed, you have created a Worker that can accept form submissions and persist them to Airtable. You have learned how to parse form data, set up environment variables, and use the `fetch` API to make requests to external services outside of your Worker.\n\n## Related resources\n\n* [Build a Slackbot](https://developers.cloudflare.com/workers/tutorials/build-a-slackbot)\n* [Build a To-Do List Jamstack App](https://developers.cloudflare.com/workers/tutorials/build-a-jamstack-app)\n* [Build a blog using Nuxt.js and Sanity.io on Cloudflare Pages](https://developers.cloudflare.com/pages/tutorials/build-a-blog-using-nuxt-and-sanity)\n* [James Quick's video on building a Cloudflare Workers + Airtable integration](https://www.youtube.com/watch?v=tFQ2kbiu1K4)\n\n</page>\n\n<page>\n---\ntitle: Connect to a MySQL database with Cloudflare Workers Â· Cloudflare Workers docs\ndescription: This tutorial explains how to connect to a Cloudflare database\n  using TCP Sockets and Hyperdrive. The Workers application you create in this\n  tutorial will interact with a product database inside of MySQL.\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: MySQL,TypeScript,SQL\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/mysql/\n  md: https://developers.cloudflare.com/workers/tutorials/mysql/index.md\n---\n\nIn this tutorial, you will learn how to create a Cloudflare Workers application and connect it to a MySQL database using [TCP Sockets](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/) and [Hyperdrive](https://developers.cloudflare.com/hyperdrive/). The Workers application you create in this tutorial will interact with a product database inside of MySQL.\n\nNote\n\nWe recommend using [Hyperdrive](https://developers.cloudflare.com/hyperdrive/) to connect to your MySQL database. Hyperdrive provides optimal performance and will ensure secure connectivity between your Worker and your MySQL database.\n\nWhen connecting directly to your MySQL database (without Hyperdrive), the MySQL drivers rely on unsupported Node.js APIs to create secure connections, which prevents connections.\n\n## Prerequisites\n\nTo continue:\n\n1. Sign up for a [Cloudflare account](https://dash.cloudflare.com/sign-up/workers-and-pages) if you have not already.\n2. Install [`npm`](https://docs.npmjs.com/getting-started).\n3. Install [`Node.js`](https://nodejs.org/en/). Use a Node version manager like [Volta](https://volta.sh/) or [nvm](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node.js versions. [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/) requires a Node version of `16.17.0` or later.\n4. Make sure you have access to a MySQL database.\n\n## 1. Create a Worker application\n\nFirst, use the [`create-cloudflare` CLI](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare) to create a new Worker application. To do this, open a terminal window and run the following command:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "This will prompt you to install the [`create-cloudflare`](https://www.npmjs.com/package/create-cloudflare) package and lead you through a setup wizard.\n\nFor setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `TypeScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nIf you choose to deploy, you will be asked to authenticate (if not logged in already), and your project will be deployed. If you deploy, you can still modify your Worker code and deploy again at the end of this tutorial.\n\nNow, move into the newly created directory:",
      "language": "unknown"
    },
    {
      "code": "## 2. Enable Node.js compatibility\n\n[Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) is required for database drivers, including mysql2, and needs to be configured for your Workers project.\n\nTo enable both built-in runtime APIs and polyfills for your Worker or Pages project, add the [`nodejs_compat`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag) [compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag) to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/), and set your compatibility date to September 23rd, 2024 or later. This will enable [Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) for your Workers project.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## 3. Create a Hyperdrive configuration\n\nCreate a Hyperdrive configuration using the connection string for your MySQL database.",
      "language": "unknown"
    },
    {
      "code": "This command outputs the Hyperdrive configuration `id` that will be used for your Hyperdrive [binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/). Set up your binding by specifying the `id` in the Wrangler file.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## 4. Query your database from your Worker\n\nInstall the [mysql2](https://github.com/sidorares/node-mysql2) driver:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Note\n\n`mysql2` v3.13.0 or later is required\n\nAdd the required Node.js compatibility flags and Hyperdrive binding to your `wrangler.jsonc` file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Create a new `connection` instance and pass the Hyperdrive parameters:",
      "language": "unknown"
    },
    {
      "code": "Note\n\nThe minimum version of `mysql2` required for Hyperdrive is `3.13.0`.\n\n## 5. Deploy your Worker\n\nRun the following command to deploy your Worker:",
      "language": "unknown"
    },
    {
      "code": "Your application is now live and accessible at `<YOUR_WORKER>.<YOUR_SUBDOMAIN>.workers.dev`.\n\n## Next steps\n\nTo build more with databases and Workers, refer to [Tutorials](https://developers.cloudflare.com/workers/tutorials) and explore the [Databases documentation](https://developers.cloudflare.com/workers/databases).\n\nIf you have any questions, need assistance, or would like to share your project, join the Cloudflare Developer community on [Discord](https://discord.cloudflare.com) to connect with fellow developers and the Cloudflare team.\n\n</page>\n\n<page>\n---\ntitle: OpenAI GPT function calling with JavaScript and Cloudflare Workers Â·\n  Cloudflare Workers docs\ndescription: Build a project that leverages OpenAI's function calling feature,\n  available in OpenAI's latest Chat Completions API models.\nlastUpdated: 2025-11-14T10:07:26.000Z\nchatbotDeprioritize: false\ntags: AI,JavaScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/openai-function-calls-workers/\n  md: https://developers.cloudflare.com/workers/tutorials/openai-function-calls-workers/index.md\n---\n\nIn this tutorial, you will build a project that leverages [OpenAI's function calling](https://platform.openai.com/docs/guides/function-calling) feature, available in OpenAI's latest Chat Completions API models.\n\nThe function calling feature allows the AI model to intelligently decide when to call a function based on the input, and respond in JSON format to match the function's signature. You will use the function calling feature to request for the model to determine a website URL which contains information relevant to a message from the user, retrieve the text content of the site, and, finally, return a final response from the model informed by real-time web data.\n\n## What you will learn\n\n* How to use OpenAI's function calling feature.\n* Integrating OpenAI's API in a Cloudflare Worker.\n* Fetching and processing website content using Cheerio.\n* Handling API responses and function calls in JavaScript.\n* Storing API keys as secrets with Wrangler.\n\n***\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## 1. Create a new Worker project\n\nCreate a Worker project in the command line:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nGo to your new `openai-function-calling-workers` Worker project:",
      "language": "unknown"
    },
    {
      "code": "Inside of your new `openai-function-calling-workers` directory, find the `src/index.js` file. You will configure this file for most of the tutorial.\n\nYou will also need an OpenAI account and API key for this tutorial. If you do not have one, [create a new OpenAI account](https://platform.openai.com/signup) and [create an API key](https://platform.openai.com/account/api-keys) to continue with this tutorial. Make sure to store you API key somewhere safe so you can use it later.\n\n## 2. Make a request to OpenAI\n\nWith your Worker project created, make your first request to OpenAI. You will use the OpenAI node library to interact with the OpenAI API. In this project, you will also use the Cheerio library to handle processing the HTML content of websites\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Now, define the structure of your Worker in `index.js`:",
      "language": "unknown"
    },
    {
      "code": "Above `export default`, add the imports for `openai` and `cheerio`:",
      "language": "unknown"
    },
    {
      "code": "Within your `fetch` function, instantiate your `OpenAI` client:",
      "language": "unknown"
    },
    {
      "code": "Use [`wrangler secret put`](https://developers.cloudflare.com/workers/wrangler/commands/#secret-put) to set `OPENAI_API_KEY`. This [secret's](https://developers.cloudflare.com/workers/configuration/secrets/) value is the API key you created earlier in the OpenAI dashboard:",
      "language": "unknown"
    },
    {
      "code": "For local development, create a new file `.dev.vars` in your Worker project and add this line. Make sure to replace `OPENAI_API_KEY` with your own OpenAI API key:",
      "language": "unknown"
    },
    {
      "code": "Now, make a request to the OpenAI [Chat Completions API](https://platform.openai.com/docs/guides/gpt/chat-completions-api):",
      "language": "unknown"
    },
    {
      "code": "Review the arguments you are passing to OpenAI:\n\n* **model**: This is the model you want OpenAI to use for your request. In this case, you are using `gpt-4o-mini`.\n\n* **messages**: This is an array containing all messages that are part of the conversation. Initially you provide a message from the user, and we later add the response from the model. The content of the user message is either the `message` query parameter from the request URL or the default \"What's in the news today?\".\n\n* **tools**: An array containing the actions available to the AI model. In this example you only have one tool, `read_website_content`, which reads the content on a given website.\n\n  * **name**: The name of your function. In this case, it is `read_website_content`.\n  * **description**: A short description that lets the model know the purpose of the function. This is optional but helps the model know when to select the tool.\n  * **parameters**: A JSON Schema object which describes the function. In this case we request a response containing an object with the required property `url`.\n\n* **tool\\_choice**: This argument is technically optional as `auto` is the default. This argument indicates that either a function call or a normal message response can be returned by OpenAI.\n\n## 3. Building your `read_website_content()` function\n\nYou will now need to define the `read_website_content` function, which is referenced in the `tools` array. The `read_website_content` function fetches the content of a given URL and extracts the text from `<p>` tags using the `cheerio` library:\n\nAdd this code above the `export default` block in your `index.js` file:",
      "language": "unknown"
    },
    {
      "code": "In this function, you take the URL that you received from OpenAI and use JavaScript's [`Fetch API`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) to pull the content of the website and extract the paragraph text. Now we need to determine when to call this function.\n\n## 4. Process the Assistant's Messages\n\nNext, we need to process the response from the OpenAI API to check if it includes any function calls. If a function call is present, you should execute the corresponding function in your Worker. Note that the assistant may request multiple function calls.\n\nModify the fetch method within the `export default` block as follows:",
      "language": "unknown"
    },
    {
      "code": "Check if the assistant message contains any function calls by checking for the `tool_calls` property. Because the AI model can call multiple functions by default, you need to loop through any potential function calls and add them to the `messages` array. Each `read_website_content` call will invoke the `read_website_content` function you defined earlier and pass the URL generated by OpenAI as an argument. \\`\n\nThe `secondChatCompletion` is needed to provide a response informed by the data you retrieved from each function call. Now, the last step is to deploy your Worker.\n\nTest your code by running `npx wrangler dev` and open the provided url in your browser. This will now show you OpenAIâ€™s response using real-time information from the retrieved web data.\n\n## 5. Deploy your Worker application\n\nTo deploy your application, run the `npx wrangler deploy` command to deploy your Worker application:",
      "language": "unknown"
    },
    {
      "code": "You can now preview your Worker at `<YOUR_WORKER>.<YOUR_SUBDOMAIN>.workers.dev`. Going to this URL will display the response from OpenAI. Optionally, add the `message` URL parameter to write a custom message: for example, `https://<YOUR_WORKER>.<YOUR_SUBDOMAIN>.workers.dev/?message=What is the weather in NYC today?`.\n\n## 6. Next steps\n\nReference the [finished code for this tutorial on GitHub](https://github.com/LoganGrasby/Cloudflare-OpenAI-Functions-Demo/blob/main/src/worker.js).\n\nTo continue working with Workers and AI, refer to [the guide on using LangChain and Cloudflare Workers together](https://blog.cloudflare.com/langchain-and-cloudflare/) or [how to build a ChatGPT plugin with Cloudflare Workers](https://blog.cloudflare.com/magic-in-minutes-how-to-build-a-chatgpt-plugin-with-cloudflare-workers/).\n\nIf you have any questions, need assistance, or would like to share your project, join the Cloudflare Developer community on [Discord](https://discord.cloudflare.com) to connect with fellow developers and the Cloudflare team.\n\n</page>\n\n<page>\n---\ntitle: Connect to a PostgreSQL database with Cloudflare Workers Â· Cloudflare\n  Workers docs\ndescription: This tutorial explains how to connect to a Postgres database with\n  Cloudflare Workers. The Workers application you create in this tutorial will\n  interact with a product database inside of Postgres.\nlastUpdated: 2025-12-30T21:52:50.000Z\nchatbotDeprioritize: false\ntags: Postgres,TypeScript,SQL\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/postgres/\n  md: https://developers.cloudflare.com/workers/tutorials/postgres/index.md\n---\n\nIn this tutorial, you will learn how to create a Cloudflare Workers application and connect it to a PostgreSQL database using [TCP Sockets](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/) and [Hyperdrive](https://developers.cloudflare.com/hyperdrive/). The Workers application you create in this tutorial will interact with a product database inside of PostgreSQL.\n\n## Prerequisites\n\nTo continue:\n\n1. Sign up for a [Cloudflare account](https://dash.cloudflare.com/sign-up/workers-and-pages) if you have not already.\n2. Install [`npm`](https://docs.npmjs.com/getting-started).\n3. Install [`Node.js`](https://nodejs.org/en/). Use a Node version manager like [Volta](https://volta.sh/) or [nvm](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node.js versions. [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/) requires a Node version of `16.17.0` or later.\n4. Make sure you have access to a PostgreSQL database.\n\n## 1. Create a Worker application\n\nFirst, use the [`create-cloudflare` CLI](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare) to create a new Worker application. To do this, open a terminal window and run the following command:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "This will prompt you to install the [`create-cloudflare`](https://www.npmjs.com/package/create-cloudflare) package and lead you through a setup wizard.\n\nFor setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `TypeScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nIf you choose to deploy, you will be asked to authenticate (if not logged in already), and your project will be deployed. If you deploy, you can still modify your Worker code and deploy again at the end of this tutorial.\n\nNow, move into the newly created directory:",
      "language": "unknown"
    },
    {
      "code": "### Enable Node.js compatibility\n\n[Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) is required for database drivers, including Postgres.js, and needs to be configured for your Workers project.\n\nTo enable both built-in runtime APIs and polyfills for your Worker or Pages project, add the [`nodejs_compat`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag) [compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag) to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/), and set your compatibility date to September 23rd, 2024 or later. This will enable [Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) for your Workers project.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## 2. Add the PostgreSQL connection library\n\nTo connect to a PostgreSQL database, you will need the `pg` library. In your Worker application directory, run the following command to install the library:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Next, install the TypeScript types for the `pg` library to enable type checking and autocompletion in your TypeScript code:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Note\n\nMake sure you are using `pg` (`node-postgres`) version `8.16.3` or higher.\n\n## 3. Configure the connection to the PostgreSQL database\n\nChoose one of the two methods to connect to your PostgreSQL database:\n\n1. [Use a connection string](#use-a-connection-string).\n2. [Set explicit parameters](#set-explicit-parameters).\n\n### Use a connection string\n\nA connection string contains all the information needed to connect to a database. It is a URL that contains the following information:",
      "language": "unknown"
    },
    {
      "code": "Replace `username`, `password`, `host`, `port`, and `database` with the appropriate values for your PostgreSQL database.\n\nSet your connection string as a [secret](https://developers.cloudflare.com/workers/configuration/secrets/) so that it is not stored as plain text. Use [`wrangler secret put`](https://developers.cloudflare.com/workers/wrangler/commands/#secret) with the example variable name `DB_URL`:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "Set your `DB_URL` secret locally in a `.dev.vars` file as documented in [Local Development with Secrets](https://developers.cloudflare.com/workers/configuration/secrets/).",
      "language": "unknown"
    },
    {
      "code": "### Set explicit parameters\n\nConfigure each database parameter as an [environment variable](https://developers.cloudflare.com/workers/configuration/environment-variables/) via the [Cloudflare dashboard](https://developers.cloudflare.com/workers/configuration/environment-variables/#add-environment-variables-via-the-dashboard) or in your Wrangler file. Refer to an example of a Wrangler file configuration:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "To set your password as a [secret](https://developers.cloudflare.com/workers/configuration/secrets/) so that it is not stored as plain text, use [`wrangler secret put`](https://developers.cloudflare.com/workers/wrangler/commands/#secret). `DB_PASSWORD` is an example variable name for this secret to be accessed in your Worker:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## 4. Connect to the PostgreSQL database in the Worker\n\nOpen your Worker's main file (for example, `worker.ts`) and import the `Client` class from the `pg` library:",
      "language": "unknown"
    },
    {
      "code": "In the `fetch` event handler, connect to the PostgreSQL database using your chosen method, either the connection string or the explicit parameters.\n\n### Use a connection string",
      "language": "unknown"
    },
    {
      "code": "### Set explicit parameters",
      "language": "unknown"
    },
    {
      "code": "## 5. Interact with the products database\n\nTo demonstrate how to interact with the products database, you will fetch data from the `products` table by querying the table when a request is received.\n\nNote\n\nIf you are following along in your own PostgreSQL instance, set up the `products` using the following SQL `CREATE TABLE` statement. This statement defines the columns and their respective data types for the `products` table:",
      "language": "unknown"
    },
    {
      "code": "Replace the existing code in your `worker.ts` file with the following code:",
      "language": "unknown"
    },
    {
      "code": "This code establishes a connection to the PostgreSQL database within your Worker application and queries the `products` table, returning the results as a JSON response.\n\n## 6. Deploy your Worker\n\nRun the following command to deploy your Worker:",
      "language": "unknown"
    },
    {
      "code": "Your application is now live and accessible at `<YOUR_WORKER>.<YOUR_SUBDOMAIN>.workers.dev`.\n\nAfter deploying, you can interact with your PostgreSQL products database using your Cloudflare Worker. Whenever a request is made to your Worker's URL, it will fetch data from the `products` table and return it as a JSON response. You can modify the query as needed to retrieve the desired data from your products database.\n\n## 7. Insert a new row into the products database\n\nTo insert a new row into the `products` table, create a new API endpoint in your Worker that handles a `POST` request. When a `POST` request is received with a JSON payload, the Worker will insert a new row into the `products` table with the provided data.\n\nAssume the `products` table has the following columns: `id`, `name`, `description`, and `price`.\n\nAdd the following code snippet inside the `fetch` event handler in your `worker.ts` file, before the existing query code:",
      "language": "unknown"
    },
    {
      "code": "This code snippet does the following:\n\n1. Checks if the request is a `POST` request and the URL path is `/products`.\n2. Parses the JSON payload from the request.\n3. Constructs an `INSERT` SQL query using the provided product data.\n4. Executes the query, inserting the new row into the `products` table.\n5. Returns the inserted row as a JSON response.\n\nNow, when you send a `POST` request to your Worker's URL with the `/products` path and a JSON payload, the Worker will insert a new row into the `products` table with the provided data. When a request to `/` is made, the Worker will return all products in the database.\n\nAfter making these changes, deploy the Worker again by running:",
      "language": "unknown"
    },
    {
      "code": "You can now use your Cloudflare Worker to insert new rows into the `products` table. To test this functionality, send a `POST` request to your Worker's URL with the `/products` path, along with a JSON payload containing the new product data:",
      "language": "unknown"
    },
    {
      "code": "You have successfully created a Cloudflare Worker that connects to a PostgreSQL database and handles fetching data and inserting new rows into a products table.\n\n## 8. Use Hyperdrive to accelerate queries\n\nCreate a Hyperdrive configuration using the connection string for your PostgreSQL database.",
      "language": "unknown"
    },
    {
      "code": "This command outputs the Hyperdrive configuration `id` that will be used for your Hyperdrive [binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/). Set up your binding by specifying the `id` in the Wrangler file.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Create the types for your Hyperdrive binding using the following command:",
      "language": "unknown"
    },
    {
      "code": "Replace your existing connection string in your Worker code with the Hyperdrive connection string.",
      "language": "unknown"
    },
    {
      "code": "## 9. Redeploy your Worker\n\nRun the following command to deploy your Worker:",
      "language": "unknown"
    },
    {
      "code": "Your Worker application is now live and accessible at `<YOUR_WORKER>.<YOUR_SUBDOMAIN>.workers.dev`, using Hyperdrive. Hyperdrive accelerates database queries by pooling your connections and caching your requests across the globe.\n\n## Next steps\n\nTo build more with databases and Workers, refer to [Tutorials](https://developers.cloudflare.com/workers/tutorials) and explore the [Databases documentation](https://developers.cloudflare.com/workers/databases).\n\nIf you have any questions, need assistance, or would like to share your project, join the Cloudflare Developer community on [Discord](https://discord.cloudflare.com) to connect with fellow developers and the Cloudflare team.\n\n</page>\n\n<page>\n---\ntitle: Send Emails With Postmark Â· Cloudflare Workers docs\ndescription: This tutorial explains how to send transactional emails from\n  Workers using Postmark.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\ntags: JavaScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/send-emails-with-postmark/\n  md: https://developers.cloudflare.com/workers/tutorials/send-emails-with-postmark/index.md\n---\n\nIn this tutorial, you will learn how to send transactional emails from Workers using [Postmark](https://postmarkapp.com/). At the end of this tutorial, youâ€™ll be able to:\n\n* Create a Worker to send emails.\n* Sign up and add a Cloudflare domain to Postmark.\n* Send emails from your Worker using Postmark.\n* Store API keys securely with secrets.\n\n## Prerequisites\n\nTo continue with this tutorial, youâ€™ll need:\n\n* AÂ [Cloudflare account](https://dash.cloudflare.com/sign-up/workers-and-pages), if you donâ€™t already have one.\n* A [registered](https://developers.cloudflare.com/registrar/get-started/register-domain/) domain.\n* Installed [npm](https://docs.npmjs.com/getting-started).\n* A [Postmark account](https://account.postmarkapp.com/sign_up).\n\n## Create a Worker project\n\nStart by usingÂ [C3](https://developers.cloudflare.com/pages/get-started/c3/)Â to create a Worker project in the command line, then, answer the prompts:",
      "language": "unknown"
    },
    {
      "code": "Alternatively, you can use CLI arguments to speed things up:",
      "language": "unknown"
    },
    {
      "code": "This creates a simple hello-world Worker having the following content:",
      "language": "unknown"
    },
    {
      "code": "## Add your domain to Postmark\n\nIf you donâ€™t already have a Postmark account, you can sign up for a [free account here](https://account.postmarkapp.com/sign_up). After signing up, check your inbox for a link to confirm your sender signature. This verifies and enables you to send emails from your registered email address.\n\nTo enable email sending from other addresses on your domain, navigate to `Sender Signatures` on the Postmark dashboard, `Add Domain or Signature` > `Add Domain`, then type in your domain and click on `Verify Domain`.\n\nNext, youâ€™re presented with a list of DNS records to add to your Cloudflare domain. On your Cloudflare dashboard, select the domain you entered earlier and navigate to `DNS` > `Records`. Copy/paste the DNS records (DKIM, and Return-Path) from Postmark to your Cloudflare domain.\n\n![Image of adding DNS records to a Cloudflare domain](https://developers.cloudflare.com/_astro/add_dns_records.CuwqhmEV_Z7bni1.webp)\n\nNote\n\nIf you need more help adding DNS records in Cloudflare, refer to [Manage DNS records](https://developers.cloudflare.com/dns/manage-dns-records/how-to/create-dns-records/).\n\nWhen thatâ€™s done, head back to Postmark and click on the `Verify` buttons. If all records are properly configured, your domain status should be updated to `Verified`.\n\n![Image of domain verification on the Postmark dashboard](https://developers.cloudflare.com/_astro/verified_domain.CSwUI8xQ_ZtQUyG.webp)\n\nTo grab your API token, navigate to the `Servers` tab, then `My First Server` > `API Tokens`, then copy your API key to a safe place.\n\n## Send emails from your Worker\n\nThe final step is putting it all together in a Worker. In your Worker, make a post request with `fetch` to Postmarkâ€™s email API and include your token and message body:\n\nNote\n\n[Postmarkâ€™s JavaScript library](https://www.npmjs.com/package/postmark) is currently not supported on Workers. Use the [email API](https://postmarkapp.com/developer/user-guide/send-email-with-api) instead.",
      "language": "unknown"
    },
    {
      "code": "To test your code locally, run the following command and navigate to <http://localhost:8787/> in a browser:",
      "language": "unknown"
    },
    {
      "code": "Deploy your Worker with `npm run deploy`.\n\n## Move API token to Secrets\n\nSensitive information such as API keys and token should always be stored in secrets. All secrets are encrypted to add an extra layer of protection. That said, itâ€™s a good idea to move your API token to a secret and access it from the environment of your Worker.\n\nTo add secrets for local development, create a `.dev.vars` file which works exactly like a `.env` file:",
      "language": "unknown"
    },
    {
      "code": "Also ensure the secret is added to your deployed worker by running:",
      "language": "unknown"
    },
    {
      "code": "The added secret can be accessed on via the `env` parameter passed to your Workerâ€™s fetch event handler:",
      "language": "unknown"
    },
    {
      "code": "And finally, deploy this update with `npm run deploy`.\n\n## Related resources\n\n* [Storing API keys and tokens with Secrets](https://developers.cloudflare.com/workers/configuration/secrets/).\n* [Transferring your domain to Cloudflare](https://developers.cloudflare.com/registrar/get-started/transfer-domain-to-cloudflare/).\n* [Send emails from Workers](https://developers.cloudflare.com/email-routing/email-workers/send-email-workers/)\n\n</page>\n\n<page>\n---\ntitle: Send Emails With Resend Â· Cloudflare Workers docs\ndescription: This tutorial explains how to send emails from Cloudflare Workers using Resend.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\ntags: JavaScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/send-emails-with-resend/\n  md: https://developers.cloudflare.com/workers/tutorials/send-emails-with-resend/index.md\n---\n\nIn this tutorial, you will learn how to send transactional emails from Workers using [Resend](https://resend.com/). At the end of this tutorial, youâ€™ll be able to:\n\n* Create a Worker to send emails.\n* Sign up and add a Cloudflare domain to Resend.\n* Send emails from your Worker using Resend.\n* Store API keys securely with secrets.\n\n## Prerequisites\n\nTo continue with this tutorial, youâ€™ll need:\n\n* AÂ [Cloudflare account](https://dash.cloudflare.com/sign-up/workers-and-pages), if you donâ€™t already have one.\n* A [registered](https://developers.cloudflare.com/registrar/get-started/register-domain/) domain.\n* Installed [npm](https://docs.npmjs.com/getting-started).\n* A [Resend account](https://resend.com/signup).\n\n## Create a Worker project\n\nStart by usingÂ [C3](https://developers.cloudflare.com/pages/get-started/c3/)Â to create a Worker project in the command line, then, answer the prompts:",
      "language": "unknown"
    },
    {
      "code": "Alternatively, you can use CLI arguments to speed things up:",
      "language": "unknown"
    },
    {
      "code": "This creates a simple hello-world Worker having the following content:",
      "language": "unknown"
    },
    {
      "code": "## Add your domain to Resend\n\nIf you donâ€™t already have a Resend account, you can sign up for a [free account here](https://resend.com/signup). After signing up, go to `Domains` using the side menu, and click the button to add a new domain. On the modal, enter the domain you want to add and then select a region.\n\nNext, youâ€™re presented with a list of DNS records to add to your Cloudflare domain. On your Cloudflare dashboard, select the domain you entered earlier and navigate to `DNS` > `Records`. Copy/paste the DNS records (DKIM, SPF, and DMARC records) from Resend to your Cloudflare domain.\n\n![Image of adding DNS records to a Cloudflare domain](https://developers.cloudflare.com/_astro/add_dns_records.Brij3X2H_1MclQU.webp)\n\nNote\n\nIf you need more help adding DNS records in Cloudflare, refer to [Manage DNS records](https://developers.cloudflare.com/dns/manage-dns-records/how-to/create-dns-records/).\n\nWhen thatâ€™s done, head back to Resend and click on the `Verify DNS Records` button. If all records are properly configured, your domain status should be updated to `Verified`.\n\n![Image of domain verification on the Resend dashboard](https://developers.cloudflare.com/_astro/verified_domain.ouYLJaQl_Ay3g5.webp)\n\nLastly, navigate to `API Keys` with the side menu, to create an API key. Give your key a descriptive name and the appropriate permissions. Click the button to add your key and then copy your API key to a safe location.\n\n## Send emails from your Worker\n\nThe final step is putting it all together in a Worker. Open up a terminal in the directory of the Worker you created earlier. Then, install the Resend SDK:",
      "language": "unknown"
    },
    {
      "code": "In your Worker, import and use the Resend library like so:",
      "language": "unknown"
    },
    {
      "code": "To test your code locally, run the following command and navigate to <http://localhost:8787/> in a browser:",
      "language": "unknown"
    },
    {
      "code": "Deploy your Worker with `npm run deploy`.\n\n## Move API keys to Secrets\n\nSensitive information such as API keys and token should always be stored in secrets. All secrets are encrypted to add an extra layer of protection. That said, itâ€™s a good idea to move your API key to a secret and access it from the environment of your Worker.\n\nTo add secrets for local development, create a `.dev.vars` file which works exactly like a `.env` file:",
      "language": "unknown"
    },
    {
      "code": "Also ensure the secret is added to your deployed worker by running:",
      "language": "unknown"
    },
    {
      "code": "The added secret can be accessed on via the `env` parameter passed to your Workerâ€™s fetch event handler:",
      "language": "unknown"
    },
    {
      "code": "And finally, deploy this update with `npm run deploy`.\n\n## Related resources\n\n* [Storing API keys and tokens with Secrets](https://developers.cloudflare.com/workers/configuration/secrets/).\n* [Transferring your domain to Cloudflare](https://developers.cloudflare.com/registrar/get-started/transfer-domain-to-cloudflare/).\n* [Send emails from Workers](https://developers.cloudflare.com/email-routing/email-workers/send-email-workers/)\n\n</page>\n\n<page>\n---\ntitle: Securely access and upload assets with Cloudflare R2 Â· Cloudflare Workers docs\ndescription: This tutorial explains how to create a TypeScript-based Cloudflare\n  Workers project that can securely access files from and upload files to a\n  CloudFlare R2 bucket.\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/upload-assets-with-r2/\n  md: https://developers.cloudflare.com/workers/tutorials/upload-assets-with-r2/index.md\n---\n\nThis tutorial explains how to create a TypeScript-based Cloudflare Workers project that can securely access files from and upload files to a [Cloudflare R2](https://developers.cloudflare.com/r2/) bucket. Cloudflare R2 allows developers to store large amounts of unstructured data without the costly egress bandwidth fees associated with typical cloud storage services.\n\n## Prerequisites\n\nTo continue:\n\n1. Sign up for a [Cloudflare account](https://dash.cloudflare.com/sign-up/workers-and-pages) if you have not already.\n2. Install [`npm`](https://docs.npmjs.com/getting-started).\n3. Install [`Node.js`](https://nodejs.org/en/). Use a Node version manager like [Volta](https://volta.sh/) or [nvm](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node.js versions. [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/) requires a Node version of `16.17.0` or later.\n\n## Create a Worker application\n\nFirst, use the [`create-cloudflare` CLI](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare) to create a new Worker. To do this, open a terminal window and run the following command:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `TypeScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nMove into your newly created directory:",
      "language": "unknown"
    },
    {
      "code": "## Create an R2 bucket\n\nBefore you integrate R2 bucket access into your Worker application, an R2 bucket must be created:",
      "language": "unknown"
    },
    {
      "code": "Replace `<YOUR_BUCKET_NAME>` with the name you want to assign to your bucket. List your account's R2 buckets to verify that a new bucket has been added:",
      "language": "unknown"
    },
    {
      "code": "## Configure access to an R2 bucket\n\nAfter your new R2 bucket is ready, use it inside your Worker application.\n\nUse your R2 bucket inside your Worker project by modifying the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) to include an R2 bucket [binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/). Add the following R2 bucket binding to your Wrangler file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Give your R2 bucket binding name. Replace `<YOUR_BUCKET_NAME>` with the name of the R2 bucket you created earlier.\n\nYour Worker application can now access your R2 bucket using the `MY_BUCKET` variable. You can now perform CRUD (Create, Read, Update, Delete) operations on the contents of the bucket.\n\n## Fetch from an R2 bucket\n\nAfter setting up an R2 bucket binding, you will implement the functionalities for the Worker to interact with the R2 bucket, such as, fetching files from the bucket and uploading files to the bucket.\n\nTo fetch files from the R2 bucket, use the `BINDING.get` function. In the below example, the R2 bucket binding is called `MY_BUCKET`. Using `.get(key)`, you can retrieve an asset based on the URL pathname as the key. In this example, the URL pathname is `/image.png`, and the asset key is `image.png`.",
      "language": "unknown"
    },
    {
      "code": "The code written above fetches and returns data from the R2 bucket when a `GET` request is made to the Worker application using a specific URL path.\n\n## Upload securely to an R2 bucket\n\nNext, you will add the ability to upload to your R2 bucket using authentication. To securely authenticate your upload requests, use [Wrangler's secret capability](https://developers.cloudflare.com/workers/wrangler/commands/#secret). Wrangler was installed when you ran the `create cloudflare@latest` command.\n\nCreate a secret value of your choice -- for instance, a random string or password. Using the Wrangler CLI, add the secret to your project as `AUTH_SECRET`:",
      "language": "unknown"
    },
    {
      "code": "Now, add a new code path that handles a `PUT` HTTP request. This new code will check that the previously uploaded secret is correctly used for authentication, and then upload to R2 using `MY_BUCKET.put(key, data)`:",
      "language": "unknown"
    },
    {
      "code": "This approach ensures that only clients who provide a valid bearer token, via the `Authorization` header equal to the `AUTH_SECRET` value, will be permitted to upload to the R2 bucket. If you used a different binding name than `AUTH_SECRET`, replace it in the code above.\n\n## Deploy your Worker application\n\nAfter completing your Cloudflare Worker project, deploy it to Cloudflare. Make sure you are in your Worker application directory that you created for this tutorial, then run:",
      "language": "unknown"
    },
    {
      "code": "Your application is now live and accessible at `<YOUR_WORKER>.<YOUR_SUBDOMAIN>.workers.dev`.\n\nYou have successfully created a Cloudflare Worker that allows you to interact with an R2 bucket to accomplish tasks such as uploading and downloading files. You can now use this as a starting point for your own projects.\n\n## Next steps\n\nTo build more with R2 and Workers, refer to [Tutorials](https://developers.cloudflare.com/workers/tutorials/) and the [R2 documentation](https://developers.cloudflare.com/r2/).\n\nIf you have any questions, need assistance, or would like to share your project, join the Cloudflare Developer community on [Discord](https://discord.cloudflare.com) to connect with fellow developers and the Cloudflare team.\n\n</page>\n\n<page>\n---\ntitle: Set up and use a Prisma Postgres database Â· Cloudflare Workers docs\ndescription: This tutorial shows you how to set up a Cloudflare Workers project\n  with Prisma ORM.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\ntags: TypeScript,SQL,Prisma ORM,Postgres\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/using-prisma-postgres-with-workers/\n  md: https://developers.cloudflare.com/workers/tutorials/using-prisma-postgres-with-workers/index.md\n---\n\n[Prisma Postgres](https://www.prisma.io/postgres) is a managed, serverless PostgreSQL database. It supports features like connection pooling, caching, real-time subscriptions, and query optimization recommendations.\n\nIn this tutorial, you will learn how to:\n\n* Set up a Cloudflare Workers project with [Prisma ORM](https://www.prisma.io/docs).\n* Create a Prisma Postgres instance from the Prisma CLI.\n* Model data and run migrations with Prisma Postgres.\n* Query the database from Workers.\n* Deploy the Worker to Cloudflare.\n\n## Prerequisites\n\nTo follow this guide, ensure you have the following:\n\n* Node.js `v18.18` or higher installed.\n* An active [Cloudflare account](https://dash.cloudflare.com/).\n* A basic familiarity with installing and using command-line interface (CLI) applications.\n\n## 1. Create a new Worker project\n\nBegin by using [C3](https://developers.cloudflare.com/pages/get-started/c3/) to create a Worker project in the command line:",
      "language": "unknown"
    },
    {
      "code": "Then navigate into your project:",
      "language": "unknown"
    },
    {
      "code": "Your initial `src/index.ts` file currently contains a simple request handler:",
      "language": "unknown"
    },
    {
      "code": "## 2. Setup Prisma in your project\n\nIn this step, you will set up Prisma ORM with a Prisma Postgres database using the CLI. Then you will create and execute helper scripts to create tables in the database and generate a Prisma client to query it.\n\n### 2.1. Install required dependencies\n\nInstall Prisma CLI as a dev dependency:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Install the [Prisma Accelerate client extension](https://www.npmjs.com/package/@prisma/extension-accelerate) as it is required for Prisma Postgres:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Install the [`dotenv-cli` package](https://www.npmjs.com/package/dotenv-cli) to load environment variables from `.dev.vars`:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "### 2.2. Create a Prisma Postgres database and initialize Prisma\n\nInitialize Prisma in your application:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "If you do not have a [Prisma Data Platform](https://console.prisma.io/) account yet, or if you are not logged in, the command will prompt you to log in using one of the available authentication providers. A browser window will open so you can log in or create an account. Return to the CLI after you have completed this step.\n\nOnce logged in (or if you were already logged in), the CLI will prompt you to select a project name and a database region.\n\nOnce the command has terminated, it will have created:\n\n* A project in your [Platform Console](https://console.prisma.io/) containing a Prisma Postgres database instance.\n* A `prisma` folder containing `schema.prisma`, where you will define your database schema.\n* An `.env` file in the project root, which will contain the Prisma Postgres database url `DATABASE_URL=<your-prisma-postgres-database-url>`.\n\nNote that Cloudflare Workers do not support `.env` files. You will use a file called `.dev.vars` instead of the `.env` file that was just created.\n\n### 2.3. Prepare environment variables\n\nRename the `.env` file in the root of your application to `.dev.vars` file:",
      "language": "unknown"
    },
    {
      "code": "### 2.4. Apply database schema changes\n\nOpen the `schema.prisma` file in the `prisma` folder and add the following `User` model to your database:",
      "language": "unknown"
    },
    {
      "code": "Next, add the following helper scripts to the `scripts` section of your `package.json`:",
      "language": "unknown"
    },
    {
      "code": "Run the migration script to apply changes to the database:",
      "language": "unknown"
    },
    {
      "code": "When prompted, provide a name for the migration (for example, `init`).\n\nAfter these steps are complete, Prisma ORM is fully set up and connected to your Prisma Postgres database.\n\n## 3. Develop the application\n\nModify the `src/index.ts` file and replace its contents with the following code:",
      "language": "unknown"
    },
    {
      "code": "Run the development server:",
      "language": "unknown"
    },
    {
      "code": "Visit [`https://localhost:8787`](https://localhost:8787) to see your app display the following output:",
      "language": "unknown"
    },
    {
      "code": "Every time you refresh the page, a new user is created. The number displayed will increment by `1` with each refresh as it returns the total number of users in your database.\n\n## 4. Deploy the application to Cloudflare\n\nWhen the application is deployed to Cloudflare, it needs access to the `DATABASE_URL` environment variable that is defined locally in `.dev.vars`. You can use the [`npx wrangler secret put`](https://developers.cloudflare.com/workers/configuration/secrets/#adding-secrets-to-your-project) command to upload the `DATABASE_URL` to the deployment environment:",
      "language": "unknown"
    },
    {
      "code": "When prompted, paste the `DATABASE_URL` value (from `.dev.vars`). If you are logged in via the Wrangler CLI, you will see a prompt asking if you'd like to create a new Worker. Confirm by choosing \"yes\":",
      "language": "unknown"
    },
    {
      "code": "Then execute the following command to deploy your project to Cloudflare Workers:",
      "language": "unknown"
    },
    {
      "code": "The `wrangler` CLI will bundle and upload your application.\n\nIf you are not already logged in, the `wrangler` CLI will open a browser window prompting you to log in to the Cloudflare dashboard.\n\nNote\n\nIf you belong to multiple accounts, select the account where you want to deploy the project.\n\nOnce the deployment completes, verify the deployment by visiting the live URL provided in the deployment output, such as `https://{PROJECT_NAME}.workers.dev`. If you encounter any issues, ensure the secrets were added correctly and check the deployment logs for errors.\n\n## Next steps\n\nCongratulations on building and deploying a simple application with Prisma Postgres and Cloudflare Workers!\n\nTo enhance your application further:\n\n* Add [caching](https://www.prisma.io/docs/postgres/caching) to your queries.\n* Explore the [Prisma Postgres documentation](https://www.prisma.io/docs/postgres/getting-started).\n\nTo see how to build a real-time application with Cloudflare Workers and Prisma Postgres, read [this](https://www.prisma.io/docs/guides/prisma-postgres-realtime-on-cloudflare) guide.\n\n</page>\n\n<page>\n---\ntitle: Use Workers KV directly from Rust Â· Cloudflare Workers docs\ndescription: This tutorial will teach you how to read and write to KV directly\n  from Rust using workers-rs. You will use Workers KV from Rust to build an app\n  to store and retrieve cities.\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/workers-kv-from-rust/\n  md: https://developers.cloudflare.com/workers/tutorials/workers-kv-from-rust/index.md\n---\n\nThis tutorial will teach you how to read and write to KV directly from Rust using [workers-rs](https://github.com/cloudflare/workers-rs).\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## Prerequisites\n\nTo complete this tutorial, you will need:\n\n* [Git](https://git-scm.com/book/en/v2/Getting-Started-Installing-Git).\n* [Wrangler](https://developers.cloudflare.com/workers/wrangler/) CLI.\n* The [Rust](https://www.rust-lang.org/tools/install) toolchain.\n* And `cargo-generate` sub-command by running:",
      "language": "unknown"
    },
    {
      "code": "## 1. Create your Worker project in Rust\n\nOpen a terminal window, and run the following command to generate a Worker project template in Rust:",
      "language": "unknown"
    },
    {
      "code": "Then select `template/hello-world-http` template, give your project a descriptive name and select enter. A new project should be created in your directory. Open the project in your editor and run `npx wrangler dev` to compile and run your project.\n\nIn this tutorial, you will use Workers KV from Rust to build an app to store and retrieve cities by a given country name.\n\n## 2. Create a KV namespace\n\nIn the terminal, use Wrangler to create a KV namespace for `cities`. This generates a configuration to be added to the project:",
      "language": "unknown"
    },
    {
      "code": "To add this configuration to your project, open the Wrangler file and create an entry for `kv_namespaces` above the build command:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "With this configured, you can access the KV namespace with the binding `\"cities\"` from Rust.\n\n## 3. Write data to KV\n\nFor this app, you will create two routes: A `POST` route to receive and store the city in KV, and a `GET` route to retrieve the city of a given country. For example, a `POST` request to `/France` with a body of `{\"city\": \"Paris\"}` should create an entry of Paris as a city in France. A `GET` request to `/France` should retrieve from KV and respond with Paris.\n\nInstall [Serde](https://serde.rs/) as a project dependency to handle JSON `cargo add serde`. Then create an app router and a struct for `Country` in `src/lib.rs`:",
      "language": "unknown"
    },
    {
      "code": "For the post handler, you will retrieve the country name from the path and the city name from the request body. Then, you will save this in KV with the country as key and the city as value. Finally, the app will respond with the city name:",
      "language": "unknown"
    },
    {
      "code": "Save the file and make a `POST` request to test this endpoint:",
      "language": "unknown"
    },
    {
      "code": "## 4. Read data from KV\n\nTo retrieve cities stored in KV, write a `GET` route that pulls the country name from the path and searches KV. You also need some error handling if the country is not found:",
      "language": "unknown"
    },
    {
      "code": "Save and make a curl request to test the endpoint:",
      "language": "unknown"
    },
    {
      "code": "## 5. Deploy your project\n\nThe source code for the completed app should include the following:",
      "language": "unknown"
    },
    {
      "code": "To deploy your Worker, run the following command:",
      "language": "unknown"
    },
    {
      "code": "## Related resources\n\n* [Rust support in Workers](https://developers.cloudflare.com/workers/languages/rust/).\n* [Using KV in Workers](https://developers.cloudflare.com/kv/get-started/).\n\n</page>\n\n<page>\n---\ntitle: Get started Â· Cloudflare Workers docs\ndescription: Get started with the Vite plugin\nlastUpdated: 2025-10-29T21:32:51.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/vite-plugin/get-started/\n  md: https://developers.cloudflare.com/workers/vite-plugin/get-started/index.md\n---\n\nNote\n\nThis guide demonstrates creating a standalone Worker from scratch. If you would instead like to create a new application from a ready-to-go template, refer to the [TanStack Start](https://developers.cloudflare.com/workers/framework-guides/web-apps/tanstack-start/), [React Router](https://developers.cloudflare.com/workers/framework-guides/web-apps/react-router/), [React](https://developers.cloudflare.com/workers/framework-guides/web-apps/react/) or [Vue](https://developers.cloudflare.com/workers/framework-guides/web-apps/vue/) framework guides.\n\n## Start with a basic `package.json`",
      "language": "unknown"
    },
    {
      "code": "Note\n\nEnsure that you include `\"type\": \"module\"` in order to use ES modules by default.\n\n## Install the dependencies\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "## Create your Vite config file and include the Cloudflare plugin",
      "language": "unknown"
    },
    {
      "code": "The Cloudflare Vite plugin doesn't require any configuration by default and will look for a `wrangler.jsonc`, `wrangler.json` or `wrangler.toml` in the root of your application.\n\nRefer to the [API reference](https://developers.cloudflare.com/workers/vite-plugin/reference/api/) for configuration options.\n\n## Create your Worker config file\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "The `name` field specifies the name of your Worker. By default, this is also used as the name of the Worker's Vite Environment (see [Vite Environments](https://developers.cloudflare.com/workers/vite-plugin/reference/vite-environments/) for more information). The `main` field specifies the entry file for your Worker code.\n\nFor more information about the Worker configuration, see [Configuration](https://developers.cloudflare.com/workers/wrangler/configuration/).\n\n## Create your Worker entry file",
      "language": "unknown"
    },
    {
      "code": "A request to this Worker will return **'Running in Cloudflare-Workers!'**, demonstrating that the code is running inside the Workers runtime.\n\n## Dev, build, preview and deploy\n\nYou can now start the Vite development server (`npm run dev`), build the application (`npm run build`), preview the built application (`npm run preview`), and deploy to Cloudflare (`npm run deploy`).\n\n</page>\n\n<page>\n---\ntitle: Reference Â· Cloudflare Workers docs\nlastUpdated: 2025-04-04T07:52:43.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/workers/vite-plugin/reference/\n  md: https://developers.cloudflare.com/workers/vite-plugin/reference/index.md\n---\n\n* [API](https://developers.cloudflare.com/workers/vite-plugin/reference/api/)\n* [Static Assets](https://developers.cloudflare.com/workers/vite-plugin/reference/static-assets/)\n* [Debugging](https://developers.cloudflare.com/workers/vite-plugin/reference/debugging/)\n* [Migrating from wrangler dev](https://developers.cloudflare.com/workers/vite-plugin/reference/migrating-from-wrangler-dev/)\n* [Secrets](https://developers.cloudflare.com/workers/vite-plugin/reference/secrets/)\n* [Vite Environments](https://developers.cloudflare.com/workers/vite-plugin/reference/vite-environments/)\n* [Cloudflare Environments](https://developers.cloudflare.com/workers/vite-plugin/reference/cloudflare-environments/)\n* [Programmatic configuration](https://developers.cloudflare.com/workers/vite-plugin/reference/programmatic-configuration/)\n\n</page>\n\n<page>\n---\ntitle: Tutorial - React SPA with an API Â· Cloudflare Workers docs\ndescription: Create a React SPA with an API Worker using the Vite plugin\nlastUpdated: 2025-07-01T10:19:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/vite-plugin/tutorial/\n  md: https://developers.cloudflare.com/workers/vite-plugin/tutorial/index.md\n---\n\nThis tutorial takes you through the steps needed to adapt a Vite project to use the Cloudflare Vite plugin. Much of the content can also be applied to adapting existing Vite projects and to front-end frameworks other than React.\n\nNote\n\nIf you want to start a new app with a template already set up with Vite, React and the Cloudflare Vite plugin, refer to the [React framework guide](https://developers.cloudflare.com/workers/framework-guides/web-apps/react/). To create a standalone Worker, refer to [Get started](https://developers.cloudflare.com/workers/vite-plugin/get-started/).\n\n## Introduction\n\nIn this tutorial, you will create a React SPA that can be deployed as a Worker with static assets. You will then add an API Worker that can be accessed from the front-end code. You will develop, build, and preview the application using Vite before finally deploying to Cloudflare.\n\n## Set up and configure the React SPA\n\n### Scaffold a Vite project\n\nStart by creating a React TypeScript project with Vite.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Next, open the `cloudflare-vite-tutorial` directory in your editor of choice.\n\n### Add the Cloudflare dependencies\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "### Add the plugin to your Vite config",
      "language": "unknown"
    },
    {
      "code": "The Cloudflare Vite plugin doesn't require any configuration by default and will look for a `wrangler.jsonc`, `wrangler.json` or `wrangler.toml` in the root of your application.\n\nRefer to the [API reference](https://developers.cloudflare.com/workers/vite-plugin/reference/api/) for configuration options.\n\n### Create your Worker config file\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "The [`not_found_handling`](https://developers.cloudflare.com/workers/static-assets/routing/single-page-application/) value has been set to `single-page-application`. This means that all not found requests will serve the `index.html` file. With the Cloudflare plugin, the `assets` routing configuration is used in place of Vite's default behavior. This ensures that your application's [routing configuration](https://developers.cloudflare.com/workers/static-assets/routing/) works the same way while developing as it does when deployed to production.\n\nNote that the [`directory`](https://developers.cloudflare.com/workers/static-assets/binding/#directory) field is not used when configuring assets with Vite. The `directory` in the output configuration will automatically point to the client build output. See [Static Assets](https://developers.cloudflare.com/workers/vite-plugin/reference/static-assets/) for more information.\n\nNote\n\nWhen using the Cloudflare Vite plugin, the Worker config (for example, `wrangler.jsonc`) that you provide is the input configuration file. A separate output `wrangler.json` file is created when you run `vite build`. This output file is a snapshot of your configuration at the time of the build and is modified to reference your build artifacts. It is the configuration that is used for preview and deployment.\n\n### Update the .gitignore file\n\nWhen developing Workers, additional files are used and/or generated that should not be stored in git. Add the following lines to your `.gitignore` file:",
      "language": "unknown"
    },
    {
      "code": "### Run the development server\n\nRun `npm run dev` to start the Vite development server and verify that your application is working as expected.\n\nFor a purely front-end application, you could now build (`npm run build`), preview (`npm run preview`), and deploy (`npm exec wrangler deploy`) your application. This tutorial, however, will show you how to go a step further and add an API Worker.\n\n## Add an API Worker\n\n### Configure TypeScript for your Worker code\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### Add to your Worker configuration\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "The `main` field specifies the entry file for your Worker code.\n\n### Add your API Worker",
      "language": "unknown"
    },
    {
      "code": "The Worker above will be invoked for any non-navigation request that does not match a static asset. It returns a JSON response if the `pathname` starts with `/api/` and otherwise return a `404` response.\n\nNote\n\nFor top-level navigation requests, browsers send a `Sec-Fetch-Mode: navigate` header. If this is present and the URL does not match a static asset, the `not_found_handling` behavior will be invoked rather than the Worker. This implicit routing is the default behavior.\n\nIf you would instead like to define the routes that invoke your Worker explicitly, you can provide an array of route patterns to [`run_worker_first`](https://developers.cloudflare.com/workers/static-assets/binding/#run_worker_first). This opts out of interpreting the `Sec-Fetch-Mode` header.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "### Call the API from the client\n\nEdit `src/App.tsx` so that it includes an additional button that calls the API and sets some state:",
      "language": "unknown"
    },
    {
      "code": "Now, if you click the button, it will display 'Name from API is: Cloudflare'.\n\nIncrement the counter to update the application state in the browser. Next, edit `api/index.ts` by changing the `name` it returns to `'Cloudflare Workers'`. If you click the button again, it will display the new `name` while preserving the previously set counter value.\n\nWith Vite and the Cloudflare plugin, you can iterate on the client and server parts of your app together, without losing UI state between edits.\n\n### Build your application\n\nRun `npm run build` to build your application.",
      "language": "unknown"
    },
    {
      "code": "If you inspect the `dist` directory, you will see that it contains two subdirectories:\n\n* `client` - the client code that runs in the browser\n* `cloudflare-vite-tutorial` - the Worker code alongside the output `wrangler.json` configuration file\n\n### Preview your application\n\nRun `npm run preview` to validate that your application runs as expected.",
      "language": "unknown"
    },
    {
      "code": "This command will run your build output locally in the Workers runtime, closely matching its behaviour in production.\n\n### Deploy to Cloudflare\n\nRun `npm exec wrangler deploy` to deploy your application to Cloudflare.",
      "language": "unknown"
    },
    {
      "code": "This command will automatically use the output `wrangler.json` that was included in the build output.\n\n## Next steps\n\nIn this tutorial, we created an SPA that could be deployed as a Worker with static assets. We then added an API Worker that could be accessed from the front-end code. Finally, we deployed both the client and server-side parts of the application to Cloudflare.\n\nPossible next steps include:\n\n* Adding a binding to another Cloudflare service such as a [KV namespace](https://developers.cloudflare.com/kv/) or [D1 database](https://developers.cloudflare.com/d1/)\n* Expanding the API to include additional routes\n* Using a library, such as [Hono](https://hono.dev/) or [tRPC](https://trpc.io/), in your API Worker\n\n</page>\n\n<page>\n---\ntitle: API Â· Cloudflare Workers docs\ndescription: A set of programmatic APIs that can be integrated with local\n  Cloudflare Workers-related workflows.\nlastUpdated: 2025-06-20T17:22:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/wrangler/api/\n  md: https://developers.cloudflare.com/workers/wrangler/api/index.md\n---\n\nWrangler offers APIs to programmatically interact with your Cloudflare Workers.\n\n* [`unstable_startWorker`](#unstable_startworker) - Start a server for running integration tests against your Worker.\n* [`unstable_dev`](#unstable_dev) - Start a server for running either end-to-end (e2e) or integration tests against your Worker.\n* [`getPlatformProxy`](#getplatformproxy) - Get proxies and values for emulating the Cloudflare Workers platform in a Node.js process.\n\n## `unstable_startWorker`\n\nThis API exposes the internals of Wrangler's dev server, and allows you to customise how it runs. For example, you could use `unstable_startWorker()` to run integration tests against your Worker. This example uses `node:test`, but should apply to any testing framework:",
      "language": "unknown"
    },
    {
      "code": "## `unstable_dev`\n\nStart an HTTP server for testing your Worker.\n\nOnce called, `unstable_dev` will return a `fetch()` function for invoking your Worker without needing to know the address or port, as well as a `stop()` function to shut down the HTTP server.\n\nBy default, `unstable_dev` will perform integration tests against a local server. If you wish to perform an e2e test against a preview Worker, pass `local: false` in the `options` object when calling the `unstable_dev()` function. Note that e2e tests can be significantly slower than integration tests.\n\nNote\n\nThe `unstable_dev()` function has an `unstable_` prefix because the API is experimental and may change in the future. We recommend migrating to the `unstable_startWorker()` API, documented above.\n\nIf you have been using `unstable_dev()` for integration testing and want to migrate to Cloudflare's Vitest integration, refer to the [Migrate from `unstable_dev` migration guide](https://developers.cloudflare.com/workers/testing/vitest-integration/migration-guides/migrate-from-unstable-dev/) for more information.\n\n### Constructor",
      "language": "unknown"
    },
    {
      "code": "### Parameters\n\n* `script` string\n\n  * A string containing a path to your Worker script, relative to your Worker project's root directory.\n\n* `options` object optional\n\n  * Optional options object containing `wrangler dev` configuration settings.\n  * Include an `experimental` object inside `options` to access experimental features such as `disableExperimentalWarning`.\n    * Set `disableExperimentalWarning` to `true` to disable Wrangler's warning about using `unstable_` prefixed APIs.\n\n### Return Type\n\n`unstable_dev()` returns an object containing the following methods:\n\n* `fetch()` `Promise<Response>`\n\n  * Send a request to your Worker. Returns a Promise that resolves with a [`Response`](https://developers.cloudflare.com/workers/runtime-apis/response) object.\n  * Refer to [`Fetch`](https://developers.cloudflare.com/workers/runtime-apis/fetch/).\n\n* `stop()` `Promise<void>`\n\n  * Shuts down the dev server.\n\n### Usage\n\nWhen initiating each test suite, use a `beforeAll()` function to start `unstable_dev()`. The `beforeAll()` function is used to minimize overhead: starting the dev server takes a few hundred milliseconds, starting and stopping for each individual test adds up quickly, slowing your tests down.\n\nIn each test case, call `await worker.fetch()`, and check that the response is what you expect.\n\nTo wrap up a test suite, call `await worker.stop()` in an `afterAll` function.\n\n#### Single Worker example\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "#### Multi-Worker example\n\nYou can test Workers that call other Workers. In the below example, we refer to the Worker that calls other Workers as the parent Worker, and the Worker being called as a child Worker.\n\nIf you shut down the child Worker prematurely, the parent Worker will not know the child Worker exists and your tests will fail.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "## `getPlatformProxy`\n\nThe `getPlatformProxy` function provides a way to obtain an object containing proxies (to **local** `workerd` bindings) and emulations of Cloudflare Workers specific values, allowing the emulation of such in a Node.js process.\n\nWarning\n\n`getPlatformProxy` is, by design, to be used exclusively in Node.js applications. `getPlatformProxy` cannot be run inside the Workers runtime.\n\nOne general use case for getting a platform proxy is for emulating bindings in applications targeting Workers, but running outside the Workers runtime (for example, framework local development servers running in Node.js), or for testing purposes (for example, ensuring code properly interacts with a type of binding).\n\nNote\n\nBinding proxies provided by this function are a best effort emulation of the real production bindings. Although they are designed to be as close as possible to the real thing, there might be slight differences and inconsistencies between the two.\n\n### Syntax",
      "language": "unknown"
    },
    {
      "code": "### Parameters\n\n* `options` object optional\n\n  * Optional options object containing preferences for the bindings:\n\n    * `environment` string\n\n      The environment to use.\n\n    * `configPath` string\n\n      The path to the config file to use.\n\n      If no path is specified, the default behavior is to search from the current directory up the filesystem for a [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) to use.\n\n      **Note:** this field is optional but if a path is specified it must point to a valid file on the filesystem.\n\n    * `persist` boolean | `{ path: string }`\n\n      Indicates if and where to persist the bindings data. If `true` or `undefined`, defaults to the same location used by Wrangler, so data can be shared between it and the caller. If `false`, no data is persisted to or read from the filesystem.\n\n      **Note:** If you use `wrangler`'s `--persist-to` option, note that this option adds a subdirectory called `v3` under the hood while `getPlatformProxy`'s `persist` does not. For example, if you run `wrangler dev --persist-to ./my-directory`, to reuse the same location using `getPlatformProxy`, you will have to specify: `persist: { path: \"./my-directory/v3\" }`.\n\n    * `experimental` `{ remoteBindings: boolean }`\n\n      Object used to enable experimental features, no guarantees are made to the stability of this API, use at your own risk.\n\n      * `remoteBindings` Enables `getPlatformProxy` to connect to [remote bindings](https://developers.cloudflare.com/workers/development-testing/#remote-bindings).\n\n### Return Type\n\n`getPlatformProxy()` returns a `Promise` resolving to an object containing the following fields.\n\n* `env` `Record<string, unknown>`\n\n  * Object containing proxies to bindings that can be used in the same way as production bindings. This matches the shape of the `env` object passed as the second argument to modules-format workers. These proxy to binding implementations run inside `workerd`.\n  * TypeScript Tip: `getPlatformProxy<Env>()` is a generic function. You can pass the shape of the bindings record as a type argument to get proper types without `unknown` values.\n\n* `cf` IncomingRequestCfProperties read-only\n\n  * Mock of the `Request`'s `cf` property, containing data similar to what you would see in production.\n\n* `ctx` object\n\n  * Mock object containing implementations of the [`waitUntil`](https://developers.cloudflare.com/workers/runtime-apis/context/#waituntil) and [`passThroughOnException`](https://developers.cloudflare.com/workers/runtime-apis/context/#passthroughonexception) functions that do nothing.\n\n* `caches` object\n\n  * Emulation of the [Workers `caches` runtime API](https://developers.cloudflare.com/workers/runtime-apis/cache/).\n  * For the time being, all cache operations do nothing. A more accurate emulation will be made available soon.\n\n* `dispose()` () => `Promise<void>`\n\n  * Terminates the underlying `workerd` process.\n  * Call this after the platform proxy is no longer required by the program. If you are running a long running process (such as a dev server) that can indefinitely make use of the proxy, you do not need to call this function.\n\n### Usage\n\nThe `getPlatformProxy` function uses bindings found in the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). For example, if you have an [environment variable](https://developers.cloudflare.com/workers/configuration/environment-variables/#add-environment-variables-via-wrangler) configuration set up in the Wrangler configuration file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "You can access the bindings by importing `getPlatformProxy` like this:",
      "language": "unknown"
    },
    {
      "code": "To access the value of the `MY_VARIABLE` binding add the following to your code:",
      "language": "unknown"
    },
    {
      "code": "This will print the following output: `MY_VARIABLE = test`.\n\n### Supported bindings\n\nAll supported bindings found in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) are available to you via `env`.\n\nThe bindings supported by `getPlatformProxy` are:\n\n* [Environment variables](https://developers.cloudflare.com/workers/configuration/environment-variables/)\n\n* [Service bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/)\n\n* [KV namespace bindings](https://developers.cloudflare.com/kv/api/)\n\n* [R2 bucket bindings](https://developers.cloudflare.com/r2/api/workers/workers-api-reference/)\n\n* [Queue bindings](https://developers.cloudflare.com/queues/configuration/javascript-apis/)\n\n* [D1 database bindings](https://developers.cloudflare.com/d1/worker-api/)\n\n* [Hyperdrive bindings](https://developers.cloudflare.com/hyperdrive)\n\n  Hyperdrive values are simple passthrough ones\n\n  Values provided by hyperdrive bindings such as `connectionString` and `host` do not have a valid meaning outside of a `workerd` process. This means that Hyperdrive proxies return passthrough values, which are values corresponding to the database connection provided by the user. Otherwise, it would return values which would be unusable from within node.js.\n\n* [Workers AI bindings](https://developers.cloudflare.com/workers-ai/get-started/workers-wrangler/#2-connect-your-worker-to-workers-ai)\n\n  Workers AI local development usage charges\n\n  Using Workers AI always accesses your Cloudflare account in order to run AI models and will incur usage charges even in local development.\n\n* [Durable Object bindings](https://developers.cloudflare.com/durable-objects/api/)\n\n  * To use a Durable Object binding with `getPlatformProxy`, always specify a [`script_name`](https://developers.cloudflare.com/workers/wrangler/configuration/#durable-objects).\n\n    For example, you might have the following binding in a Wrangler configuration file read by `getPlatformProxy`.\n\n    * wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "You will need to declare your Durable Object `\"MyDurableObject\"` in another Worker, called `external-do-worker` in this example.",
      "language": "unknown"
    },
    {
      "code": "That Worker also needs a Wrangler configuration file that looks like this:\n\n    * wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "If you are not using RPC with your Durable Object, you can run a separate Wrangler dev session alongside your framework development server.\n\n    Otherwise, you can build your application and run both Workers in the same Wrangler dev session.\n\n    If you are using Pages run:\n\n    * npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "If you are using Workers with Assets run:\n\n    * npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Bundling Â· Cloudflare Workers docs\ndescription: Review Wrangler's default bundling.\nlastUpdated: 2025-07-28T08:46:13.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/wrangler/bundling/\n  md: https://developers.cloudflare.com/workers/wrangler/bundling/index.md\n---\n\nBy default, Wrangler bundles your Worker code using [`esbuild`](https://esbuild.github.io/). This means that Wrangler has built-in support for importing modules from [npm](https://www.npmjs.com/) defined in your `package.json`. To review the exact code that Wrangler will upload to Cloudflare, run `npx wrangler deploy --dry-run --outdir dist`, which will show your Worker code after Wrangler's bundling.\n\n`esbuild` version\n\nWrangler uses `esbuild`. We periodically update the `esbuild` version included with Wrangler, and since `esbuild` is a pre-1.0.0 tool, this may sometimes include breaking changes to how bundling works. In particular, we may bump the `esbuild` version in a Wrangler minor version.\n\nNote\n\nWrangler's inbuilt bundling usually provides the best experience, but we understand there are cases where you will need more flexibility. You can provide `rules` and set `find_additional_modules` in your configuration to control which files are included in the deployed Worker but not bundled into the entry-point file. Furthermore, we have an escape hatch in the form of [Custom Builds](https://developers.cloudflare.com/workers/wrangler/custom-builds/), which lets you run your own build before Wrangler's built-in one.\n\n## Including non-JavaScript modules\n\nBundling your Worker code takes multiple modules and bundles them into one file. Sometimes, you might have modules that cannot be inlined directly into the bundle. For example, instead of bundling a Wasm file into your JavaScript Worker, you would want to upload the Wasm file as a separate module that can be imported at runtime. Wrangler supports this for the following file types:\n\n* `.txt`\n* `.html`\n* `.bin`\n* `.wasm` and `.wasm?module`\n\nRefer to [Bundling configuration](https://developers.cloudflare.com/workers/wrangler/configuration/#bundling) to customize these file types.\n\nFor example, with the following import, the variable `data` will be a string containing the contents of `example.html`:",
      "language": "unknown"
    },
    {
      "code": "This is also the basis of Wasm support with Wrangler. To use a Wasm module in a Worker developed with Wrangler, add the following to your Worker:",
      "language": "unknown"
    },
    {
      "code": "Warning\n\nCloudflare Workers does not support `WebAssembly.instantiateStreaming()`.\n\n## Find additional modules\n\nBy setting `find_additional_modules` to `true` in your configuration file, Wrangler will traverse the file tree below `base_dir`. Any files that match the `rules` you define will also be included as unbundled, external modules in the deployed Worker.\n\nThis approach is useful for supporting lazy loading of large or dynamically imported JavaScript files:\n\n* Normally, a large lazy-imported file (for example, `await import(\"./large-dep.mjs\")`) would be bundled directly into your entrypoint, reducing the effectiveness of the lazy loading. If matching rule is added to `rules`, then this file would only be loaded and executed at runtime when it is actually imported.\n* Previously, variable based dynamic imports (for example, ``await import(`./lang/${language}.mjs`)``) would always fail at runtime because Wrangler had no way of knowing which modules to include in the upload. Providing a rule that matches all these files, such as `{ \"type\": \"EsModule\", \"globs\": [\"./lang/**/*.mjs\"], \"fallthrough\": true }`, will ensure this module is available at runtime.\n* \"Partial bundling\" is supported when `find_additional_modules` is `true`, and a source file matches one of the configured `rules`, since Wrangler will then treat it as \"external\" and not try to bundle it into the entry-point file.\n\n## Conditional exports\n\nWrangler respects the [conditional `exports` field](https://nodejs.org/api/packages.html#conditional-exports) in `package.json`. This allows developers to implement isomorphic libraries that have different implementations depending on the JavaScript runtime they are running in. When bundling, Wrangler will try to load the [`workerd` key](https://runtime-keys.proposal.wintercg.org/#workerd). Refer to the Wrangler repository for [an example isomorphic package](https://github.com/cloudflare/workers-sdk/tree/main/fixtures/isomorphic-random-example).\n\n## Disable bundling\n\nWarning\n\nDisabling bundling is not recommended in most scenarios. Use this option only when deploying code pre-processed by other tooling.\n\nIf your build tooling already produces build artifacts suitable for direct deployment to Cloudflare, you can opt out of bundling by using the `--no-bundle` command line flag: `npx wrangler deploy --no-bundle`. If you opt out of bundling, Wrangler will not process your code and some features introduced by Wrangler bundling (for example minification, and polyfills injection) will not be available.\n\nUse [Custom Builds](https://developers.cloudflare.com/workers/wrangler/custom-builds/) to customize what Wrangler will bundle and upload to the Cloudflare global network when you use [`wrangler dev`](https://developers.cloudflare.com/workers/wrangler/commands/#dev) and [`wrangler deploy`](https://developers.cloudflare.com/workers/wrangler/commands/#deploy).\n\n## Generated Wrangler configuration\n\nSome framework tools, or custom pre-build processes, generate a modified Wrangler configuration to be used to deploy the Worker code. It is possible for Wrangler to automatically use this generated configuration rather than the original, user's configuration.\n\nSee [Generated Wrangler configuration](https://developers.cloudflare.com/workers/wrangler/configuration/#generated-wrangler-configuration) for more information.\n\n</page>\n\n<page>\n---\ntitle: Commands - Wrangler Â· Cloudflare Workers docs\ndescription: Create, develop, and deploy your Cloudflare Workers with Wrangler commands.\nlastUpdated: 2025-12-29T17:29:32.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/wrangler/commands/\n  md: https://developers.cloudflare.com/workers/wrangler/commands/index.md\n---\n\nWrangler offers a number of commands to manage your Cloudflare Workers.\n\n* [`docs`](#docs) - Open this page in your default browser.\n* [`init`](#init) - Create a new project from a variety of web frameworks and templates.\n* [`containers`](#containers) - Interact with Containers.\n* [`d1`](#d1) - Interact with D1.\n* [`vectorize`](#vectorize) - Interact with Vectorize indexes.\n* [`hyperdrive`](#hyperdrive) - Manage your Hyperdrives.\n* [`deploy`](#deploy) - Deploy your Worker to Cloudflare.\n* [`dev`](#dev) - Start a local server for developing your Worker.\n* [`delete`](#delete) - Delete your Worker from Cloudflare.\n* [`kv namespace`](#kv-namespace) - Manage Workers KV namespaces.\n* [`kv key`](#kv-key) - Manage key-value pairs within a Workers KV namespace.\n* [`kv bulk`](#kv-bulk) - Manage multiple key-value pairs within a Workers KV namespace in batches.\n* [`r2 bucket`](#r2-bucket) - Manage Workers R2 buckets.\n* [`r2 object`](#r2-object) - Manage Workers R2 objects.\n* [`r2 sql`](#r2-sql) - Query tables in R2 Data Catalog with R2 SQL.\n* [`setup`](#setup) - Configure your framework for Cloudflare automatically.\n* [`secret`](#secret) - Manage the secret variables for a Worker.\n* [`secret bulk`](#secret-bulk) - Manage multiple secret variables for a Worker.\n* [`secrets-store secret`](#secrets-store-secret) - Manage account secrets within a secrets store.\n* [`secrets-store store`](#secrets-store-store) - Manage your store within secrets store.\n* [`workflows`](#workflows) - Manage and configure Workflows.\n* [`tail`](#tail) - Start a session to livestream logs from a deployed Worker.\n* [`pages`](#pages) - Configure Cloudflare Pages.\n* [`pipelines`](#pipelines) - Configure Cloudflare Pipelines.\n* [`queues`](#queues) - Configure Workers Queues.\n* [`login`](#login) - Authorize Wrangler with your Cloudflare account using OAuth.\n* [`logout`](#logout) - Remove Wrangler's authorization for accessing your account.\n* [`whoami`](#whoami) - Retrieve your user information and test your authentication configuration.\n* [`versions`](#versions) - Retrieve details for recent versions.\n* [`deployments`](#deployments) - Retrieve details for recent deployments.\n* [`rollback`](#rollback) - Rollback to a recent deployment.\n* [`dispatch-namespace`](#dispatch-namespace) - Interact with a [dispatch namespace](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/how-workers-for-platforms-works/#dispatch-namespace).\n* [`mtls-certificate`](#mtls-certificate) - Manage certificates used for mTLS connections.\n* [`cert`](#cert) - Manage certificates used for mTLS and Certificate Authority (CA) chain connections.\n* [`types`](#types) - Generate types from bindings and module rules in configuration.\n* [`telemetry`](#telemetry) - Configure whether Wrangler can collect anonymous usage data.\n* [`check`](#check) - Validate your Worker.\n\nNote\n\nThe following global flags work on every command:\n\n* `--help` boolean\n  * Show help.\n* `--config` string (not supported by Pages)\n  * Path to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).\n* `--cwd` string\n  * Run as if Wrangler was started in the specified directory instead of the current working directory.\n\n***\n\n## How to run Wrangler commands\n\nThis page provides a reference for Wrangler commands.",
      "language": "unknown"
    },
    {
      "code": "Since Cloudflare recommends [installing Wrangler locally](https://developers.cloudflare.com/workers/wrangler/install-and-update/) in your project(rather than globally), the way to run Wrangler will depend on your specific setup and package manager.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "You can add Wrangler commands that you use often as scripts in your project's `package.json` file:",
      "language": "unknown"
    },
    {
      "code": "You can then run them using your package manager of choice:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n## `docs`\n\nOpen the Cloudflare developer documentation in your default browser.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[SEARCH]` string\n\n  Enter search terms (e.g. the wrangler command) you want to know more about\n\n- `--yes` boolean alias: --y\n\n  Takes you to the docs, even if search fails\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n***\n\n## `init`\n\nCreate a new project via the [create-cloudflare-cli (C3) tool](https://developers.cloudflare.com/workers/get-started/guide/#1-create-a-new-worker-project). A variety of web frameworks are available to choose from as well as templates. Dependencies are installed by default, with the option to deploy your project immediately.",
      "language": "unknown"
    },
    {
      "code": "* `NAME` string optional (default: name of working directory)\n  * The name of the Workers project. This is both the directory name and `name` property in the generated [Wrangler configuration](https://developers.cloudflare.com/workers/wrangler/configuration/).\n\n* `--yes` boolean optional\n  * Answer yes to any prompts for new projects.\n\n* `--from-dash` string optional\n\n  * Fetch a Worker initialized from the dashboard. This is done by passing the flag and the Worker name. `wrangler init --from-dash <WORKER_NAME>`.\n  * The `--from-dash` command will not automatically sync changes made to the dashboard after the command is used. Therefore, it is recommended that you continue using the CLI.\n\nThe following global flags work on every command:\n\n* `--help` boolean\n  * Show help.\n* `--config` string (not supported by Pages)\n  * Path to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).\n* `--cwd` string\n  * Run as if Wrangler was started in the specified directory instead of the current working directory.\n\n***\n\n## `containers`\n\nInteract with Cloudflare's Container Platform.\n\n### `build`\n\nBuild a Container image from a Dockerfile.",
      "language": "unknown"
    },
    {
      "code": "* `PATH` string optional\n  * Path for the directory containing the Dockerfile to build.\n\n* `-t, --tag` string required\n  * Name and optionally a tag (format: \"name:tag\").\n\n* `--path-to-docker` string optional\n\n  * Path to your docker binary if it's not on `$PATH`.\n  * Default: \"docker\"\n\n* `-p, --push` boolean optional\n\n  * Push the built image to Cloudflare's managed registry.\n  * Default: false\n\n### `delete`\n\nDelete a Container (application).",
      "language": "unknown"
    },
    {
      "code": "* `CONTAINER_ID` string required\n  * The ID of the Container to delete.\n\n### `images`\n\nPerform operations on images in your containers registry.\n\n#### `images list`\n\nList images in your containers registry.",
      "language": "unknown"
    },
    {
      "code": "* `--filter` string optional\n  * Regex to filter results.\n\n* `--json` boolean optional\n\n  * Return output as clean JSON.\n  * Default: false\n\n#### `images delete`\n\nRemove an image from your containers registry.",
      "language": "unknown"
    },
    {
      "code": "* `IMAGE` string required\n  * Image to delete of the form `IMAGE:TAG`\n\n### `registries`\n\nConfigure and view registries available to your container. [Read more](https://developers.cloudflare.com/containers/platform-details/image-management/#using-amazon-ecr-container-images) about our currently supported external registries.\n\n#### `registries list`\n\nList registries your containers are able to use.",
      "language": "unknown"
    },
    {
      "code": "* `--json` boolean optional\n\n  * Return output as clean JSON.\n  * Default: false\n\n#### `registries configure`\n\nConfigure a new registry for your account.",
      "language": "unknown"
    },
    {
      "code": "* `DOMAIN` string required\n  * domain to configre for the registry\n* `--public-credential` string required\n  * The public part of the registry credentials, e.g. `AWS_ACCESS_KEY_ID` for ECR\n* `--secret-store-id` string optional\n  * The ID of the secret store to use to store the registry credentials\n* `--secret-name` string optional\n  * The name Wrangler should store the registry credentials under\n\nWhen run interactively, wrangler will prompt you for your secret and store it in Secrets Store. To run non-interactively, you can send your secret value to wrangler through stdin to have the secret created for you.\n\n#### `registries delete`\n\nRemove a registry configuration from your account.",
      "language": "unknown"
    },
    {
      "code": "* `DOMAIN` string required\n  * domain of the registry to delete\n\n### `info`\n\nGet information about a specific Container, including top-level details and a list of instances.",
      "language": "unknown"
    },
    {
      "code": "* `CONTAINER_ID` string required\n  * The ID of the Container to get information about.\n\n### `list`\n\nList the Containers in your account.",
      "language": "unknown"
    },
    {
      "code": "### `push`\n\nPush a tagged image to a Cloudflare managed registry, which is automatically integrated with your account.",
      "language": "unknown"
    },
    {
      "code": "* `TAG` string required\n  * The name and tag of the container image to push.\n\n* `--path-to-docker` string optional\n\n  * Path to your docker binary if it's not on `$PATH`.\n  * Default: \"docker\"\n\n## `d1`\n\nInteract with Cloudflare's D1 service.\n\n### `d1 create`\n\nCreates a new D1 database, and provides the binding and UUID that you will put in your config file\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the new D1 database\n\n- `--location` string\n\n  A hint for the primary location of the new DB. Options: weur: Western Europe eeur: Eastern Europe apac: Asia Pacific oc: Oceania wnam: Western North America enam: Eastern North America\n\n- `--jurisdiction` string\n\n  The location to restrict the D1 database to run and store data within to comply with local regulations. Note that if jurisdictions are set, the location hint is ignored. Options: eu: The European Union fedramp: FedRAMP-compliant data centers\n\n- `--use-remote` boolean\n\n  Use a remote binding when adding the newly created resource to your config\n\n- `--update-config` boolean\n\n  Automatically update your config file with the newly added resource\n\n- `--binding` string\n\n  The binding name of this resource in your Worker\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 info`\n\nGet information about a D1 database, including the current database size and state\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the DB\n\n- `--json` boolean default: false\n\n  Return output as clean JSON\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 list`\n\nList all D1 databases in your account\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `--json` boolean default: false\n\n  Return output as clean JSON\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 delete`\n\nDelete a D1 database\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name or binding of the DB\n\n- `--skip-confirmation` boolean alias: --y default: false\n\n  Skip confirmation\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 execute`\n\nExecute a command or SQL file\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[DATABASE]` string required\n\n  The name or binding of the DB\n\n- `--command` string\n\n  The SQL query you wish to execute, or multiple queries separated by ';'\n\n- `--file` string\n\n  A .sql file to ingest\n\n- `--yes` boolean alias: --y\n\n  Answer \"yes\" to any prompts\n\n- `--local` boolean\n\n  Execute commands/files against a local DB for use with wrangler dev\n\n- `--remote` boolean\n\n  Execute commands/files against a remote D1 database for use with remote bindings or your deployed Worker\n\n- `--persist-to` string\n\n  Specify directory to use for local persistence (for use with --local)\n\n- `--json` boolean default: false\n\n  Return output as clean JSON\n\n- `--preview` boolean default: false\n\n  Execute commands/files against a preview D1 database\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 export`\n\nExport the contents or schema of your database as a .sql file\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the D1 database to export\n\n- `--local` boolean\n\n  Export from your local DB you use with wrangler dev\n\n- `--remote` boolean\n\n  Export from a remote D1 database\n\n- `--output` string required\n\n  Path to the SQL file for your export\n\n- `--table` string\n\n  Specify which tables to include in export\n\n- `--no-schema` boolean\n\n  Only output table contents, not the DB schema\n\n- `--no-data` boolean\n\n  Only output table schema, not the contents of the DBs themselves\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 time-travel info`\n\nRetrieve information about a database at a specific point-in-time using Time Travel\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[DATABASE]` string required\n\n  The name or binding of the DB\n\n- `--timestamp` string\n\n  Accepts a Unix (seconds from epoch) or RFC3339 timestamp (e.g. 2023-07-13T08:46:42.228Z) to retrieve a bookmark for\n\n- `--json` boolean default: false\n\n  Return output as clean JSON\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 time-travel restore`\n\nRestore a database back to a specific point-in-time\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[DATABASE]` string required\n\n  The name or binding of the DB\n\n- `--bookmark` string\n\n  Bookmark to use for time travel\n\n- `--timestamp` string\n\n  Accepts a Unix (seconds from epoch) or RFC3339 timestamp (e.g. 2023-07-13T08:46:42.228Z) to retrieve a bookmark for (within the last 30 days)\n\n- `--json` boolean default: false\n\n  Return output as clean JSON\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 migrations create`\n\nCreate a new migration\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[DATABASE]` string required\n\n  The name or binding of the DB\n\n- `[MESSAGE]` string required\n\n  The Migration message\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 migrations list`\n\nView a list of unapplied migration files\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[DATABASE]` string required\n\n  The name or binding of the DB\n\n- `--local` boolean\n\n  Check migrations against a local DB for use with wrangler dev\n\n- `--remote` boolean\n\n  Check migrations against a remote DB for use with wrangler dev --remote\n\n- `--preview` boolean default: false\n\n  Check migrations against a preview D1 DB\n\n- `--persist-to` string\n\n  Specify directory to use for local persistence (you must use --local with this flag)\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 migrations apply`\n\nApply any unapplied D1 migrations\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[DATABASE]` string required\n\n  The name or binding of the DB\n\n- `--local` boolean\n\n  Execute commands/files against a local DB for use with wrangler dev\n\n- `--remote` boolean\n\n  Execute commands/files against a remote DB for use with wrangler dev --remote\n\n- `--preview` boolean default: false\n\n  Execute commands/files against a preview D1 DB\n\n- `--persist-to` string\n\n  Specify directory to use for local persistence (you must use --local with this flag)\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `d1 insights`\n\nExperimental\n\nGet information about the queries run on a D1 database\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the DB\n\n- `--timePeriod` string default: 1d\n\n  Fetch data from now to the provided time period\n\n- `--sort-type` string default: sum\n\n  Choose the operation you want to sort insights by\n\n- `--sort-by` string default: time\n\n  Choose the field you want to sort insights by\n\n- `--sort-direction` string default: DESC\n\n  Choose a sort direction\n\n- `--limit` number default: 5\n\n  fetch insights about the first X queries\n\n- `--json` boolean default: false\n\n  return output as clean JSON\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n***\n\n## `hyperdrive`\n\nManage [Hyperdrive](https://developers.cloudflare.com/hyperdrive/) database configurations.\n\n### `hyperdrive create`\n\nCreate a Hyperdrive config\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Hyperdrive config\n\n- `--connection-string` string\n\n  The connection string for the database you want Hyperdrive to connect to - ex: protocol://user:password\\@host:port/database\n\n- `--origin-host` string alias: --host\n\n  The host of the origin database\n\n- `--origin-port` number alias: --port\n\n  The port number of the origin database\n\n- `--origin-scheme` string alias: --scheme default: postgresql\n\n  The scheme used to connect to the origin database\n\n- `--database` string\n\n  The name of the database within the origin database\n\n- `--origin-user` string alias: --user\n\n  The username used to connect to the origin database\n\n- `--origin-password` string alias: --password\n\n  The password used to connect to the origin database\n\n- `--access-client-id` string\n\n  The Client ID of the Access token to use when connecting to the origin database\n\n- `--access-client-secret` string\n\n  The Client Secret of the Access token to use when connecting to the origin database\n\n- `--caching-disabled` boolean\n\n  Disables the caching of SQL responses\n\n- `--max-age` number\n\n  Specifies max duration for which items should persist in the cache, cannot be set when caching is disabled\n\n- `--swr` number\n\n  Indicates the number of seconds cache may serve the response after it becomes stale, cannot be set when caching is disabled\n\n- `--ca-certificate-id` string alias: --ca-certificate-uuid\n\n  Sets custom CA certificate when connecting to origin database. Must be valid UUID of already uploaded CA certificate.\n\n- `--mtls-certificate-id` string alias: --mtls-certificate-uuid\n\n  Sets custom mTLS client certificates when connecting to origin database. Must be valid UUID of already uploaded public/private key certificates.\n\n- `--sslmode` string\n\n  Sets CA sslmode for connecting to database.\n\n- `--origin-connection-limit` number\n\n  The (soft) maximum number of connections that Hyperdrive may establish to the origin database\n\n- `--binding` string\n\n  The binding name of this resource in your Worker\n\n- `--use-remote` boolean\n\n  Use a remote binding when adding the newly created resource to your config\n\n- `--update-config` boolean\n\n  Automatically update your config file with the newly added resource\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `hyperdrive delete`\n\nDelete a Hyperdrive config\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[ID]` string required\n\n  The ID of the Hyperdrive config\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `hyperdrive get`\n\nGet a Hyperdrive config\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[ID]` string required\n\n  The ID of the Hyperdrive config\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `hyperdrive list`\n\nList Hyperdrive configs\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "Global flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `hyperdrive update`\n\nUpdate a Hyperdrive config\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[ID]` string required\n\n  The ID of the Hyperdrive config\n\n- `--name` string\n\n  Give your config a new name\n\n- `--connection-string` string\n\n  The connection string for the database you want Hyperdrive to connect to - ex: protocol://user:password\\@host:port/database\n\n- `--origin-host` string alias: --host\n\n  The host of the origin database\n\n- `--origin-port` number alias: --port\n\n  The port number of the origin database\n\n- `--origin-scheme` string alias: --scheme\n\n  The scheme used to connect to the origin database\n\n- `--database` string\n\n  The name of the database within the origin database\n\n- `--origin-user` string alias: --user\n\n  The username used to connect to the origin database\n\n- `--origin-password` string alias: --password\n\n  The password used to connect to the origin database\n\n- `--access-client-id` string\n\n  The Client ID of the Access token to use when connecting to the origin database\n\n- `--access-client-secret` string\n\n  The Client Secret of the Access token to use when connecting to the origin database\n\n- `--caching-disabled` boolean\n\n  Disables the caching of SQL responses\n\n- `--max-age` number\n\n  Specifies max duration for which items should persist in the cache, cannot be set when caching is disabled\n\n- `--swr` number\n\n  Indicates the number of seconds cache may serve the response after it becomes stale, cannot be set when caching is disabled\n\n- `--ca-certificate-id` string alias: --ca-certificate-uuid\n\n  Sets custom CA certificate when connecting to origin database. Must be valid UUID of already uploaded CA certificate.\n\n- `--mtls-certificate-id` string alias: --mtls-certificate-uuid\n\n  Sets custom mTLS client certificates when connecting to origin database. Must be valid UUID of already uploaded public/private key certificates.\n\n- `--sslmode` string\n\n  Sets CA sslmode for connecting to database.\n\n- `--origin-connection-limit` number\n\n  The (soft) maximum number of connections that Hyperdrive may establish to the origin database\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n***\n\n## `vectorize`\n\nInteract with a [Vectorize](https://developers.cloudflare.com/vectorize/) vector database.\n\n### `vectorize create`\n\nCreate a Vectorize index\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index to create (must be unique).\n\n- `--dimensions` number\n\n  The dimension size to configure this index for, based on the output dimensions of your ML model.\n\n- `--metric` string\n\n  The distance metric to use for searching within the index.\n\n- `--preset` string\n\n  The name of an preset representing an embeddings model: Vectorize will configure the dimensions and distance metric for you when provided.\n\n- `--description` string\n\n  An optional description for this index.\n\n- `--json` boolean default: false\n\n  Return output as clean JSON\n\n- `--deprecated-v1` boolean default: false\n\n  Create a deprecated Vectorize V1 index. This is not recommended and indexes created with this option need all other Vectorize operations to have this option enabled.\n\n- `--use-remote` boolean\n\n  Use a remote binding when adding the newly created resource to your config\n\n- `--update-config` boolean\n\n  Automatically update your config file with the newly added resource\n\n- `--binding` string\n\n  The binding name of this resource in your Worker\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize delete`\n\nDelete a Vectorize index\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index\n\n- `--force` boolean alias: --y default: false\n\n  Skip confirmation\n\n- `--deprecated-v1` boolean default: false\n\n  Delete a deprecated Vectorize V1 index.\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize get`\n\nGet a Vectorize index by name\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index.\n\n- `--json` boolean default: false\n\n  Return output as clean JSON\n\n- `--deprecated-v1` boolean default: false\n\n  Fetch a deprecated V1 Vectorize index. This must be enabled if the index was created with V1 option.\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize list`\n\nList your Vectorize indexes\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `--json` boolean default: false\n\n  Return output as clean JSON\n\n- `--deprecated-v1` boolean default: false\n\n  List deprecated Vectorize V1 indexes for your account.\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize list-vectors`\n\nList vector identifiers in a Vectorize index\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index\n\n- `--count` number\n\n  Maximum number of vectors to return (1-1000)\n\n- `--cursor` string\n\n  Cursor for pagination to get the next page of results\n\n- `--json` boolean default: false\n\n  Return output as clean JSON\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize query`\n\nQuery a Vectorize index\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index\n\n- `--vector` number\n\n  Vector to query the Vectorize Index\n\n- `--vector-id` string\n\n  Identifier for a vector in the index against which the index should be queried\n\n- `--top-k` number default: 5\n\n  The number of results (nearest neighbors) to return\n\n- `--return-values` boolean default: false\n\n  Specify if the vector values should be included in the results\n\n- `--return-metadata` string default: none\n\n  Specify if the vector metadata should be included in the results\n\n- `--namespace` string\n\n  Filter the query results based on this namespace\n\n- `--filter` string\n\n  Filter the query results based on this metadata filter.\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize insert`\n\nInsert vectors into a Vectorize index\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index.\n\n- `--file` string required\n\n  A file containing line separated json (ndjson) vector objects.\n\n- `--batch-size` number default: 1000\n\n  Number of vector records to include when sending to the Cloudflare API.\n\n- `--json` boolean default: false\n\n  return output as clean JSON\n\n- `--deprecated-v1` boolean default: false\n\n  Insert into a deprecated V1 Vectorize index. This must be enabled if the index was created with the V1 option.\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize upsert`\n\nUpsert vectors into a Vectorize index\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index.\n\n- `--file` string required\n\n  A file containing line separated json (ndjson) vector objects.\n\n- `--batch-size` number default: 5000\n\n  Number of vector records to include in a single upsert batch when sending to the Cloudflare API.\n\n- `--json` boolean default: false\n\n  return output as clean JSON\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize get-vectors`\n\nGet vectors from a Vectorize index\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index.\n\n- `--ids` string required\n\n  Vector identifiers to be fetched from the Vectorize Index. Example: `--ids a 'b' 1 '2'`\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize delete-vectors`\n\nDelete vectors in a Vectorize index\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index.\n\n- `--ids` string required\n\n  Vector identifiers to be deleted from the Vectorize Index. Example: `--ids a 'b' 1 '2'`\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize info`\n\nGet additional details about the index\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index.\n\n- `--json` boolean default: false\n\n  return output as clean JSON\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize create-metadata-index`\n\nEnable metadata filtering on the specified property\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index.\n\n- `--propertyName` string required\n\n  The name of the metadata property to index.\n\n- `--type` string required\n\n  The type of metadata property to index. Valid types are 'string', 'number' and 'boolean'.\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize list-metadata-index`\n\nList metadata properties on which metadata filtering is enabled\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index.\n\n- `--json` boolean default: false\n\n  return output as clean JSON\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `vectorize delete-metadata-index`\n\nDelete metadata indexes\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the Vectorize index.\n\n- `--propertyName` string required\n\n  The name of the metadata property to index.\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n***\n\n## `dev`\n\nStart a local server for developing your Worker.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nNone of the options for this command are required. Many of these options can be set in your Wrangler file. Refer to the [Wrangler configuration](https://developers.cloudflare.com/workers/wrangler/configuration) documentation for more information.\n\n* `SCRIPT` string\n  * The path to an entry point for your Worker. Only required if your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) does not include a `main` key (for example, `main = \"index.js\"`).\n\n* `--name` string optional\n  * Name of the Worker.\n\n* `--config`, `-c` string\\[] optional\n\n  * Path(s) to [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). If not provided, Wrangler will use the nearest config file based on your current working directory.\n  * You can provide multiple configuration files to run multiple Workers in one dev session like this: `wrangler dev -c ./wrangler.toml -c ../other-worker/wrangler.toml`. The first config will be treated as the *primary* Worker, which will be exposed over HTTP. The remaining config files will only be accessible via a service binding from the primary Worker.\n\n* `--no-bundle` boolean (default: false) optional\n  * Skip Wrangler's build steps. Particularly useful when using custom builds. Refer to [Bundling](https://developers.cloudflare.com/workers/wrangler/bundling/) for more information.\n\n* `--env` string optional\n  * Perform on a specific environment.\n\n* `--compatibility-date` string optional\n  * A date in the form yyyy-mm-dd, which will be used to determine which version of the Workers runtime is used.\n\n* `--compatibility-flags`, `--compatibility-flag` string\\[] optional\n  * Flags to use for compatibility checks.\n\n* `--latest` boolean (default: true) optional\n  * Use the latest version of the Workers runtime.\n\n* `--ip` string optional\n  * IP address to listen on, defaults to `localhost`.\n\n* `--port` number optional\n  * Port to listen on.\n\n* `--inspector-port` number optional\n  * Port for devtools to connect to.\n\n* `--routes`, `--route` string\\[] optional\n\n  * Routes to upload.\n  * For example: `--route example.com/*`.\n\n* `--host` string optional\n  * Host to forward requests to, defaults to the zone of project.\n\n* `--local-protocol` 'http'|'https' (default: http) optional\n  * Protocol to listen to requests on.\n\n* `--https-key-path` string optional\n  * Path to a custom certificate key.\n\n* `--https-cert-path` string optional\n  * Path to a custom certificate.\n\n* `--local-upstream` string optional\n  * Host to act as origin in local mode, defaults to `dev.host` or route.\n\n* `--assets` string optional beta\n  * Folder of static assets to be served. Replaces [Workers Sites](https://developers.cloudflare.com/workers/configuration/sites/). Visit [assets](https://developers.cloudflare.com/workers/static-assets/) for more information.\n\n* `--site` string optional deprecated, use \\`--assets\\`\n\n  * Folder of static assets for Workers Sites.\n\n    Warning\n\n    Workers Sites is deprecated. Please use [Workers Assets](https://developers.cloudflare.com/workers/static-assets/) or [Pages](https://developers.cloudflare.com/pages/).\n\n* `--site-include` string\\[] optional deprecated\n  * Array of `.gitignore`-style patterns that match file or directory names from the sites directory. Only matched items will be uploaded.\n\n* `--site-exclude` string\\[] optional deprecated\n  * Array of `.gitignore`-style patterns that match file or directory names from the sites directory. Matched items will not be uploaded.\n\n* `--upstream-protocol` 'http'|'https' (default: https) optional\n  * Protocol to forward requests to host on.\n\n* `--var` key:value\\\\\\[] optional\n\n  * Array of `key:value` pairs to inject as variables into your code. The value will always be passed as a string to your Worker.\n  * For example, `--var \"git_hash:'$(git rev-parse HEAD)'\" \"test:123\"` makes the `git_hash` and `test` variables available in your Worker's `env`.\n  * This flag is an alternative to defining [`vars`](https://developers.cloudflare.com/workers/wrangler/configuration/#non-inheritable-keys) in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). If defined in both places, this flag's values will be used.\n\n* `--define` key:value\\\\\\[] optional\n\n  * Array of `key:value` pairs to replace global identifiers in your code.\n  * For example, `--define \"GIT_HASH:'$(git rev-parse HEAD)'\"` will replace all uses of `GIT_HASH` with the actual value at build time.\n  * This flag is an alternative to defining [`define`](https://developers.cloudflare.com/workers/wrangler/configuration/#non-inheritable-keys) in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). If defined in both places, this flag's values will be used.\n\n* `--tsconfig` string optional\n  * Path to a custom `tsconfig.json` file.\n\n* `--minify` boolean optional\n  * Minify the Worker.\n\n* `--persist-to` string optional\n  * Specify directory to use for local persistence.\n\n* `--remote` boolean (default: false) optional\n  * Develop against remote resources and data stored on Cloudflare's network.\n\n* `--test-scheduled` boolean (default: false) optional\n  * Exposes a `/__scheduled` fetch route which will trigger a scheduled event (Cron Trigger) for testing during development. To simulate different cron patterns, a `cron` query parameter can be passed in: `/__scheduled?cron=*+*+*+*+*` or `/cdn-cgi/handler/scheduled?cron=*+*+*+*+*`.\n\n* `--log-level` 'debug'|'info'|'log'|'warn'|'error|'none' (default: log) optional\n  * Specify Wrangler's logging level.\n\n* `--show-interactive-dev-session` boolean (default: true if the terminal supports interactivity) optional\n  * Show the interactive dev session.\n\n* `--alias` `Array<string>`\n  * Specify modules to alias using [module aliasing](https://developers.cloudflare.com/workers/wrangler/configuration/#module-aliasing).\n\nThe following global flags work on every command:\n\n* `--help` boolean\n  * Show help.\n* `--config` string (not supported by Pages)\n  * Path to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).\n* `--cwd` string\n  * Run as if Wrangler was started in the specified directory instead of the current working directory.\n\n`wrangler dev` is a way to [locally test](https://developers.cloudflare.com/workers/development-testing/) your Worker while developing. With `wrangler dev` running, send HTTP requests to `localhost:8787` and your Worker should execute as expected. You will also see `console.log` messages and exceptions appearing in your terminal.\n\n***\n\n## `deploy`\n\nDeploy your Worker to Cloudflare.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nNone of the options for this command are required. Also, many can be set in your Wrangler file. Refer to the [Wrangler configuration](https://developers.cloudflare.com/workers/wrangler/configuration/) documentation for more information.\n\n* `PATH` string\n\n  * A path specific what needs to be deployed, this can either be:\n\n    * The path to an entry point for your Worker.\n\n      * Only required if your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) does not include a `main` key (for example, `main = \"index.js\"`).\n\n    * Or the path to an assets directory for the deployment of a static site.\n\n      * Visit [assets](https://developers.cloudflare.com/workers/static-assets/) for more information.\n      * This overrides the eventual `assets` configuration in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).\n      * This is equivalent to the `--assets` option listed below.\n      * Note: this option currently only works only in interactive mode (so not in CI systems).\n\n* `--name` string optional\n\n  * Name of the Worker.\n\n* `--no-bundle` boolean (default: false) optional\n\n  * Skip Wrangler's build steps. Particularly useful when using custom builds. Refer to [Bundling](https://developers.cloudflare.com/workers/wrangler/bundling/) for more information.\n\n* `--env` string optional\n\n  * Perform on a specific environment.\n\n    Note\n\n    If you're using the [Cloudflare Vite plugin](https://developers.cloudflare.com/workers/vite-plugin/), you select the environment at dev or build time via the `CLOUDFLARE_ENV` environment variable rather than the `--env` flag. Otherwise, environments are defined in your Worker config file as usual. For more detail on using environments with the Cloudflare Vite plugin, refer to the [plugin documentation](https://developers.cloudflare.com/workers/vite-plugin/reference/cloudflare-environments/).\n\n* `--outdir` string optional\n\n  * Path to directory where Wrangler will write the bundled Worker files.\n\n* `--compatibility-date` string optional\n\n  * A date in the form yyyy-mm-dd, which will be used to determine which version of the Workers runtime is used.\n\n* `--compatibility-flags`, `--compatibility-flag` string\\[] optional\n\n  * Flags to use for compatibility checks.\n\n* `--latest` boolean (default: true) optional\n\n  * Use the latest version of the Workers runtime.\n\n* `--assets` string optional beta\n\n  * Folder of static assets to be served. Replaces [Workers Sites](https://developers.cloudflare.com/workers/configuration/sites/). Visit [assets](https://developers.cloudflare.com/workers/static-assets/) for more information.\n\n* `--site` string optional deprecated, use \\`--assets\\`\n\n  * Folder of static assets for Workers Sites.\n\n    Warning\n\n    Workers Sites is deprecated. Please use [Workers Assets](https://developers.cloudflare.com/workers/static-assets/) or [Pages](https://developers.cloudflare.com/pages/).\n\n* `--site-include` string\\[] optional deprecated\n\n  * Array of `.gitignore`-style patterns that match file or directory names from the sites directory. Only matched items will be uploaded.\n\n* `--site-exclude` string\\[] optional deprecated\n\n  * Array of `.gitignore`-style patterns that match file or directory names from the sites directory. Matched items will not be uploaded.\n\n* `--var` key:value\\\\\\[] optional\n\n  * Array of `key:value` pairs to inject as variables into your code. The value will always be passed as a string to your Worker.\n  * For example, `--var git_hash:$(git rev-parse HEAD) test:123` makes the `git_hash` and `test` variables available in your Worker's `env`.\n  * This flag is an alternative to defining [`vars`](https://developers.cloudflare.com/workers/wrangler/configuration/#non-inheritable-keys) in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). If defined in both places, this flag's values will be used.\n\n* `--define` key:value\\\\\\[] optional\n\n  * Array of `key:value` pairs to replace global identifiers in your code.\n  * For example, `--define GIT_HASH:$(git rev-parse HEAD)` will replace all uses of `GIT_HASH` with the actual value at build time.\n  * This flag is an alternative to defining [`define`](https://developers.cloudflare.com/workers/wrangler/configuration/#non-inheritable-keys) in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). If defined in both places, this flag's values will be used.\n\n* `--triggers`, `--schedule`, `--schedules` string\\[] optional\n\n  * Cron schedules to attach to the deployed Worker. Refer to [Cron Trigger Examples](https://developers.cloudflare.com/workers/configuration/cron-triggers/#examples).\n\n* `--routes`, `--route` string\\[] optional\n\n  * Routes where this Worker will be deployed.\n  * For example: `--route example.com/*`.\n\n* `--tsconfig` string optional\n\n  * Path to a custom `tsconfig.json` file.\n\n* `--minify` boolean optional\n\n  * Minify the bundled Worker before deploying.\n\n* `--dry-run` boolean (default: false) optional\n\n  * Compile a project without actually deploying to live servers. Combined with `--outdir`, this is also useful for testing the output of `npx wrangler deploy`. It also gives developers a chance to upload our generated sourcemap to a service like Sentry, so that errors from the Worker can be mapped against source code, but before the service goes live.\n\n* `--keep-vars` boolean (default: false) optional\n\n  * It is recommended best practice to treat your Wrangler developer environment as a source of truth for your Worker configuration, and avoid making changes via the Cloudflare dashboard.\n  * If you change your environment variables in the Cloudflare dashboard, Wrangler will override them the next time you deploy. If you want to disable this behaviour set `keep-vars` to `true`.\n  * Secrets are never deleted by a deployment whether this flag is true or false.\n\n* `--dispatch-namespace` string optional\n\n  * Specify the [Workers for Platforms dispatch namespace](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/how-workers-for-platforms-works/#dispatch-namespace) to upload this Worker to.\n\n* `--metafile` string optional\n\n  * Specify a file to write the build metadata from esbuild to. If flag is used without a path string, this defaults to `bundle-meta.json` inside the directory specified by `--outdir`. This can be useful for understanding the bundle size.\n\n* `--containers-rollout` immediate | gradual optional\n\n  * Specify the [rollout strategy](https://developers.cloudflare.com/containers/faq#how-do-container-updates-and-rollouts-work) for [Containers](https://developers.cloudflare.com/containers) associated with the Worker. If set to `immediate`, 100% of container instances will be updated in one rollout step, overriding any configuration in `rollout_step_percentage`. Note that `rollout_active_grace_period`, if configured, still applies.\n  * Defaults to `gradual`, where the default rollout is 10% then 100% of instances.\n\n* `--strict` boolean (default: false) optional\n\n  * Turns on strict mode for the deployment command, meaning that the command will be more defensive and prevent deployments which could introduce potential issues. In particular, this mode prevents deployments if the deployment would potentially override remote settings in non-interactive environments.\n\nThe following global flags work on every command:\n\n* `--help` boolean\n  * Show help.\n* `--config` string (not supported by Pages)\n  * Path to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).\n* `--cwd` string\n  * Run as if Wrangler was started in the specified directory instead of the current working directory.\n\n***\n\n## `delete`\n\nDelete your Worker and all associated Cloudflare developer platform resources.",
      "language": "unknown"
    },
    {
      "code": "* `SCRIPT` string\n  * The path to an entry point for your Worker. Only required if your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) does not include a `main` key (for example, `main = \"index.js\"`).\n* `--name` string optional\n  * Name of the Worker.\n* `--env` string optional\n  * Perform on a specific environment.\n* `--dry-run` boolean (default: false) optional\n  * Do not actually delete the Worker. This is useful for testing the output of `wrangler delete`.\n\nThe following global flags work on every command:\n\n* `--help` boolean\n  * Show help.\n* `--config` string (not supported by Pages)\n  * Path to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).\n* `--cwd` string\n  * Run as if Wrangler was started in the specified directory instead of the current working directory.\n\n***\n\n## `kv namespace`\n\nManage Workers KV namespaces.\n\nNote\n\nThe `kv ...` commands allow you to manage your Workers KV resources in the Cloudflare network. Learn more about using Workers KV with Wrangler in the [Workers KV guide](https://developers.cloudflare.com/kv/get-started/).\n\nWarning\n\nSince version 3.60.0, Wrangler supports the `kv ...` syntax. If you are using versions below 3.60.0, the command follows the `kv:...` syntax. Learn more about the deprecation of the `kv:...` syntax in the [Wrangler commands](https://developers.cloudflare.com/kv/reference/kv-commands/#deprecations) for KV page.\n\n### `kv namespace create`\n\nCreate a new namespace\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAMESPACE]` string required\n\n  The name of the new namespace\n\n- `--preview` boolean\n\n  Interact with a preview namespace\n\n- `--use-remote` boolean\n\n  Use a remote binding when adding the newly created resource to your config\n\n- `--update-config` boolean\n\n  Automatically update your config file with the newly added resource\n\n- `--binding` string\n\n  The binding name of this resource in your Worker\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `kv namespace list`\n\nOutput a list of all KV namespaces associated with your account id\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "Global flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `kv namespace delete`\n\nDelete a given namespace.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `--binding` string\n\n  The binding name to the namespace to delete from\n\n- `--namespace-id` string\n\n  The id of the namespace to delete\n\n- `--preview` boolean\n\n  Interact with a preview namespace\n\n- `--skip-confirmation` boolean alias: --y default: false\n\n  Skip confirmation\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `kv namespace rename`\n\nRename a KV namespace\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[OLD-NAME]` string\n\n  The current name (title) of the namespace to rename\n\n- `--namespace-id` string\n\n  The id of the namespace to rename\n\n- `--new-name` string required\n\n  The new name for the namespace\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n## `kv key`\n\nManage key-value pairs within a Workers KV namespace.\n\nNote\n\nThe `kv ...` commands allow you to manage your Workers KV resources in the Cloudflare network. Learn more about using Workers KV with Wrangler in the [Workers KV guide](https://developers.cloudflare.com/kv/get-started/).\n\nWarning\n\nSince version 3.60.0, Wrangler supports the `kv ...` syntax. If you are using versions below 3.60.0, the command follows the `kv:...` syntax. Learn more about the deprecation of the `kv:...` syntax in the [Wrangler commands](https://developers.cloudflare.com/kv/reference/kv-commands/) for KV page.\n\n### `kv key put`\n\nWrite a single key/value pair to the given namespace\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[KEY]` string required\n\n  The key to write to\n\n- `[VALUE]` string\n\n  The value to write\n\n- `--path` string\n\n  Read value from the file at a given path\n\n- `--binding` string\n\n  The binding name to the namespace to write to\n\n- `--namespace-id` string\n\n  The id of the namespace to write to\n\n- `--preview` boolean\n\n  Interact with a preview namespace\n\n- `--ttl` number\n\n  Time for which the entries should be visible\n\n- `--expiration` number\n\n  Time since the UNIX epoch after which the entry expires\n\n- `--metadata` string\n\n  Arbitrary JSON that is associated with a key\n\n- `--local` boolean\n\n  Interact with local storage\n\n- `--remote` boolean\n\n  Interact with remote storage\n\n- `--persist-to` string\n\n  Directory for local persistence\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `kv key list`\n\nOutput a list of all keys in a given namespace\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `--binding` string\n\n  The binding name to the namespace to list\n\n- `--namespace-id` string\n\n  The id of the namespace to list\n\n- `--preview` boolean default: false\n\n  Interact with a preview namespace\n\n- `--prefix` string\n\n  A prefix to filter listed keys\n\n- `--local` boolean\n\n  Interact with local storage\n\n- `--remote` boolean\n\n  Interact with remote storage\n\n- `--persist-to` string\n\n  Directory for local persistence\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `kv key get`\n\nRead a single value by key from the given namespace\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[KEY]` string required\n\n  The key value to get.\n\n- `--text` boolean default: false\n\n  Decode the returned value as a utf8 string\n\n- `--binding` string\n\n  The binding name to the namespace to get from\n\n- `--namespace-id` string\n\n  The id of the namespace to get from\n\n- `--preview` boolean default: false\n\n  Interact with a preview namespace\n\n- `--local` boolean\n\n  Interact with local storage\n\n- `--remote` boolean\n\n  Interact with remote storage\n\n- `--persist-to` string\n\n  Directory for local persistence\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `kv key delete`\n\nRemove a single key value pair from the given namespace\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[KEY]` string required\n\n  The key value to delete.\n\n- `--binding` string\n\n  The binding name to the namespace to delete from\n\n- `--namespace-id` string\n\n  The id of the namespace to delete from\n\n- `--preview` boolean\n\n  Interact with a preview namespace\n\n- `--local` boolean\n\n  Interact with local storage\n\n- `--remote` boolean\n\n  Interact with remote storage\n\n- `--persist-to` string\n\n  Directory for local persistence\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n## `kv bulk`\n\nManage multiple key-value pairs within a Workers KV namespace in batches.\n\nNote\n\nThe `kv ...` commands allow you to manage your Workers KV resources in the Cloudflare network. Learn more about using Workers KV with Wrangler in the [Workers KV guide](https://developers.cloudflare.com/kv/get-started/).\n\nWarning\n\nSince version 3.60.0, Wrangler supports the `kv ...` syntax. If you are using versions below 3.60.0, the command follows the `kv:...` syntax. Learn more about the deprecation of the `kv:...` syntax in the [Wrangler commands](https://developers.cloudflare.com/kv/reference/kv-commands/) for KV page.\n\n### `kv bulk get`\n\nGets multiple key-value pairs from a namespace\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[FILENAME]` string required\n\n  The file containing the keys to get\n\n- `--binding` string\n\n  The binding name to the namespace to get from\n\n- `--namespace-id` string\n\n  The id of the namespace to get from\n\n- `--preview` boolean default: false\n\n  Interact with a preview namespace\n\n- `--local` boolean\n\n  Interact with local storage\n\n- `--remote` boolean\n\n  Interact with remote storage\n\n- `--persist-to` string\n\n  Directory for local persistence\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `kv bulk put`\n\nUpload multiple key-value pairs to a namespace\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[FILENAME]` string required\n\n  The file containing the key/value pairs to write\n\n- `--binding` string\n\n  The binding name to the namespace to write to\n\n- `--namespace-id` string\n\n  The id of the namespace to write to\n\n- `--preview` boolean\n\n  Interact with a preview namespace\n\n- `--ttl` number\n\n  Time for which the entries should be visible\n\n- `--expiration` number\n\n  Time since the UNIX epoch after which the entry expires\n\n- `--metadata` string\n\n  Arbitrary JSON that is associated with a key\n\n- `--local` boolean\n\n  Interact with local storage\n\n- `--remote` boolean\n\n  Interact with remote storage\n\n- `--persist-to` string\n\n  Directory for local persistence\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `kv bulk delete`\n\nDelete multiple key-value pairs from a namespace\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[FILENAME]` string required\n\n  The file containing the keys to delete\n\n- `--force` boolean alias: --f\n\n  Do not ask for confirmation before deleting\n\n- `--binding` string\n\n  The binding name to the namespace to delete from\n\n- `--namespace-id` string\n\n  The id of the namespace to delete from\n\n- `--preview` boolean\n\n  Interact with a preview namespace\n\n- `--local` boolean\n\n  Interact with local storage\n\n- `--remote` boolean\n\n  Interact with remote storage\n\n- `--persist-to` string\n\n  Directory for local persistence\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n***\n\n## `r2 bucket`\n\nInteract with buckets in an R2 store.\n\nNote\n\nThe `r2 bucket` commands allow you to manage application data in the Cloudflare network to be accessed from Workers using [the R2 API](https://developers.cloudflare.com/r2/api/workers/workers-api-reference/).\n\n### `r2 bucket create`\n\nCreate a new R2 bucket\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[NAME]` string required\n\n  The name of the new bucket\n\n- `--location` string\n\n  The optional location hint that determines geographic placement of the R2 bucket\n\n- `--storage-class` string alias: --s\n\n  The default storage class for objects uploaded to this bucket\n\n- `--jurisdiction` string alias: --J\n\n  The jurisdiction where the new bucket will be created\n\n- `--use-remote` boolean\n\n  Use a remote binding when adding the newly created resource to your config\n\n- `--update-config` boolean\n\n  Automatically update your config file with the newly added resource\n\n- `--binding` string\n\n  The binding name of this resource in your Worker\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `r2 bucket info`\n\nGet information about an R2 bucket\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[BUCKET]` string required\n\n  The name of the bucket to retrieve info for\n\n- `--jurisdiction` string alias: --J\n\n  The jurisdiction where the bucket exists\n\n- `--json` boolean default: false\n\n  Return the bucket information as JSON\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `r2 bucket delete`\n\nDelete an R2 bucket\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[BUCKET]` string required\n\n  The name of the bucket to delete\n\n- `--jurisdiction` string alias: --J\n\n  The jurisdiction where the bucket exists\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `r2 bucket list`\n\nList R2 buckets\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `--jurisdiction` string alias: --J\n\n  The jurisdiction to list\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `r2 bucket catalog enable`\n\nEnable the data catalog on an R2 bucket\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[BUCKET]` string required\n\n  The name of the bucket to enable\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `r2 bucket catalog disable`\n\nDisable the data catalog for an R2 bucket\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[BUCKET]` string required\n\n  The name of the bucket to disable the data catalog for\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `r2 bucket catalog get`\n\nGet the status of the data catalog for an R2 bucket\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[BUCKET]` string required\n\n  The name of the R2 bucket whose data catalog status to retrieve\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\n### `r2 bucket catalog compaction enable`\n\nEnable automatic file compaction for your R2 data catalog or a specific table\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "- `[BUCKET]` string required\n\n  The name of the bucket which contains the catalog\n\n- `[NAMESPACE]` string\n\n  The namespace containing the table (optional, for table-level compaction)\n\n- `[TABLE]` string\n\n  The name of the table (optional, for table-level compaction)\n\n- `--target-size` number default: 128\n\n  The target size for compacted files in MB (allowed values: 64, 128, 256, 512)\n\n- `--token` string\n\n  A cloudflare api token with access to R2 and R2 Data Catalog (required for catalog-level compaction settings only)\n\nGlobal flags\n\n* `--v` boolean alias: --version\n\n  Show version number\n\n* `--cwd` string\n\n  Run as if Wrangler was started in the specified directory instead of the current working directory\n\n* `--config` string alias: --c\n\n  Path to Wrangler configuration file\n\n* `--env` string alias: --e\n\n  Environment to use for operations, and for selecting .env and .dev.vars files\n\n* `--env-file` string\n\n  Path to an .env file to load - can be specified multiple times - values from earlier files are overridden by values in later files\n\n* `--experimental-provision` boolean aliases: --x-provision default: true\n\n  Experimental: Enable automatic resource provisioning\n\n* `--experimental-auto-create` boolean alias: --x-auto-create default: true\n\n  Automatically provision draft bindings with new resources\n\nExamples:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Install extra libraries",
      "id": "install-extra-libraries"
    },
    {
      "level": "h2",
      "text": "Write your Worker",
      "id": "write-your-worker"
    },
    {
      "level": "h2",
      "text": "Run the Worker locally with Wrangler",
      "id": "run-the-worker-locally-with-wrangler"
    },
    {
      "level": "h2",
      "text": "Deploy to Cloudflare",
      "id": "deploy-to-cloudflare"
    },
    {
      "level": "h2",
      "text": "Optional: Clean up",
      "id": "optional:-clean-up"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Create a Worker application",
      "id": "1.-create-a-worker-application"
    },
    {
      "level": "h2",
      "text": "2. Upload a fine-tune document to R2",
      "id": "2.-upload-a-fine-tune-document-to-r2"
    },
    {
      "level": "h2",
      "text": "3. Bind your bucket to the Worker",
      "id": "3.-bind-your-bucket-to-the-worker"
    },
    {
      "level": "h2",
      "text": "4. Initialize your Worker application",
      "id": "4.-initialize-your-worker-application"
    },
    {
      "level": "h2",
      "text": "5. Read R2 files and upload them to OpenAI",
      "id": "5.-read-r2-files-and-upload-them-to-openai"
    },
    {
      "level": "h2",
      "text": "6. Create fine-tuned models",
      "id": "6.-create-fine-tuned-models"
    },
    {
      "level": "h2",
      "text": "7. List all fine-tune jobs",
      "id": "7.-list-all-fine-tune-jobs"
    },
    {
      "level": "h2",
      "text": "8. Deploy your application",
      "id": "8.-deploy-your-application"
    },
    {
      "level": "h2",
      "text": "9. View the fine-tune job status and use the model",
      "id": "9.-view-the-fine-tune-job-status-and-use-the-model"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "Clone the chat application repository",
      "id": "clone-the-chat-application-repository"
    },
    {
      "level": "h2",
      "text": "Authenticate Wrangler",
      "id": "authenticate-wrangler"
    },
    {
      "level": "h2",
      "text": "Deploy your project",
      "id": "deploy-your-project"
    },
    {
      "level": "h2",
      "text": "Uninstall your application",
      "id": "uninstall-your-application"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "Quick start",
      "id": "quick-start"
    },
    {
      "level": "h2",
      "text": "1. Create a new Cloudflare Workers project",
      "id": "1.-create-a-new-cloudflare-workers-project"
    },
    {
      "level": "h2",
      "text": "2. Install Express and dependencies",
      "id": "2.-install-express-and-dependencies"
    },
    {
      "level": "h2",
      "text": "3. Create a D1 database",
      "id": "3.-create-a-d1-database"
    },
    {
      "level": "h2",
      "text": "4. Create database schema",
      "id": "4.-create-database-schema"
    },
    {
      "level": "h2",
      "text": "5. Initialize Express application",
      "id": "5.-initialize-express-application"
    },
    {
      "level": "h2",
      "text": "6. Implement read operations",
      "id": "6.-implement-read-operations"
    },
    {
      "level": "h2",
      "text": "7. Implement create operation",
      "id": "7.-implement-create-operation"
    },
    {
      "level": "h2",
      "text": "8. Implement update operation",
      "id": "8.-implement-update-operation"
    },
    {
      "level": "h2",
      "text": "9. Implement delete operation",
      "id": "9.-implement-delete-operation"
    },
    {
      "level": "h2",
      "text": "10. Test locally",
      "id": "10.-test-locally"
    },
    {
      "level": "h2",
      "text": "11. Deploy to Cloudflare Workers",
      "id": "11.-deploy-to-cloudflare-workers"
    },
    {
      "level": "h2",
      "text": "12. Test production deployment",
      "id": "12.-test-production-deployment"
    },
    {
      "level": "h2",
      "text": "Conclusion",
      "id": "conclusion"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "Learning goals",
      "id": "learning-goals"
    },
    {
      "level": "h2",
      "text": "Upload your image",
      "id": "upload-your-image"
    },
    {
      "level": "h3",
      "text": "Upload with the dashboard",
      "id": "upload-with-the-dashboard"
    },
    {
      "level": "h3",
      "text": "Upload with the API",
      "id": "upload-with-the-api"
    },
    {
      "level": "h2",
      "text": "Create a Worker to transform text to image",
      "id": "create-a-worker-to-transform-text-to-image"
    },
    {
      "level": "h2",
      "text": "Create a Worker to display the original image",
      "id": "create-a-worker-to-display-the-original-image"
    },
    {
      "level": "h2",
      "text": "Add custom text on your image",
      "id": "add-custom-text-on-your-image"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "Create a Worker project",
      "id": "create-a-worker-project"
    },
    {
      "level": "h2",
      "text": "Configure GitHub",
      "id": "configure-github"
    },
    {
      "level": "h2",
      "text": "Parsing the response",
      "id": "parsing-the-response"
    },
    {
      "level": "h2",
      "text": "Sending a text with Twilio",
      "id": "sending-a-text-with-twilio"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "1. Create a form",
      "id": "1.-create-a-form"
    },
    {
      "level": "h2",
      "text": "2. Create a Worker project",
      "id": "2.-create-a-worker-project"
    },
    {
      "level": "h2",
      "text": "3. Configure an Airtable base",
      "id": "3.-configure-an-airtable-base"
    },
    {
      "level": "h2",
      "text": "4. Submit data to Airtable",
      "id": "4.-submit-data-to-airtable"
    },
    {
      "level": "h2",
      "text": "Conclusion",
      "id": "conclusion"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Create a Worker application",
      "id": "1.-create-a-worker-application"
    },
    {
      "level": "h2",
      "text": "2. Enable Node.js compatibility",
      "id": "2.-enable-node.js-compatibility"
    },
    {
      "level": "h2",
      "text": "3. Create a Hyperdrive configuration",
      "id": "3.-create-a-hyperdrive-configuration"
    },
    {
      "level": "h2",
      "text": "4. Query your database from your Worker",
      "id": "4.-query-your-database-from-your-worker"
    },
    {
      "level": "h2",
      "text": "5. Deploy your Worker",
      "id": "5.-deploy-your-worker"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "What you will learn",
      "id": "what-you-will-learn"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "1. Create a new Worker project",
      "id": "1.-create-a-new-worker-project"
    },
    {
      "level": "h2",
      "text": "2. Make a request to OpenAI",
      "id": "2.-make-a-request-to-openai"
    },
    {
      "level": "h2",
      "text": "3. Building your `read_website_content()` function",
      "id": "3.-building-your-`read_website_content()`-function"
    },
    {
      "level": "h2",
      "text": "4. Process the Assistant's Messages",
      "id": "4.-process-the-assistant's-messages"
    },
    {
      "level": "h2",
      "text": "5. Deploy your Worker application",
      "id": "5.-deploy-your-worker-application"
    },
    {
      "level": "h2",
      "text": "6. Next steps",
      "id": "6.-next-steps"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Create a Worker application",
      "id": "1.-create-a-worker-application"
    },
    {
      "level": "h3",
      "text": "Enable Node.js compatibility",
      "id": "enable-node.js-compatibility"
    },
    {
      "level": "h2",
      "text": "2. Add the PostgreSQL connection library",
      "id": "2.-add-the-postgresql-connection-library"
    },
    {
      "level": "h2",
      "text": "3. Configure the connection to the PostgreSQL database",
      "id": "3.-configure-the-connection-to-the-postgresql-database"
    },
    {
      "level": "h3",
      "text": "Use a connection string",
      "id": "use-a-connection-string"
    },
    {
      "level": "h3",
      "text": "Set explicit parameters",
      "id": "set-explicit-parameters"
    },
    {
      "level": "h2",
      "text": "4. Connect to the PostgreSQL database in the Worker",
      "id": "4.-connect-to-the-postgresql-database-in-the-worker"
    },
    {
      "level": "h3",
      "text": "Use a connection string",
      "id": "use-a-connection-string"
    },
    {
      "level": "h3",
      "text": "Set explicit parameters",
      "id": "set-explicit-parameters"
    },
    {
      "level": "h2",
      "text": "5. Interact with the products database",
      "id": "5.-interact-with-the-products-database"
    },
    {
      "level": "h2",
      "text": "6. Deploy your Worker",
      "id": "6.-deploy-your-worker"
    },
    {
      "level": "h2",
      "text": "7. Insert a new row into the products database",
      "id": "7.-insert-a-new-row-into-the-products-database"
    },
    {
      "level": "h2",
      "text": "8. Use Hyperdrive to accelerate queries",
      "id": "8.-use-hyperdrive-to-accelerate-queries"
    },
    {
      "level": "h2",
      "text": "9. Redeploy your Worker",
      "id": "9.-redeploy-your-worker"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "Create a Worker project",
      "id": "create-a-worker-project"
    },
    {
      "level": "h2",
      "text": "Add your domain to Postmark",
      "id": "add-your-domain-to-postmark"
    },
    {
      "level": "h2",
      "text": "Send emails from your Worker",
      "id": "send-emails-from-your-worker"
    },
    {
      "level": "h2",
      "text": "Move API token to Secrets",
      "id": "move-api-token-to-secrets"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "Create a Worker project",
      "id": "create-a-worker-project"
    },
    {
      "level": "h2",
      "text": "Add your domain to Resend",
      "id": "add-your-domain-to-resend"
    },
    {
      "level": "h2",
      "text": "Send emails from your Worker",
      "id": "send-emails-from-your-worker"
    },
    {
      "level": "h2",
      "text": "Move API keys to Secrets",
      "id": "move-api-keys-to-secrets"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "Create a Worker application",
      "id": "create-a-worker-application"
    },
    {
      "level": "h2",
      "text": "Create an R2 bucket",
      "id": "create-an-r2-bucket"
    },
    {
      "level": "h2",
      "text": "Configure access to an R2 bucket",
      "id": "configure-access-to-an-r2-bucket"
    },
    {
      "level": "h2",
      "text": "Fetch from an R2 bucket",
      "id": "fetch-from-an-r2-bucket"
    },
    {
      "level": "h2",
      "text": "Upload securely to an R2 bucket",
      "id": "upload-securely-to-an-r2-bucket"
    },
    {
      "level": "h2",
      "text": "Deploy your Worker application",
      "id": "deploy-your-worker-application"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Create a new Worker project",
      "id": "1.-create-a-new-worker-project"
    },
    {
      "level": "h2",
      "text": "2. Setup Prisma in your project",
      "id": "2.-setup-prisma-in-your-project"
    },
    {
      "level": "h3",
      "text": "2.1. Install required dependencies",
      "id": "2.1.-install-required-dependencies"
    },
    {
      "level": "h3",
      "text": "2.2. Create a Prisma Postgres database and initialize Prisma",
      "id": "2.2.-create-a-prisma-postgres-database-and-initialize-prisma"
    },
    {
      "level": "h3",
      "text": "2.3. Prepare environment variables",
      "id": "2.3.-prepare-environment-variables"
    },
    {
      "level": "h3",
      "text": "2.4. Apply database schema changes",
      "id": "2.4.-apply-database-schema-changes"
    },
    {
      "level": "h2",
      "text": "3. Develop the application",
      "id": "3.-develop-the-application"
    },
    {
      "level": "h2",
      "text": "4. Deploy the application to Cloudflare",
      "id": "4.-deploy-the-application-to-cloudflare"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Create your Worker project in Rust",
      "id": "1.-create-your-worker-project-in-rust"
    },
    {
      "level": "h2",
      "text": "2. Create a KV namespace",
      "id": "2.-create-a-kv-namespace"
    },
    {
      "level": "h2",
      "text": "3. Write data to KV",
      "id": "3.-write-data-to-kv"
    },
    {
      "level": "h2",
      "text": "4. Read data from KV",
      "id": "4.-read-data-from-kv"
    },
    {
      "level": "h2",
      "text": "5. Deploy your project",
      "id": "5.-deploy-your-project"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Start with a basic `package.json`",
      "id": "start-with-a-basic-`package.json`"
    },
    {
      "level": "h2",
      "text": "Install the dependencies",
      "id": "install-the-dependencies"
    },
    {
      "level": "h2",
      "text": "Create your Vite config file and include the Cloudflare plugin",
      "id": "create-your-vite-config-file-and-include-the-cloudflare-plugin"
    },
    {
      "level": "h2",
      "text": "Create your Worker config file",
      "id": "create-your-worker-config-file"
    },
    {
      "level": "h2",
      "text": "Create your Worker entry file",
      "id": "create-your-worker-entry-file"
    },
    {
      "level": "h2",
      "text": "Dev, build, preview and deploy",
      "id": "dev,-build,-preview-and-deploy"
    },
    {
      "level": "h2",
      "text": "Introduction",
      "id": "introduction"
    },
    {
      "level": "h2",
      "text": "Set up and configure the React SPA",
      "id": "set-up-and-configure-the-react-spa"
    },
    {
      "level": "h3",
      "text": "Scaffold a Vite project",
      "id": "scaffold-a-vite-project"
    },
    {
      "level": "h3",
      "text": "Add the Cloudflare dependencies",
      "id": "add-the-cloudflare-dependencies"
    },
    {
      "level": "h3",
      "text": "Add the plugin to your Vite config",
      "id": "add-the-plugin-to-your-vite-config"
    },
    {
      "level": "h3",
      "text": "Create your Worker config file",
      "id": "create-your-worker-config-file"
    },
    {
      "level": "h3",
      "text": "Update the .gitignore file",
      "id": "update-the-.gitignore-file"
    },
    {
      "level": "h3",
      "text": "Run the development server",
      "id": "run-the-development-server"
    },
    {
      "level": "h2",
      "text": "Add an API Worker",
      "id": "add-an-api-worker"
    },
    {
      "level": "h3",
      "text": "Configure TypeScript for your Worker code",
      "id": "configure-typescript-for-your-worker-code"
    },
    {
      "level": "h3",
      "text": "Add to your Worker configuration",
      "id": "add-to-your-worker-configuration"
    },
    {
      "level": "h3",
      "text": "Add your API Worker",
      "id": "add-your-api-worker"
    },
    {
      "level": "h3",
      "text": "Call the API from the client",
      "id": "call-the-api-from-the-client"
    },
    {
      "level": "h3",
      "text": "Build your application",
      "id": "build-your-application"
    },
    {
      "level": "h3",
      "text": "Preview your application",
      "id": "preview-your-application"
    },
    {
      "level": "h3",
      "text": "Deploy to Cloudflare",
      "id": "deploy-to-cloudflare"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "`unstable_startWorker`",
      "id": "`unstable_startworker`"
    },
    {
      "level": "h2",
      "text": "`unstable_dev`",
      "id": "`unstable_dev`"
    },
    {
      "level": "h3",
      "text": "Constructor",
      "id": "constructor"
    },
    {
      "level": "h3",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h3",
      "text": "Return Type",
      "id": "return-type"
    },
    {
      "level": "h3",
      "text": "Usage",
      "id": "usage"
    },
    {
      "level": "h2",
      "text": "`getPlatformProxy`",
      "id": "`getplatformproxy`"
    },
    {
      "level": "h3",
      "text": "Syntax",
      "id": "syntax"
    },
    {
      "level": "h3",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h3",
      "text": "Return Type",
      "id": "return-type"
    },
    {
      "level": "h3",
      "text": "Usage",
      "id": "usage"
    },
    {
      "level": "h3",
      "text": "Supported bindings",
      "id": "supported-bindings"
    },
    {
      "level": "h2",
      "text": "Including non-JavaScript modules",
      "id": "including-non-javascript-modules"
    },
    {
      "level": "h2",
      "text": "Find additional modules",
      "id": "find-additional-modules"
    },
    {
      "level": "h2",
      "text": "Conditional exports",
      "id": "conditional-exports"
    },
    {
      "level": "h2",
      "text": "Disable bundling",
      "id": "disable-bundling"
    },
    {
      "level": "h2",
      "text": "Generated Wrangler configuration",
      "id": "generated-wrangler-configuration"
    },
    {
      "level": "h2",
      "text": "How to run Wrangler commands",
      "id": "how-to-run-wrangler-commands"
    },
    {
      "level": "h2",
      "text": "`docs`",
      "id": "`docs`"
    },
    {
      "level": "h2",
      "text": "`init`",
      "id": "`init`"
    },
    {
      "level": "h2",
      "text": "`containers`",
      "id": "`containers`"
    },
    {
      "level": "h3",
      "text": "`build`",
      "id": "`build`"
    },
    {
      "level": "h3",
      "text": "`delete`",
      "id": "`delete`"
    },
    {
      "level": "h3",
      "text": "`images`",
      "id": "`images`"
    },
    {
      "level": "h3",
      "text": "`registries`",
      "id": "`registries`"
    },
    {
      "level": "h3",
      "text": "`info`",
      "id": "`info`"
    },
    {
      "level": "h3",
      "text": "`list`",
      "id": "`list`"
    },
    {
      "level": "h3",
      "text": "`push`",
      "id": "`push`"
    },
    {
      "level": "h2",
      "text": "`d1`",
      "id": "`d1`"
    },
    {
      "level": "h3",
      "text": "`d1 create`",
      "id": "`d1-create`"
    },
    {
      "level": "h3",
      "text": "`d1 info`",
      "id": "`d1-info`"
    },
    {
      "level": "h3",
      "text": "`d1 list`",
      "id": "`d1-list`"
    },
    {
      "level": "h3",
      "text": "`d1 delete`",
      "id": "`d1-delete`"
    },
    {
      "level": "h3",
      "text": "`d1 execute`",
      "id": "`d1-execute`"
    },
    {
      "level": "h3",
      "text": "`d1 export`",
      "id": "`d1-export`"
    },
    {
      "level": "h3",
      "text": "`d1 time-travel info`",
      "id": "`d1-time-travel-info`"
    },
    {
      "level": "h3",
      "text": "`d1 time-travel restore`",
      "id": "`d1-time-travel-restore`"
    },
    {
      "level": "h3",
      "text": "`d1 migrations create`",
      "id": "`d1-migrations-create`"
    },
    {
      "level": "h3",
      "text": "`d1 migrations list`",
      "id": "`d1-migrations-list`"
    },
    {
      "level": "h3",
      "text": "`d1 migrations apply`",
      "id": "`d1-migrations-apply`"
    },
    {
      "level": "h3",
      "text": "`d1 insights`",
      "id": "`d1-insights`"
    },
    {
      "level": "h2",
      "text": "`hyperdrive`",
      "id": "`hyperdrive`"
    },
    {
      "level": "h3",
      "text": "`hyperdrive create`",
      "id": "`hyperdrive-create`"
    },
    {
      "level": "h3",
      "text": "`hyperdrive delete`",
      "id": "`hyperdrive-delete`"
    },
    {
      "level": "h3",
      "text": "`hyperdrive get`",
      "id": "`hyperdrive-get`"
    },
    {
      "level": "h3",
      "text": "`hyperdrive list`",
      "id": "`hyperdrive-list`"
    },
    {
      "level": "h3",
      "text": "`hyperdrive update`",
      "id": "`hyperdrive-update`"
    },
    {
      "level": "h2",
      "text": "`vectorize`",
      "id": "`vectorize`"
    },
    {
      "level": "h3",
      "text": "`vectorize create`",
      "id": "`vectorize-create`"
    },
    {
      "level": "h3",
      "text": "`vectorize delete`",
      "id": "`vectorize-delete`"
    },
    {
      "level": "h3",
      "text": "`vectorize get`",
      "id": "`vectorize-get`"
    },
    {
      "level": "h3",
      "text": "`vectorize list`",
      "id": "`vectorize-list`"
    },
    {
      "level": "h3",
      "text": "`vectorize list-vectors`",
      "id": "`vectorize-list-vectors`"
    },
    {
      "level": "h3",
      "text": "`vectorize query`",
      "id": "`vectorize-query`"
    },
    {
      "level": "h3",
      "text": "`vectorize insert`",
      "id": "`vectorize-insert`"
    },
    {
      "level": "h3",
      "text": "`vectorize upsert`",
      "id": "`vectorize-upsert`"
    },
    {
      "level": "h3",
      "text": "`vectorize get-vectors`",
      "id": "`vectorize-get-vectors`"
    },
    {
      "level": "h3",
      "text": "`vectorize delete-vectors`",
      "id": "`vectorize-delete-vectors`"
    },
    {
      "level": "h3",
      "text": "`vectorize info`",
      "id": "`vectorize-info`"
    },
    {
      "level": "h3",
      "text": "`vectorize create-metadata-index`",
      "id": "`vectorize-create-metadata-index`"
    },
    {
      "level": "h3",
      "text": "`vectorize list-metadata-index`",
      "id": "`vectorize-list-metadata-index`"
    },
    {
      "level": "h3",
      "text": "`vectorize delete-metadata-index`",
      "id": "`vectorize-delete-metadata-index`"
    },
    {
      "level": "h2",
      "text": "`dev`",
      "id": "`dev`"
    },
    {
      "level": "h2",
      "text": "`deploy`",
      "id": "`deploy`"
    },
    {
      "level": "h2",
      "text": "`delete`",
      "id": "`delete`"
    },
    {
      "level": "h2",
      "text": "`kv namespace`",
      "id": "`kv-namespace`"
    },
    {
      "level": "h3",
      "text": "`kv namespace create`",
      "id": "`kv-namespace-create`"
    },
    {
      "level": "h3",
      "text": "`kv namespace list`",
      "id": "`kv-namespace-list`"
    },
    {
      "level": "h3",
      "text": "`kv namespace delete`",
      "id": "`kv-namespace-delete`"
    },
    {
      "level": "h3",
      "text": "`kv namespace rename`",
      "id": "`kv-namespace-rename`"
    },
    {
      "level": "h2",
      "text": "`kv key`",
      "id": "`kv-key`"
    },
    {
      "level": "h3",
      "text": "`kv key put`",
      "id": "`kv-key-put`"
    },
    {
      "level": "h3",
      "text": "`kv key list`",
      "id": "`kv-key-list`"
    },
    {
      "level": "h3",
      "text": "`kv key get`",
      "id": "`kv-key-get`"
    },
    {
      "level": "h3",
      "text": "`kv key delete`",
      "id": "`kv-key-delete`"
    },
    {
      "level": "h2",
      "text": "`kv bulk`",
      "id": "`kv-bulk`"
    },
    {
      "level": "h3",
      "text": "`kv bulk get`",
      "id": "`kv-bulk-get`"
    },
    {
      "level": "h3",
      "text": "`kv bulk put`",
      "id": "`kv-bulk-put`"
    },
    {
      "level": "h3",
      "text": "`kv bulk delete`",
      "id": "`kv-bulk-delete`"
    },
    {
      "level": "h2",
      "text": "`r2 bucket`",
      "id": "`r2-bucket`"
    },
    {
      "level": "h3",
      "text": "`r2 bucket create`",
      "id": "`r2-bucket-create`"
    },
    {
      "level": "h3",
      "text": "`r2 bucket info`",
      "id": "`r2-bucket-info`"
    },
    {
      "level": "h3",
      "text": "`r2 bucket delete`",
      "id": "`r2-bucket-delete`"
    },
    {
      "level": "h3",
      "text": "`r2 bucket list`",
      "id": "`r2-bucket-list`"
    },
    {
      "level": "h3",
      "text": "`r2 bucket catalog enable`",
      "id": "`r2-bucket-catalog-enable`"
    },
    {
      "level": "h3",
      "text": "`r2 bucket catalog disable`",
      "id": "`r2-bucket-catalog-disable`"
    },
    {
      "level": "h3",
      "text": "`r2 bucket catalog get`",
      "id": "`r2-bucket-catalog-get`"
    },
    {
      "level": "h3",
      "text": "`r2 bucket catalog compaction enable`",
      "id": "`r2-bucket-catalog-compaction-enable`"
    }
  ],
  "url": "llms-txt#ensure-you-specify-the-secret-name-exactly:-your-worker-will-need-to-reference-it-later.",
  "links": []
}