{
  "title": "Note: This is the value that was successfully PUT above",
  "content": "js\ninterface Env {\n  MY_BUCKET: R2Bucket;\n}\n\nexport default {\n  async fetch(\n    request,\n    env,\n    ctx\n  ): Promise<Response> {\n    const bucket = env.MY_BUCKET;\n\nconst url = new URL(request.url);\n    const key = url.pathname.slice(1);\n    const action = url.searchParams.get(\"action\");\n\nif (action === null) {\n      return new Response(\"Missing action type\", { status: 400 });\n    }\n\n// Route the request based on the HTTP method and action type\n    switch (request.method) {\n      case \"POST\":\n        switch (action) {\n          case \"mpu-create\": {\n            const multipartUpload = await bucket.createMultipartUpload(key);\n            return new Response(\n              JSON.stringify({\n                key: multipartUpload.key,\n                uploadId: multipartUpload.uploadId,\n              })\n            );\n          }\n          case \"mpu-complete\": {\n            const uploadId = url.searchParams.get(\"uploadId\");\n            if (uploadId === null) {\n              return new Response(\"Missing uploadId\", { status: 400 });\n            }\n\nconst multipartUpload = env.MY_BUCKET.resumeMultipartUpload(\n              key,\n              uploadId\n            );\n\ninterface completeBody {\n              parts: R2UploadedPart[];\n            }\n            const completeBody: completeBody = await request.json();\n            if (completeBody === null) {\n              return new Response(\"Missing or incomplete body\", {\n                status: 400,\n              });\n            }\n\n// Error handling in case the multipart upload does not exist anymore\n            try {\n              const object = await multipartUpload.complete(completeBody.parts);\n              return new Response(null, {\n                headers: {\n                  etag: object.httpEtag,\n                },\n              });\n            } catch (error: any) {\n              return new Response(error.message, { status: 400 });\n            }\n          }\n          default:\n            return new Response(`Unknown action ${action} for POST`, {\n              status: 400,\n            });\n        }\n      case \"PUT\":\n        switch (action) {\n          case \"mpu-uploadpart\": {\n            const uploadId = url.searchParams.get(\"uploadId\");\n            const partNumberString = url.searchParams.get(\"partNumber\");\n            if (partNumberString === null || uploadId === null) {\n              return new Response(\"Missing partNumber or uploadId\", {\n                status: 400,\n              });\n            }\n            if (request.body === null) {\n              return new Response(\"Missing request body\", { status: 400 });\n            }\n\nconst partNumber = parseInt(partNumberString);\n            const multipartUpload = env.MY_BUCKET.resumeMultipartUpload(\n              key,\n              uploadId\n            );\n            try {\n              const uploadedPart: R2UploadedPart =\n                await multipartUpload.uploadPart(partNumber, request.body);\n              return new Response(JSON.stringify(uploadedPart));\n            } catch (error: any) {\n              return new Response(error.message, { status: 400 });\n            }\n          }\n          default:\n            return new Response(`Unknown action ${action} for PUT`, {\n              status: 400,\n            });\n        }\n      case \"GET\":\n        if (action !== \"get\") {\n          return new Response(`Unknown action ${action} for GET`, {\n            status: 400,\n          });\n        }\n        const object = await env.MY_BUCKET.get(key);\n        if (object === null) {\n          return new Response(\"Object Not Found\", { status: 404 });\n        }\n        const headers = new Headers();\n        object.writeHttpMetadata(headers);\n        headers.set(\"etag\", object.httpEtag);\n        return new Response(object.body, { headers });\n      case \"DELETE\":\n        switch (action) {\n          case \"mpu-abort\": {\n            const uploadId = url.searchParams.get(\"uploadId\");\n            if (uploadId === null) {\n              return new Response(\"Missing uploadId\", { status: 400 });\n            }\n            const multipartUpload = env.MY_BUCKET.resumeMultipartUpload(\n              key,\n              uploadId\n            );\n\ntry {\n              multipartUpload.abort();\n            } catch (error: any) {\n              return new Response(error.message, { status: 400 });\n            }\n            return new Response(null, { status: 204 });\n          }\n          case \"delete\": {\n            await env.MY_BUCKET.delete(key);\n            return new Response(null, { status: 204 });\n          }\n          default:\n            return new Response(`Unknown action ${action} for DELETE`, {\n              status: 400,\n            });\n        }\n      default:\n        return new Response(\"Method Not Allowed\", {\n          status: 405,\n          headers: { Allow: \"PUT, POST, GET, DELETE\" },\n        });\n    }\n  },\n} satisfies ExportedHandler<Env>;\npython\nimport math\nimport os\nimport requests\nfrom requests.adapters import HTTPAdapter, Retry\nimport sys\nimport concurrent.futures",
  "code_samples": [
    {
      "code": "By completing this guide, you have successfully installed Wrangler and deployed your R2 bucket to Cloudflare.\n\n## Related resources\n\n1. [Workers Tutorials](https://developers.cloudflare.com/workers/tutorials/)\n2. [Workers Examples](https://developers.cloudflare.com/workers/examples/)\n\n</page>\n\n<page>\n---\ntitle: Use the R2 multipart API from Workers Â· Cloudflare R2 docs\ndescription: >-\n  By following this guide, you will create a Worker through which your\n  applications can perform multipart uploads.\n\n  This example worker could serve as a basis for your own use case where you can\n  add authentication to the worker, or even add extra validation logic when\n  uploading each part.\n\n  This guide also contains an example Python application that uploads files to\n  this worker.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/r2/api/workers/workers-multipart-usage/\n  md: https://developers.cloudflare.com/r2/api/workers/workers-multipart-usage/index.md\n---\n\nBy following this guide, you will create a Worker through which your applications can perform multipart uploads. This example worker could serve as a basis for your own use case where you can add authentication to the worker, or even add extra validation logic when uploading each part. This guide also contains an example Python application that uploads files to this worker.\n\nThis guide assumes you have set up the [R2 binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/) for your Worker. Refer to [Use R2 from Workers](https://developers.cloudflare.com/r2/api/workers/workers-api-usage) for instructions on setting up an R2 binding.\n\n## An example Worker using the multipart API\n\nThe following example Worker exposes an HTTP API which enables applications to use the multipart API through the Worker.\n\nIn this example, each request is routed based on the HTTP method and the action request parameter. As your Worker becomes more complicated, consider utilizing a serverless web framework such as [Hono](https://honojs.dev/) to handle the routing for you.\n\nThe following example Worker includes any new information about the state of the multipart upload in the response to each request. For the request which creates the multipart upload, the `uploadId` is returned. For requests uploading a part, the part number and `etag` are returned. In turn, the client keeps track of this state, and includes the uploadId in subsequent requests, and the `etag` and part number of each part when completing a multipart upload.\n\nAdd the following code to your project's `index.js` file and replace `MY_BUCKET` with your bucket's name:",
      "language": "unknown"
    },
    {
      "code": "After you have updated your Worker with the above code, run `npx wrangler deploy`.\n\nYou can now use this Worker to perform multipart uploads. You can either send requests from your existing application to this Worker to perform uploads or use a script to upload files through this Worker.\n\nThe next section is optional and shows an example of a Python script which uploads a chosen file on your machine to your Worker.\n\n## Perform a multipart upload with your Worker (optional)\n\nThis example application uploads a local file to the Worker in multiple parts. It uses Python's built-in `ThreadPoolExecutor` to parallelize the uploading of parts to the Worker, which increases upload speeds. HTTP requests to the Worker are made with the [requests](https://pypi.org/project/requests/) library.\n\nUtilizing the multipart API in this way also allows you to use your Worker to upload files larger than the [Workers request body size limit](https://developers.cloudflare.com/workers/platform/limits#request-limits). The uploading of individual parts is still subject to this limit.\n\nSave the following code in a file named `mpuscript.py` on your local machine. Change the `worker_endpoint variable` to where your worker is deployed. Pass the file you want to upload as an argument when running this script: `python3 mpuscript.py myfile`. This will upload the file `myfile` from your machine to your bucket through the Worker.",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "An example Worker using the multipart API",
      "id": "an-example-worker-using-the-multipart-api"
    },
    {
      "level": "h2",
      "text": "Perform a multipart upload with your Worker (optional)",
      "id": "perform-a-multipart-upload-with-your-worker-(optional)"
    }
  ],
  "url": "llms-txt#note:-this-is-the-value-that-was-successfully-put-above",
  "links": []
}