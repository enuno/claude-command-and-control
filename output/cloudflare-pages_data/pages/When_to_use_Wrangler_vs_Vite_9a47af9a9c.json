{
  "title": "When to use Wrangler vs Vite",
  "content": "Deciding between Wrangler and the Cloudflare Vite plugin depends on your project's focus and development workflow. Here are some quick guidelines to help you choose:\n\n## When to use Wrangler\n\n* **Backend & Workers-focused:** If you're primarily building APIs, serverless functions, or background tasks, use Wrangler.\n\n* **Remote development:** If your project needs the ability to run your worker remotely on Cloudflare's network, use Wrangler's `--remote` flag.\n\n* **Simple frontends:** If you have minimal frontend requirements and don’t need hot reloading or advanced bundling, Wrangler may be sufficient.\n\n## When to use the Cloudflare Vite Plugin\n\nUse the [Vite plugin](https://developers.cloudflare.com/workers/vite-plugin/) for:\n\n* **Frontend-centric development:** If you already use Vite with modern frontend frameworks like React, Vue, Svelte, or Solid, the Vite plugin integrates into your development workflow.\n\n* **React Router v7:** If you are using [React Router v7](https://reactrouter.com/) (the successor to Remix), it is officially supported by the Vite plugin as a full-stack SSR framework.\n\n* **Rapid iteration (HMR):** If you need near-instant updates in the browser, the Vite plugin provides [Hot Module Replacement (HMR)](https://vite.dev/guide/features.html#hot-module-replacement) during local development.\n\n* **Advanced optimizations:** If you require more advanced optimizations (code splitting, efficient bundling, CSS handling, build time transformations, etc.), Vite is a strong fit.\n\n* **Greater flexibility:** Due to Vite's advanced configuration options and large ecosystem of plugins, there is more flexibility to customize your development experience and build output.\n\n<page>\n---\ntitle: AI & agents · Cloudflare Workers docs\nlastUpdated: 2025-06-05T13:25:05.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/workers/framework-guides/ai-and-agents/\n  md: https://developers.cloudflare.com/workers/framework-guides/ai-and-agents/index.md\n---\n\nCreate full-stack applications deployed to Cloudflare Workers with AI & agent frameworks.\n\n* [Agents SDK](https://developers.cloudflare.com/agents/)\n* [LangChain](https://developers.cloudflare.com/workers/languages/python/packages/langchain/)\n\n<page>\n---\ntitle: APIs · Cloudflare Workers docs\nlastUpdated: 2025-06-05T13:25:05.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/workers/framework-guides/apis/\n  md: https://developers.cloudflare.com/workers/framework-guides/apis/index.md\n---\n\nCreate full-stack applications deployed to Cloudflare Workers using APIs.\n\n* [FastAPI](https://developers.cloudflare.com/workers/languages/python/packages/fastapi/)\n* [Hono](https://developers.cloudflare.com/workers/framework-guides/web-apps/more-web-frameworks/hono/)\n\n<page>\n---\ntitle: Mobile applications · Cloudflare Workers docs\nlastUpdated: 2025-06-05T13:25:05.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/workers/framework-guides/mobile-apps/\n  md: https://developers.cloudflare.com/workers/framework-guides/mobile-apps/index.md\n---\n\nCreate full-stack mobile applications deployed to Cloudflare Workers.\n\n* [Expo](https://docs.expo.dev/eas/hosting/reference/worker-runtime/)\n\n<page>\n---\ntitle: Web applications · Cloudflare Workers docs\nlastUpdated: 2025-06-05T13:25:05.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/workers/framework-guides/web-apps/\n  md: https://developers.cloudflare.com/workers/framework-guides/web-apps/index.md\n---\n\nCreate full-stack web applications deployed to Cloudflare Workers.\n\n* [React + Vite](https://developers.cloudflare.com/workers/framework-guides/web-apps/react/)\n\n* [Astro](https://developers.cloudflare.com/workers/framework-guides/web-apps/astro/)\n\n* [React Router (formerly Remix)](https://developers.cloudflare.com/workers/framework-guides/web-apps/react-router/)\n\n* [Next.js](https://developers.cloudflare.com/workers/framework-guides/web-apps/nextjs/)\n\n* [Vue](https://developers.cloudflare.com/workers/framework-guides/web-apps/vue/)\n\n* [RedwoodSDK](https://developers.cloudflare.com/workers/framework-guides/web-apps/redwoodsdk/)\n\n* [TanStack Start](https://developers.cloudflare.com/workers/framework-guides/web-apps/tanstack-start/)\n\n* [SvelteKit](https://developers.cloudflare.com/workers/framework-guides/web-apps/sveltekit/)\n\n* [More guides...](https://developers.cloudflare.com/workers/framework-guides/web-apps/more-web-frameworks/)\n\n* [Angular](https://developers.cloudflare.com/workers/framework-guides/web-apps/more-web-frameworks/angular/)\n  * [Docusaurus](https://developers.cloudflare.com/workers/framework-guides/web-apps/more-web-frameworks/docusaurus/)\n  * [Gatsby](https://developers.cloudflare.com/workers/framework-guides/web-apps/more-web-frameworks/gatsby/)\n  * [Hono](https://developers.cloudflare.com/workers/framework-guides/web-apps/more-web-frameworks/hono/)\n  * [Nuxt](https://developers.cloudflare.com/workers/framework-guides/web-apps/more-web-frameworks/nuxt/)\n  * [Qwik](https://developers.cloudflare.com/workers/framework-guides/web-apps/more-web-frameworks/qwik/)\n  * [Solid](https://developers.cloudflare.com/workers/framework-guides/web-apps/more-web-frameworks/solid/)\n  * [Waku](https://developers.cloudflare.com/workers/framework-guides/web-apps/more-web-frameworks/waku/)\n\n<page>\n---\ntitle: 103 Early Hints · Cloudflare Workers docs\ndescription: Allow a client to request static assets while waiting for the HTML response.\nlastUpdated: 2025-09-17T11:26:09.000Z\nchatbotDeprioritize: false\ntags: Middleware,Headers,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/103-early-hints/\n  md: https://developers.cloudflare.com/workers/examples/103-early-hints/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/103-early-hints)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n`103` Early Hints is an HTTP status code designed to speed up content delivery. When enabled, Cloudflare can cache the `Link` headers marked with preload and/or preconnect from HTML pages and serve them in a `103` Early Hints response before reaching the origin server. Browsers can use these hints to fetch linked assets while waiting for the origin’s final response, dramatically improving page load speeds.\n\nTo ensure Early Hints are enabled on your zone:\n\n1. In the Cloudflare dashboard, go to the **Speed settings** page.\n\n[Go to **Settings**](https://dash.cloudflare.com/?to=/:account/:zone/speed/optimization)\n\n2. Go to **Content Optimization**.\n\n3. Enable the **Early Hints** toggle to on.\n\nYou can return `Link` headers from a Worker running on your zone to speed up your page load times.\n\n<page>\n---\ntitle: A/B testing with same-URL direct access · Cloudflare Workers docs\ndescription: Set up an A/B test by controlling what response is served based on\n  cookies. This version supports passing the request through to test and control\n  on the origin, bypassing random assignment.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/ab-testing/\n  md: https://developers.cloudflare.com/workers/examples/ab-testing/index.md\n---\n\n<page>\n---\ntitle: Accessing the Cloudflare Object · Cloudflare Workers docs\ndescription: Access custom Cloudflare properties and control how Cloudflare\n  features are applied to every request.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/accessing-the-cloudflare-object/\n  md: https://developers.cloudflare.com/workers/examples/accessing-the-cloudflare-object/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/accessing-the-cloudflare-object)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Aggregate requests · Cloudflare Workers docs\ndescription: Send two GET request to two urls and aggregates the responses into\n  one response.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/aggregate-requests/\n  md: https://developers.cloudflare.com/workers/examples/aggregate-requests/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/aggregate-requests)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Alter headers · Cloudflare Workers docs\ndescription: Example of how to add, change, or delete headers sent in a request\n  or returned in a response.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Headers,Middleware,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/alter-headers/\n  md: https://developers.cloudflare.com/workers/examples/alter-headers/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/alter-headers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nYou can also use the [`custom-headers-example` template](https://github.com/kristianfreeman/custom-headers-example) to deploy this code to your custom domain.\n\n<page>\n---\ntitle: Auth with headers · Cloudflare Workers docs\ndescription: Allow or deny a request based on a known pre-shared key in a\n  header. This is not meant to replace the WebCrypto API.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Authentication,Web Crypto,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/auth-with-headers/\n  md: https://developers.cloudflare.com/workers/examples/auth-with-headers/index.md\n---\n\nCaution when using in production\n\nThe example code contains a generic header key and value of `X-Custom-PSK` and `mypresharedkey`. To best protect your resources, change the header key and value in the Workers editor before saving your code.\n\n<page>\n---\ntitle: HTTP Basic Authentication · Cloudflare Workers docs\ndescription: Shows how to restrict access using the HTTP Basic schema.\nlastUpdated: 2025-10-23T20:06:36.000Z\nchatbotDeprioritize: false\ntags: Security,Authentication,JavaScript,TypeScript,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/basic-auth/\n  md: https://developers.cloudflare.com/workers/examples/basic-auth/index.md\n---\n\nThis example Worker makes use of the [Node.js Buffer API](https://developers.cloudflare.com/workers/runtime-apis/nodejs/buffer/), which is available as part of the Workers runtime [Node.js compatibility mode](https://developers.cloudflare.com/workers/runtime-apis/nodejs/). To run this Worker, you will need to [enable the `nodejs_compat` compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag).\n\nCaution when using in production\n\nThis code is provided as a sample, and is not suitable for production use. Basic Authentication sends credentials unencrypted, and must be used with an HTTPS connection to be considered secure. For a production-ready authentication system, consider using [Cloudflare Access](https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/self-hosted-public-app/).\n\n<page>\n---\ntitle: Block on TLS · Cloudflare Workers docs\ndescription: Inspects the incoming request's TLS version and blocks if under TLSv1.2.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Security,Middleware,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/block-on-tls/\n  md: https://developers.cloudflare.com/workers/examples/block-on-tls/index.md\n---\n\n<page>\n---\ntitle: Bulk origin override · Cloudflare Workers docs\ndescription: Resolve requests to your domain to a set of proxy third-party origin URLs.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/bulk-origin-proxy/\n  md: https://developers.cloudflare.com/workers/examples/bulk-origin-proxy/index.md\n---\n\n<page>\n---\ntitle: Bulk redirects · Cloudflare Workers docs\ndescription: Redirect requests to certain URLs based on a mapped object to the\n  request's URL.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,Redirects,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/bulk-redirects/\n  md: https://developers.cloudflare.com/workers/examples/bulk-redirects/index.md\n---\n\n<page>\n---\ntitle: Using the Cache API · Cloudflare Workers docs\ndescription: Use the Cache API to store responses in Cloudflare's cache.\nlastUpdated: 2025-12-12T16:06:17.000Z\nchatbotDeprioritize: false\ntags: Middleware,Caching,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cache-api/\n  md: https://developers.cloudflare.com/workers/examples/cache-api/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cache-api)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Cache POST requests · Cloudflare Workers docs\ndescription: Cache POST requests using the Cache API.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,Caching,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cache-post-request/\n  md: https://developers.cloudflare.com/workers/examples/cache-post-request/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cache-post-request)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Cache Tags using Workers · Cloudflare Workers docs\ndescription: Send Additional Cache Tags using Workers\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Caching,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cache-tags/\n  md: https://developers.cloudflare.com/workers/examples/cache-tags/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cache-tags)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Cache using fetch · Cloudflare Workers docs\ndescription: Determine how to cache a resource by setting TTLs, custom cache\n  keys, and cache headers in a fetch request.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Caching,Middleware,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cache-using-fetch/\n  md: https://developers.cloudflare.com/workers/examples/cache-using-fetch/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cache-using-fetch)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n## Caching HTML resources\n\nSetting the cache level to **Cache Everything** will override the default cacheability of the asset. For time-to-live (TTL), Cloudflare will still rely on headers set by the origin.\n\nThis feature is available only to Enterprise customers.\n\nA request's cache key is what determines if two requests are the same for caching purposes. If a request has the same cache key as some previous request, then Cloudflare can serve the same cached response for both. For more about cache keys, refer to the [Create custom cache keys](https://developers.cloudflare.com/cache/how-to/cache-keys/#create-custom-cache-keys) documentation.\n\nNormally, Cloudflare computes the cache key for a request based on the request's URL. Sometimes, though, you may like different URLs to be treated as if they were the same for caching purposes. For example, if your website content is hosted from both Amazon S3 and Google Cloud Storage - you have the same content in both places, and you can use a Worker to randomly balance between the two. However, you do not want to end up caching two copies of your content. You could utilize custom cache keys to cache based on the original request URL rather than the subrequest URL:\n\nWorkers operating on behalf of different zones cannot affect each other's cache. You can only override cache keys when making requests within your own zone (in the above example `event.request.url` was the key stored), or requests to hosts that are not on Cloudflare. When making a request to another Cloudflare zone (for example, belonging to a different Cloudflare customer), that zone fully controls how its own content is cached within Cloudflare; you cannot override it.\n\n## Override based on origin response code\n\nThis option is a version of the `cacheTtl` feature which chooses a TTL based on the response's status code and does not automatically set `cacheEverything: true`. If the response to this request has a status code that matches, Cloudflare will cache for the instructed time, and override cache directives sent by the origin. You can review [details on the `cacheTtl` feature on the Request page](https://developers.cloudflare.com/workers/runtime-apis/request/#the-cf-property-requestinitcfproperties).\n\n## Customize cache behavior based on request file type\n\nUsing custom cache keys and overrides based on response code, you can write a Worker that sets the TTL based on the response status code from origin, and request file type.\n\nThe following example demonstrates how you might use this to cache requests for streaming media assets:\n\nService Workers are deprecated\n\nService Workers are deprecated, but still supported. We recommend using [Module Workers](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) instead. New features may not be supported for Service Workers.\n\n## Using the HTTP Cache API\n\nThe `cache` mode can be set in `fetch` options. Currently Workers only support the `no-store` and `no-cache` mode for controlling the cache. When `no-store` is supplied the cache is bypassed on the way to the origin and the request is not cacheable. When `no-cache` is supplied the cache is forced to revalidate the currently cached response with the origin.\n\n<page>\n---\ntitle: Conditional response · Cloudflare Workers docs\ndescription: Return a response based on the incoming request's URL, HTTP method,\n  User Agent, IP address, ASN or device type.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/conditional-response/\n  md: https://developers.cloudflare.com/workers/examples/conditional-response/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/conditional-response)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: CORS header proxy · Cloudflare Workers docs\ndescription: Add the necessary CORS headers to a third party API response.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Security,Headers,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cors-header-proxy/\n  md: https://developers.cloudflare.com/workers/examples/cors-header-proxy/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cors-header-proxy)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Country code redirect · Cloudflare Workers docs\ndescription: Redirect a response based on the country code in the header of a visitor.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Redirects,Geolocation,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/country-code-redirect/\n  md: https://developers.cloudflare.com/workers/examples/country-code-redirect/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/country-code-redirect)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Setting Cron Triggers · Cloudflare Workers docs\ndescription: Set a Cron Trigger for your Worker.\nlastUpdated: 2025-11-11T15:40:52.000Z\nchatbotDeprioritize: false\ntags: Middleware,JavaScript,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cron-trigger/\n  md: https://developers.cloudflare.com/workers/examples/cron-trigger/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cron-trigger)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n## Set Cron Triggers in Wrangler\n\nRefer to [Cron Triggers](https://developers.cloudflare.com/workers/configuration/cron-triggers/) for more information on how to add a Cron Trigger.\n\nIf you are deploying with Wrangler, set the cron syntax (once per hour as shown below) by adding this to your Wrangler file:\n\nYou also can set a different Cron Trigger for each [environment](https://developers.cloudflare.com/workers/wrangler/environments/) in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). You need to put the `[triggers]` table under your chosen environment. For example:\n\n## Test Cron Triggers using Wrangler\n\nThe recommended way of testing Cron Triggers is using Wrangler.\n\nCron Triggers can be tested using Wrangler by passing in the `--test-scheduled` flag to [`wrangler dev`](https://developers.cloudflare.com/workers/wrangler/commands/#dev). This will expose a `/__scheduled` (or `/cdn-cgi/handler/scheduled` for Python Workers) route which can be used to test using a HTTP request. To simulate different cron patterns, a `cron` query parameter can be passed in.\n\n<page>\n---\ntitle: Data loss prevention · Cloudflare Workers docs\ndescription: Protect sensitive data to prevent data loss, and send alerts to a\n  webhooks server in the event of a data breach.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Security,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/data-loss-prevention/\n  md: https://developers.cloudflare.com/workers/examples/data-loss-prevention/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/data-loss-prevention)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Debugging logs · Cloudflare Workers docs\ndescription: Send debugging information in an errored response to a logging service.\nlastUpdated: 2025-09-01T10:19:51.000Z\nchatbotDeprioritize: false\ntags: Debugging,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/debugging-logs/\n  md: https://developers.cloudflare.com/workers/examples/debugging-logs/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/debugging-logs)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Cookie parsing · Cloudflare Workers docs\ndescription: Given the cookie name, get the value of a cookie. You can also use\n  cookies for A/B testing.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Headers,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/extract-cookie-value/\n  md: https://developers.cloudflare.com/workers/examples/extract-cookie-value/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/extract-cookie-value)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nExternal dependencies\n\nThis example requires the npm package [`cookie`](https://www.npmjs.com/package/cookie) to be installed in your JavaScript project.\n\nThe Hono example uses the built-in cookie utilities provided by Hono, so no external dependencies are needed for that implementation.\n\n<page>\n---\ntitle: Fetch HTML · Cloudflare Workers docs\ndescription: Send a request to a remote server, read HTML from the response, and\n  serve that HTML.\nlastUpdated: 2025-08-20T18:47:44.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/fetch-html/\n  md: https://developers.cloudflare.com/workers/examples/fetch-html/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/fetch-html)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n[Run Worker in Playground](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbPYZb6HbW5QDGU2AAwB2ABwBWACwBmAGwAmYQE5JkgFwsWbYBzhcafASIkyFy1QFgAUAGF0VCAFMH2ACJQAzjHQeo0e2ok2ngExCRUcMCODABEUDSOAB4AdABWHjGkqFBgzpHRcQkp6THWdg7OENgAKnQwjoFwMDBgfARQ9sipcABucB68CLAQANTA6LjgjtbWSd5IJLiOqHDgECQA3lYkJP10VLxBjhC8ABYAFAiOAI4gjh4QAJSb2zskyABUH69vHyQASo4WnBeI4SAADK7jJzgkgAdz8pxIEFOYNOPnWdEo8M8SIg6BIHmcuBIV1u9wgHmR6B+Ow+yFpvHsD1JjmhYIYJBipwgEBgHjUyGQSUiLUcySZwEyVlpVwgIAQVF2cLgfiOJwuUPQTgANKzyQ9HkRXgBfHVWE1EayaZjaXT6Hj8IRiKRyRQqSRlexOFzuLw+PwdKiBYK6UgRKKxKKEXSZII5PKRmJkMDoMilWzeyo1OoNXbNVq8dqddL2GZWDYxYCqqgAfXGk1yMTUhSWxQyJutNrtoQdhmdJjd5kkzGsQA)\n\n<page>\n---\ntitle: Fetch JSON · Cloudflare Workers docs\ndescription: Send a GET request and read in JSON from the response. Use to fetch\n  external data.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JSON,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/fetch-json/\n  md: https://developers.cloudflare.com/workers/examples/fetch-json/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/fetch-json)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: \"Geolocation: Weather application · Cloudflare Workers docs\"\ndescription: Fetch weather data from an API using the user's geolocation data.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Geolocation,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/geolocation-app-weather/\n  md: https://developers.cloudflare.com/workers/examples/geolocation-app-weather/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/geolocation-app-weather)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: \"Geolocation: Custom Styling · Cloudflare Workers docs\"\ndescription: Personalize website styling based on localized user time.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Geolocation,JavaScript,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/geolocation-custom-styling/\n  md: https://developers.cloudflare.com/workers/examples/geolocation-custom-styling/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/geolocation-custom-styling)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: \"Geolocation: Hello World · Cloudflare Workers docs\"\ndescription: Get all geolocation data fields and display them in HTML.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Geolocation,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/geolocation-hello-world/\n  md: https://developers.cloudflare.com/workers/examples/geolocation-hello-world/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/geolocation-hello-world)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Hot-link protection · Cloudflare Workers docs\ndescription: Block other websites from linking to your content. This is useful\n  for protecting images.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Security,Headers,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/hot-link-protection/\n  md: https://developers.cloudflare.com/workers/examples/hot-link-protection/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/hot-link-protection)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Custom Domain with Images · Cloudflare Workers docs\ndescription: Set up custom domain for Images using a Worker or serve images\n  using a prefix path and Cloudflare registered domain.\nlastUpdated: 2025-09-09T12:12:09.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/images-workers/\n  md: https://developers.cloudflare.com/workers/examples/images-workers/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/images-workers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nTo serve images from a custom domain:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n[Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. Select **Create application** > **Workers** > **Create Worker** and create your Worker.\n\n3. In your Worker, select **Quick edit** and paste the following code.\n\nAnother way you can serve images from a custom domain is by using the `cdn-cgi/imagedelivery` prefix path which is used as path to trigger `cdn-cgi` image proxy.\n\nBelow is an example showing the hostname as a Cloudflare proxied domain under the same account as the Image, followed with the prefix path and the image `<ACCOUNT_HASH>`, `<IMAGE_ID>` and `<VARIANT_NAME>` which can be found in the **Images** on the Cloudflare dashboard.\n\n<page>\n---\ntitle: Logging headers to console · Cloudflare Workers docs\ndescription: Examine the contents of a Headers object by logging to console with a Map.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Debugging,Headers,JavaScript,Rust,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/logging-headers/\n  md: https://developers.cloudflare.com/workers/examples/logging-headers/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/logging-headers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n## Console-logging headers\n\nUse a `Map` if you need to log a `Headers` object to the console:\n\nUse the `spread` operator if you need to quickly stringify a `Headers` object:\n\nUse `Object.fromEntries` to convert the headers to an object:\n\nWhen debugging Workers, examine the headers on a request or response. A common mistake is to try to log headers to the developer console via code like this:\n\nBoth attempts result in what appears to be an empty object — the string `\"{}\"` — even though calling `request.headers.has(\"Your-Header-Name\")` might return true. This is the same behavior that browsers implement.\n\nThe reason this happens is because [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) objects do not store headers in enumerable JavaScript properties, so the developer console and JSON stringifier do not know how to read the names and values of the headers. It is not actually an empty object, but rather an opaque object.\n\n`Headers` objects are iterable, which you can take advantage of to develop a couple of quick one-liners for debug-printing headers.\n\n### Pass headers through a Map\n\nThe first common idiom for making Headers `console.log()`-friendly is to construct a `Map` object from the `Headers` object and log the `Map` object.\n\n* `Map` objects can be constructed from iterables, like `Headers`.\n\n* The `Map` object does store its entries in enumerable JavaScript properties, so the developer console can see into it.\n\n### Spread headers into an array\n\nThe `Map` approach works for calls to `console.log()`. If you need to stringify your headers, you will discover that stringifying a `Map` yields nothing more than `[object Map]`.\n\nEven though a `Map` stores its data in enumerable properties, those properties are [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)-keyed. Because of this, `JSON.stringify()` will [ignore Symbol-keyed properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#symbols_and_json.stringify) and you will receive an empty `{}`.\n\nInstead, you can take advantage of the iterability of the `Headers` object in a new way by applying the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) (`...`) to it.\n\n### Convert headers into an object with Object.fromEntries (ES2019)\n\nES2019 provides [`Object.fromEntries`](https://github.com/tc39/proposal-object-from-entries) which is a call to convert the headers into an object:\n\nThis results in something like:\n\n<page>\n---\ntitle: Modify request property · Cloudflare Workers docs\ndescription: Create a modified request with edited properties based off of an\n  incoming request.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,Headers,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/modify-request-property/\n  md: https://developers.cloudflare.com/workers/examples/modify-request-property/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/modify-request-property)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Modify response · Cloudflare Workers docs\ndescription: Fetch and modify response properties which are immutable by\n  creating a copy first.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,Headers,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/modify-response/\n  md: https://developers.cloudflare.com/workers/examples/modify-response/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/modify-response)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Multiple Cron Triggers · Cloudflare Workers docs\ndescription: Set multiple Cron Triggers on three different schedules.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,JavaScript,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/multiple-cron-triggers/\n  md: https://developers.cloudflare.com/workers/examples/multiple-cron-triggers/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/multiple-cron-triggers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n## Test Cron Triggers using Wrangler\n\nThe recommended way of testing Cron Triggers is using Wrangler.\n\nCron Triggers can be tested using Wrangler by passing in the `--test-scheduled` flag to [`wrangler dev`](https://developers.cloudflare.com/workers/wrangler/commands/#dev). This will expose a `/__scheduled` (or `/cdn-cgi/handler/scheduled` for Python Workers) route which can be used to test using a HTTP request. To simulate different cron patterns, a `cron` query parameter can be passed in.\n\n<page>\n---\ntitle: Stream OpenAI API Responses · Cloudflare Workers docs\ndescription: Use the OpenAI v4 SDK to stream responses from OpenAI.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\ntags: AI,JavaScript,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/openai-sdk-streaming/\n  md: https://developers.cloudflare.com/workers/examples/openai-sdk-streaming/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/openai-sdk-streaming)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nIn order to run this code, you must install the OpenAI SDK by running `npm i openai`.\n\nFor analytics, caching, rate limiting, and more, you can also send requests like this through Cloudflare's [AI Gateway](https://developers.cloudflare.com/ai-gateway/usage/providers/openai/).\n\n<page>\n---\ntitle: Post JSON · Cloudflare Workers docs\ndescription: Send a POST request with JSON data. Use to share data with external servers.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JSON,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/post-json/\n  md: https://developers.cloudflare.com/workers/examples/post-json/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/post-json)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Using timingSafeEqual · Cloudflare Workers docs\ndescription: Protect against timing attacks by safely comparing values using\n  `timingSafeEqual`.\nlastUpdated: 2025-09-01T10:19:51.000Z\nchatbotDeprioritize: false\ntags: Security,Web Crypto,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/protect-against-timing-attacks/\n  md: https://developers.cloudflare.com/workers/examples/protect-against-timing-attacks/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/protect-against-timing-attacks)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nThe [`crypto.subtle.timingSafeEqual`](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#timingsafeequal) function compares two values using a constant-time algorithm. The time taken is independent of the contents of the values.\n\nWhen strings are compared using the equality operator (`==` or `===`), the comparison will end at the first mismatched character. By using `timingSafeEqual`, an attacker would not be able to use timing to find where at which point in the two strings there is a difference.\n\nThe `timingSafeEqual` function takes two `ArrayBuffer` or `TypedArray` values to compare. These buffers must be of equal length, otherwise an exception is thrown. Note that this function is not constant time with respect to the length of the parameters and also does not guarantee constant time for the surrounding code. Handling of secrets should be taken with care to not introduce timing side channels.\n\nIn order to compare two strings, you must use the [`TextEncoder`](https://developers.cloudflare.com/workers/runtime-apis/encoding/#textencoder) API.\n\n<page>\n---\ntitle: Read POST · Cloudflare Workers docs\ndescription: Serve an HTML form, then read POST requests. Use also to read JSON\n  or POST data from an incoming request.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JSON,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/read-post/\n  md: https://developers.cloudflare.com/workers/examples/read-post/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/read-post)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nPrevent potential errors when accessing request.body\n\nThe body of a [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) can only be accessed once. If you previously used `request.formData()` in the same request, you may encounter a TypeError when attempting to access `request.body`.\n\nTo avoid errors, create a clone of the Request object with `request.clone()` for each subsequent attempt to access a Request's body. Keep in mind that Workers have a [memory limit of 128 MB per Worker](https://developers.cloudflare.com/workers/platform/limits#worker-limits) and loading particularly large files into a Worker's memory multiple times may reach this limit. To ensure memory usage does not reach this limit, consider using [Streams](https://developers.cloudflare.com/workers/runtime-apis/streams/).\n\n<page>\n---\ntitle: Redirect · Cloudflare Workers docs\ndescription: Redirect requests from one URL to another or from one set of URLs\n  to another set.\nlastUpdated: 2025-08-20T18:47:44.000Z\nchatbotDeprioritize: false\ntags: Middleware,Redirects,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/redirect/\n  md: https://developers.cloudflare.com/workers/examples/redirect/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/redirect)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n## Redirect all requests to one URL\n\n[Run Worker in Playground](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbPYZb6HbW5QDGU2AAwBmAKwBGQQCZRANimzx4gFwsWbYBzhcafASInS5CpQFgAUAGF0VCAFNb2ACJQAzjHSuo0G8pIa8AmISKjhgOwYAIigaOwAPADoAK1dI0lQoMAcwiOjYxJTIi2tbBwhsABU6GDs-OBgYMD4CKBtkJLgANzhXXgRYCABqYHRccDsLC3iPJBJcO1Q4cAgSAG9zEhIeuipefzsIXgALAAoEOwBHEDtXCABKNY3Nkl4bW7mb6FCfKgBVACUADIkBgkSJHCAQGCuZTIZDxMKNOwJV7ANJPTavKjvW4EECuazzEEkYSCcREDEkc4QEAIKgkf43DzY5HnHjnXgQE7zW4xFo2AGAgA0JFxNIJozsdwpmwAvkLzLKiBY1MwNFodDx+EIxJIZPJFOJijZ7I4XO5PN5WlQ-AEtKRQuEouFCFo0v5MtknZEyGB0GQilYTWVKtValsGk1ePyqO1XDZJuZVpFgHAYgB9EZjLKRZR5eYFVKylWq9VBTV6HWGfUmcTMCxAA)\n\n## Redirect requests from one domain to another\n\n<page>\n---\ntitle: Respond with another site · Cloudflare Workers docs\ndescription: Respond to the Worker request with the response from another\n  website (example.com in this example).\nlastUpdated: 2025-10-17T07:10:47.000Z\nchatbotDeprioritize: false\ntags: Middleware,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/respond-with-another-site/\n  md: https://developers.cloudflare.com/workers/examples/respond-with-another-site/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/respond-with-another-site)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n[Run Worker in Playground](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbPYZb6HbW5QDGU2AAyCAbACYAnABZhgiWICMALhYs2wDnC40+A4eOmz5CgLAAoAMLoqEAKY3sAESgBnGOhdRo1pSXV4CYhIqOGBbBgAiKBpbAA8AOgArFwjSVCgwe1DwqJiE5IjzKxt7CGwAFToYW184GBgwPgIoa2REuAA3OBdeBFgIAGpgdFxwW3NzOPckElxbVDhwCBIAbzMSEm66Kl4-WwheAAsACgRbAEcQWxcIAEpV9Y2-al5vKhIAWX3DkYA5dAgAEEwGB0AB3Wy4U4XK43e5rJ5PM4QEAId5UWxgkgAJWu7ioLlsxwABl8ID9cCQACQrM6Xa4QeJhckjAC+wQBmxB4Mh8WJABoHojETcCCAXL4ZABWfmPYUkQ62OBzBASoXyp7A0Fg3wRADiAFFyhFZRqSKzTcLWbciHLzXbkMgSAB5KhgOgkQ3lEh02EQFwkMGYADWga8hxI5NcJBgCHQsTo8TtUFQJGh9JuTO+IxIAEIGAwSPqjRF7sjUe8yRT-kDuRCob6GTa7eW0XsDidiYcIBAYBLHXFQg1bPFeOhgMTmxsLWZWURzKpmOpNNoePwhKJJDJhMYitY7A5nG4PF4WlRfP5NKQQmFIszlYFUn4MllbxEyKCyIVLPvShUqjUmz1I0vDNK0yTWBMZgrBEwBwNEAD6wyjJkERKLkcz5CkrILouy6BKuugbgY25yIozDmEAA)\n\n<page>\n---\ntitle: Return small HTML page · Cloudflare Workers docs\ndescription: Deliver an HTML page from an HTML string directly inside the Worker script.\nlastUpdated: 2025-08-20T18:47:44.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/return-html/\n  md: https://developers.cloudflare.com/workers/examples/return-html/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/return-html)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n[Run Worker in Playground](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbPYZb6HbW5QDGU2AAwBmAEwBGACwBOAByyA7AFZZogFwsWbYBzhcafASIkz5y1QFgAUAGF0VCAFMH2ACJQAzjHQeo0e2ok2ngExCRUcMCODABEUDSOAB4AdABWHjGkqFBgzpHRcQkp6THWdg7OENgAKnQwjoFwMDBgfARQ9sipcABucB68CLAQANTA6LjgjtbWSd5IJLiOqHDgECQA3lYkJP10VLxBjhC8ABYAFAiOAI4gjh4QAJSb2zskvPYPJKcQwGAkDBIAAMADwAQlcAHkbNUAJoABQAot9fmAAHyvHYgii4OgYt5vEGncRogASjjAYHQJAA6pgwLgQchifiCSQQTA0dVTp4SMBEABrEAwEgAd36JAA5s5HAgCI5cOQ6LsSDYqSBcKgwIhHLTMALZckmZzMezkDi8UCiFZTVcICAEFRwo5RSQAEr3bxUDyOc4-P4AGhebO+jjgSwQHkCWxDOxiHwqLggdUcMUCMSciRQ-rARDOiB9EAYAFVqgAxbCyGIB007AC+NYJdce1vrNbrRGsmmY2l0+h4-CEYikckUKlEZXsThc7i8Pj8HSogWCulIESisSihF0mSCOTyG5iZCpZFKtinlRqKcazVavHanXS9hmVg2MX58QA+uNJrk04UlmKDI6y7bte1CftDCHExR3MURmGsIA)\n\n<page>\n---\ntitle: Return JSON · Cloudflare Workers docs\ndescription: Return JSON directly from a Worker script, useful for building APIs\n  and middleware.\nlastUpdated: 2025-08-20T18:47:44.000Z\nchatbotDeprioritize: false\ntags: JSON,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/return-json/\n  md: https://developers.cloudflare.com/workers/examples/return-json/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/return-json)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n[Run Worker in Playground](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbPYZb6HbW5QDGU2AAwBmAGwAOAOwBWGeNGjhALhYs2wDnC40+AkRJlyFwgLAAoAMLoqEAKY3sAESgBnGOhdRo1pSXV4CYhIqOGBbBgAiKBpbAA8AOgArFwjSVCgwe1DwqJiE5IjzKxt7CGwAFToYW184GBgwPgIoa2REuAA3OBdeBFgIAGpgdFxwW3NzOPckElxbVDhwCBIAbzMSEm66Kl4-WwheAAsACgRbAEcQWxcIAEpV9Y2SXmsb2cCSBgenp8PbMDA6F8EQA7pgwLgIgAaR4bAC+RDMsJIZwgIAQVBIACVru4qC5bEkXNZjppboj4TCEeZVMx1JptDx+EIxFJZNJ5IoitY7A5nG4PF4WlRfP5NKQQmFImFCJpUn4MlkpREyICyIVLDzShUqjVNvVGrxmq1ktYJmYVhFgHBogB9YajTIRJS5Ob5FJwmm0+mBRm6FkGdmc4TMcxAA)\n\n<page>\n---\ntitle: Rewrite links · Cloudflare Workers docs\ndescription: Rewrite URL links in HTML using the HTMLRewriter. This is useful\n  for JAMstack websites.\nlastUpdated: 2025-08-19T19:54:31.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/rewrite-links/\n  md: https://developers.cloudflare.com/workers/examples/rewrite-links/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/rewrite-links)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Set security headers · Cloudflare Workers docs\ndescription: Set common security headers (X-XSS-Protection, X-Frame-Options,\n  X-Content-Type-Options, Permissions-Policy, Referrer-Policy,\n  Strict-Transport-Security, Content-Security-Policy).\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Security,Middleware,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/security-headers/\n  md: https://developers.cloudflare.com/workers/examples/security-headers/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/security-headers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n<page>\n---\ntitle: Sign requests · Cloudflare Workers docs\ndescription: Verify a signed request using the HMAC and SHA-256 algorithms or return a 403.\nlastUpdated: 2025-09-01T10:19:51.000Z\nchatbotDeprioritize: false\ntags: Security,Web Crypto,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/signing-requests/\n  md: https://developers.cloudflare.com/workers/examples/signing-requests/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/signing-requests)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nThis example Worker makes use of the [Node.js Buffer API](https://developers.cloudflare.com/workers/runtime-apis/nodejs/buffer/), which is available as part of the Workers runtime [Node.js compatibility mode](https://developers.cloudflare.com/workers/runtime-apis/nodejs/). To run this Worker, you will need to [enable the `nodejs_compat` compatibility flag](https://developers.cloudflare.com/workers/runtime-apis/nodejs/#get-started).\n\nYou can both verify and generate signed requests from within a Worker using the [Web Crypto APIs](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle).\n\nThe following Worker will:\n\n* For request URLs beginning with `/generate/`, replace `/generate/` with `/`, sign the resulting path with its timestamp, and return the full, signed URL in the response body.\n\n* For all other request URLs, verify the signed URL and allow the request through.\n\n## Validate signed requests using the WAF\n\nThe provided example code for signing requests is compatible with the [`is_timed_hmac_valid_v0()`](https://developers.cloudflare.com/ruleset-engine/rules-language/functions/#hmac-validation) Rules language function. This means that you can verify requests signed by the Worker script using a [custom rule](https://developers.cloudflare.com/waf/custom-rules/use-cases/configure-token-authentication/#option-2-configure-using-custom-rules).\n\n<page>\n---\ntitle: Stream large JSON · Cloudflare Workers docs\ndescription: Parse and transform large JSON request and response bodies using streaming.\nlastUpdated: 2025-12-16T04:37:37.000Z\nchatbotDeprioritize: false\ntags: Middleware,JSON,JavaScript,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/streaming-json/\n  md: https://developers.cloudflare.com/workers/examples/streaming-json/index.md\n---\n\nUse the [Streams API](https://developers.cloudflare.com/workers/runtime-apis/streams/) to process JSON payloads that would exceed a Worker's 128 MB memory limit if fully buffered. Streaming allows you to parse and transform JSON data incrementally as it arrives. This is faster than buffering the entire payload into memory, as your Worker can start processing data incrementally, and allows your Worker to handle multi-gigabyte payloads or files within its memory limits.\n\nThe [`@streamparser/json-whatwg`](https://www.npmjs.com/package/@streamparser/json-whatwg) library provides a streaming JSON parser compatible with the Web Streams API.\n\nInstall the dependency:\n\n## Stream a JSON request body\n\nThis example parses a large JSON request body and extracts specific fields without loading the entire payload into memory.\n\n## Stream and transform a JSON response\n\nThis example fetches a large JSON response from an upstream API, transforms specific fields, and streams the modified response to the client.\n\n* [Streams API](https://developers.cloudflare.com/workers/runtime-apis/streams/) - Learn more about streaming in Workers\n* [TransformStream](https://developers.cloudflare.com/workers/runtime-apis/streams/transformstream/) - Create custom stream transformations\n* [@streamparser/json-whatwg](https://www.npmjs.com/package/@streamparser/json-whatwg) - Streaming JSON parser documentation\n\n<page>\n---\ntitle: Turnstile with Workers · Cloudflare Workers docs\ndescription: Inject [Turnstile](/turnstile/) implicitly into HTML elements using\n  the HTMLRewriter runtime API.\nlastUpdated: 2025-09-01T10:19:51.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/turnstile-html-rewriter/\n  md: https://developers.cloudflare.com/workers/examples/turnstile-html-rewriter/index.md\n---\n\nThis is only half the implementation for Turnstile. The corresponding token that is a result of a widget being rendered also needs to be verified using the [Siteverify API](https://developers.cloudflare.com/turnstile/get-started/server-side-validation/). Refer to the example below for one such implementation.\n\nPrevent potential errors when accessing request.body\n\nThe body of a [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) can only be accessed once. If you previously used `request.formData()` in the same request, you may encounter a TypeError when attempting to access `request.body`.\n\nTo avoid errors, create a clone of the Request object with `request.clone()` for each subsequent attempt to access a Request's body. Keep in mind that Workers have a [memory limit of 128 MB per Worker](https://developers.cloudflare.com/workers/platform/limits#worker-limits) and loading particularly large files into a Worker's memory multiple times may reach this limit. To ensure memory usage does not reach this limit, consider using [Streams](https://developers.cloudflare.com/workers/runtime-apis/streams/).\n\n<page>\n---\ntitle: Using the WebSockets API · Cloudflare Workers docs\ndescription: Use the WebSockets API to communicate in real time with your\n  Cloudflare Workers.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: WebSockets,JavaScript,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/websockets/\n  md: https://developers.cloudflare.com/workers/examples/websockets/index.md\n---\n\nWebSockets allow you to communicate in real time with your Cloudflare Workers serverless functions. In this guide, you will learn the basics of WebSockets on Cloudflare Workers, both from the perspective of writing WebSocket servers in your Workers functions, as well as connecting to and working with those WebSocket servers as a client.\n\nWebSockets are open connections sustained between the client and the origin server. Inside a WebSocket connection, the client and the origin can pass data back and forth without having to reestablish sessions. This makes exchanging data within a WebSocket connection fast. WebSockets are often used for real-time applications such as live chat and gaming.\n\nWebSockets utilize an event-based system for receiving and sending messages, much like the Workers runtime model of responding to events.\n\nIf your application needs to coordinate among multiple WebSocket connections, such as a chat room or game match, you will need clients to send messages to a single-point-of-coordination. Durable Objects provide a single-point-of-coordination for Cloudflare Workers, and are often used in parallel with WebSockets to persist state over multiple clients and connections. In this case, refer to [Durable Objects](https://developers.cloudflare.com/durable-objects/) to get started, and prefer using the Durable Objects' extended [WebSockets API](https://developers.cloudflare.com/durable-objects/best-practices/websockets/).\n\n## Write a WebSocket Server\n\nWebSocket servers in Cloudflare Workers allow you to receive messages from a client in real time. This guide will show you how to set up a WebSocket server in Workers.\n\nA client can make a WebSocket request in the browser by instantiating a new instance of `WebSocket`, passing in the URL for your Workers function:\n\nFor more details about creating and working with WebSockets in the client, refer to [Writing a WebSocket client](#write-a-websocket-client).\n\nWhen an incoming WebSocket request reaches the Workers function, it will contain an `Upgrade` header, set to the string value `websocket`. Check for this header before continuing to instantiate a WebSocket:\n\nAfter you have appropriately checked for the `Upgrade` header, you can create a new instance of `WebSocketPair`, which contains server and client WebSockets. One of these WebSockets should be handled by the Workers function and the other should be returned as part of a `Response` with the [`101` status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/101), indicating the request is switching protocols:\n\nThe `WebSocketPair` constructor returns an Object, with the `0` and `1` keys each holding a `WebSocket` instance as its value. It is common to grab the two WebSockets from this pair using [`Object.values`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Object/values) and [ES6 destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment), as seen in the below example.\n\nIn order to begin communicating with the `client` WebSocket in your Worker, call `accept` on the `server` WebSocket. This will tell the Workers runtime that it should listen for WebSocket data and keep the connection open with your `client` WebSocket:\n\nWebSockets emit a number of [Events](https://developers.cloudflare.com/workers/runtime-apis/websockets/#events) that can be connected to using `addEventListener`. The below example hooks into the `message` event and emits a `console.log` with the data from it:\n\n### Connect to the WebSocket server from a client\n\nWriting WebSocket clients that communicate with your Workers function is a two-step process: first, create the WebSocket instance, and then attach event listeners to it:\n\nWebSocket clients can send messages back to the server using the [`send`](https://developers.cloudflare.com/workers/runtime-apis/websockets/#send) function:\n\nWhen the WebSocket interaction is complete, the client can close the connection using [`close`](https://developers.cloudflare.com/workers/runtime-apis/websockets/#close):\n\nFor an example of this in practice, refer to the [`websocket-template`](https://github.com/cloudflare/websocket-template) to get started with WebSockets.\n\n## Write a WebSocket client\n\nCloudflare Workers supports the `new WebSocket(url)` constructor. A Worker can establish a WebSocket connection to a remote server in the same manner as the client implementation described above.\n\nAdditionally, Cloudflare supports establishing WebSocket connections by making a fetch request to a URL with the `Upgrade` header set.\n\n## WebSocket compression\n\nCloudflare Workers supports WebSocket compression. Refer to [WebSocket Compression](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#websocket-compression) for more information.\n\n<page>\n---\ntitle: Get started - Dashboard · Cloudflare Workers docs\ndescription: Follow this guide to create a Workers application using the\n  Cloudflare dashboard.\nlastUpdated: 2025-09-09T12:12:09.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/get-started/dashboard/\n  md: https://developers.cloudflare.com/workers/get-started/dashboard/index.md\n---\n\nFollow this guide to create a Workers application using the Cloudflare dashboard.\n\nThe quickest way to experiment with Cloudflare Workers is in the [Playground](https://workers.cloudflare.com/playground). The Playground does not require any setup. It is an instant way to preview and test a Worker directly in the browser.\n\n[Create a Cloudflare account](https://developers.cloudflare.com/fundamentals/account/create-account/), if you have not already.\n\nTo get started with a new Workers application:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n[Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. Select **Create application**. From here, you can:\n\n* Select from the gallery of production-ready templates\n   * Import an existing Git repository on your own account\n   * Let Cloudflare clone and bootstrap a public repository containing a Workers application.\n\n3. Once you have connected to your chosen [Git provider](https://developers.cloudflare.com/workers/ci-cd/builds/git-integration/github-integration/), configure your project and select **Deploy**.\n\n4. Cloudflare will kick off a new build and deployment. Once deployed, preview your Worker at its provided `workers.dev` subdomain.\n\n## Continue development\n\nApplications started in the dashboard are set up with Git to help kickstart your development workflow. To continue developing on your repository, you can run:",
  "code_samples": [
    {
      "code": "const CSS = \"body { color: red; }\";\n  const HTML = `\n  <!doctype html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"utf-8\">\n      <title>Early Hints test</title>\n      <link rel=\"stylesheet\" href=\"/test.css\">\n  </head>\n  <body>\n      <h1>Early Hints test page</h1>\n  </body>\n  </html>\n  `;\n\n\n  export default {\n    async fetch(req) {\n      // If request is for test.css, serve the raw CSS\n      if (/test\\.css$/.test(req.url)) {\n        return new Response(CSS, {\n          headers: {\n            \"content-type\": \"text/css\",\n          },\n        });\n      } else {\n        // Serve raw HTML using Early Hints for the CSS file\n        return new Response(HTML, {\n          headers: {\n            \"content-type\": \"text/html\",\n            link: \"</test.css>; rel=preload; as=style\",\n          },\n        });\n      }\n    },\n  };",
      "language": "js"
    },
    {
      "code": "const CSS = \"body { color: red; }\";\n  const HTML = `\n  <!doctype html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"utf-8\">\n      <title>Early Hints test</title>\n      <link rel=\"stylesheet\" href=\"/test.css\">\n  </head>\n  <body>\n      <h1>Early Hints test page</h1>\n  </body>\n  </html>\n  `;\n\n\n  export default {\n    async fetch(req): Promise<Response> {\n      // If request is for test.css, serve the raw CSS\n      if (/test\\.css$/.test(req.url)) {\n        return new Response(CSS, {\n          headers: {\n            \"content-type\": \"text/css\",\n          },\n        });\n      } else {\n        // Serve raw HTML using Early Hints for the CSS file\n        return new Response(HTML, {\n          headers: {\n            \"content-type\": \"text/html\",\n            link: \"</test.css>; rel=preload; as=style\",\n          },\n        });\n      }\n    },\n  } satisfies ExportedHandler;",
      "language": "js"
    },
    {
      "code": "import re\n  from workers import Response, WorkerEntrypoint\n\n\n  CSS = \"body { color: red; }\"\n  HTML = \"\"\"\n  <!doctype html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"utf-8\">\n      <title>Early Hints test</title>\n      <link rel=\"stylesheet\" href=\"/test.css\">\n  </head>\n  <body>\n      <h1>Early Hints test page</h1>\n  </body>\n  </html>\n  \"\"\"\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          if re.search(\"test.css\", request.url):\n              headers = {\"content-type\": \"text/css\"}\n              return Response(CSS, headers=headers)\n          else:\n              headers = {\"content-type\": \"text/html\",\"link\": \"</test.css>; rel=preload; as=style\"}\n          return Response(HTML, headers=headers)",
      "language": "py"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  const CSS = \"body { color: red; }\";\n  const HTML = `\n  <!doctype html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"utf-8\">\n      <title>Early Hints test</title>\n      <link rel=\"stylesheet\" href=\"/test.css\">\n  </head>\n  <body>\n      <h1>Early Hints test page</h1>\n  </body>\n  </html>\n  `;\n\n\n  // Serve CSS file\n  app.get(\"/test.css\", (c) => {\n    return c.body(CSS, {\n      headers: {\n        \"content-type\": \"text/css\",\n      },\n    });\n  });\n\n\n  // Serve HTML with early hints\n  app.get(\"*\", (c) => {\n    return c.html(HTML, {\n      headers: {\n        link: \"</test.css>; rel=preload; as=style\",\n      },\n    });\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "const NAME = \"myExampleWorkersABTest\";\n\n\n  export default {\n    async fetch(req) {\n      const url = new URL(req.url);\n\n\n      // Enable Passthrough to allow direct access to control and test routes.\n      if (url.pathname.startsWith(\"/control\") || url.pathname.startsWith(\"/test\"))\n        return fetch(req);\n\n\n      // Determine which group this requester is in.\n      const cookie = req.headers.get(\"cookie\");\n\n\n      if (cookie && cookie.includes(`${NAME}=control`)) {\n        url.pathname = \"/control\" + url.pathname;\n      } else if (cookie && cookie.includes(`${NAME}=test`)) {\n        url.pathname = \"/test\" + url.pathname;\n      } else {\n        // If there is no cookie, this is a new client. Choose a group and set the cookie.\n        const group = Math.random() < 0.5 ? \"test\" : \"control\"; // 50/50 split\n        if (group === \"control\") {\n          url.pathname = \"/control\" + url.pathname;\n        } else {\n          url.pathname = \"/test\" + url.pathname;\n        }\n        // Reconstruct response to avoid immutability\n        let res = await fetch(url);\n        res = new Response(res.body, res);\n        // Set cookie to enable persistent A/B sessions.\n        res.headers.append(\"Set-Cookie\", `${NAME}=${group}; path=/`);\n        return res;\n      }\n      return fetch(url);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "const NAME = \"myExampleWorkersABTest\";\n\n\n  export default {\n    async fetch(req): Promise<Response> {\n      const url = new URL(req.url);\n      // Enable Passthrough to allow direct access to control and test routes.\n      if (url.pathname.startsWith(\"/control\") || url.pathname.startsWith(\"/test\"))\n        return fetch(req);\n      // Determine which group this requester is in.\n      const cookie = req.headers.get(\"cookie\");\n      if (cookie && cookie.includes(`${NAME}=control`)) {\n        url.pathname = \"/control\" + url.pathname;\n      } else if (cookie && cookie.includes(`${NAME}=test`)) {\n        url.pathname = \"/test\" + url.pathname;\n      } else {\n        // If there is no cookie, this is a new client. Choose a group and set the cookie.\n        const group = Math.random() < 0.5 ? \"test\" : \"control\"; // 50/50 split\n        if (group === \"control\") {\n          url.pathname = \"/control\" + url.pathname;\n        } else {\n          url.pathname = \"/test\" + url.pathname;\n        }\n        // Reconstruct response to avoid immutability\n        let res = await fetch(url);\n        res = new Response(res.body, res);\n        // Set cookie to enable persistent A/B sessions.\n        res.headers.append(\"Set-Cookie\", `${NAME}=${group}; path=/`);\n        return res;\n      }\n      return fetch(url);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import random\n  from urllib.parse import urlparse, urlunparse\n  from workers import Response, fetch, WorkerEntrypoint\n\n\n  NAME = \"myExampleWorkersABTest\"\n\n\n  class Default(WorkerEntrypoint):\n    async def fetch(self, request):\n      url = urlparse(request.url)\n      # Uncomment below when testing locally\n      # url = url._replace(netloc=\"example.com\") if \"localhost\" in url.netloc else url\n\n\n      # Enable Passthrough to allow direct access to control and test routes.\n      if url.path.startswith(\"/control\") or url.path.startswith(\"/test\"):\n        return fetch(urlunparse(url))\n\n\n      # Determine which group this requester is in.\n      cookie = request.headers.get(\"cookie\")\n\n\n      if cookie and f'{NAME}=control' in cookie:\n        url = url._replace(path=\"/control\" + url.path)\n      elif cookie and f'{NAME}=test' in cookie:\n        url = url._replace(path=\"/test\" + url.path)\n      else:\n        # If there is no cookie, this is a new client. Choose a group and set the cookie.\n        group = \"test\" if random.random() < 0.5 else \"control\"\n        if group == \"control\":\n          url = url._replace(path=\"/control\" + url.path)\n        else:\n          url = url._replace(path=\"/test\" + url.path)\n\n\n        # Reconstruct response to avoid immutability\n        res = await fetch(urlunparse(url))\n        headers = dict(res.headers)\n        headers[\"Set-Cookie\"] = f'{NAME}={group}; path=/'\n        return Response(res.body, headers=headers)\n\n\n      return fetch(urlunparse(url))",
      "language": "py"
    },
    {
      "code": "import { Hono } from \"hono\";\n  import { getCookie, setCookie } from \"hono/cookie\";\n\n\n  const app = new Hono();\n\n\n  const NAME = \"myExampleWorkersABTest\";\n\n\n  // Enable passthrough to allow direct access to control and test routes\n  app.all(\"/control/*\", (c) => fetch(c.req.raw));\n  app.all(\"/test/*\", (c) => fetch(c.req.raw));\n\n\n  // Middleware to handle A/B testing logic\n  app.use(\"*\", async (c) => {\n    const url = new URL(c.req.url);\n\n\n    // Determine which group this requester is in\n    const abTestCookie = getCookie(c, NAME);\n\n\n    if (abTestCookie === \"control\") {\n      // User is in control group\n      url.pathname = \"/control\" + c.req.path;\n    } else if (abTestCookie === \"test\") {\n      // User is in test group\n      url.pathname = \"/test\" + c.req.path;\n    } else {\n      // If there is no cookie, this is a new client\n      // Choose a group and set the cookie (50/50 split)\n      const group = Math.random() < 0.5 ? \"test\" : \"control\";\n\n\n      // Update URL path based on assigned group\n      if (group === \"control\") {\n        url.pathname = \"/control\" + c.req.path;\n      } else {\n        url.pathname = \"/test\" + c.req.path;\n      }\n\n\n      // Set cookie to enable persistent A/B sessions\n      setCookie(c, NAME, group, {\n        path: \"/\",\n      });\n    }\n\n\n    const res = await fetch(url);\n\n\n    return c.body(res.body, res);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(req) {\n      const data =\n        req.cf !== undefined\n          ? req.cf\n          : { error: \"The `cf` object is not available inside the preview.\" };\n\n\n      return new Response(JSON.stringify(data, null, 2), {\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(req): Promise<Response> {\n      const data =\n        req.cf !== undefined\n          ? req.cf\n          : { error: \"The `cf` object is not available inside the preview.\" };\n\n\n      return new Response(JSON.stringify(data, null, 2), {\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      });\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  app.get(\"*\", async (c) => {\n    // Access the raw request to get the cf object\n    const req = c.req.raw;\n\n\n    // Check if the cf object is available\n    const data =\n      req.cf !== undefined\n        ? req.cf\n        : { error: \"The `cf` object is not available inside the preview.\" };\n\n\n    // Return the data formatted with 2-space indentation\n    return c.json(data);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "import json\n  from workers import Response, WorkerEntrypoint\n  from js import JSON\n\n\n  class Default(WorkerEntrypoint):\n    async def fetch(self, request):\n      error = json.dumps({ \"error\": \"The `cf` object is not available inside the preview.\" })\n      data = request.cf if request.cf is not None else error\n      headers = {\"content-type\":\"application/json\"}\n      return Response(JSON.stringify(data, None, 2), headers=headers)",
      "language": "py"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      // someHost is set up to return JSON responses\n      const someHost = \"https://jsonplaceholder.typicode.com\";\n      const url1 = someHost + \"/todos/1\";\n      const url2 = someHost + \"/todos/2\";\n\n\n      const responses = await Promise.all([fetch(url1), fetch(url2)]);\n      const results = await Promise.all(responses.map((r) => r.json()));\n\n\n      const options = {\n        headers: { \"content-type\": \"application/json;charset=UTF-8\" },\n      };\n      return new Response(JSON.stringify(results), options);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      // someHost is set up to return JSON responses\n      const someHost = \"https://jsonplaceholder.typicode.com\";\n      const url1 = someHost + \"/todos/1\";\n      const url2 = someHost + \"/todos/2\";\n\n\n      const responses = await Promise.all([fetch(url1), fetch(url2)]);\n      const results = await Promise.all(responses.map((r) => r.json()));\n\n\n      const options = {\n        headers: { \"content-type\": \"application/json;charset=UTF-8\" },\n      };\n      return new Response(JSON.stringify(results), options);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  app.get(\"*\", async (c) => {\n    // someHost is set up to return JSON responses\n    const someHost = \"https://jsonplaceholder.typicode.com\";\n    const url1 = someHost + \"/todos/1\";\n    const url2 = someHost + \"/todos/2\";\n\n\n    // Fetch both URLs concurrently\n    const responses = await Promise.all([fetch(url1), fetch(url2)]);\n\n\n    // Parse JSON responses concurrently\n    const results = await Promise.all(responses.map((r) => r.json()));\n\n\n    // Return aggregated results\n    return c.json(results);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "from workers import Response, fetch, WorkerEntrypoint\n  import asyncio\n  import json\n\n\n  class Default(WorkerEntrypoint):\n    async def fetch(self, request):\n      # some_host is set up to return JSON responses\n      some_host = \"https://jsonplaceholder.typicode.com\"\n      url1 = some_host + \"/todos/1\"\n      url2 = some_host + \"/todos/2\"\n\n\n      responses = await asyncio.gather(fetch(url1), fetch(url2))\n      results = await asyncio.gather(*(r.json() for r in responses))\n\n\n      headers = {\"content-type\": \"application/json;charset=UTF-8\"}\n      return Response.json(results, headers=headers)",
      "language": "py"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const response = await fetch(\"https://example.com\");\n\n\n      // Clone the response so that it's no longer immutable\n      const newResponse = new Response(response.body, response);\n\n\n      // Add a custom header with a value\n      newResponse.headers.append(\n        \"x-workers-hello\",\n        \"Hello from Cloudflare Workers\",\n      );\n\n\n      // Delete headers\n      newResponse.headers.delete(\"x-header-to-delete\");\n      newResponse.headers.delete(\"x-header2-to-delete\");\n\n\n      // Adjust the value for an existing header\n      newResponse.headers.set(\"x-header-to-change\", \"NewValue\");\n\n\n      return newResponse;\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const response = await fetch(request);\n\n\n      // Clone the response so that it's no longer immutable\n      const newResponse = new Response(response.body, response);\n\n\n      // Add a custom header with a value\n      newResponse.headers.append(\n        \"x-workers-hello\",\n        \"Hello from Cloudflare Workers\",\n      );\n\n\n      // Delete headers\n      newResponse.headers.delete(\"x-header-to-delete\");\n      newResponse.headers.delete(\"x-header2-to-delete\");\n\n\n      // Adjust the value for an existing header\n      newResponse.headers.set(\"x-header-to-change\", \"NewValue\");\n\n\n      return newResponse;\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import Response, fetch, WorkerEntrypoint\n\n\n  class Default(WorkerEntrypoint):\n    async def fetch(self, request):\n        response = await fetch(\"https://example.com\")\n\n\n        # Grab the response headers so they can be modified\n        new_headers = response.headers\n\n\n        # Add a custom header with a value\n        new_headers[\"x-workers-hello\"] = \"Hello from Cloudflare Workers\"\n\n\n        # Delete headers\n        if \"x-header-to-delete\" in new_headers:\n            del new_headers[\"x-header-to-delete\"]\n        if \"x-header2-to-delete\" in new_headers:\n            del new_headers[\"x-header2-to-delete\"]\n\n\n        # Adjust the value for an existing header\n        new_headers[\"x-header-to-change\"] = \"NewValue\"\n\n\n        return Response(response.body, headers=new_headers)",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  const app = new Hono();\n\n\n  app.use('*', async (c, next) => {\n    // Process the request with the next middleware/handler\n    await next();\n\n\n    // After the response is generated, we can modify its headers\n\n\n    // Add a custom header with a value\n    c.res.headers.append(\n      \"x-workers-hello\",\n      \"Hello from Cloudflare Workers with Hono\"\n    );\n\n\n    // Delete headers\n    c.res.headers.delete(\"x-header-to-delete\");\n    c.res.headers.delete(\"x-header2-to-delete\");\n\n\n    // Adjust the value for an existing header\n    c.res.headers.set(\"x-header-to-change\", \"NewValue\");\n  });\n\n\n  app.get('*', async (c) => {\n    // Fetch content from example.com\n    const response = await fetch(\"https://example.com\");\n\n\n    // Return the response body with original headers\n    // (our middleware will modify the headers before sending)\n    return new Response(response.body, {\n      headers: response.headers\n    });\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      /**\n       * @param {string} PRESHARED_AUTH_HEADER_KEY Custom header to check for key\n       * @param {string} PRESHARED_AUTH_HEADER_VALUE Hard coded key value\n       */\n      const PRESHARED_AUTH_HEADER_KEY = \"X-Custom-PSK\";\n      const PRESHARED_AUTH_HEADER_VALUE = \"mypresharedkey\";\n      const psk = request.headers.get(PRESHARED_AUTH_HEADER_KEY);\n\n\n      if (psk === PRESHARED_AUTH_HEADER_VALUE) {\n        // Correct preshared header key supplied. Fetch request from origin.\n        return fetch(request);\n      }\n\n\n      // Incorrect key supplied. Reject the request.\n      return new Response(\"Sorry, you have supplied an invalid key.\", {\n        status: 403,\n      });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * @param {string} PRESHARED_AUTH_HEADER_KEY Custom header to check for key\n       * @param {string} PRESHARED_AUTH_HEADER_VALUE Hard coded key value\n       */\n      const PRESHARED_AUTH_HEADER_KEY = \"X-Custom-PSK\";\n      const PRESHARED_AUTH_HEADER_VALUE = \"mypresharedkey\";\n      const psk = request.headers.get(PRESHARED_AUTH_HEADER_KEY);\n\n\n      if (psk === PRESHARED_AUTH_HEADER_VALUE) {\n        // Correct preshared header key supplied. Fetch request from origin.\n        return fetch(request);\n      }\n\n\n      // Incorrect key supplied. Reject the request.\n      return new Response(\"Sorry, you have supplied an invalid key.\", {\n        status: 403,\n      });\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response, fetch\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          PRESHARED_AUTH_HEADER_KEY = \"X-Custom-PSK\"\n          PRESHARED_AUTH_HEADER_VALUE = \"mypresharedkey\"\n\n\n          psk = request.headers[PRESHARED_AUTH_HEADER_KEY]\n\n\n          if psk == PRESHARED_AUTH_HEADER_VALUE:\n              # Correct preshared header key supplied. Fetch request from origin.\n              return fetch(request)\n\n\n          # Incorrect key supplied. Reject the request.\n          return Response(\"Sorry, you have supplied an invalid key.\", status=403)",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  const app = new Hono();\n\n\n  // Add authentication middleware\n  app.use('*', async (c, next) => {\n    /**\n     * Define authentication constants\n     */\n    const PRESHARED_AUTH_HEADER_KEY = \"X-Custom-PSK\";\n    const PRESHARED_AUTH_HEADER_VALUE = \"mypresharedkey\";\n\n\n    // Get the pre-shared key from the request header\n    const psk = c.req.header(PRESHARED_AUTH_HEADER_KEY);\n\n\n    if (psk === PRESHARED_AUTH_HEADER_VALUE) {\n      // Correct preshared header key supplied. Continue to the next handler.\n      await next();\n    } else {\n      // Incorrect key supplied. Reject the request.\n      return c.text(\"Sorry, you have supplied an invalid key.\", 403);\n    }\n  });\n\n\n  // Handle all authenticated requests by passing through to origin\n  app.all('*', async (c) => {\n    return fetch(c.req.raw);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "/**\n   * Shows how to restrict access using the HTTP Basic schema.\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\n   * @see https://tools.ietf.org/html/rfc7617\n   *\n   */\n\n\n  import { Buffer } from \"node:buffer\";\n\n\n  const encoder = new TextEncoder();\n\n\n  /**\n   * Protect against timing attacks by safely comparing values using `timingSafeEqual`.\n   * Refer to https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#timingsafeequal for more details\n   * @param {string} a\n   * @param {string} b\n   * @returns {boolean}\n   */\n  function timingSafeEqual(a, b) {\n    const aBytes = encoder.encode(a);\n    const bBytes = encoder.encode(b);\n\n\n    if (aBytes.byteLength !== bBytes.byteLength) {\n      // Strings must be the same length in order to compare\n      // with crypto.subtle.timingSafeEqual\n      return false;\n    }\n\n\n    return crypto.subtle.timingSafeEqual(aBytes, bBytes);\n  }\n\n\n  export default {\n    /**\n     *\n     * @param {Request} request\n     * @param {{PASSWORD: string}} env\n     * @returns\n     */\n    async fetch(request, env) {\n      const BASIC_USER = \"admin\";\n\n\n      // You will need an admin password. This should be\n      // attached to your Worker as an encrypted secret.\n      // Refer to https://developers.cloudflare.com/workers/configuration/secrets/\n      const BASIC_PASS = env.PASSWORD ?? \"password\";\n\n\n      const url = new URL(request.url);\n\n\n      switch (url.pathname) {\n        case \"/\":\n          return new Response(\"Anyone can access the homepage.\");\n\n\n        case \"/logout\":\n          // Invalidate the \"Authorization\" header by returning a HTTP 401.\n          // We do not send a \"WWW-Authenticate\" header, as this would trigger\n          // a popup in the browser, immediately asking for credentials again.\n          return new Response(\"Logged out.\", { status: 401 });\n\n\n        case \"/admin\": {\n          // The \"Authorization\" header is sent when authenticated.\n          const authorization = request.headers.get(\"Authorization\");\n          if (!authorization) {\n            return new Response(\"You need to login.\", {\n              status: 401,\n              headers: {\n                // Prompts the user for credentials.\n                \"WWW-Authenticate\": 'Basic realm=\"my scope\", charset=\"UTF-8\"',\n              },\n            });\n          }\n          const [scheme, encoded] = authorization.split(\" \");\n\n\n          // The Authorization header must start with Basic, followed by a space.\n          if (!encoded || scheme !== \"Basic\") {\n            return new Response(\"Malformed authorization header.\", {\n              status: 400,\n            });\n          }\n\n\n          const credentials = Buffer.from(encoded, \"base64\").toString();\n\n\n          // The username & password are split by the first colon.\n          //=> example: \"username:password\"\n          const index = credentials.indexOf(\":\");\n          const user = credentials.substring(0, index);\n          const pass = credentials.substring(index + 1);\n\n\n          if (\n            !timingSafeEqual(BASIC_USER, user) ||\n            !timingSafeEqual(BASIC_PASS, pass)\n          ) {\n            return new Response(\"You need to login.\", {\n              status: 401,\n              headers: {\n                // Prompts the user for credentials.\n                \"WWW-Authenticate\": 'Basic realm=\"my scope\", charset=\"UTF-8\"',\n              },\n            });\n          }\n\n\n          return new Response(\"🎉 You have private access!\", {\n            status: 200,\n            headers: {\n              \"Cache-Control\": \"no-store\",\n            },\n          });\n        }\n      }\n\n\n      return new Response(\"Not Found.\", { status: 404 });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "/**\n   * Shows how to restrict access using the HTTP Basic schema.\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\n   * @see https://tools.ietf.org/html/rfc7617\n   *\n   */\n\n\n  import { Buffer } from \"node:buffer\";\n\n\n  const encoder = new TextEncoder();\n\n\n  /**\n   * Protect against timing attacks by safely comparing values using `timingSafeEqual`.\n   * Refer to https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#timingsafeequal for more details\n   */\n  function timingSafeEqual(a: string, b: string) {\n    const aBytes = encoder.encode(a);\n    const bBytes = encoder.encode(b);\n\n\n    if (aBytes.byteLength !== bBytes.byteLength) {\n      // Strings must be the same length in order to compare\n      // with crypto.subtle.timingSafeEqual\n      return false;\n    }\n\n\n    return crypto.subtle.timingSafeEqual(aBytes, bBytes);\n  }\n\n\n  interface Env {\n    PASSWORD: string;\n  }\n  export default {\n    async fetch(request, env): Promise<Response> {\n      const BASIC_USER = \"admin\";\n\n\n      // You will need an admin password. This should be\n      // attached to your Worker as an encrypted secret.\n      // Refer to https://developers.cloudflare.com/workers/configuration/secrets/\n      const BASIC_PASS = env.PASSWORD ?? \"password\";\n\n\n      const url = new URL(request.url);\n\n\n      switch (url.pathname) {\n        case \"/\":\n          return new Response(\"Anyone can access the homepage.\");\n\n\n        case \"/logout\":\n          // Invalidate the \"Authorization\" header by returning a HTTP 401.\n          // We do not send a \"WWW-Authenticate\" header, as this would trigger\n          // a popup in the browser, immediately asking for credentials again.\n          return new Response(\"Logged out.\", { status: 401 });\n\n\n        case \"/admin\": {\n          // The \"Authorization\" header is sent when authenticated.\n          const authorization = request.headers.get(\"Authorization\");\n          if (!authorization) {\n            return new Response(\"You need to login.\", {\n              status: 401,\n              headers: {\n                // Prompts the user for credentials.\n                \"WWW-Authenticate\": 'Basic realm=\"my scope\", charset=\"UTF-8\"',\n              },\n            });\n          }\n          const [scheme, encoded] = authorization.split(\" \");\n\n\n          // The Authorization header must start with Basic, followed by a space.\n          if (!encoded || scheme !== \"Basic\") {\n            return new Response(\"Malformed authorization header.\", {\n              status: 400,\n            });\n          }\n\n\n          const credentials = Buffer.from(encoded, \"base64\").toString();\n\n\n          // The username and password are split by the first colon.\n          //=> example: \"username:password\"\n          const index = credentials.indexOf(\":\");\n          const user = credentials.substring(0, index);\n          const pass = credentials.substring(index + 1);\n\n\n          if (\n            !timingSafeEqual(BASIC_USER, user) ||\n            !timingSafeEqual(BASIC_PASS, pass)\n          ) {\n            return new Response(\"You need to login.\", {\n              status: 401,\n              headers: {\n                // Prompts the user for credentials.\n                \"WWW-Authenticate\": 'Basic realm=\"my scope\", charset=\"UTF-8\"',\n              },\n            });\n          }\n\n\n          return new Response(\"🎉 You have private access!\", {\n            status: 200,\n            headers: {\n              \"Cache-Control\": \"no-store\",\n            },\n          });\n        }\n      }\n\n\n      return new Response(\"Not Found.\", { status: 404 });\n    },\n  } satisfies ExportedHandler<Env>;",
      "language": "ts"
    },
    {
      "code": "use base64::prelude::*;\n  use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(req: Request, env: Env, _ctx: Context) -> Result<Response> {\n      let basic_user = \"admin\";\n      // You will need an admin password. This should be\n      // attached to your Worker as an encrypted secret.\n      // Refer to https://developers.cloudflare.com/workers/configuration/secrets/\n      let basic_pass = match env.secret(\"PASSWORD\") {\n          Ok(s) => s.to_string(),\n          Err(_) => \"password\".to_string(),\n      };\n      let url = req.url()?;\n\n\n      match url.path() {\n          \"/\" => Response::ok(\"Anyone can access the homepage.\"),\n          // Invalidate the \"Authorization\" header by returning a HTTP 401.\n          // We do not send a \"WWW-Authenticate\" header, as this would trigger\n          // a popup in the browser, immediately asking for credentials again.\n          \"/logout\" => Response::error(\"Logged out.\", 401),\n          \"/admin\" => {\n              // The \"Authorization\" header is sent when authenticated.\n              let authorization = req.headers().get(\"Authorization\")?;\n              if authorization == None {\n                  let mut headers = Headers::new();\n                  // Prompts the user for credentials.\n                  headers.set(\n                      \"WWW-Authenticate\",\n                      \"Basic realm='my scope', charset='UTF-8'\",\n                  )?;\n                  return Ok(Response::error(\"You need to login.\", 401)?.with_headers(headers));\n              }\n              let authorization = authorization.unwrap();\n              let auth: Vec<&str> = authorization.split(\" \").collect();\n              let scheme = auth[0];\n              let encoded = auth[1];\n\n\n              // The Authorization header must start with Basic, followed by a space.\n              if encoded == \"\" || scheme != \"Basic\" {\n                  return Response::error(\"Malformed authorization header.\", 400);\n              }\n\n\n              let buff = BASE64_STANDARD.decode(encoded).unwrap();\n              let credentials = String::from_utf8_lossy(&buff);\n              // The username & password are split by the first colon.\n              //=> example: \"username:password\"\n              let credentials: Vec<&str> = credentials.split(':').collect();\n              let user = credentials[0];\n              let pass = credentials[1];\n\n\n              if user != basic_user || pass != basic_pass {\n                  let mut headers = Headers::new();\n                  // Prompts the user for credentials.\n                  headers.set(\n                      \"WWW-Authenticate\",\n                      \"Basic realm='my scope', charset='UTF-8'\",\n                  )?;\n                  return Ok(Response::error(\"You need to login.\", 401)?.with_headers(headers));\n              }\n\n\n              let mut headers = Headers::new();\n              headers.set(\"Cache-Control\", \"no-store\")?;\n              Ok(Response::ok(\"🎉 You have private access!\")?.with_headers(headers))\n          }\n          _ => Response::error(\"Not Found.\", 404),\n      }\n  }",
      "language": "rs"
    },
    {
      "code": "/**\n   * Shows how to restrict access using the HTTP Basic schema with Hono.\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\n   * @see https://tools.ietf.org/html/rfc7617\n   */\n\n\n  import { Hono } from \"hono\";\n  import { basicAuth } from \"hono/basic-auth\";\n\n\n  // Define environment interface\n  interface Env {\n    Bindings: {\n      USERNAME: string;\n      PASSWORD: string;\n    };\n  }\n\n\n  const app = new Hono<Env>();\n\n\n  // Public homepage - accessible to everyone\n  app.get(\"/\", (c) => {\n    return c.text(\"Anyone can access the homepage.\");\n  });\n\n\n  // Admin route - protected with Basic Auth\n  app.get(\n    \"/admin\",\n    async (c, next) => {\n      const auth = basicAuth({\n        username: c.env.USERNAME,\n        password: c.env.PASSWORD,\n      });\n\n\n      return await auth(c, next);\n    },\n    (c) => {\n      return c.text(\"🎉 You have private access!\", 200, {\n        \"Cache-Control\": \"no-store\",\n      });\n    },\n  );\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      try {\n        const tlsVersion = request.cf.tlsVersion;\n        // Allow only TLS versions 1.2 and 1.3\n        if (tlsVersion !== \"TLSv1.2\" && tlsVersion !== \"TLSv1.3\") {\n          return new Response(\"Please use TLS version 1.2 or higher.\", {\n            status: 403,\n          });\n        }\n        return fetch(request);\n      } catch (err) {\n        console.error(\n          \"request.cf does not exist in the previewer, only in production\",\n        );\n        return new Response(`Error in workers script ${err.message}`, {\n          status: 500,\n        });\n      }\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      try {\n        const tlsVersion = request.cf.tlsVersion;\n        // Allow only TLS versions 1.2 and 1.3\n        if (tlsVersion !== \"TLSv1.2\" && tlsVersion !== \"TLSv1.3\") {\n          return new Response(\"Please use TLS version 1.2 or higher.\", {\n            status: 403,\n          });\n        }\n        return fetch(request);\n      } catch (err) {\n        console.error(\n          \"request.cf does not exist in the previewer, only in production\",\n        );\n        return new Response(`Error in workers script ${err.message}`, {\n          status: 500,\n        });\n      }\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  // Middleware to check TLS version\n  app.use(\"*\", async (c, next) => {\n    // Access the raw request to get the cf object with TLS info\n    const request = c.req.raw;\n    const tlsVersion = request.cf?.tlsVersion;\n\n\n    // Allow only TLS versions 1.2 and 1.3\n    if (tlsVersion !== \"TLSv1.2\" && tlsVersion !== \"TLSv1.3\") {\n      return c.text(\"Please use TLS version 1.2 or higher.\", 403);\n    }\n\n\n    await next();\n\n\n  });\n\n\n  app.onError((err, c) => {\n      console.error(\n        \"request.cf does not exist in the previewer, only in production\",\n      );\n      return c.text(`Error in workers script: ${err.message}`, 500);\n  });\n\n\n  app.get(\"/\", async (c) => {\n    return c.text(`TLS Version: ${c.req.raw.cf.tlsVersion}`);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response, fetch\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          tls_version = request.cf.tlsVersion\n          if tls_version not in (\"TLSv1.2\", \"TLSv1.3\"):\n              return Response(\"Please use TLS version 1.2 or higher.\", status=403)\n          return fetch(request)",
      "language": "py"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      /**\n       * An object with different URLs to fetch\n       * @param {Object} ORIGINS\n       */\n      const ORIGINS = {\n        \"starwarsapi.yourdomain.com\": \"swapi.dev\",\n        \"google.yourdomain.com\": \"www.google.com\",\n      };\n\n\n      const url = new URL(request.url);\n\n\n      // Check if incoming hostname is a key in the ORIGINS object\n      if (url.hostname in ORIGINS) {\n        const target = ORIGINS[url.hostname];\n        url.hostname = target;\n        // If it is, proxy request to that third party origin\n        return fetch(url.toString(), request);\n      }\n      // Otherwise, process request as normal\n      return fetch(request);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * An object with different URLs to fetch\n       * @param {Object} ORIGINS\n       */\n      const ORIGINS = {\n        \"starwarsapi.yourdomain.com\": \"swapi.dev\",\n        \"google.yourdomain.com\": \"www.google.com\",\n      };\n\n\n      const url = new URL(request.url);\n\n\n      // Check if incoming hostname is a key in the ORIGINS object\n      if (url.hostname in ORIGINS) {\n        const target = ORIGINS[url.hostname];\n        url.hostname = target;\n        // If it is, proxy request to that third party origin\n        return fetch(url.toString(), request);\n      }\n      // Otherwise, process request as normal\n      return fetch(request);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from \"hono\";\n  import { proxy } from \"hono/proxy\";\n\n\n  // An object with different URLs to fetch\n  const ORIGINS: Record<string, string> = {\n    \"starwarsapi.yourdomain.com\": \"swapi.dev\",\n    \"google.yourdomain.com\": \"www.google.com\",\n  };\n\n\n  const app = new Hono();\n\n\n  app.all(\"*\", async (c) => {\n    const url = new URL(c.req.url);\n\n\n    // Check if incoming hostname is a key in the ORIGINS object\n    if (url.hostname in ORIGINS) {\n      const target = ORIGINS[url.hostname];\n      url.hostname = target;\n\n\n      // If it is, proxy request to that third party origin\n      return proxy(url, c.req.raw);\n    }\n\n\n    // Otherwise, process request as normal\n    return proxy(c.req.raw);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from js import fetch, URL\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # A dict with different URLs to fetch\n          ORIGINS = {\n            \"starwarsapi.yourdomain.com\": \"swapi.dev\",\n            \"google.yourdomain.com\": \"www.google.com\",\n          }\n\n\n          url = URL.new(request.url)\n\n\n          # Check if incoming hostname is a key in the ORIGINS object\n          if url.hostname in ORIGINS:\n              url.hostname = ORIGINS[url.hostname]\n              # If it is, proxy request to that third party origin\n              return fetch(url.toString(), request)\n\n\n          # Otherwise, process request as normal\n          return fetch(request)",
      "language": "py"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const externalHostname = \"examples.cloudflareworkers.com\";\n\n\n      const redirectMap = new Map([\n        [\"/bulk1\", \"https://\" + externalHostname + \"/redirect2\"],\n        [\"/bulk2\", \"https://\" + externalHostname + \"/redirect3\"],\n        [\"/bulk3\", \"https://\" + externalHostname + \"/redirect4\"],\n        [\"/bulk4\", \"https://google.com\"],\n      ]);\n\n\n      const requestURL = new URL(request.url);\n      const path = requestURL.pathname;\n      const location = redirectMap.get(path);\n\n\n      if (location) {\n        return Response.redirect(location, 301);\n      }\n      // If request not in map, return the original request\n      return fetch(request);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const externalHostname = \"examples.cloudflareworkers.com\";\n\n\n      const redirectMap = new Map([\n        [\"/bulk1\", \"https://\" + externalHostname + \"/redirect2\"],\n        [\"/bulk2\", \"https://\" + externalHostname + \"/redirect3\"],\n        [\"/bulk3\", \"https://\" + externalHostname + \"/redirect4\"],\n        [\"/bulk4\", \"https://google.com\"],\n      ]);\n\n\n      const requestURL = new URL(request.url);\n      const path = requestURL.pathname;\n      const location = redirectMap.get(path);\n\n\n      if (location) {\n        return Response.redirect(location, 301);\n      }\n      // If request not in map, return the original request\n      return fetch(request);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response, fetch\n  from urllib.parse import urlparse\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          external_hostname = \"examples.cloudflareworkers.com\"\n\n\n          redirect_map = {\n            \"/bulk1\": \"https://\" + external_hostname + \"/redirect2\",\n            \"/bulk2\": \"https://\" + external_hostname + \"/redirect3\",\n            \"/bulk3\": \"https://\" + external_hostname + \"/redirect4\",\n            \"/bulk4\": \"https://google.com\",\n            }\n\n\n          url = urlparse(request.url)\n          location = redirect_map.get(url.path, None)\n\n\n          if location:\n              return Response.redirect(location, 301)\n\n\n          # If request not in map, return the original request\n          return fetch(request)",
      "language": "py"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  // Configure your redirects\n  const externalHostname = \"examples.cloudflareworkers.com\";\n\n\n  const redirectMap = new Map([\n    [\"/bulk1\", `https://${externalHostname}/redirect2`],\n    [\"/bulk2\", `https://${externalHostname}/redirect3`],\n    [\"/bulk3\", `https://${externalHostname}/redirect4`],\n    [\"/bulk4\", \"https://google.com\"],\n  ]);\n\n\n  // Middleware to handle redirects\n  app.use(\"*\", async (c, next) => {\n    const path = c.req.path;\n    const location = redirectMap.get(path);\n\n\n    if (location) {\n      // If path is in our redirect map, perform the redirect\n      return c.redirect(location, 301);\n    }\n\n\n    // Otherwise, continue to the next handler\n    await next();\n  });\n\n\n  // Default handler for requests that don't match any redirects\n  app.all(\"*\", async (c) => {\n    // Pass through to origin\n    return fetch(c.req.raw);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request, env, ctx) {\n      const cacheUrl = new URL(request.url);\n\n\n      // Construct the cache key from the cache URL\n      const cacheKey = new Request(cacheUrl.toString(), request);\n      const cache = caches.default;\n\n\n      // Check whether the value is already available in the cache\n      // if not, you will need to fetch it from origin, and store it in the cache\n      let response = await cache.match(cacheKey);\n\n\n      if (!response) {\n        console.log(\n          `Response for request url: ${request.url} not present in cache. Fetching and caching request.`,\n        );\n        // If not in cache, get it from origin\n        response = await fetch(request);\n\n\n        // Must use Response constructor to inherit all of response's fields\n        response = new Response(response.body, response);\n\n\n        // Cache API respects Cache-Control headers. Setting s-maxage to 10\n        // will limit the response to be in cache for 10 seconds max\n\n\n        // Any changes made to the response here will be reflected in the cached value\n        response.headers.append(\"Cache-Control\", \"s-maxage=10\");\n\n\n        ctx.waitUntil(cache.put(cacheKey, response.clone()));\n      } else {\n        console.log(`Cache hit for: ${request.url}.`);\n      }\n      return response;\n    },\n  };",
      "language": "js"
    },
    {
      "code": "interface Env {}\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      const cacheUrl = new URL(request.url);\n\n\n      // Construct the cache key from the cache URL\n      const cacheKey = new Request(cacheUrl.toString(), request);\n      const cache = caches.default;\n\n\n      // Check whether the value is already available in the cache\n      // if not, you will need to fetch it from origin, and store it in the cache\n      let response = await cache.match(cacheKey);\n\n\n      if (!response) {\n        console.log(\n          `Response for request url: ${request.url} not present in cache. Fetching and caching request.`,\n        );\n        // If not in cache, get it from origin\n        response = await fetch(request);\n\n\n        // Must use Response constructor to inherit all of response's fields\n        response = new Response(response.body, response);\n\n\n        // Cache API respects Cache-Control headers. Setting s-maxage to 10\n        // will limit the response to be in cache for 10 seconds max\n\n\n        // Any changes made to the response here will be reflected in the cached value\n        response.headers.append(\"Cache-Control\", \"s-maxage=10\");\n\n\n        ctx.waitUntil(cache.put(cacheKey, response.clone()));\n      } else {\n        console.log(`Cache hit for: ${request.url}.`);\n      }\n      return response;\n    },\n  } satisfies ExportedHandler<Env>;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from pyodide.ffi import create_proxy\n  from js import Response, Request, URL, caches, fetch\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          cache_url = request.url\n\n\n          # Construct the cache key from the cache URL\n          cache_key = Request.new(cache_url, request)\n          cache = caches.default\n\n\n          # Check whether the value is already available in the cache\n          # if not, you will need to fetch it from origin, and store it in the cache\n          response = await cache.match(cache_key)\n\n\n          if response is None:\n              print(f\"Response for request url: {request.url} not present in cache. Fetching and caching request.\")\n              # If not in cache, get it from origin\n              response = await fetch(request)\n              # Must use Response constructor to inherit all of response's fields\n              response = Response.new(response.body, response)\n\n\n              # Cache API respects Cache-Control headers. Setting s-max-age to 10\n              # will limit the response to be in cache for 10 seconds s-maxage\n              # Any changes made to the response here will be reflected in the cached value\n              response.headers.append(\"Cache-Control\", \"s-maxage=10\")\n              self.ctx.waitUntil(create_proxy(cache.put(cache_key, response.clone())))\n          else:\n              print(f\"Cache hit for: {request.url}.\")\n          return response",
      "language": "py"
    },
    {
      "code": "import { Hono } from \"hono\";\n  import { cache } from \"hono/cache\";\n\n\n  const app = new Hono();\n\n\n  // We leverage hono built-in cache helper here\n  app.get(\n    \"*\",\n    cache({\n      cacheName: \"my-cache\",\n      cacheControl: \"max-age=3600\", // 1 hour\n    }),\n  );\n\n\n  // Add a route to handle the request if it's not in cache\n  app.get(\"*\", (c) => {\n    return c.text(\"Hello from Hono!\");\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request, env, ctx) {\n      async function sha256(message) {\n        // encode as UTF-8\n        const msgBuffer = await new TextEncoder().encode(message);\n        // hash the message\n        const hashBuffer = await crypto.subtle.digest(\"SHA-256\", msgBuffer);\n        // convert bytes to hex string\n        return [...new Uint8Array(hashBuffer)]\n          .map((b) => b.toString(16).padStart(2, \"0\"))\n          .join(\"\");\n      }\n      try {\n        if (request.method.toUpperCase() === \"POST\") {\n          const body = await request.clone().text();\n          // Hash the request body to use it as a part of the cache key\n          const hash = await sha256(body);\n          const cacheUrl = new URL(request.url);\n          // Store the URL in cache by prepending the body's hash\n          cacheUrl.pathname = \"/posts\" + cacheUrl.pathname + hash;\n          // Convert to a GET to be able to cache\n          const cacheKey = new Request(cacheUrl.toString(), {\n            headers: request.headers,\n            method: \"GET\",\n          });\n\n\n          const cache = caches.default;\n          // Find the cache key in the cache\n          let response = await cache.match(cacheKey);\n          // Otherwise, fetch response to POST request from origin\n          if (!response) {\n            response = await fetch(request);\n            ctx.waitUntil(cache.put(cacheKey, response.clone()));\n          }\n          return response;\n        }\n        return fetch(request);\n      } catch (e) {\n        return new Response(\"Error thrown \" + e.message);\n      }\n    },\n  };",
      "language": "js"
    },
    {
      "code": "interface Env {}\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      async function sha256(message) {\n        // encode as UTF-8\n        const msgBuffer = await new TextEncoder().encode(message);\n        // hash the message\n        const hashBuffer = await crypto.subtle.digest(\"SHA-256\", msgBuffer);\n        // convert bytes to hex string\n        return [...new Uint8Array(hashBuffer)]\n          .map((b) => b.toString(16).padStart(2, \"0\"))\n          .join(\"\");\n      }\n      try {\n        if (request.method.toUpperCase() === \"POST\") {\n          const body = await request.clone().text();\n          // Hash the request body to use it as a part of the cache key\n          const hash = await sha256(body);\n          const cacheUrl = new URL(request.url);\n          // Store the URL in cache by prepending the body's hash\n          cacheUrl.pathname = \"/posts\" + cacheUrl.pathname + hash;\n          // Convert to a GET to be able to cache\n          const cacheKey = new Request(cacheUrl.toString(), {\n            headers: request.headers,\n            method: \"GET\",\n          });\n\n\n          const cache = caches.default;\n          // Find the cache key in the cache\n          let response = await cache.match(cacheKey);\n          // Otherwise, fetch response to POST request from origin\n          if (!response) {\n            response = await fetch(request);\n            ctx.waitUntil(cache.put(cacheKey, response.clone()));\n          }\n          return response;\n        }\n        return fetch(request);\n      } catch (e) {\n        return new Response(\"Error thrown \" + e.message);\n      }\n    },\n  } satisfies ExportedHandler<Env>;",
      "language": "ts"
    },
    {
      "code": "import hashlib\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import create_proxy\n  from js import fetch, URL, Headers, Request, caches\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request, _, ctx):\n          if 'POST' in request.method:\n              # Hash the request body to use it as a part of the cache key\n              body = await request.clone().text()\n              body_hash = hashlib.sha256(body.encode('UTF-8')).hexdigest()\n\n\n              # Store the URL in cache by prepending the body's hash\n              cache_url = URL.new(request.url)\n              cache_url.pathname = \"/posts\" + cache_url.pathname + body_hash\n\n\n              # Convert to a GET to be able to cache\n              headers = Headers.new(dict(request.headers).items())\n              cache_key = Request.new(cache_url.toString(), method='GET', headers=headers)\n\n\n              # Find the cache key in the cache\n              cache = caches.default\n              response = await cache.match(cache_key)\n\n\n              # Otherwise, fetch response to POST request from origin\n              if response is None:\n                  response = await fetch(request)\n                  ctx.waitUntil(create_proxy(cache.put(cache_key, response.clone())))\n\n\n              return response\n\n\n          return fetch(request)",
      "language": "py"
    },
    {
      "code": "import { Hono } from \"hono\";\n  import { sha256 } from \"hono/utils/crypto\";\n\n\n  const app = new Hono();\n\n\n  // Middleware for caching POST requests\n  app.post(\"*\", async (c) => {\n    try {\n      // Get the request body\n      const body = await c.req.raw.clone().text();\n\n\n      // Hash the request body to use it as part of the cache key\n      const hash = await sha256(body);\n\n\n      // Create the cache URL\n      const cacheUrl = new URL(c.req.url);\n\n\n      // Store the URL in cache by prepending the body's hash\n      cacheUrl.pathname = \"/posts\" + cacheUrl.pathname + hash;\n\n\n      // Convert to a GET to be able to cache\n      const cacheKey = new Request(cacheUrl.toString(), {\n        headers: c.req.raw.headers,\n        method: \"GET\",\n      });\n\n\n      const cache = caches.default;\n\n\n      // Find the cache key in the cache\n      let response = await cache.match(cacheKey);\n\n\n      // If not in cache, fetch response to POST request from origin\n      if (!response) {\n        response = await fetch(c.req.raw);\n        c.executionCtx.waitUntil(cache.put(cacheKey, response.clone()));\n      }\n\n\n      return response;\n    } catch (e) {\n      return c.text(\"Error thrown \" + e.message, 500);\n    }\n  });\n\n\n  // Handle all other HTTP methods\n  app.all(\"*\", (c) => {\n    return fetch(c.req.raw);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const requestUrl = new URL(request.url);\n      const params = requestUrl.searchParams;\n      const tags =\n        params && params.has(\"tags\") ? params.get(\"tags\").split(\",\") : [];\n      const url = params && params.has(\"uri\") ? params.get(\"uri\") : \"\";\n      if (!url) {\n        const errorObject = {\n          error: \"URL cannot be empty\",\n        };\n        return new Response(JSON.stringify(errorObject), { status: 400 });\n      }\n      const init = {\n        cf: {\n          cacheTags: tags,\n        },\n      };\n      return fetch(url, init)\n        .then((result) => {\n          const cacheStatus = result.headers.get(\"cf-cache-status\");\n          const lastModified = result.headers.get(\"last-modified\");\n          const response = {\n            cache: cacheStatus,\n            lastModified: lastModified,\n          };\n          return new Response(JSON.stringify(response), {\n            status: result.status,\n          });\n        })\n        .catch((err) => {\n          const errorObject = {\n            error: err.message,\n          };\n          return new Response(JSON.stringify(errorObject), { status: 500 });\n        });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const requestUrl = new URL(request.url);\n      const params = requestUrl.searchParams;\n      const tags =\n        params && params.has(\"tags\") ? params.get(\"tags\").split(\",\") : [];\n      const url = params && params.has(\"uri\") ? params.get(\"uri\") : \"\";\n      if (!url) {\n        const errorObject = {\n          error: \"URL cannot be empty\",\n        };\n        return new Response(JSON.stringify(errorObject), { status: 400 });\n      }\n      const init = {\n        cf: {\n          cacheTags: tags,\n        },\n      };\n      return fetch(url, init)\n        .then((result) => {\n          const cacheStatus = result.headers.get(\"cf-cache-status\");\n          const lastModified = result.headers.get(\"last-modified\");\n          const response = {\n            cache: cacheStatus,\n            lastModified: lastModified,\n          };\n          return new Response(JSON.stringify(response), {\n            status: result.status,\n          });\n        })\n        .catch((err) => {\n          const errorObject = {\n            error: err.message,\n          };\n          return new Response(JSON.stringify(errorObject), { status: 500 });\n        });\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  app.all(\"*\", async (c) => {\n    const tags = c.req.query(\"tags\") ? c.req.query(\"tags\").split(\",\") : [];\n    const uri = c.req.query(\"uri\") ? c.req.query(\"uri\") : \"\";\n\n\n    if (!uri) {\n      return c.json({ error: \"URL cannot be empty\" }, 400);\n    }\n\n\n    const init = {\n      cf: {\n        cacheTags: tags,\n      },\n    };\n\n\n    const result = await fetch(uri, init);\n    const cacheStatus = result.headers.get(\"cf-cache-status\");\n    const lastModified = result.headers.get(\"last-modified\");\n\n\n    const response = {\n      cache: cacheStatus,\n      lastModified: lastModified,\n    };\n\n\n    return c.json(response, result.status);\n  });\n\n\n  app.onError((err, c) => {\n    return c.json({ error: err.message }, 500);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Response, URL, Object, fetch\n\n\n  def to_js(x):\n      return _to_js(x, dict_converter=Object.fromEntries)\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          request_url = URL.new(request.url)\n          params = request_url.searchParams\n          tags = params[\"tags\"].split(\",\") if \"tags\" in params else []\n          url = params[\"uri\"] or None\n\n\n          if url is None:\n              error = {\"error\": \"URL cannot be empty\"}\n              return Response.json(to_js(error), status=400)\n\n\n          options = {\"cf\": {\"cacheTags\": tags}}\n          result = await fetch(url, to_js(options))\n\n\n          cache_status = result.headers[\"cf-cache-status\"]\n          last_modified = result.headers[\"last-modified\"]\n          response = {\"cache\": cache_status, \"lastModified\": last_modified}\n\n\n          return Response.json(to_js(response), status=result.status)",
      "language": "py"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const url = new URL(request.url);\n      // Only use the path for the cache key, removing query strings\n      // and always store using HTTPS, for example, https://www.example.com/file-uri-here\n      const someCustomKey = `https://${url.hostname}${url.pathname}`;\n      let response = await fetch(request, {\n        cf: {\n          // Always cache this fetch regardless of content type\n          // for a max of 5 seconds before revalidating the resource\n          cacheTtl: 5,\n          cacheEverything: true,\n          //Enterprise only feature, see Cache API for other plans\n          cacheKey: someCustomKey,\n        },\n      });\n      // Reconstruct the Response object to make its headers mutable.\n      response = new Response(response.body, response);\n      // Set cache control headers to cache on browser for 25 minutes\n      response.headers.set(\"Cache-Control\", \"max-age=1500\");\n      return response;\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const url = new URL(request.url);\n      // Only use the path for the cache key, removing query strings\n      // and always store using HTTPS, for example, https://www.example.com/file-uri-here\n      const someCustomKey = `https://${url.hostname}${url.pathname}`;\n      let response = await fetch(request, {\n        cf: {\n          // Always cache this fetch regardless of content type\n          // for a max of 5 seconds before revalidating the resource\n          cacheTtl: 5,\n          cacheEverything: true,\n          //Enterprise only feature, see Cache API for other plans\n          cacheKey: someCustomKey,\n        },\n      });\n      // Reconstruct the Response object to make its headers mutable.\n      response = new Response(response.body, response);\n      // Set cache control headers to cache on browser for 25 minutes\n      response.headers.set(\"Cache-Control\", \"max-age=1500\");\n      return response;\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  type Bindings = {};\n\n\n  const app = new Hono<{ Bindings: Bindings }>();\n\n\n  app.all('*', async (c) => {\n    const url = new URL(c.req.url);\n\n\n    // Only use the path for the cache key, removing query strings\n    // and always store using HTTPS, for example, https://www.example.com/file-uri-here\n    const someCustomKey = `https://${url.hostname}${url.pathname}`;\n\n\n    // Fetch the request with custom cache settings\n    let response = await fetch(c.req.raw, {\n      cf: {\n        // Always cache this fetch regardless of content type\n        // for a max of 5 seconds before revalidating the resource\n        cacheTtl: 5,\n        cacheEverything: true,\n        // Enterprise only feature, see Cache API for other plans\n        cacheKey: someCustomKey,\n      },\n    });\n\n\n    // Reconstruct the Response object to make its headers mutable\n    response = new Response(response.body, response);\n\n\n    // Set cache control headers to cache on browser for 25 minutes\n    response.headers.set(\"Cache-Control\", \"max-age=1500\");\n\n\n    return response;\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Response, URL, Object, fetch\n\n\n  def to_js(x):\n      return _to_js(x, dict_converter=Object.fromEntries)\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          url = URL.new(request.url)\n\n\n          # Only use the path for the cache key, removing query strings\n          # and always store using HTTPS, for example, https://www.example.com/file-uri-here\n          some_custom_key = f\"https://{url.hostname}{url.pathname}\"\n\n\n          response = await fetch(\n              request,\n              cf=to_js({\n                  # Always cache this fetch regardless of content type\n                  # for a max of 5 seconds before revalidating the resource\n                  \"cacheTtl\": 5,\n                  \"cacheEverything\": True,\n                  # Enterprise only feature, see Cache API for other plans\n                  \"cacheKey\": some_custom_key,\n              }),\n          )\n\n\n          # Reconstruct the Response object to make its headers mutable\n          response = Response.new(response.body, response)\n\n\n          # Set cache control headers to cache on browser for 25 minutes\n          response.headers[\"Cache-Control\"] = \"max-age=1500\"\n\n\n          return response",
      "language": "py"
    },
    {
      "code": "use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let url = req.url()?;\n\n\n      // Only use the path for the cache key, removing query strings\n      // and always store using HTTPS, for example, https://www.example.com/file-uri-here\n      let custom_key = format!(\n          \"https://{host}{path}\",\n          host = url.host_str().unwrap(),\n          path = url.path()\n      );\n\n\n      let request = Request::new_with_init(\n          url.as_str(),\n          &RequestInit {\n              headers: req.headers().clone(),\n              method: req.method(),\n              cf: CfProperties {\n                  // Always cache this fetch regardless of content type\n                  // for a max of 5 seconds before revalidating the resource\n                  cache_ttl: Some(5),\n                  cache_everything: Some(true),\n                  // Enterprise only feature, see Cache API for other plans\n                  cache_key: Some(custom_key),\n                  ..CfProperties::default()\n              },\n              ..RequestInit::default()\n          },\n      )?;\n\n\n      let mut response = Fetch::Request(request).send().await?;\n\n\n      // Set cache control headers to cache on browser for 25 minutes\n      let _ = response.headers_mut().set(\"Cache-Control\", \"max-age=1500\");\n      Ok(response)\n  }",
      "language": "rs"
    },
    {
      "code": "// Force Cloudflare to cache an asset\nfetch(event.request, { cf: { cacheEverything: true } });",
      "language": "js"
    },
    {
      "code": "// Set cache key for this request to \"some-string\".\nfetch(event.request, { cf: { cacheKey: \"some-string\" } });",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      let url = new URL(request.url);\n\n\n      if (Math.random() < 0.5) {\n        url.hostname = \"example.s3.amazonaws.com\";\n      } else {\n        url.hostname = \"example.storage.googleapis.com\";\n      }\n\n\n      let newRequest = new Request(url, request);\n      return fetch(newRequest, {\n        cf: { cacheKey: request.url },\n      });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      let url = new URL(request.url);\n\n\n      if (Math.random() < 0.5) {\n        url.hostname = \"example.s3.amazonaws.com\";\n      } else {\n        url.hostname = \"example.storage.googleapis.com\";\n      }\n\n\n      let newRequest = new Request(url, request);\n      return fetch(newRequest, {\n        cf: { cacheKey: request.url },\n      });\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  type Bindings = {};\n\n\n  const app = new Hono<{ Bindings: Bindings }>();\n\n\n  app.all('*', async (c) => {\n    const originalUrl = c.req.url;\n    const url = new URL(originalUrl);\n\n\n    // Randomly select a storage backend\n    if (Math.random() < 0.5) {\n      url.hostname = \"example.s3.amazonaws.com\";\n    } else {\n      url.hostname = \"example.storage.googleapis.com\";\n    }\n\n\n    // Create a new request to the selected backend\n    const newRequest = new Request(url, c.req.raw);\n\n\n    // Fetch using the original URL as the cache key\n    return fetch(newRequest, {\n      cf: { cacheKey: originalUrl },\n    });\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "// Force response to be cached for 86400 seconds for 200 status\n// codes, 1 second for 404, and do not cache 500 errors.\nfetch(request, {\n  cf: { cacheTtlByStatus: { \"200-299\": 86400, 404: 1, \"500-599\": 0 } },\n});",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      // Instantiate new URL to make it mutable\n      const newRequest = new URL(request.url);\n\n\n      const customCacheKey = `${newRequest.hostname}${newRequest.pathname}`;\n      const queryCacheKey = `${newRequest.hostname}${newRequest.pathname}${newRequest.search}`;\n\n\n      // Different asset types usually have different caching strategies. Most of the time media content such as audio, videos and images that are not user-generated content would not need to be updated often so a long TTL would be best. However, with HLS streaming, manifest files usually are set with short TTLs so that playback will not be affected, as this files contain the data that the player would need. By setting each caching strategy for categories of asset types in an object within an array, you can solve complex needs when it comes to media content for your application\n\n\n      const cacheAssets = [\n        {\n          asset: \"video\",\n          key: customCacheKey,\n          regex:\n            /(.*\\/Video)|(.*\\.(m4s|mp4|ts|avi|mpeg|mpg|mkv|bin|webm|vob|flv|m2ts|mts|3gp|m4v|wmv|qt))/,\n          info: 0,\n          ok: 31556952,\n          redirects: 30,\n          clientError: 10,\n          serverError: 0,\n        },\n        {\n          asset: \"image\",\n          key: queryCacheKey,\n          regex:\n            /(.*\\/Images)|(.*\\.(jpg|jpeg|png|bmp|pict|tif|tiff|webp|gif|heif|exif|bat|bpg|ppm|pgn|pbm|pnm))/,\n          info: 0,\n          ok: 3600,\n          redirects: 30,\n          clientError: 10,\n          serverError: 0,\n        },\n        {\n          asset: \"frontEnd\",\n          key: queryCacheKey,\n          regex: /^.*\\.(css|js)/,\n          info: 0,\n          ok: 3600,\n          redirects: 30,\n          clientError: 10,\n          serverError: 0,\n        },\n        {\n          asset: \"audio\",\n          key: customCacheKey,\n          regex:\n            /(.*\\/Audio)|(.*\\.(flac|aac|mp3|alac|aiff|wav|ogg|aiff|opus|ape|wma|3gp))/,\n          info: 0,\n          ok: 31556952,\n          redirects: 30,\n          clientError: 10,\n          serverError: 0,\n        },\n        {\n          asset: \"directPlay\",\n          key: customCacheKey,\n          regex: /.*(\\/Download)/,\n          info: 0,\n          ok: 31556952,\n          redirects: 30,\n          clientError: 10,\n          serverError: 0,\n        },\n        {\n          asset: \"manifest\",\n          key: customCacheKey,\n          regex: /^.*\\.(m3u8|mpd)/,\n          info: 0,\n          ok: 3,\n          redirects: 2,\n          clientError: 1,\n          serverError: 0,\n        },\n      ];\n\n\n      const { asset, regex, ...cache } =\n        cacheAssets.find(({ regex }) => newRequest.pathname.match(regex)) ?? {};\n\n\n      const newResponse = await fetch(request, {\n        cf: {\n          cacheKey: cache.key,\n          polish: false,\n          cacheEverything: true,\n          cacheTtlByStatus: {\n            \"100-199\": cache.info,\n            \"200-299\": cache.ok,\n            \"300-399\": cache.redirects,\n            \"400-499\": cache.clientError,\n            \"500-599\": cache.serverError,\n          },\n          cacheTags: [\"static\"],\n        },\n      });\n\n\n      const response = new Response(newResponse.body, newResponse);\n\n\n      // For debugging purposes\n      response.headers.set(\"debug\", JSON.stringify(cache));\n      return response;\n    },\n  };",
      "language": "js"
    },
    {
      "code": "addEventListener(\"fetch\", (event) => {\n    return event.respondWith(handleRequest(event.request));\n  });\n\n\n  async function handleRequest(request) {\n    // Instantiate new URL to make it mutable\n    const newRequest = new URL(request.url);\n\n\n    // Set `const` to be used in the array later on\n    const customCacheKey = `${newRequest.hostname}${newRequest.pathname}`;\n    const queryCacheKey = `${newRequest.hostname}${newRequest.pathname}${newRequest.search}`;\n\n\n    // Set all variables needed to manipulate Cloudflare's cache using the fetch API in the `cf` object. You will be passing these variables in the objects down below.\n    const cacheAssets = [\n      {\n        asset: \"video\",\n        key: customCacheKey,\n        regex:\n          /(.*\\/Video)|(.*\\.(m4s|mp4|ts|avi|mpeg|mpg|mkv|bin|webm|vob|flv|m2ts|mts|3gp|m4v|wmv|qt))/,\n        info: 0,\n        ok: 31556952,\n        redirects: 30,\n        clientError: 10,\n        serverError: 0,\n      },\n      {\n        asset: \"image\",\n        key: queryCacheKey,\n        regex:\n          /(.*\\/Images)|(.*\\.(jpg|jpeg|png|bmp|pict|tif|tiff|webp|gif|heif|exif|bat|bpg|ppm|pgn|pbm|pnm))/,\n        info: 0,\n        ok: 3600,\n        redirects: 30,\n        clientError: 10,\n        serverError: 0,\n      },\n      {\n        asset: \"frontEnd\",\n        key: queryCacheKey,\n        regex: /^.*\\.(css|js)/,\n        info: 0,\n        ok: 3600,\n        redirects: 30,\n        clientError: 10,\n        serverError: 0,\n      },\n      {\n        asset: \"audio\",\n        key: customCacheKey,\n        regex:\n          /(.*\\/Audio)|(.*\\.(flac|aac|mp3|alac|aiff|wav|ogg|aiff|opus|ape|wma|3gp))/,\n        info: 0,\n        ok: 31556952,\n        redirects: 30,\n        clientError: 10,\n        serverError: 0,\n      },\n      {\n        asset: \"directPlay\",\n        key: customCacheKey,\n        regex: /.*(\\/Download)/,\n        info: 0,\n        ok: 31556952,\n        redirects: 30,\n        clientError: 10,\n        serverError: 0,\n      },\n      {\n        asset: \"manifest\",\n        key: customCacheKey,\n        regex: /^.*\\.(m3u8|mpd)/,\n        info: 0,\n        ok: 3,\n        redirects: 2,\n        clientError: 1,\n        serverError: 0,\n      },\n    ];\n\n\n    // the `.find` method is used to find elements in an array (`cacheAssets`), in this case, `regex`, which can passed to the .`match` method to match on file extensions to cache, since they are many media types in the array. If you want to add more types, update the array. Refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find for more information.\n    const { asset, regex, ...cache } =\n      cacheAssets.find(({ regex }) => newRequest.pathname.match(regex)) ?? {};\n\n\n    const newResponse = await fetch(request, {\n      cf: {\n        cacheKey: cache.key,\n        polish: false,\n        cacheEverything: true,\n        cacheTtlByStatus: {\n          \"100-199\": cache.info,\n          \"200-299\": cache.ok,\n          \"300-399\": cache.redirects,\n          \"400-499\": cache.clientError,\n          \"500-599\": cache.serverError,\n        },\n        cacheTags: [\"static\"],\n      },\n    });\n\n\n    const response = new Response(newResponse.body, newResponse);\n\n\n    // For debugging purposes\n    response.headers.set(\"debug\", JSON.stringify(cache));\n    return response;\n  }",
      "language": "js"
    },
    {
      "code": "fetch(request, { cache: 'no-store'});\nfetch(request, { cache: 'no-cache'});",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const BLOCKED_HOSTNAMES = [\"nope.mywebsite.com\", \"bye.website.com\"];\n      // Return a new Response based on a URL's hostname\n      const url = new URL(request.url);\n      if (BLOCKED_HOSTNAMES.includes(url.hostname)) {\n        return new Response(\"Blocked Host\", { status: 403 });\n      }\n      // Block paths ending in .doc or .xml based on the URL's file extension\n      const forbiddenExtRegExp = new RegExp(/\\.(doc|xml)$/);\n      if (forbiddenExtRegExp.test(url.pathname)) {\n        return new Response(\"Blocked Extension\", { status: 403 });\n      }\n      // On HTTP method\n      if (request.method === \"POST\") {\n        return new Response(\"Response for POST\");\n      }\n      // On User Agent\n      const userAgent = request.headers.get(\"User-Agent\") || \"\";\n      if (userAgent.includes(\"bot\")) {\n        return new Response(\"Block User Agent containing bot\", { status: 403 });\n      }\n      // On Client's IP address\n      const clientIP = request.headers.get(\"CF-Connecting-IP\");\n      if (clientIP === \"1.2.3.4\") {\n        return new Response(\"Block the IP 1.2.3.4\", { status: 403 });\n      }\n      // On ASN\n      if (request.cf && request.cf.asn == 64512) {\n        return new Response(\"Block the ASN 64512 response\");\n      }\n      // On Device Type\n      // Requires Enterprise \"CF-Device-Type Header\" zone setting or\n      // Page Rule with \"Cache By Device Type\" setting applied.\n      const device = request.headers.get(\"CF-Device-Type\");\n      if (device === \"mobile\") {\n        return Response.redirect(\"https://mobile.example.com\");\n      }\n      console.error(\n        \"Getting Client's IP address, device type, and ASN are not supported in playground. Must test on a live worker\",\n      );\n      return fetch(request);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const BLOCKED_HOSTNAMES = [\"nope.mywebsite.com\", \"bye.website.com\"];\n      // Return a new Response based on a URL's hostname\n      const url = new URL(request.url);\n      if (BLOCKED_HOSTNAMES.includes(url.hostname)) {\n        return new Response(\"Blocked Host\", { status: 403 });\n      }\n      // Block paths ending in .doc or .xml based on the URL's file extension\n      const forbiddenExtRegExp = new RegExp(/\\.(doc|xml)$/);\n      if (forbiddenExtRegExp.test(url.pathname)) {\n        return new Response(\"Blocked Extension\", { status: 403 });\n      }\n      // On HTTP method\n      if (request.method === \"POST\") {\n        return new Response(\"Response for POST\");\n      }\n      // On User Agent\n      const userAgent = request.headers.get(\"User-Agent\") || \"\";\n      if (userAgent.includes(\"bot\")) {\n        return new Response(\"Block User Agent containing bot\", { status: 403 });\n      }\n      // On Client's IP address\n      const clientIP = request.headers.get(\"CF-Connecting-IP\");\n      if (clientIP === \"1.2.3.4\") {\n        return new Response(\"Block the IP 1.2.3.4\", { status: 403 });\n      }\n      // On ASN\n      if (request.cf && request.cf.asn == 64512) {\n        return new Response(\"Block the ASN 64512 response\");\n      }\n      // On Device Type\n      // Requires Enterprise \"CF-Device-Type Header\" zone setting or\n      // Page Rule with \"Cache By Device Type\" setting applied.\n      const device = request.headers.get(\"CF-Device-Type\");\n      if (device === \"mobile\") {\n        return Response.redirect(\"https://mobile.example.com\");\n      }\n      console.error(\n        \"Getting Client's IP address, device type, and ASN are not supported in playground. Must test on a live worker\",\n      );\n      return fetch(request);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import re\n  from workers import WorkerEntrypoint, Response, fetch\n  from urllib.parse import urlparse\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          blocked_hostnames = [\"nope.mywebsite.com\", \"bye.website.com\"]\n          url = urlparse(request.url)\n\n\n          # Block on hostname\n          if url.hostname in blocked_hostnames:\n              return Response(\"Blocked Host\", status=403)\n\n\n          # On paths ending in .doc or .xml\n          if re.search(r'\\.(doc|xml)$', url.path):\n              return Response(\"Blocked Extension\", status=403)\n\n\n          # On HTTP method\n          if \"POST\" in request.method:\n              return Response(\"Response for POST\")\n\n\n          # On User Agent\n          user_agent = request.headers[\"User-Agent\"] or \"\"\n          if \"bot\" in user_agent:\n              return Response(\"Block User Agent containing bot\", status=403)\n\n\n          # On Client's IP address\n          client_ip = request.headers[\"CF-Connecting-IP\"]\n          if client_ip == \"1.2.3.4\":\n              return Response(\"Block the IP 1.2.3.4\", status=403)\n\n\n          # On ASN\n          if request.cf and request.cf.asn == 64512:\n              return Response(\"Block the ASN 64512 response\")\n\n\n          # On Device Type\n          # Requires Enterprise \"CF-Device-Type Header\" zone setting or\n          # Page Rule with \"Cache By Device Type\" setting applied.\n          device = request.headers[\"CF-Device-Type\"]\n          if device == \"mobile\":\n              return Response.redirect(\"https://mobile.example.com\")\n\n\n          return fetch(request)",
      "language": "py"
    },
    {
      "code": "import { Hono } from \"hono\";\n  import { HTTPException } from \"hono/http-exception\";\n\n\n  const app = new Hono();\n\n\n  // Middleware to handle all conditions before reaching the main handler\n  app.use(\"*\", async (c, next) => {\n    const request = c.req.raw;\n    const BLOCKED_HOSTNAMES = [\"nope.mywebsite.com\", \"bye.website.com\"];\n    const hostname = new URL(c.req.url)?.hostname;\n\n\n    // Return a new Response based on a URL's hostname\n    if (BLOCKED_HOSTNAMES.includes(hostname)) {\n      return c.text(\"Blocked Host\", 403);\n    }\n\n\n    // Block paths ending in .doc or .xml based on the URL's file extension\n    const forbiddenExtRegExp = new RegExp(/\\.(doc|xml)$/);\n    if (forbiddenExtRegExp.test(c.req.pathname)) {\n      return c.text(\"Blocked Extension\", 403);\n    }\n\n\n    // On User Agent\n    const userAgent = c.req.header(\"User-Agent\") || \"\";\n    if (userAgent.includes(\"bot\")) {\n      return c.text(\"Block User Agent containing bot\", 403);\n    }\n\n\n    // On Client's IP address\n    const clientIP = c.req.header(\"CF-Connecting-IP\");\n    if (clientIP === \"1.2.3.4\") {\n      return c.text(\"Block the IP 1.2.3.4\", 403);\n    }\n\n\n    // On ASN\n    if (request.cf && request.cf.asn === 64512) {\n      return c.text(\"Block the ASN 64512 response\");\n    }\n\n\n    // On Device Type\n    // Requires Enterprise \"CF-Device-Type Header\" zone setting or\n    // Page Rule with \"Cache By Device Type\" setting applied.\n    const device = c.req.header(\"CF-Device-Type\");\n    if (device === \"mobile\") {\n      return c.redirect(\"https://mobile.example.com\");\n    }\n\n\n    // Continue to the next handler\n    await next();\n  });\n\n\n  // Handle POST requests differently\n  app.post(\"*\", (c) => {\n    return c.text(\"Response for POST\");\n  });\n\n\n  // Default handler for other methods\n  app.get(\"*\", async (c) => {\n    console.error(\n      \"Getting Client's IP address, device type, and ASN are not supported in playground. Must test on a live worker\",\n    );\n\n\n    // Fetch the original request\n    return fetch(c.req.raw);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const corsHeaders = {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET,HEAD,POST,OPTIONS\",\n        \"Access-Control-Max-Age\": \"86400\",\n      };\n\n\n      // The URL for the remote third party API you want to fetch from\n      // but does not implement CORS\n      const API_URL = \"https://examples.cloudflareworkers.com/demos/demoapi\";\n\n\n      // The endpoint you want the CORS reverse proxy to be on\n      const PROXY_ENDPOINT = \"/corsproxy/\";\n\n\n      // The rest of this snippet for the demo page\n      function rawHtmlResponse(html) {\n        return new Response(html, {\n          headers: {\n            \"content-type\": \"text/html;charset=UTF-8\",\n          },\n        });\n      }\n\n\n      const DEMO_PAGE = `\n        <!DOCTYPE html>\n        <html>\n        <body>\n          <h1>API GET without CORS Proxy</h1>\n          <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\">Shows TypeError: Failed to fetch since CORS is misconfigured</a>\n          <p id=\"noproxy-status\"/>\n          <code id=\"noproxy\">Waiting</code>\n          <h1>API GET with CORS Proxy</h1>\n          <p id=\"proxy-status\"/>\n          <code id=\"proxy\">Waiting</code>\n          <h1>API POST with CORS Proxy + Preflight</h1>\n          <p id=\"proxypreflight-status\"/>\n          <code id=\"proxypreflight\">Waiting</code>\n          <script>\n          let reqs = {};\n          reqs.noproxy = () => {\n            return fetch(\"${API_URL}\").then(r => r.json())\n          }\n          reqs.proxy = async () => {\n            let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n            return fetch(window.location.origin + href).then(r => r.json())\n          }\n          reqs.proxypreflight = async () => {\n            let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n            let response = await fetch(window.location.origin + href, {\n              method: \"POST\",\n              headers: {\n                \"Content-Type\": \"application/json\"\n              },\n              body: JSON.stringify({\n                msg: \"Hello world!\"\n              })\n            })\n            return response.json()\n          }\n          (async () => {\n          for (const [reqName, req] of Object.entries(reqs)) {\n            try {\n              let data = await req()\n              document.getElementById(reqName).innerHTML = JSON.stringify(data)\n            } catch (e) {\n              document.getElementById(reqName).innerHTML = e\n            }\n          }\n        })()\n          </script>\n        </body>\n        </html>\n      `;\n\n\n      async function handleRequest(request) {\n        const url = new URL(request.url);\n        let apiUrl = url.searchParams.get(\"apiurl\");\n\n\n        if (apiUrl == null) {\n          apiUrl = API_URL;\n        }\n\n\n        // Rewrite request to point to API URL. This also makes the request mutable\n        // so you can add the correct Origin header to make the API server think\n        // that this request is not cross-site.\n        request = new Request(apiUrl, request);\n        request.headers.set(\"Origin\", new URL(apiUrl).origin);\n        let response = await fetch(request);\n        // Recreate the response so you can modify the headers\n\n\n        response = new Response(response.body, response);\n        // Set CORS headers\n\n\n        response.headers.set(\"Access-Control-Allow-Origin\", url.origin);\n\n\n        // Append to/Add Vary header so browser will cache response correctly\n        response.headers.append(\"Vary\", \"Origin\");\n\n\n        return response;\n      }\n\n\n      async function handleOptions(request) {\n        if (\n          request.headers.get(\"Origin\") !== null &&\n          request.headers.get(\"Access-Control-Request-Method\") !== null &&\n          request.headers.get(\"Access-Control-Request-Headers\") !== null\n        ) {\n          // Handle CORS preflight requests.\n          return new Response(null, {\n            headers: {\n              ...corsHeaders,\n              \"Access-Control-Allow-Headers\": request.headers.get(\n                \"Access-Control-Request-Headers\",\n              ),\n            },\n          });\n        } else {\n          // Handle standard OPTIONS request.\n          return new Response(null, {\n            headers: {\n              Allow: \"GET, HEAD, POST, OPTIONS\",\n            },\n          });\n        }\n      }\n\n\n      const url = new URL(request.url);\n      if (url.pathname.startsWith(PROXY_ENDPOINT)) {\n        if (request.method === \"OPTIONS\") {\n          // Handle CORS preflight requests\n          return handleOptions(request);\n        } else if (\n          request.method === \"GET\" ||\n          request.method === \"HEAD\" ||\n          request.method === \"POST\"\n        ) {\n          // Handle requests to the API server\n          return handleRequest(request);\n        } else {\n          return new Response(null, {\n            status: 405,\n            statusText: \"Method Not Allowed\",\n          });\n        }\n      } else {\n        return rawHtmlResponse(DEMO_PAGE);\n      }\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const corsHeaders = {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET,HEAD,POST,OPTIONS\",\n        \"Access-Control-Max-Age\": \"86400\",\n      };\n\n\n      // The URL for the remote third party API you want to fetch from\n      // but does not implement CORS\n      const API_URL = \"https://examples.cloudflareworkers.com/demos/demoapi\";\n\n\n      // The endpoint you want the CORS reverse proxy to be on\n      const PROXY_ENDPOINT = \"/corsproxy/\";\n\n\n      // The rest of this snippet for the demo page\n      function rawHtmlResponse(html) {\n        return new Response(html, {\n          headers: {\n            \"content-type\": \"text/html;charset=UTF-8\",\n          },\n        });\n      }\n\n\n      const DEMO_PAGE = `\n        <!DOCTYPE html>\n        <html>\n        <body>\n          <h1>API GET without CORS Proxy</h1>\n          <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\">Shows TypeError: Failed to fetch since CORS is misconfigured</a>\n          <p id=\"noproxy-status\"/>\n          <code id=\"noproxy\">Waiting</code>\n          <h1>API GET with CORS Proxy</h1>\n          <p id=\"proxy-status\"/>\n          <code id=\"proxy\">Waiting</code>\n          <h1>API POST with CORS Proxy + Preflight</h1>\n          <p id=\"proxypreflight-status\"/>\n          <code id=\"proxypreflight\">Waiting</code>\n          <script>\n          let reqs = {};\n          reqs.noproxy = () => {\n            return fetch(\"${API_URL}\").then(r => r.json())\n          }\n          reqs.proxy = async () => {\n            let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n            return fetch(window.location.origin + href).then(r => r.json())\n          }\n          reqs.proxypreflight = async () => {\n            let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n            let response = await fetch(window.location.origin + href, {\n              method: \"POST\",\n              headers: {\n                \"Content-Type\": \"application/json\"\n              },\n              body: JSON.stringify({\n                msg: \"Hello world!\"\n              })\n            })\n            return response.json()\n          }\n          (async () => {\n          for (const [reqName, req] of Object.entries(reqs)) {\n            try {\n              let data = await req()\n              document.getElementById(reqName).textContent = JSON.stringify(data)\n            } catch (e) {\n              document.getElementById(reqName).textContent = e\n            }\n          }\n        })()\n          </script>\n        </body>\n        </html>\n      `;\n\n\n      async function handleRequest(request) {\n        const url = new URL(request.url);\n        let apiUrl = url.searchParams.get(\"apiurl\");\n\n\n        if (apiUrl == null) {\n          apiUrl = API_URL;\n        }\n\n\n        // Rewrite request to point to API URL. This also makes the request mutable\n        // so you can add the correct Origin header to make the API server think\n        // that this request is not cross-site.\n        request = new Request(apiUrl, request);\n        request.headers.set(\"Origin\", new URL(apiUrl).origin);\n        let response = await fetch(request);\n        // Recreate the response so you can modify the headers\n\n\n        response = new Response(response.body, response);\n        // Set CORS headers\n\n\n        response.headers.set(\"Access-Control-Allow-Origin\", url.origin);\n\n\n        // Append to/Add Vary header so browser will cache response correctly\n        response.headers.append(\"Vary\", \"Origin\");\n\n\n        return response;\n      }\n\n\n      async function handleOptions(request) {\n        if (\n          request.headers.get(\"Origin\") !== null &&\n          request.headers.get(\"Access-Control-Request-Method\") !== null &&\n          request.headers.get(\"Access-Control-Request-Headers\") !== null\n        ) {\n          // Handle CORS preflight requests.\n          return new Response(null, {\n            headers: {\n              ...corsHeaders,\n              \"Access-Control-Allow-Headers\": request.headers.get(\n                \"Access-Control-Request-Headers\",\n              ),\n            },\n          });\n        } else {\n          // Handle standard OPTIONS request.\n          return new Response(null, {\n            headers: {\n              Allow: \"GET, HEAD, POST, OPTIONS\",\n            },\n          });\n        }\n      }\n\n\n      const url = new URL(request.url);\n      if (url.pathname.startsWith(PROXY_ENDPOINT)) {\n        if (request.method === \"OPTIONS\") {\n          // Handle CORS preflight requests\n          return handleOptions(request);\n        } else if (\n          request.method === \"GET\" ||\n          request.method === \"HEAD\" ||\n          request.method === \"POST\"\n        ) {\n          // Handle requests to the API server\n          return handleRequest(request);\n        } else {\n          return new Response(null, {\n            status: 405,\n            statusText: \"Method Not Allowed\",\n          });\n        }\n      } else {\n        return rawHtmlResponse(DEMO_PAGE);\n      }\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from \"hono\";\n  import { cors } from \"hono/cors\";\n\n\n  // The URL for the remote third party API you want to fetch from\n  // but does not implement CORS\n  const API_URL = \"https://examples.cloudflareworkers.com/demos/demoapi\";\n\n\n  // The endpoint you want the CORS reverse proxy to be on\n  const PROXY_ENDPOINT = \"/corsproxy/\";\n\n\n  const app = new Hono();\n\n\n  // Demo page handler\n  app.get(\"*\", async (c) => {\n    // Only handle non-proxy requests with this handler\n    if (c.req.path.startsWith(PROXY_ENDPOINT)) {\n      return next();\n    }\n\n\n    // Create the demo page HTML\n    const DEMO_PAGE = `\n      <!DOCTYPE html>\n      <html>\n      <body>\n        <h1>API GET without CORS Proxy</h1>\n        <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\">Shows TypeError: Failed to fetch since CORS is misconfigured</a>\n        <p id=\"noproxy-status\"/>\n        <code id=\"noproxy\">Waiting</code>\n        <h1>API GET with CORS Proxy</h1>\n        <p id=\"proxy-status\"/>\n        <code id=\"proxy\">Waiting</code>\n        <h1>API POST with CORS Proxy + Preflight</h1>\n        <p id=\"proxypreflight-status\"/>\n        <code id=\"proxypreflight\">Waiting</code>\n        <script>\n        let reqs = {};\n        reqs.noproxy = () => {\n          return fetch(\"${API_URL}\").then(r => r.json())\n        }\n        reqs.proxy = async () => {\n          let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n          return fetch(window.location.origin + href).then(r => r.json())\n        }\n        reqs.proxypreflight = async () => {\n          let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n          let response = await fetch(window.location.origin + href, {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n              msg: \"Hello world!\"\n            })\n          })\n          return response.json()\n        }\n        (async () => {\n        for (const [reqName, req] of Object.entries(reqs)) {\n          try {\n            let data = await req()\n            document.getElementById(reqName).innerHTML = JSON.stringify(data)\n          } catch (e) {\n            document.getElementById(reqName).innerHTML = e\n          }\n        }\n      })()\n        </script>\n      </body>\n      </html>\n    `;\n\n\n    return c.html(DEMO_PAGE);\n  });\n\n\n  // CORS proxy routes\n  app.on([\"GET\", \"HEAD\", \"POST\", \"OPTIONS\"], PROXY_ENDPOINT + \"*\", async (c) => {\n    const url = new URL(c.req.url);\n\n\n    // Handle OPTIONS preflight requests\n    if (c.req.method === \"OPTIONS\") {\n      const origin = c.req.header(\"Origin\");\n      const requestMethod = c.req.header(\"Access-Control-Request-Method\");\n      const requestHeaders = c.req.header(\"Access-Control-Request-Headers\");\n\n\n      if (origin && requestMethod && requestHeaders) {\n        // Handle CORS preflight requests\n        return new Response(null, {\n          headers: {\n            \"Access-Control-Allow-Origin\": \"*\",\n            \"Access-Control-Allow-Methods\": \"GET,HEAD,POST,OPTIONS\",\n            \"Access-Control-Max-Age\": \"86400\",\n            \"Access-Control-Allow-Headers\": requestHeaders,\n          },\n        });\n      } else {\n        // Handle standard OPTIONS request\n        return new Response(null, {\n          headers: {\n            Allow: \"GET, HEAD, POST, OPTIONS\",\n          },\n        });\n      }\n    }\n\n\n    // Handle actual requests\n    let apiUrl = url.searchParams.get(\"apiurl\") || API_URL;\n\n\n    // Rewrite request to point to API URL\n    const modifiedRequest = new Request(apiUrl, c.req.raw);\n    modifiedRequest.headers.set(\"Origin\", new URL(apiUrl).origin);\n\n\n    let response = await fetch(modifiedRequest);\n\n\n    // Recreate the response so we can modify the headers\n    response = new Response(response.body, response);\n\n\n    // Set CORS headers\n    response.headers.set(\"Access-Control-Allow-Origin\", url.origin);\n\n\n    // Append to/Add Vary header so browser will cache response correctly\n    response.headers.append(\"Vary\", \"Origin\");\n\n\n    return response;\n  });\n\n\n  // Handle method not allowed for proxy endpoint\n  app.all(PROXY_ENDPOINT + \"*\", (c) => {\n    return new Response(null, {\n      status: 405,\n      statusText: \"Method Not Allowed\",\n    });\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Response, URL, fetch, Object, Request\n\n\n  def to_js(x):\n      return _to_js(x, dict_converter=Object.fromEntries)\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          cors_headers = {\n              \"Access-Control-Allow-Origin\": \"*\",\n              \"Access-Control-Allow-Methods\": \"GET,HEAD,POST,OPTIONS\",\n              \"Access-Control-Max-Age\": \"86400\",\n          }\n\n\n          api_url = \"https://examples.cloudflareworkers.com/demos/demoapi\"\n\n\n          proxy_endpoint = \"/corsproxy/\"\n\n\n          def raw_html_response(html):\n              return Response.new(html, headers=to_js({\"content-type\": \"text/html;charset=UTF-8\"}))\n\n\n          demo_page = f'''\n          <!DOCTYPE html>\n          <html>\n          <body>\n          <h1>API GET without CORS Proxy</h1>\n          <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\">Shows TypeError: Failed to fetch since CORS is misconfigured</a>\n          <p id=\"noproxy-status\"/>\n          <code id=\"noproxy\">Waiting</code>\n          <h1>API GET with CORS Proxy</h1>\n          <p id=\"proxy-status\"/>\n          <code id=\"proxy\">Waiting</code>\n          <h1>API POST with CORS Proxy + Preflight</h1>\n          <p id=\"proxypreflight-status\"/>\n          <code id=\"proxypreflight\">Waiting</code>\n          <script>\n          let reqs = {{}};\n          reqs.noproxy = () => {{\n              return fetch(\"{api_url}\").then(r => r.json())\n          }}\n          reqs.proxy = async () => {{\n              let href = \"{proxy_endpoint}?apiurl={api_url}\"\n              return fetch(window.location.origin + href).then(r => r.json())\n          }}\n          reqs.proxypreflight = async () => {{\n              let href = \"{proxy_endpoint}?apiurl={api_url}\"\n              let response = await fetch(window.location.origin + href, {{\n              method: \"POST\",\n              headers: {{\n                  \"Content-Type\": \"application/json\"\n              }},\n              body: JSON.stringify({{\n                  msg: \"Hello world!\"\n              }})\n              }})\n              return response.json()\n          }}\n          (async () => {{\n          for (const [reqName, req] of Object.entries(reqs)) {{\n              try {{\n              let data = await req()\n              document.getElementById(reqName).innerHTML = JSON.stringify(data)\n              }} catch (e) {{\n              document.getElementById(reqName).innerHTML = e\n              }}\n          }}\n          }})()\n          </script>\n          </body>\n          </html>\n          '''\n\n\n          async def handle_request(request):\n              url = URL.new(request.url)\n              api_url2 = url.searchParams[\"apiurl\"]\n\n\n              if not api_url2:\n                  api_url2 = api_url\n\n\n              request = Request.new(api_url2, request)\n              request.headers[\"Origin\"] = (URL.new(api_url2)).origin\n              print(request.headers)\n              response = await fetch(request)\n              response = Response.new(response.body, response)\n              response.headers[\"Access-Control-Allow-Origin\"] = url.origin\n              response.headers[\"Vary\"] = \"Origin\"\n              return response\n\n\n          async def handle_options(request):\n              if \"Origin\" in request.headers and \"Access-Control-Request-Method\" in request.headers and \"Access-Control-Request-Headers\" in request.headers:\n                  return Response.new(None, headers=to_js({\n                  **cors_headers,\n                  \"Access-Control-Allow-Headers\": request.headers[\"Access-Control-Request-Headers\"]\n                  }))\n              return Response.new(None, headers=to_js({\"Allow\": \"GET, HEAD, POST, OPTIONS\"}))\n\n\n          url = URL.new(request.url)\n\n\n          if url.pathname.startswith(proxy_endpoint):\n              if request.method == \"OPTIONS\":\n                  return handle_options(request)\n              if request.method in (\"GET\", \"HEAD\", \"POST\"):\n                  return handle_request(request)\n              return Response.new(None, status=405, statusText=\"Method Not Allowed\")\n          return raw_html_response(demo_page)",
      "language": "py"
    },
    {
      "code": "use std::{borrow::Cow, collections::HashMap};\n  use worker::*;\n\n\n  fn raw_html_response(html: &str) -> Result<Response> {\n      Response::from_html(html)\n  }\n  async fn handle_request(req: Request, api_url: &str) -> Result<Response> {\n      let url = req.url().unwrap();\n      let mut api_url2 = url\n          .query_pairs()\n          .find(|x| x.0 == Cow::Borrowed(\"apiurl\"))\n          .unwrap()\n          .1\n          .to_string();\n      if api_url2 == String::from(\"\") {\n          api_url2 = api_url.to_string();\n      }\n      let mut request = req.clone_mut()?;\n      *request.path_mut()? = api_url2.clone();\n      if let url::Origin::Tuple(origin, _, _) = Url::parse(&api_url2)?.origin() {\n          (*request.headers_mut()?).set(\"Origin\", &origin)?;\n      }\n      let mut response = Fetch::Request(request).send().await?.cloned()?;\n      let headers = response.headers_mut();\n      if let url::Origin::Tuple(origin, _, _) = url.origin() {\n          headers.set(\"Access-Control-Allow-Origin\", &origin)?;\n          headers.set(\"Vary\", \"Origin\")?;\n      }\n\n\n      Ok(response)\n  }\n\n\n  fn handle_options(req: Request, cors_headers: &HashMap<&str, &str>) -> Result<Response> {\n      let headers: Vec<_> = req.headers().keys().collect();\n      if [\n          \"access-control-request-method\",\n          \"access-control-request-headers\",\n          \"origin\",\n      ]\n      .iter()\n      .all(|i| headers.contains(&i.to_string()))\n      {\n          let mut headers = Headers::new();\n          for (k, v) in cors_headers.iter() {\n              headers.set(k, v)?;\n          }\n          return Ok(Response::empty()?.with_headers(headers));\n      }\n      Response::empty()\n  }\n\n\n  #[event(fetch)]\n  async fn fetch(req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let cors_headers = HashMap::from([\n          (\"Access-Control-Allow-Origin\", \"*\"),\n          (\"Access-Control-Allow-Methods\", \"GET,HEAD,POST,OPTIONS\"),\n          (\"Access-Control-Max-Age\", \"86400\"),\n      ]);\n      let api_url = \"https://examples.cloudflareworkers.com/demos/demoapi\";\n      let proxy_endpoint = \"/corsproxy/\";\n      let demo_page = format!(\n  r#\"\n\n\n  <!DOCTYPE html>\n\n\n  <html>\n  <body>\n  <h1>API GET without CORS Proxy</h1>\n  <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\">Shows TypeError: Failed to fetch since CORS is misconfigured</a>\n  <p id=\"noproxy-status\"/>\n  <code id=\"noproxy\">Waiting</code>\n  <h1>API GET with CORS Proxy</h1>\n  <p id=\"proxy-status\"/>\n  <code id=\"proxy\">Waiting</code>\n  <h1>API POST with CORS Proxy + Preflight</h1>\n  <p id=\"proxypreflight-status\"/>\n  <code id=\"proxypreflight\">Waiting</code>\n  <script>\n  let reqs = {{}};\n  reqs.noproxy = () => {{\n          return fetch(\"{api_url}\").then(r => r.json())\n      }}\n  reqs.proxy = async () => {{\n          let href = \"{proxy_endpoint}?apiurl={api_url}\"\n          return fetch(window.location.origin + href).then(r => r.json())\n      }}\n  reqs.proxypreflight = async () => {{\n          let href = \"{proxy_endpoint}?apiurl={api_url}\"\n          let response = await fetch(window.location.origin + href, {{\n          method: \"POST\",\n          headers: {{\n              \"Content-Type\": \"application/json\"\n          }},\n  body: JSON.stringify({{\n              msg: \"Hello world!\"\n          }})\n  }})\n  return response.json()\n  }}\n  (async () => {{\n      for (const [reqName, req] of Object.entries(reqs)) {{\n          try {{\n          let data = await req()\n          document.getElementById(reqName).innerHTML = JSON.stringify(data)\n          }} catch (e) {{\n          document.getElementById(reqName).innerHTML = e\n          }}\n  }}\n  }})()\n  </script>\n  </body>\n  </html>\n  \"#\n      );\n\n\n      if req.url()?.path().starts_with(proxy_endpoint) {\n          match req.method() {\n              Method::Options => return handle_options(req, &cors_headers),\n              Method::Get | Method::Head | Method::Post => return handle_request(req, api_url).await,\n              _ => return Response::error(\"Method Not Allowed\", 405),\n          }\n      }\n      raw_html_response(&demo_page)\n\n\n  }",
      "language": "rs"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      /**\n       * A map of the URLs to redirect to\n       * @param {Object} countryMap\n       */\n      const countryMap = {\n        US: \"https://example.com/us\",\n        EU: \"https://example.com/eu\",\n      };\n\n\n      // Use the cf object to obtain the country of the request\n      // more on the cf object: https://developers.cloudflare.com/workers/runtime-apis/request#incomingrequestcfproperties\n      const country = request.cf.country;\n\n\n      if (country != null && country in countryMap) {\n        const url = countryMap[country];\n        // Remove this logging statement from your final output.\n        console.log(\n          `Based on ${country}-based request, your user would go to ${url}.`,\n        );\n        return Response.redirect(url);\n      } else {\n        return fetch(\"https://example.com\", request);\n      }\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * A map of the URLs to redirect to\n       * @param {Object} countryMap\n       */\n      const countryMap = {\n        US: \"https://example.com/us\",\n        EU: \"https://example.com/eu\",\n      };\n\n\n      // Use the cf object to obtain the country of the request\n      // more on the cf object: https://developers.cloudflare.com/workers/runtime-apis/request#incomingrequestcfproperties\n      const country = request.cf.country;\n\n\n      if (country != null && country in countryMap) {\n        const url = countryMap[country];\n        return Response.redirect(url);\n      } else {\n        return fetch(request);\n      }\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response, fetch\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          countries = {\n              \"US\": \"https://example.com/us\",\n              \"EU\": \"https://example.com/eu\",\n          }\n\n\n          # Use the cf object to obtain the country of the request\n          # more on the cf object: https://developers.cloudflare.com/workers/runtime-apis/request#incomingrequestcfproperties\n          country = request.cf.country\n\n\n          if country and country in countries:\n              url = countries[country]\n              return Response.redirect(url)\n\n\n          return fetch(\"https://example.com\", request)",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  // Define the RequestWithCf interface to add Cloudflare-specific properties\n  interface RequestWithCf extends Request {\n    cf: {\n      country: string;\n      // Other CF properties can be added as needed\n    };\n  }\n\n\n  const app = new Hono();\n\n\n  app.get('*', async (c) => {\n    /**\n     * A map of the URLs to redirect to\n     */\n    const countryMap: Record<string, string> = {\n      US: \"https://example.com/us\",\n      EU: \"https://example.com/eu\",\n    };\n\n\n    // Cast the raw request to include Cloudflare-specific properties\n    const request = c.req.raw as RequestWithCf;\n\n\n    // Use the cf object to obtain the country of the request\n    // more on the cf object: https://developers.cloudflare.com/workers/runtime-apis/request#incomingrequestcfproperties\n    const country = request.cf.country;\n\n\n    if (country != null && country in countryMap) {\n      const url = countryMap[country];\n      // Redirect using Hono's redirect helper\n      return c.redirect(url);\n    } else {\n      // Default fallback\n      return fetch(\"https://example.com\", request);\n    }\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async scheduled(controller, env, ctx) {\n      console.log(\"cron processed\");\n    },\n  };",
      "language": "js"
    },
    {
      "code": "interface Env {}\n  export default {\n    async scheduled(\n      controller: ScheduledController,\n      env: Env,\n      ctx: ExecutionContext,\n    ) {\n      console.log(\"cron processed\");\n    },\n  };",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response\n\n\n  class Default(WorkerEntrypoint):\n      async def scheduled(self, controller, env, ctx):\n          print(\"cron processed\")",
      "language": "python"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  interface Env {}\n\n\n  // Create Hono app\n  const app = new Hono<{ Bindings: Env }>();\n\n\n  // Regular routes for normal HTTP requests\n  app.get(\"/\", (c) => c.text(\"Hello World!\"));\n\n\n  // Export both the app and a scheduled function\n  export default {\n    // The Hono app handles regular HTTP requests\n    fetch: app.fetch,\n\n\n    // The scheduled function handles Cron triggers\n    async scheduled(\n      controller: ScheduledController,\n      env: Env,\n      ctx: ExecutionContext,\n    ) {\n      console.log(\"cron processed\");\n\n\n      // You could also perform actions like:\n      // - Fetching data from external APIs\n      // - Updating KV or Durable Object storage\n      // - Running maintenance tasks\n      // - Sending notifications\n    },\n  };",
      "language": "ts"
    },
    {
      "code": "{\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"worker\",\n    \"triggers\": {\n      \"crons\": [\n        \"0 * * * *\"\n      ]\n    }\n  }",
      "language": "jsonc"
    },
    {
      "code": "name = \"worker\"\n\n\n  # ...\n\n\n  [triggers]\n  crons = [\"0 * * * *\"]",
      "language": "toml"
    },
    {
      "code": "{\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"env\": {\n      \"dev\": {\n        \"triggers\": {\n          \"crons\": [\n            \"0 * * * *\"\n          ]\n        }\n      }\n    }\n  }",
      "language": "jsonc"
    },
    {
      "code": "[env.dev.triggers]\n  crons = [\"0 * * * *\"]",
      "language": "toml"
    },
    {
      "code": "npx wrangler dev --test-scheduled\n\n\ncurl \"http://localhost:8787/__scheduled?cron=0+*+*+*+*\"\n\n\ncurl \"http://localhost:8787/cdn-cgi/handler/scheduled?cron=*+*+*+*+*\" # Python Workers",
      "language": "sh"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const DEBUG = true;\n      const SOME_HOOK_SERVER = \"https://webhook.flow-wolf.io/hook\";\n\n\n      /**\n       * Alert a data breach by posting to a webhook server\n       */\n      async function postDataBreach(request) {\n        return await fetch(SOME_HOOK_SERVER, {\n          method: \"POST\",\n          headers: {\n            \"content-type\": \"application/json;charset=UTF-8\",\n          },\n          body: JSON.stringify({\n            ip: request.headers.get(\"cf-connecting-ip\"),\n            time: Date.now(),\n            request: request,\n          }),\n        });\n      }\n\n\n      /**\n       * Define personal data with regular expressions.\n       * Respond with block if credit card data, and strip\n       * emails and phone numbers from the response.\n       * Execution will be limited to MIME type \"text/*\".\n       */\n      const response = await fetch(request);\n\n\n      // Return origin response, if response wasn’t text\n      const contentType = response.headers.get(\"content-type\") || \"\";\n      if (!contentType.toLowerCase().includes(\"text/\")) {\n        return response;\n      }\n\n\n      let text = await response.text();\n\n\n      // When debugging replace the response\n      // from the origin with an email\n      text = DEBUG\n        ? text.replace(\"You may use this\", \"me@example.com may use this\")\n        : text;\n      const sensitiveRegexsMap = {\n        creditCard: String.raw`\\b(?:4[0-9]{12}(?:[0-9]{3})?|(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\\d{3})\\d{11})\\b`,\n        email: String.raw`\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b`,\n        phone: String.raw`\\b07\\d{9}\\b`,\n      };\n\n\n      for (const kind in sensitiveRegexsMap) {\n        const sensitiveRegex = new RegExp(sensitiveRegexsMap[kind], \"ig\");\n        const match = await sensitiveRegex.test(text);\n        if (match) {\n          // Alert a data breach\n          await postDataBreach(request);\n          // Respond with a block if credit card,\n          // otherwise replace sensitive text with `*`s\n          return kind === \"creditCard\"\n            ? new Response(kind + \" found\\nForbidden\\n\", {\n                status: 403,\n                statusText: \"Forbidden\",\n              })\n            : new Response(text.replace(sensitiveRegex, \"**********\"), response);\n        }\n      }\n      return new Response(text, response);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const DEBUG = true;\n      const SOME_HOOK_SERVER = \"https://webhook.flow-wolf.io/hook\";\n\n\n      /**\n       * Alert a data breach by posting to a webhook server\n       */\n      async function postDataBreach(request) {\n        return await fetch(SOME_HOOK_SERVER, {\n          method: \"POST\",\n          headers: {\n            \"content-type\": \"application/json;charset=UTF-8\",\n          },\n          body: JSON.stringify({\n            ip: request.headers.get(\"cf-connecting-ip\"),\n            time: Date.now(),\n            request: request,\n          }),\n        });\n      }\n\n\n      /**\n       * Define personal data with regular expressions.\n       * Respond with block if credit card data, and strip\n       * emails and phone numbers from the response.\n       * Execution will be limited to MIME type \"text/*\".\n       */\n      const response = await fetch(request);\n\n\n      // Return origin response, if response wasn’t text\n      const contentType = response.headers.get(\"content-type\") || \"\";\n      if (!contentType.toLowerCase().includes(\"text/\")) {\n        return response;\n      }\n\n\n      let text = await response.text();\n\n\n      // When debugging replace the response\n      // from the origin with an email\n      text = DEBUG\n        ? text.replace(\"You may use this\", \"me@example.com may use this\")\n        : text;\n      const sensitiveRegexsMap = {\n        creditCard: String.raw`\\b(?:4[0-9]{12}(?:[0-9]{3})?|(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\\d{3})\\d{11})\\b`,\n        email: String.raw`\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b`,\n        phone: String.raw`\\b07\\d{9}\\b`,\n      };\n\n\n      for (const kind in sensitiveRegexsMap) {\n        const sensitiveRegex = new RegExp(sensitiveRegexsMap[kind], \"ig\");\n        const match = await sensitiveRegex.test(text);\n        if (match) {\n          // Alert a data breach\n          await postDataBreach(request);\n          // Respond with a block if credit card,\n          // otherwise replace sensitive text with `*`s\n          return kind === \"creditCard\"\n            ? new Response(kind + \" found\\nForbidden\\n\", {\n                status: 403,\n                statusText: \"Forbidden\",\n              })\n            : new Response(text.replace(sensitiveRegex, \"**********\"), response);\n        }\n      }\n      return new Response(text, response);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import re\n  from workers import WorkerEntrypoint\n  from datetime import datetime\n  from js import Response, fetch, JSON, Headers\n\n\n  # Alert a data breach by posting to a webhook server\n  async def post_data_breach(request):\n      some_hook_server = \"https://webhook.flow-wolf.io/hook\"\n      headers = Headers.new({\"content-type\": \"application/json\"}.items())\n      body = JSON.stringify({\n        \"ip\": request.headers[\"cf-connecting-ip\"],\n        \"time\": datetime.now(),\n        \"request\": request,\n      })\n      return await fetch(some_hook_server, method=\"POST\", headers=headers, body=body)\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n      debug = True\n\n\n      # Define personal data with regular expressions.\n      # Respond with block if credit card data, and strip\n      # emails and phone numbers from the response.\n      # Execution will be limited to MIME type \"text/*\".\n      response = await fetch(request)\n\n\n      # Return origin response, if response wasn’t text\n      content_type = response.headers[\"content-type\"] or \"\"\n      if \"text\" not in content_type:\n        return response\n\n\n      text = await response.text()\n      # When debugging replace the response from the origin with an email\n      text = text.replace(\"You may use this\", \"me@example.com may use this\") if debug else text\n\n\n      sensitive_regex = [\n      (\"credit_card\",\n      r'\\b(?:4[0-9]{12}(?:[0-9]{3})?|(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\\d{3})\\d{11})\\b'),\n      (\"email\", r'\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b'),\n      (\"phone\", r'\\b07\\d{9}\\b'),\n      ]\n      for (kind, regex) in sensitive_regex:\n        match = re.search(regex, text, flags=re.IGNORECASE)\n        if match:\n          # Alert a data breach\n          await post_data_breach(request)\n          # Respond with a block if credit card, otherwise replace sensitive text with `*`s\n          card_resp = Response.new(kind + \" found\\nForbidden\\n\", status=403,statusText=\"Forbidden\")\n          sensitive_resp = Response.new(re.sub(regex, \"*\"*10, text, flags=re.IGNORECASE), response)\n          return card_resp if kind == \"credit_card\" else  sensitive_resp\n\n\n      return Response.new(text, response)",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  const app = new Hono();\n\n\n  // Configuration\n  const DEBUG = true;\n  const SOME_HOOK_SERVER = \"https://webhook.flow-wolf.io/hook\";\n\n\n  // Define sensitive data patterns\n  const sensitiveRegexsMap = {\n    creditCard: String.raw`\\b(?:4[0-9]{12}(?:[0-9]{3})?|(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\\d{3})\\d{11})\\b`,\n    email: String.raw`\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b`,\n    phone: String.raw`\\b07\\d{9}\\b`,\n  };\n\n\n  /**\n   * Alert a data breach by posting to a webhook server\n   */\n  async function postDataBreach(request: Request) {\n    return await fetch(SOME_HOOK_SERVER, {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json;charset=UTF-8\",\n      },\n      body: JSON.stringify({\n        ip: request.headers.get(\"cf-connecting-ip\"),\n        time: Date.now(),\n        request: request,\n      }),\n    });\n  }\n\n\n  // Main middleware to handle data loss prevention\n  app.use('*', async (c) => {\n    // Fetch the origin response\n    const response = await fetch(c.req.raw);\n\n\n    // Return origin response if response wasn't text\n    const contentType = response.headers.get(\"content-type\") || \"\";\n    if (!contentType.toLowerCase().includes(\"text/\")) {\n      return response;\n    }\n\n\n    // Get the response text\n    let text = await response.text();\n\n\n    // When debugging, replace the response from the origin with an email\n    text = DEBUG\n      ? text.replace(\"You may use this\", \"me@example.com may use this\")\n      : text;\n\n\n    // Check for sensitive data\n    for (const kind in sensitiveRegexsMap) {\n      const sensitiveRegex = new RegExp(sensitiveRegexsMap[kind], \"ig\");\n      const match = sensitiveRegex.test(text);\n\n\n      if (match) {\n        // Alert a data breach\n        await postDataBreach(c.req.raw);\n\n\n        // Respond with a block if credit card, otherwise replace sensitive text with `*`s\n        if (kind === \"creditCard\") {\n          return c.text(`${kind} found\\nForbidden\\n`, 403);\n        } else {\n          return new Response(text.replace(sensitiveRegex, \"**********\"), {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers,\n          });\n        }\n      }\n    }\n\n\n    // Return the modified response\n    return new Response(text, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    });\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request, env, ctx) {\n      // Service configured to receive logs\n      const LOG_URL = \"https://log-service.example.com/\";\n\n\n      async function postLog(data) {\n        return await fetch(LOG_URL, {\n          method: \"POST\",\n          body: data,\n        });\n      }\n\n\n      let response;\n\n\n      try {\n        response = await fetch(request);\n        if (!response.ok && !response.redirected) {\n          const body = await response.text();\n          throw new Error(\n            \"Bad response at origin. Status: \" +\n              response.status +\n              \" Body: \" +\n              // Ensure the string is small enough to be a header\n              body.trim().substring(0, 10),\n          );\n        }\n      } catch (err) {\n        // Without ctx.waitUntil(), your fetch() to Cloudflare's\n        // logging service may or may not complete\n        ctx.waitUntil(postLog(err.toString()));\n        const stack = JSON.stringify(err.stack) || err;\n        // Copy the response and initialize body to the stack trace\n        response = new Response(stack, response);\n        // Add the error stack into a header to find out what happened\n        response.headers.set(\"X-Debug-stack\", stack);\n        response.headers.set(\"X-Debug-err\", err);\n      }\n      return response;\n    },\n  };",
      "language": "js"
    },
    {
      "code": "interface Env {}\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      // Service configured to receive logs\n      const LOG_URL = \"https://log-service.example.com/\";\n\n\n      async function postLog(data) {\n        return await fetch(LOG_URL, {\n          method: \"POST\",\n          body: data,\n        });\n      }\n\n\n      let response;\n\n\n      try {\n        response = await fetch(request);\n        if (!response.ok && !response.redirected) {\n          const body = await response.text();\n          throw new Error(\n            \"Bad response at origin. Status: \" +\n              response.status +\n              \" Body: \" +\n              // Ensure the string is small enough to be a header\n              body.trim().substring(0, 10),\n          );\n        }\n      } catch (err) {\n        // Without ctx.waitUntil(), your fetch() to Cloudflare's\n        // logging service may or may not complete\n        ctx.waitUntil(postLog(err.toString()));\n        const stack = JSON.stringify(err.stack) || err;\n        // Copy the response and initialize body to the stack trace\n        response = new Response(stack, response);\n        // Add the error stack into a header to find out what happened\n        response.headers.set(\"X-Debug-stack\", stack);\n        response.headers.set(\"X-Debug-err\", err);\n      }\n      return response;\n    },\n  } satisfies ExportedHandler<Env>;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from pyodide.ffi import create_proxy\n  from js import Response, fetch\n\n\n  async def post_log(data):\n    log_url = \"https://log-service.example.com/\"\n    await fetch(log_url, method=\"POST\", body=data)\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # Service configured to receive logs\n          response = await fetch(request)\n\n\n          try:\n              if not response.ok and not response.redirected:\n                  body = await response.text()\n              # Simulating an error. Ensure the string is small enough to be a header\n              raise Exception(f'Bad response at origin. Status:{response.status} Body:{body.strip()[:10]}')\n          except Exception as e:\n              # Without ctx.waitUntil(), your fetch() to Cloudflare's\n              # logging service may or may not complete\n              self.ctx.waitUntil(create_proxy(post_log(str(e))))\n              # Copy the response and add to header\n              response = Response.new(stack, response)\n              response.headers[\"X-Debug-err\"] = str(e)\n\n\n          return response",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  // Define the environment with appropriate types\n  interface Env {}\n\n\n  const app = new Hono<{ Bindings: Env }>();\n\n\n  // Service configured to receive logs\n  const LOG_URL = \"https://log-service.example.com/\";\n\n\n  // Function to post logs to an external service\n  async function postLog(data: string) {\n    return await fetch(LOG_URL, {\n      method: \"POST\",\n      body: data,\n    });\n  }\n\n\n  // Middleware to handle error logging\n  app.use('*', async (c, next) => {\n    try {\n      // Process the request with the next handler\n      await next();\n\n\n      // After processing, check if the response indicates an error\n      if (c.res && (!c.res.ok && !c.res.redirected)) {\n        const body = await c.res.clone().text();\n        throw new Error(\n          \"Bad response at origin. Status: \" +\n          c.res.status +\n          \" Body: \" +\n          // Ensure the string is small enough to be a header\n          body.trim().substring(0, 10)\n        );\n      }\n\n\n    } catch (err) {\n      // Without waitUntil, the fetch to the logging service may not complete\n      c.executionCtx.waitUntil(\n        postLog(err.toString())\n      );\n\n\n      // Get the error stack or error itself\n      const stack = JSON.stringify(err.stack) || err.toString();\n\n\n      // Create a new response with the error information\n      const response = c.res ?\n        new Response(stack, {\n          status: c.res.status,\n          headers: c.res.headers\n        }) :\n        new Response(stack, { status: 500 });\n\n\n      // Add debug headers\n      response.headers.set(\"X-Debug-stack\", stack);\n      response.headers.set(\"X-Debug-err\", err.toString());\n\n\n      // Set the modified response\n      c.res = response;\n    }\n  });\n\n\n  // Default route handler that passes requests through\n  app.all('*', async (c) => {\n    return fetch(c.req.raw);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "import { parse } from \"cookie\";\n  export default {\n    async fetch(request) {\n      // The name of the cookie\n      const COOKIE_NAME = \"__uid\";\n      const cookie = parse(request.headers.get(\"Cookie\") || \"\");\n      if (cookie[COOKIE_NAME] != null) {\n        // Respond with the cookie value\n        return new Response(cookie[COOKIE_NAME]);\n      }\n      return new Response(\"No cookie with name: \" + COOKIE_NAME);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "import { parse } from \"cookie\";\n  export default {\n    async fetch(request): Promise<Response> {\n      // The name of the cookie\n      const COOKIE_NAME = \"__uid\";\n      const cookie = parse(request.headers.get(\"Cookie\") || \"\");\n      if (cookie[COOKIE_NAME] != null) {\n        // Respond with the cookie value\n        return new Response(cookie[COOKIE_NAME]);\n      }\n      return new Response(\"No cookie with name: \" + COOKIE_NAME);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from http.cookies import SimpleCookie\n  from workers import WorkerEntrypoint, Response\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # Name of the cookie\n          cookie_name = \"__uid\"\n\n\n          cookies = SimpleCookie(request.headers[\"Cookie\"] or \"\")\n\n\n          if cookie_name in cookies:\n              # Respond with cookie value\n              return Response(cookies[cookie_name].value)\n\n\n          return Response(\"No cookie with name: \" + cookie_name)",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n  import { getCookie } from 'hono/cookie';\n\n\n  const app = new Hono();\n\n\n  app.get('*', (c) => {\n    // The name of the cookie\n    const COOKIE_NAME = \"__uid\";\n\n\n    // Get the specific cookie value using Hono's cookie helper\n    const cookieValue = getCookie(c, COOKIE_NAME);\n\n\n    if (cookieValue) {\n      // Respond with the cookie value\n      return c.text(cookieValue);\n    }\n\n\n    return c.text(\"No cookie with name: \" + COOKIE_NAME);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      /**\n       * Replace `remote` with the host you wish to send requests to\n       */\n      const remote = \"https://example.com\";\n\n\n      return await fetch(remote, request);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request: Request): Promise<Response> {\n      /**\n       * Replace `remote` with the host you wish to send requests to\n       */\n      const remote = \"https://example.com\";\n\n\n      return await fetch(remote, request);\n    },\n  };",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from js import fetch\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # Replace `remote` with the host you wish to send requests to\n          remote = \"https://example.com\"\n          return await fetch(remote, request)",
      "language": "py"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  app.all(\"*\", async (c) => {\n    /**\n     * Replace `remote` with the host you wish to send requests to\n     */\n    const remote = \"https://example.com\";\n\n\n    // Forward the request to the remote server\n    return await fetch(remote, c.req.raw);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request, env, ctx) {\n      const url = \"https://jsonplaceholder.typicode.com/todos/1\";\n\n\n      // gatherResponse returns both content-type & response body as a string\n      async function gatherResponse(response) {\n        const { headers } = response;\n        const contentType = headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          return { contentType, result: JSON.stringify(await response.json()) };\n        }\n        return { contentType, result: await response.text() };\n      }\n\n\n      const response = await fetch(url);\n      const { contentType, result } = await gatherResponse(response);\n\n\n      const options = { headers: { \"content-type\": contentType } };\n      return new Response(result, options);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "interface Env {}\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      const url = \"https://jsonplaceholder.typicode.com/todos/1\";\n\n\n      // gatherResponse returns both content-type & response body as a string\n      async function gatherResponse(response) {\n        const { headers } = response;\n        const contentType = headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          return { contentType, result: JSON.stringify(await response.json()) };\n        }\n        return { contentType, result: await response.text() };\n      }\n\n\n      const response = await fetch(url);\n      const { contentType, result } = await gatherResponse(response);\n\n\n      const options = { headers: { \"content-type\": contentType } };\n      return new Response(result, options);\n    },\n  } satisfies ExportedHandler<Env>;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response, fetch\n  import json\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          url = \"https://jsonplaceholder.typicode.com/todos/1\"\n\n\n          # gather_response returns both content-type & response body as a string\n          async def gather_response(response):\n              headers = response.headers\n              content_type = headers[\"content-type\"] or \"\"\n\n\n              if \"application/json\" in content_type:\n                  return (content_type, json.dumps(await response.json()))\n              return (content_type, await response.text())\n\n\n          response = await fetch(url)\n          content_type, result = await gather_response(response)\n\n\n          headers = {\"content-type\": content_type}\n          return Response(result, headers=headers)",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  type Env = {};\n\n\n  const app = new Hono<{ Bindings: Env }>();\n\n\n  app.get('*', async (c) => {\n    const url = \"https://jsonplaceholder.typicode.com/todos/1\";\n\n\n    // gatherResponse returns both content-type & response body as a string\n    async function gatherResponse(response: Response) {\n      const { headers } = response;\n      const contentType = headers.get(\"content-type\") || \"\";\n\n\n      if (contentType.includes(\"application/json\")) {\n        return { contentType, result: JSON.stringify(await response.json()) };\n      }\n\n\n      return { contentType, result: await response.text() };\n    }\n\n\n    const response = await fetch(url);\n    const { contentType, result } = await gatherResponse(response);\n\n\n    return new Response(result, {\n      headers: { \"content-type\": contentType }\n    });\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      let endpoint = \"https://api.waqi.info/feed/geo:\";\n      const token = \"\"; //Use a token from https://aqicn.org/api/\n      let html_style = `body{padding:6em; font-family: sans-serif;} h1{color:#f6821f}`;\n\n\n      let html_content = \"<h1>Weather 🌦</h1>\";\n\n\n      const latitude = request.cf.latitude;\n      const longitude = request.cf.longitude;\n      endpoint += `${latitude};${longitude}/?token=${token}`;\n      const init = {\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      };\n\n\n      const response = await fetch(endpoint, init);\n      const content = await response.json();\n\n\n      html_content += `<p>This is a demo using Workers geolocation data. </p>`;\n      html_content += `You are located at: ${latitude},${longitude}.</p>`;\n      html_content += `<p>Based off sensor data from <a href=\"${content.data.city.url}\">${content.data.city.name}</a>:</p>`;\n      html_content += `<p>The AQI level is: ${content.data.aqi}.</p>`;\n      html_content += `<p>The N02 level is: ${content.data.iaqi.no2?.v}.</p>`;\n      html_content += `<p>The O3 level is: ${content.data.iaqi.o3?.v}.</p>`;\n      html_content += `<p>The temperature is: ${content.data.iaqi.t?.v}°C.</p>`;\n\n\n      let html = `\n        <!DOCTYPE html>\n        <head>\n          <title>Geolocation: Weather</title>\n        </head>\n        <body>\n          <style>${html_style}</style>\n          <div id=\"container\">\n          ${html_content}\n          </div>\n        </body>`;\n\n\n      return new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      let endpoint = \"https://api.waqi.info/feed/geo:\";\n      const token = \"\"; //Use a token from https://aqicn.org/api/\n      let html_style = `body{padding:6em; font-family: sans-serif;} h1{color:#f6821f}`;\n\n\n      let html_content = \"<h1>Weather 🌦</h1>\";\n\n\n      const latitude = request.cf.latitude;\n      const longitude = request.cf.longitude;\n      endpoint += `${latitude};${longitude}/?token=${token}`;\n      const init = {\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      };\n\n\n      const response = await fetch(endpoint, init);\n      const content = await response.json();\n\n\n      html_content += `<p>This is a demo using Workers geolocation data. </p>`;\n      html_content += `You are located at: ${latitude},${longitude}.</p>`;\n      html_content += `<p>Based off sensor data from <a href=\"${content.data.city.url}\">${content.data.city.name}</a>:</p>`;\n      html_content += `<p>The AQI level is: ${content.data.aqi}.</p>`;\n      html_content += `<p>The N02 level is: ${content.data.iaqi.no2?.v}.</p>`;\n      html_content += `<p>The O3 level is: ${content.data.iaqi.o3?.v}.</p>`;\n      html_content += `<p>The temperature is: ${content.data.iaqi.t?.v}°C.</p>`;\n\n\n      let html = `\n        <!DOCTYPE html>\n        <head>\n          <title>Geolocation: Weather</title>\n        </head>\n        <body>\n          <style>${html_style}</style>\n          <div id=\"container\">\n          ${html_content}\n          </div>\n        </body>`;\n\n\n      return new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from 'hono';\n  import { html } from 'hono/html';\n\n\n  type Bindings = {};\n\n\n  interface WeatherApiResponse {\n    data: {\n      aqi: number;\n      city: {\n        name: string;\n        url: string;\n      };\n      iaqi: {\n        no2?: { v: number };\n        o3?: { v: number };\n        t?: { v: number };\n      };\n    };\n  }\n\n\n  const app = new Hono<{ Bindings: Bindings }>();\n\n\n  app.get('*', async (c) => {\n    // Get API endpoint\n    let endpoint = \"https://api.waqi.info/feed/geo:\";\n    const token = \"\"; // Use a token from https://aqicn.org/api/\n\n\n    // Define styles\n    const html_style = `body{padding:6em; font-family: sans-serif;} h1{color:#f6821f}`;\n\n\n    // Get geolocation from Cloudflare request\n    const req = c.req.raw;\n    const latitude = req.cf?.latitude;\n    const longitude = req.cf?.longitude;\n\n\n    // Create complete API endpoint with coordinates\n    endpoint += `${latitude};${longitude}/?token=${token}`;\n\n\n    // Fetch weather data\n    const init = {\n      headers: {\n        \"content-type\": \"application/json;charset=UTF-8\",\n      },\n    };\n    const response = await fetch(endpoint, init);\n    const content = await response.json() as WeatherApiResponse;\n\n\n    // Build HTML content\n    const weatherContent = html`\n      <h1>Weather 🌦</h1>\n      <p>This is a demo using Workers geolocation data.</p>\n      <p>You are located at: ${latitude},${longitude}.</p>\n      <p>Based off sensor data from <a href=\"${content.data.city.url}\">${content.data.city.name}</a>:</p>\n      <p>The AQI level is: ${content.data.aqi}.</p>\n      <p>The N02 level is: ${content.data.iaqi.no2?.v}.</p>\n      <p>The O3 level is: ${content.data.iaqi.o3?.v}.</p>\n      <p>The temperature is: ${content.data.iaqi.t?.v}°C.</p>\n    `;\n\n\n    // Complete HTML document\n    const htmlDocument = html`\n      <!DOCTYPE html>\n      <head>\n        <title>Geolocation: Weather</title>\n      </head>\n      <body>\n        <style>${html_style}</style>\n        <div id=\"container\">\n          ${weatherContent}\n        </div>\n      </body>\n    `;\n\n\n    // Return HTML response\n    return c.html(htmlDocument);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response, fetch\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          endpoint = \"https://api.waqi.info/feed/geo:\"\n          token = \"\" # Use a token from https://aqicn.org/api/\n          html_style = \"body{padding:6em; font-family: sans-serif;} h1{color:#f6821f}\"\n          html_content = \"<h1>Weather 🌦</h1>\"\n\n\n          latitude = request.cf.latitude\n          longitude = request.cf.longitude\n\n\n          endpoint += f\"{latitude};{longitude}/?token={token}\"\n          response = await fetch(endpoint)\n          content = await response.json()\n\n\n          html_content += \"<p>This is a demo using Workers geolocation data. </p>\"\n          html_content += f\"You are located at: {latitude},{longitude}.</p>\"\n          html_content += f\"<p>Based off sensor data from <a href='{content['data']['city']['url']}'>{content['data']['city']['name']}</a>:</p>\"\n          html_content += f\"<p>The AQI level is: {content['data']['aqi']}.</p>\"\n          html_content += f\"<p>The N02 level is: {content['data']['iaqi']['no2']['v']}.</p>\"\n          html_content += f\"<p>The O3 level is: {content['data']['iaqi']['o3']['v']}.</p>\"\n          html_content += f\"<p>The temperature is: {content['data']['iaqi']['t']['v']}°C.</p>\"\n\n\n          html = f\"\"\"\n          <!DOCTYPE html>\n            <head>\n              <title>Geolocation: Weather</title>\n            </head>\n            <body>\n              <style>{html_style}</style>\n              <div id=\"container\">\n              {html_content}\n              </div>\n            </body>\n          \"\"\"\n\n\n          headers = {\"content-type\": \"text/html;charset=UTF-8\"}\n          return Response(html, headers=headers)",
      "language": "py"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      let grads = [\n        [\n          { color: \"00000c\", position: 0 },\n          { color: \"00000c\", position: 0 },\n        ],\n        [\n          { color: \"020111\", position: 85 },\n          { color: \"191621\", position: 100 },\n        ],\n        [\n          { color: \"020111\", position: 60 },\n          { color: \"20202c\", position: 100 },\n        ],\n        [\n          { color: \"020111\", position: 10 },\n          { color: \"3a3a52\", position: 100 },\n        ],\n        [\n          { color: \"20202c\", position: 0 },\n          { color: \"515175\", position: 100 },\n        ],\n        [\n          { color: \"40405c\", position: 0 },\n          { color: \"6f71aa\", position: 80 },\n          { color: \"8a76ab\", position: 100 },\n        ],\n        [\n          { color: \"4a4969\", position: 0 },\n          { color: \"7072ab\", position: 50 },\n          { color: \"cd82a0\", position: 100 },\n        ],\n        [\n          { color: \"757abf\", position: 0 },\n          { color: \"8583be\", position: 60 },\n          { color: \"eab0d1\", position: 100 },\n        ],\n        [\n          { color: \"82addb\", position: 0 },\n          { color: \"ebb2b1\", position: 100 },\n        ],\n        [\n          { color: \"94c5f8\", position: 1 },\n          { color: \"a6e6ff\", position: 70 },\n          { color: \"b1b5ea\", position: 100 },\n        ],\n        [\n          { color: \"b7eaff\", position: 0 },\n          { color: \"94dfff\", position: 100 },\n        ],\n        [\n          { color: \"9be2fe\", position: 0 },\n          { color: \"67d1fb\", position: 100 },\n        ],\n        [\n          { color: \"90dffe\", position: 0 },\n          { color: \"38a3d1\", position: 100 },\n        ],\n        [\n          { color: \"57c1eb\", position: 0 },\n          { color: \"246fa8\", position: 100 },\n        ],\n        [\n          { color: \"2d91c2\", position: 0 },\n          { color: \"1e528e\", position: 100 },\n        ],\n        [\n          { color: \"2473ab\", position: 0 },\n          { color: \"1e528e\", position: 70 },\n          { color: \"5b7983\", position: 100 },\n        ],\n        [\n          { color: \"1e528e\", position: 0 },\n          { color: \"265889\", position: 50 },\n          { color: \"9da671\", position: 100 },\n        ],\n        [\n          { color: \"1e528e\", position: 0 },\n          { color: \"728a7c\", position: 50 },\n          { color: \"e9ce5d\", position: 100 },\n        ],\n        [\n          { color: \"154277\", position: 0 },\n          { color: \"576e71\", position: 30 },\n          { color: \"e1c45e\", position: 70 },\n          { color: \"b26339\", position: 100 },\n        ],\n        [\n          { color: \"163C52\", position: 0 },\n          { color: \"4F4F47\", position: 30 },\n          { color: \"C5752D\", position: 60 },\n          { color: \"B7490F\", position: 80 },\n          { color: \"2F1107\", position: 100 },\n        ],\n        [\n          { color: \"071B26\", position: 0 },\n          { color: \"071B26\", position: 30 },\n          { color: \"8A3B12\", position: 80 },\n          { color: \"240E03\", position: 100 },\n        ],\n        [\n          { color: \"010A10\", position: 30 },\n          { color: \"59230B\", position: 80 },\n          { color: \"2F1107\", position: 100 },\n        ],\n        [\n          { color: \"090401\", position: 50 },\n          { color: \"4B1D06\", position: 100 },\n        ],\n        [\n          { color: \"00000c\", position: 80 },\n          { color: \"150800\", position: 100 },\n        ],\n      ];\n      async function toCSSGradient(hour) {\n        let css = \"linear-gradient(to bottom,\";\n        const data = grads[hour];\n        const len = data.length;\n        for (let i = 0; i < len; i++) {\n          const item = data[i];\n          css += ` #${item.color} ${item.position}%`;\n          if (i < len - 1) css += \",\";\n        }\n        return css + \")\";\n      }\n      let html_content = \"\";\n      let html_style = `\n        html{width:100vw; height:100vh;}\n        body{padding:0; margin:0 !important;height:100%;}\n        #container {\n          display: flex;\n          flex-direction:column;\n          align-items: center;\n          justify-content: center;\n          height: 100%;\n          color:white;\n          font-family:sans-serif;\n        }`;\n      const timezone = request.cf.timezone;\n      console.log(timezone);\n      let localized_date = new Date(\n        new Date().toLocaleString(\"en-US\", { timeZone: timezone }),\n      );\n      let hour = localized_date.getHours();\n      let minutes = localized_date.getMinutes();\n      html_content += \"<h1>\" + hour + \":\" + minutes + \"</h1>\";\n      html_content += \"<p>\" + timezone + \"<br/></p>\";\n      html_style += \"body{background:\" + (await toCSSGradient(hour)) + \";}\";\n      let html = `\n        <!DOCTYPE html>\n        <head>\n          <title>Geolocation: Customized Design</title>\n        </head>\n        <body>\n          <style> ${html_style}</style>\n          <div id=\"container\">\n            ${html_content}\n          </div>\n        </body>`;\n      return new Response(html, {\n        headers: { \"content-type\": \"text/html;charset=UTF-8\" },\n      });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      let grads = [\n        [\n          { color: \"00000c\", position: 0 },\n          { color: \"00000c\", position: 0 },\n        ],\n        [\n          { color: \"020111\", position: 85 },\n          { color: \"191621\", position: 100 },\n        ],\n        [\n          { color: \"020111\", position: 60 },\n          { color: \"20202c\", position: 100 },\n        ],\n        [\n          { color: \"020111\", position: 10 },\n          { color: \"3a3a52\", position: 100 },\n        ],\n        [\n          { color: \"20202c\", position: 0 },\n          { color: \"515175\", position: 100 },\n        ],\n        [\n          { color: \"40405c\", position: 0 },\n          { color: \"6f71aa\", position: 80 },\n          { color: \"8a76ab\", position: 100 },\n        ],\n        [\n          { color: \"4a4969\", position: 0 },\n          { color: \"7072ab\", position: 50 },\n          { color: \"cd82a0\", position: 100 },\n        ],\n        [\n          { color: \"757abf\", position: 0 },\n          { color: \"8583be\", position: 60 },\n          { color: \"eab0d1\", position: 100 },\n        ],\n        [\n          { color: \"82addb\", position: 0 },\n          { color: \"ebb2b1\", position: 100 },\n        ],\n        [\n          { color: \"94c5f8\", position: 1 },\n          { color: \"a6e6ff\", position: 70 },\n          { color: \"b1b5ea\", position: 100 },\n        ],\n        [\n          { color: \"b7eaff\", position: 0 },\n          { color: \"94dfff\", position: 100 },\n        ],\n        [\n          { color: \"9be2fe\", position: 0 },\n          { color: \"67d1fb\", position: 100 },\n        ],\n        [\n          { color: \"90dffe\", position: 0 },\n          { color: \"38a3d1\", position: 100 },\n        ],\n        [\n          { color: \"57c1eb\", position: 0 },\n          { color: \"246fa8\", position: 100 },\n        ],\n        [\n          { color: \"2d91c2\", position: 0 },\n          { color: \"1e528e\", position: 100 },\n        ],\n        [\n          { color: \"2473ab\", position: 0 },\n          { color: \"1e528e\", position: 70 },\n          { color: \"5b7983\", position: 100 },\n        ],\n        [\n          { color: \"1e528e\", position: 0 },\n          { color: \"265889\", position: 50 },\n          { color: \"9da671\", position: 100 },\n        ],\n        [\n          { color: \"1e528e\", position: 0 },\n          { color: \"728a7c\", position: 50 },\n          { color: \"e9ce5d\", position: 100 },\n        ],\n        [\n          { color: \"154277\", position: 0 },\n          { color: \"576e71\", position: 30 },\n          { color: \"e1c45e\", position: 70 },\n          { color: \"b26339\", position: 100 },\n        ],\n        [\n          { color: \"163C52\", position: 0 },\n          { color: \"4F4F47\", position: 30 },\n          { color: \"C5752D\", position: 60 },\n          { color: \"B7490F\", position: 80 },\n          { color: \"2F1107\", position: 100 },\n        ],\n        [\n          { color: \"071B26\", position: 0 },\n          { color: \"071B26\", position: 30 },\n          { color: \"8A3B12\", position: 80 },\n          { color: \"240E03\", position: 100 },\n        ],\n        [\n          { color: \"010A10\", position: 30 },\n          { color: \"59230B\", position: 80 },\n          { color: \"2F1107\", position: 100 },\n        ],\n        [\n          { color: \"090401\", position: 50 },\n          { color: \"4B1D06\", position: 100 },\n        ],\n        [\n          { color: \"00000c\", position: 80 },\n          { color: \"150800\", position: 100 },\n        ],\n      ];\n      async function toCSSGradient(hour) {\n        let css = \"linear-gradient(to bottom,\";\n        const data = grads[hour];\n        const len = data.length;\n        for (let i = 0; i < len; i++) {\n          const item = data[i];\n          css += ` #${item.color} ${item.position}%`;\n          if (i < len - 1) css += \",\";\n        }\n        return css + \")\";\n      }\n      let html_content = \"\";\n      let html_style = `\n        html{width:100vw; height:100vh;}\n        body{padding:0; margin:0 !important;height:100%;}\n        #container {\n          display: flex;\n          flex-direction:column;\n          align-items: center;\n          justify-content: center;\n          height: 100%;\n          color:white;\n          font-family:sans-serif;\n        }`;\n      const timezone = request.cf.timezone;\n      console.log(timezone);\n      let localized_date = new Date(\n        new Date().toLocaleString(\"en-US\", { timeZone: timezone }),\n      );\n      let hour = localized_date.getHours();\n      let minutes = localized_date.getMinutes();\n      html_content += \"<h1>\" + hour + \":\" + minutes + \"</h1>\";\n      html_content += \"<p>\" + timezone + \"<br/></p>\";\n      html_style += \"body{background:\" + (await toCSSGradient(hour)) + \";}\";\n      let html = `\n        <!DOCTYPE html>\n        <head>\n          <title>Geolocation: Customized Design</title>\n        </head>\n        <body>\n          <style> ${html_style}</style>\n          <div id=\"container\">\n            ${html_content}\n          </div>\n        </body>`;\n      return new Response(html, {\n        headers: { \"content-type\": \"text/html;charset=UTF-8\" },\n      });\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  type Bindings = {};\n  type ColorStop = { color: string; position: number };\n\n\n  const app = new Hono<{ Bindings: Bindings }>();\n\n\n  // Gradient configurations for each hour of the day (0-23)\n  const grads: ColorStop[][] = [\n    [\n      { color: \"00000c\", position: 0 },\n      { color: \"00000c\", position: 0 },\n    ],\n    [\n      { color: \"020111\", position: 85 },\n      { color: \"191621\", position: 100 },\n    ],\n    [\n      { color: \"020111\", position: 60 },\n      { color: \"20202c\", position: 100 },\n    ],\n    [\n      { color: \"020111\", position: 10 },\n      { color: \"3a3a52\", position: 100 },\n    ],\n    [\n      { color: \"20202c\", position: 0 },\n      { color: \"515175\", position: 100 },\n    ],\n    [\n      { color: \"40405c\", position: 0 },\n      { color: \"6f71aa\", position: 80 },\n      { color: \"8a76ab\", position: 100 },\n    ],\n    [\n      { color: \"4a4969\", position: 0 },\n      { color: \"7072ab\", position: 50 },\n      { color: \"cd82a0\", position: 100 },\n    ],\n    [\n      { color: \"757abf\", position: 0 },\n      { color: \"8583be\", position: 60 },\n      { color: \"eab0d1\", position: 100 },\n    ],\n    [\n      { color: \"82addb\", position: 0 },\n      { color: \"ebb2b1\", position: 100 },\n    ],\n    [\n      { color: \"94c5f8\", position: 1 },\n      { color: \"a6e6ff\", position: 70 },\n      { color: \"b1b5ea\", position: 100 },\n    ],\n    [\n      { color: \"b7eaff\", position: 0 },\n      { color: \"94dfff\", position: 100 },\n    ],\n    [\n      { color: \"9be2fe\", position: 0 },\n      { color: \"67d1fb\", position: 100 },\n    ],\n    [\n      { color: \"90dffe\", position: 0 },\n      { color: \"38a3d1\", position: 100 },\n    ],\n    [\n      { color: \"57c1eb\", position: 0 },\n      { color: \"246fa8\", position: 100 },\n    ],\n    [\n      { color: \"2d91c2\", position: 0 },\n      { color: \"1e528e\", position: 100 },\n    ],\n    [\n      { color: \"2473ab\", position: 0 },\n      { color: \"1e528e\", position: 70 },\n      { color: \"5b7983\", position: 100 },\n    ],\n    [\n      { color: \"1e528e\", position: 0 },\n      { color: \"265889\", position: 50 },\n      { color: \"9da671\", position: 100 },\n    ],\n    [\n      { color: \"1e528e\", position: 0 },\n      { color: \"728a7c\", position: 50 },\n      { color: \"e9ce5d\", position: 100 },\n    ],\n    [\n      { color: \"154277\", position: 0 },\n      { color: \"576e71\", position: 30 },\n      { color: \"e1c45e\", position: 70 },\n      { color: \"b26339\", position: 100 },\n    ],\n    [\n      { color: \"163C52\", position: 0 },\n      { color: \"4F4F47\", position: 30 },\n      { color: \"C5752D\", position: 60 },\n      { color: \"B7490F\", position: 80 },\n      { color: \"2F1107\", position: 100 },\n    ],\n    [\n      { color: \"071B26\", position: 0 },\n      { color: \"071B26\", position: 30 },\n      { color: \"8A3B12\", position: 80 },\n      { color: \"240E03\", position: 100 },\n    ],\n    [\n      { color: \"010A10\", position: 30 },\n      { color: \"59230B\", position: 80 },\n      { color: \"2F1107\", position: 100 },\n    ],\n    [\n      { color: \"090401\", position: 50 },\n      { color: \"4B1D06\", position: 100 },\n    ],\n    [\n      { color: \"00000c\", position: 80 },\n      { color: \"150800\", position: 100 },\n    ],\n  ];\n\n\n  // Convert hour to CSS gradient\n  async function toCSSGradient(hour: number): Promise<string> {\n    let css = \"linear-gradient(to bottom,\";\n    const data = grads[hour];\n    const len = data.length;\n\n\n    for (let i = 0; i < len; i++) {\n      const item = data[i];\n      css += ` #${item.color} ${item.position}%`;\n      if (i < len - 1) css += \",\";\n    }\n\n\n    return css + \")\";\n  }\n\n\n  app.get('*', async (c) => {\n    const request = c.req.raw;\n\n\n    // Base HTML style\n    let html_style = `\n      html{width:100vw; height:100vh;}\n      body{padding:0; margin:0 !important;height:100%;}\n      #container {\n        display: flex;\n        flex-direction:column;\n        align-items: center;\n        justify-content: center;\n        height: 100%;\n        color:white;\n        font-family:sans-serif;\n      }`;\n\n\n    // Get timezone from Cloudflare request\n    const timezone = request.cf?.timezone || 'UTC';\n    console.log(timezone);\n\n\n    // Get localized time\n    let localized_date = new Date(\n      new Date().toLocaleString(\"en-US\", { timeZone: timezone })\n    );\n\n\n    let hour = localized_date.getHours();\n    let minutes = localized_date.getMinutes();\n\n\n    // Generate HTML content\n    let html_content = `<h1>${hour}:${minutes}</h1>`;\n    html_content += `<p>${timezone}<br/></p>`;\n\n\n    // Add background gradient based on hour\n    html_style += `body{background:${await toCSSGradient(hour)};}`;\n\n\n    // Complete HTML document\n    let html = `\n      <!DOCTYPE html>\n      <head>\n        <title>Geolocation: Customized Design</title>\n      </head>\n      <body>\n        <style>${html_style}</style>\n        <div id=\"container\">\n          ${html_content}\n        </div>\n      </body>`;\n\n\n    return c.html(html);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      let html_content = \"\";\n      let html_style =\n        \"body{padding:6em; font-family: sans-serif;} h1{color:#f6821f;}\";\n\n\n      html_content += \"<p> Colo: \" + request.cf.colo + \"</p>\";\n      html_content += \"<p> Country: \" + request.cf.country + \"</p>\";\n      html_content += \"<p> City: \" + request.cf.city + \"</p>\";\n      html_content += \"<p> Continent: \" + request.cf.continent + \"</p>\";\n      html_content += \"<p> Latitude: \" + request.cf.latitude + \"</p>\";\n      html_content += \"<p> Longitude: \" + request.cf.longitude + \"</p>\";\n      html_content += \"<p> PostalCode: \" + request.cf.postalCode + \"</p>\";\n      html_content += \"<p> MetroCode: \" + request.cf.metroCode + \"</p>\";\n      html_content += \"<p> Region: \" + request.cf.region + \"</p>\";\n      html_content += \"<p> RegionCode: \" + request.cf.regionCode + \"</p>\";\n      html_content += \"<p> Timezone: \" + request.cf.timezone + \"</p>\";\n\n\n      let html = `<!DOCTYPE html>\n        <head>\n          <title> Geolocation: Hello World </title>\n          <style> ${html_style} </style>\n        </head>\n        <body>\n          <h1>Geolocation: Hello World!</h1>\n          <p>You now have access to geolocation data about where your user is visiting from.</p>\n          ${html_content}\n        </body>`;\n\n\n      return new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      let html_content = \"\";\n      let html_style =\n        \"body{padding:6em; font-family: sans-serif;} h1{color:#f6821f;}\";\n\n\n      html_content += \"<p> Colo: \" + request.cf.colo + \"</p>\";\n      html_content += \"<p> Country: \" + request.cf.country + \"</p>\";\n      html_content += \"<p> City: \" + request.cf.city + \"</p>\";\n      html_content += \"<p> Continent: \" + request.cf.continent + \"</p>\";\n      html_content += \"<p> Latitude: \" + request.cf.latitude + \"</p>\";\n      html_content += \"<p> Longitude: \" + request.cf.longitude + \"</p>\";\n      html_content += \"<p> PostalCode: \" + request.cf.postalCode + \"</p>\";\n      html_content += \"<p> MetroCode: \" + request.cf.metroCode + \"</p>\";\n      html_content += \"<p> Region: \" + request.cf.region + \"</p>\";\n      html_content += \"<p> RegionCode: \" + request.cf.regionCode + \"</p>\";\n      html_content += \"<p> Timezone: \" + request.cf.timezone + \"</p>\";\n\n\n      let html = `<!DOCTYPE html>\n        <head>\n          <title> Geolocation: Hello World </title>\n          <style> ${html_style} </style>\n        </head>\n        <body>\n          <h1>Geolocation: Hello World!</h1>\n          <p>You now have access to geolocation data about where your user is visiting from.</p>\n          ${html_content}\n        </body>`;\n\n\n      return new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          html_content = \"\"\n          html_style = \"body{padding:6em font-family: sans-serif;} h1{color:#f6821f;}\"\n\n\n          html_content += \"<p> Colo: \" + request.cf.colo + \"</p>\"\n          html_content += \"<p> Country: \" + request.cf.country + \"</p>\"\n          html_content += \"<p> City: \" + request.cf.city + \"</p>\"\n          html_content += \"<p> Continent: \" + request.cf.continent + \"</p>\"\n          html_content += \"<p> Latitude: \" + request.cf.latitude + \"</p>\"\n          html_content += \"<p> Longitude: \" + request.cf.longitude + \"</p>\"\n          html_content += \"<p> PostalCode: \" + request.cf.postalCode + \"</p>\"\n          html_content += \"<p> Region: \" + request.cf.region + \"</p>\"\n          html_content += \"<p> RegionCode: \" + request.cf.regionCode + \"</p>\"\n          html_content += \"<p> Timezone: \" + request.cf.timezone + \"</p>\"\n\n\n          html = f\"\"\"\n          <!DOCTYPE html>\n            <head>\n              <title> Geolocation: Hello World </title>\n              <style> {html_style} </style>\n            </head>\n            <body>\n              <h1>Geolocation: Hello World!</h1>\n              <p>You now have access to geolocation data about where your user is visiting from.</p>\n              {html_content}\n            </body>\n          \"\"\"\n\n\n          headers = {\"content-type\": \"text/html;charset=UTF-8\"}\n          return Response(html, headers=headers)",
      "language": "py"
    },
    {
      "code": "import { Hono } from \"hono\";\n  import { html } from \"hono/html\";\n\n\n  // Define the RequestWithCf interface to add Cloudflare-specific properties\n  interface RequestWithCf extends Request {\n    cf: {\n      // Cloudflare-specific properties for geolocation\n      colo: string;\n      country: string;\n      city: string;\n      continent: string;\n      latitude: string;\n      longitude: string;\n      postalCode: string;\n      metroCode: string;\n      region: string;\n      regionCode: string;\n      timezone: string;\n      // Add other CF properties as needed\n    };\n  }\n\n\n  const app = new Hono();\n\n\n  app.get(\"*\", (c) => {\n    // Cast the raw request to include Cloudflare-specific properties\n    const request = c.req.raw;\n\n\n    // Define styles\n    const html_style =\n      \"body{padding:6em; font-family: sans-serif;} h1{color:#f6821f;}\";\n\n\n    // Create content with geolocation data\n    let html_content = html` <p>Colo: ${request.cf.colo}</p>\n      <p>Country: ${request.cf.country}</p>\n      <p>City: ${request.cf.city}</p>\n      <p>Continent: ${request.cf.continent}</p>\n      <p>Latitude: ${request.cf.latitude}</p>\n      <p>Longitude: ${request.cf.longitude}</p>\n      <p>PostalCode: ${request.cf.postalCode}</p>\n      <p>MetroCode: ${request.cf.metroCode}</p>\n      <p>Region: ${request.cf.region}</p>\n      <p>RegionCode: ${request.cf.regionCode}</p>\n      <p>Timezone: ${request.cf.timezone}</p>`;\n\n\n    // Compose the full HTML\n    const htmlContent = html`<!DOCTYPE html>\n      <head>\n        <title>Geolocation: Hello World</title>\n        <style>\n          ${html_style}\n        </style>\n      </head>\n      <body>\n        <h1>Geolocation: Hello World!</h1>\n        <p>\n          You now have access to geolocation data about where your user is\n          visiting from.\n        </p>\n        ${html_content}\n      </body> `;\n\n\n    // Return the HTML response\n    return c.html(htmlContent);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const HOMEPAGE_URL = \"https://tutorial.cloudflareworkers.com/\";\n      const PROTECTED_TYPE = \"image/\";\n\n\n      // Fetch the original request\n      const response = await fetch(request);\n\n\n      // If it's an image, engage hotlink protection based on the\n      // Referer header.\n      const referer = request.headers.get(\"Referer\");\n      const contentType = response.headers.get(\"Content-Type\") || \"\";\n\n\n      if (referer && contentType.startsWith(PROTECTED_TYPE)) {\n        // If the hostnames don't match, it's a hotlink\n        if (new URL(referer).hostname !== new URL(request.url).hostname) {\n          // Redirect the user to your website\n          return Response.redirect(HOMEPAGE_URL, 302);\n        }\n      }\n\n\n      // Everything is fine, return the response normally.\n      return response;\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const HOMEPAGE_URL = \"https://tutorial.cloudflareworkers.com/\";\n      const PROTECTED_TYPE = \"image/\";\n\n\n      // Fetch the original request\n      const response = await fetch(request);\n\n\n      // If it's an image, engage hotlink protection based on the\n      // Referer header.\n      const referer = request.headers.get(\"Referer\");\n      const contentType = response.headers.get(\"Content-Type\") || \"\";\n\n\n      if (referer && contentType.startsWith(PROTECTED_TYPE)) {\n        // If the hostnames don't match, it's a hotlink\n        if (new URL(referer).hostname !== new URL(request.url).hostname) {\n          // Redirect the user to your website\n          return Response.redirect(HOMEPAGE_URL, 302);\n        }\n      }\n\n\n      // Everything is fine, return the response normally.\n      return response;\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response, fetch\n  from urllib.parse import urlparse\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          homepage_url = \"https://tutorial.cloudflareworkers.com/\"\n          protected_type = \"image/\"\n\n\n          # Fetch the original request\n          response = await fetch(request)\n\n\n          # If it's an image, engage hotlink protection based on the referer header\n          referer = request.headers[\"Referer\"]\n          content_type = response.headers[\"Content-Type\"] or \"\"\n\n\n          if referer and content_type.startswith(protected_type):\n              # If the hostnames don't match, it's a hotlink\n              if urlparse(referer).hostname != urlparse(request.url).hostname:\n                  # Redirect the user to your website\n                  return Response.redirect(homepage_url, 302)\n\n\n          # Everything is fine, return the response normally\n          return response",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  const app = new Hono();\n\n\n  // Middleware for hot-link protection\n  app.use('*', async (c, next) => {\n    const HOMEPAGE_URL = \"https://tutorial.cloudflareworkers.com/\";\n    const PROTECTED_TYPE = \"image/\";\n\n\n    // Continue to the next handler to get the response\n    await next();\n\n\n    // If we have a response, check for hotlinking\n    if (c.res) {\n      // If it's an image, engage hotlink protection based on the Referer header\n      const referer = c.req.header(\"Referer\");\n      const contentType = c.res.headers.get(\"Content-Type\") || \"\";\n\n\n      if (referer && contentType.startsWith(PROTECTED_TYPE)) {\n        // If the hostnames don't match, it's a hotlink\n        if (new URL(referer).hostname !== new URL(c.req.url).hostname) {\n          // Redirect the user to your website\n          c.res = c.redirect(HOMEPAGE_URL, 302);\n        }\n      }\n    }\n  });\n\n\n  // Default route handler that passes through the request to the origin\n  app.all('*', async (c) => {\n    // Fetch the original request\n    return fetch(c.req.raw);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      // You can find this in the dashboard, it should look something like this: ZWd9g1K7eljCn_KDTu_MWA\n      const accountHash = \"\";\n\n\n      const { pathname } = new URL(request.url);\n\n\n      // A request to something like cdn.example.com/83eb7b2-5392-4565-b69e-aff66acddd00/public\n      // will fetch \"https://imagedelivery.net/<accountHash>/83eb7b2-5392-4565-b69e-aff66acddd00/public\"\n\n\n      return fetch(`https://imagedelivery.net/${accountHash}${pathname}`);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      // You can find this in the dashboard, it should look something like this: ZWd9g1K7eljCn_KDTu_MWA\n      const accountHash = \"\";\n\n\n      const { pathname } = new URL(request.url);\n\n\n      // A request to something like cdn.example.com/83eb7b2-5392-4565-b69e-aff66acddd00/public\n      // will fetch \"https://imagedelivery.net/<accountHash>/83eb7b2-5392-4565-b69e-aff66acddd00/public\"\n\n\n      return fetch(`https://imagedelivery.net/${accountHash}${pathname}`);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  interface Env {\n    // You can store your account hash as a binding variable\n    ACCOUNT_HASH?: string;\n  }\n\n\n  const app = new Hono<{ Bindings: Env }>();\n\n\n  app.get('*', async (c) => {\n    // You can find this in the dashboard, it should look something like this: ZWd9g1K7eljCn_KDTu_MWA\n    // Either get it from environment or hardcode it here\n    const accountHash = c.env.ACCOUNT_HASH || \"\";\n\n\n    const url = new URL(c.req.url);\n\n\n    // A request to something like cdn.example.com/83eb7b2-5392-4565-b69e-aff66acddd00/public\n    // will fetch \"https://imagedelivery.net/<accountHash>/83eb7b2-5392-4565-b69e-aff66acddd00/public\"\n\n\n    return fetch(`https://imagedelivery.net/${accountHash}${url.pathname}`);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from js import URL, fetch\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # You can find this in the dashboard, it should look something like this: ZWd9g1K7eljCn_KDTu_MWA\n          account_hash = \"\"\n          url = URL.new(request.url)\n\n\n          # A request to something like cdn.example.com/83eb7b2-5392-4565-b69e-aff66acddd00/public\n          # will fetch \"https://imagedelivery.net/<accountHash>/83eb7b2-5392-4565-b69e-aff66acddd00/public\"\n          return fetch(f'https://imagedelivery.net/{account_hash}{url.pathname}')",
      "language": "py"
    },
    {
      "code": "https://example.com/cdn-cgi/imagedelivery/<ACCOUNT_HASH>/<IMAGE_ID>/<VARIANT_NAME>",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      console.log(new Map(request.headers));\n      return new Response(\"Hello world\");\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      console.log(new Map(request.headers));\n      return new Response(\"Hello world\");\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          print(dict(request.headers))\n          return Response('Hello world')",
      "language": "py"
    },
    {
      "code": "use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(req: HttpRequest, _env: Env, _ctx: Context) -> Result<Response> {\n      console_log!(\"{:?}\", req.headers());\n      Response::ok(\"hello world\")\n  }",
      "language": "rs"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  const app = new Hono();\n\n\n  app.get('*', (c) => {\n    // Different ways to log headers in Hono:\n\n\n    // 1. Using Map to display headers in console\n    console.log('Headers as Map:', new Map(c.req.raw.headers));\n\n\n    // 2. Using spread operator to log headers\n    console.log('Headers spread:', [...c.req.raw.headers]);\n\n\n    // 3. Using Object.fromEntries to convert to an object\n    console.log('Headers as Object:', Object.fromEntries(c.req.raw.headers));\n\n\n    // 4. Hono's built-in header accessor (for individual headers)\n    console.log('User-Agent:', c.req.header('User-Agent'));\n\n\n    // 5. Using c.req.headers to get all headers\n    console.log('All headers from Hono context:', c.req.header());\n\n\n    return c.text('Hello world');\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "console.log(new Map(request.headers));",
      "language": "js"
    },
    {
      "code": "let requestHeaders = JSON.stringify([...request.headers]);",
      "language": "js"
    },
    {
      "code": "let requestHeaders = Object.fromEntries(request.headers);",
      "language": "js"
    },
    {
      "code": "console.log(request.headers);",
      "language": "js"
    },
    {
      "code": "console.log(`Request headers: ${JSON.stringify(request.headers)}`);",
      "language": "js"
    },
    {
      "code": "console.log(new Map(request.headers));",
      "language": "js"
    },
    {
      "code": "let requestHeaders = JSON.stringify([...request.headers], null, 2);\nconsole.log(`Request headers: ${requestHeaders}`);",
      "language": "js"
    },
    {
      "code": "let headersObject = Object.fromEntries(request.headers);\nlet requestHeaders = JSON.stringify(headersObject, null, 2);\nconsole.log(`Request headers: ${requestHeaders}`);",
      "language": "js"
    },
    {
      "code": "Request headers: {\n  \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\",\n  \"accept-encoding\": \"gzip\",\n  \"accept-language\": \"en-US,en;q=0.9\",\n  \"cf-ipcountry\": \"US\",\n  // ...\n}\"",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      /**\n       * Example someHost is set up to return raw JSON\n       * @param {string} someUrl the URL to send the request to, since we are setting hostname too only path is applied\n       * @param {string} someHost the host the request will resolve too\n       */\n      const someHost = \"example.com\";\n      const someUrl = \"https://foo.example.com/api.js\";\n\n\n      /**\n       * The best practice is to only assign new RequestInit properties\n       * on the request object using either a method or the constructor\n       */\n      const newRequestInit = {\n        // Change method\n        method: \"POST\",\n        // Change body\n        body: JSON.stringify({ bar: \"foo\" }),\n        // Change the redirect mode.\n        redirect: \"follow\",\n        // Change headers, note this method will erase existing headers\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        // Change a Cloudflare feature on the outbound response\n        cf: { apps: false },\n      };\n\n\n      // Change just the host\n      const url = new URL(someUrl);\n\n\n      url.hostname = someHost;\n\n\n      // Best practice is to always use the original request to construct the new request\n      // to clone all the attributes. Applying the URL also requires a constructor\n      // since once a Request has been constructed, its URL is immutable.\n      const newRequest = new Request(\n        url.toString(),\n        new Request(request, newRequestInit),\n      );\n\n\n      // Set headers using method\n      newRequest.headers.set(\"X-Example\", \"bar\");\n      newRequest.headers.set(\"Content-Type\", \"application/json\");\n      try {\n        return await fetch(newRequest);\n      } catch (e) {\n        return new Response(JSON.stringify({ error: e.message }), {\n          status: 500,\n        });\n      }\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * Example someHost is set up to return raw JSON\n       * @param {string} someUrl the URL to send the request to, since we are setting hostname too only path is applied\n       * @param {string} someHost the host the request will resolve too\n       */\n      const someHost = \"example.com\";\n      const someUrl = \"https://foo.example.com/api.js\";\n\n\n      /**\n       * The best practice is to only assign new RequestInit properties\n       * on the request object using either a method or the constructor\n       */\n      const newRequestInit = {\n        // Change method\n        method: \"POST\",\n        // Change body\n        body: JSON.stringify({ bar: \"foo\" }),\n        // Change the redirect mode.\n        redirect: \"follow\",\n        // Change headers, note this method will erase existing headers\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        // Change a Cloudflare feature on the outbound response\n        cf: { apps: false },\n      };\n\n\n      // Change just the host\n      const url = new URL(someUrl);\n\n\n      url.hostname = someHost;\n\n\n      // Best practice is to always use the original request to construct the new request\n      // to clone all the attributes. Applying the URL also requires a constructor\n      // since once a Request has been constructed, its URL is immutable.\n      const newRequest = new Request(\n        url.toString(),\n        new Request(request, newRequestInit),\n      );\n\n\n      // Set headers using method\n      newRequest.headers.set(\"X-Example\", \"bar\");\n      newRequest.headers.set(\"Content-Type\", \"application/json\");\n      try {\n        return await fetch(newRequest);\n      } catch (e) {\n        return new Response(JSON.stringify({ error: e.message }), {\n          status: 500,\n        });\n      }\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import json\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Object, URL, Request, fetch, Response\n\n\n  def to_js(obj):\n      return _to_js(obj, dict_converter=Object.fromEntries)\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          some_host = \"example.com\"\n          some_url = \"https://foo.example.com/api.js\"\n\n\n          # The best practice is to only assign new_request_init properties\n          # on the request object using either a method or the constructor\n          new_request_init = {\n            \"method\": \"POST\", # Change method\n            \"body\": json.dumps({ \"bar\": \"foo\" }), # Change body\n            \"redirect\": \"follow\", # Change the redirect mode\n            # Change headers, note this method will erase existing headers\n            \"headers\": {\n              \"Content-Type\": \"application/json\",\n            },\n            #  Change a Cloudflare feature on the outbound response\n            \"cf\": { \"apps\": False },\n          }\n\n\n          # Change just the host\n          url = URL.new(some_url)\n          url.hostname = some_host\n\n\n          # Best practice is to always use the original request to construct the new request\n          # to clone all the attributes. Applying the URL also requires a constructor\n          # since once a Request has been constructed, its URL is immutable.\n          org_request = Request.new(request, new_request_init)\n          new_request = Request.new(url.toString(),org_request)\n\n\n          new_request.headers[\"X-Example\"] =  \"bar\"\n          new_request.headers[\"Content-Type\"] = \"application/json\"\n\n\n          try:\n              return await fetch(new_request)\n          except Exception as e:\n              return Response.new({\"error\": str(e)}, status=500)",
      "language": "py"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  app.all(\"*\", async (c) => {\n    /**\n     * Example someHost is set up to return raw JSON\n     */\n    const someHost = \"example.com\";\n    const someUrl = \"https://foo.example.com/api.js\";\n\n\n    // Create a URL object to modify the hostname\n    const url = new URL(someUrl);\n    url.hostname = someHost;\n\n\n    // Create a new request\n    // First create a clone of the original request with the new properties\n    const requestClone = new Request(c.req.raw, {\n      // Change method\n      method: \"POST\",\n      // Change body\n      body: JSON.stringify({ bar: \"foo\" }),\n      // Change the redirect mode\n      redirect: \"follow\" as RequestRedirect,\n      // Change headers, note this method will erase existing headers\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Example\": \"bar\",\n      },\n      // Change a Cloudflare feature on the outbound response\n      cf: { apps: false },\n    });\n\n\n    // Then create a new request with the modified URL\n    const newRequest = new Request(url.toString(), requestClone);\n\n\n    // Send the modified request\n    const response = await fetch(newRequest);\n\n\n    // Return the response\n    return response;\n  });\n\n\n  // Handle errors\n  app.onError((err, c) => {\n    return err.getResponse();\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      /**\n       * @param {string} headerNameSrc Header to get the new value from\n       * @param {string} headerNameDst Header to set based off of value in src\n       */\n      const headerNameSrc = \"foo\"; //\"Orig-Header\"\n      const headerNameDst = \"Last-Modified\";\n\n\n      /**\n       * Response properties are immutable. To change them, construct a new\n       * Response and pass modified status or statusText in the ResponseInit\n       * object. Response headers can be modified through the headers `set` method.\n       */\n      const originalResponse = await fetch(request);\n\n\n      // Change status and statusText, but preserve body and headers\n      let response = new Response(originalResponse.body, {\n        status: 500,\n        statusText: \"some message\",\n        headers: originalResponse.headers,\n      });\n\n\n      // Change response body by adding the foo prop\n      const originalBody = await originalResponse.json();\n      const body = JSON.stringify({ foo: \"bar\", ...originalBody });\n      response = new Response(body, response);\n\n\n      // Add a header using set method\n      response.headers.set(\"foo\", \"bar\");\n\n\n      // Set destination header to the value of the source header\n      const src = response.headers.get(headerNameSrc);\n\n\n      if (src != null) {\n        response.headers.set(headerNameDst, src);\n        console.log(\n          `Response header \"${headerNameDst}\" was set to \"${response.headers.get(\n            headerNameDst,\n          )}\"`,\n        );\n      }\n      return response;\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * @param {string} headerNameSrc Header to get the new value from\n       * @param {string} headerNameDst Header to set based off of value in src\n       */\n      const headerNameSrc = \"foo\"; //\"Orig-Header\"\n      const headerNameDst = \"Last-Modified\";\n\n\n      /**\n       * Response properties are immutable. To change them, construct a new\n       * Response and pass modified status or statusText in the ResponseInit\n       * object. Response headers can be modified through the headers `set` method.\n       */\n      const originalResponse = await fetch(request);\n\n\n      // Change status and statusText, but preserve body and headers\n      let response = new Response(originalResponse.body, {\n        status: 500,\n        statusText: \"some message\",\n        headers: originalResponse.headers,\n      });\n\n\n      // Change response body by adding the foo prop\n      const originalBody = await originalResponse.json();\n      const body = JSON.stringify({ foo: \"bar\", ...originalBody });\n      response = new Response(body, response);\n\n\n      // Add a header using set method\n      response.headers.set(\"foo\", \"bar\");\n\n\n      // Set destination header to the value of the source header\n      const src = response.headers.get(headerNameSrc);\n\n\n      if (src != null) {\n        response.headers.set(headerNameDst, src);\n        console.log(\n          `Response header \"${headerNameDst}\" was set to \"${response.headers.get(\n            headerNameDst,\n          )}\"`,\n        );\n      }\n      return response;\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response, fetch\n  import json\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          header_name_src = \"foo\" # Header to get the new value from\n          header_name_dst = \"Last-Modified\" # Header to set based off of value in src\n\n\n          # Response properties are immutable. To change them, construct a new response\n          original_response = await fetch(request)\n\n\n          # Change status and statusText, but preserve body and headers\n          response = Response(original_response.body, status=500, status_text=\"some message\", headers=original_response.headers)\n\n\n          # Change response body by adding the foo prop\n          new_body = await original_response.json()\n          new_body[\"foo\"] = \"bar\"\n          response.replace_body(json.dumps(new_body))\n\n\n          # Add a new header\n          response.headers[\"foo\"] = \"bar\"\n\n\n          # Set destination header to the value of the source header\n          src = response.headers[header_name_src]\n\n\n          if src is not None:\n              response.headers[header_name_dst] = src\n              print(f'Response header {header_name_dst} was set to {response.headers[header_name_dst]}')\n\n\n          return response",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  const app = new Hono();\n\n\n  app.get('*', async (c) => {\n    /**\n     * Header configuration\n     */\n    const headerNameSrc = \"foo\"; // Header to get the new value from\n    const headerNameDst = \"Last-Modified\"; // Header to set based off of value in src\n\n\n    /**\n     * Response properties are immutable. With Hono, we can modify the response\n     * by creating custom response objects.\n     */\n    const originalResponse = await fetch(c.req.raw);\n\n\n    // Get the JSON body from the original response\n    const originalBody = await originalResponse.json();\n\n\n    // Modify the body by adding a new property\n    const modifiedBody = {\n      foo: \"bar\",\n      ...originalBody\n    };\n\n\n    // Create a new custom response with modified status, headers, and body\n    const response = new Response(JSON.stringify(modifiedBody), {\n      status: 500,\n      statusText: \"some message\",\n      headers: originalResponse.headers,\n    });\n\n\n    // Add a header using set method\n    response.headers.set(\"foo\", \"bar\");\n\n\n    // Set destination header to the value of the source header\n    const src = response.headers.get(headerNameSrc);\n    if (src != null) {\n      response.headers.set(headerNameDst, src);\n      console.log(\n        `Response header \"${headerNameDst}\" was set to \"${response.headers.get(headerNameDst)}\"`\n      );\n    }\n\n\n    return response;\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async scheduled(event, env, ctx) {\n      // Write code for updating your API\n      switch (event.cron) {\n        case \"*/3 * * * *\":\n          // Every three minutes\n          await updateAPI();\n          break;\n        case \"*/10 * * * *\":\n          // Every ten minutes\n          await updateAPI2();\n          break;\n        case \"*/45 * * * *\":\n          // Every forty-five minutes\n          await updateAPI3();\n          break;\n      }\n      console.log(\"cron processed\");\n    },\n  };",
      "language": "js"
    },
    {
      "code": "interface Env {}\n  export default {\n    async scheduled(\n      controller: ScheduledController,\n      env: Env,\n      ctx: ExecutionContext,\n    ) {\n      // Write code for updating your API\n      switch (controller.cron) {\n        case \"*/3 * * * *\":\n          // Every three minutes\n          await updateAPI();\n          break;\n        case \"*/10 * * * *\":\n          // Every ten minutes\n          await updateAPI2();\n          break;\n        case \"*/45 * * * *\":\n          // Every forty-five minutes\n          await updateAPI3();\n          break;\n      }\n      console.log(\"cron processed\");\n    },\n  };",
      "language": "ts"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  interface Env {}\n\n\n  // Create Hono app\n  const app = new Hono<{ Bindings: Env }>();\n\n\n  // Regular routes for normal HTTP requests\n  app.get(\"/\", (c) => c.text(\"Multiple Cron Trigger Example\"));\n\n\n  // Export both the app and a scheduled function\n  export default {\n    // The Hono app handles regular HTTP requests\n    fetch: app.fetch,\n\n\n    // The scheduled function handles Cron triggers\n    async scheduled(\n      controller: ScheduledController,\n      env: Env,\n      ctx: ExecutionContext,\n    ) {\n      // Check which cron schedule triggered this execution\n      switch (controller.cron) {\n        case \"*/3 * * * *\":\n          // Every three minutes\n          await updateAPI();\n          break;\n        case \"*/10 * * * *\":\n          // Every ten minutes\n          await updateAPI2();\n          break;\n        case \"*/45 * * * *\":\n          // Every forty-five minutes\n          await updateAPI3();\n          break;\n      }\n      console.log(\"cron processed\");\n    },\n  };",
      "language": "ts"
    },
    {
      "code": "npx wrangler dev --test-scheduled\n\n\ncurl \"http://localhost:8787/__scheduled?cron=*%2F3+*+*+*+*\"\n\n\ncurl \"http://localhost:8787/cdn-cgi/handler/scheduled?cron=*+*+*+*+*\" # Python Workers",
      "language": "sh"
    },
    {
      "code": "import OpenAI from \"openai\";\n\n\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      const openai = new OpenAI({\n        apiKey: env.OPENAI_API_KEY,\n      });\n\n\n      // Create a TransformStream to handle streaming data\n      let { readable, writable } = new TransformStream();\n      let writer = writable.getWriter();\n      const textEncoder = new TextEncoder();\n\n\n      ctx.waitUntil(\n        (async () => {\n          const stream = await openai.chat.completions.create({\n            model: \"gpt-4o-mini\",\n            messages: [{ role: \"user\", content: \"Tell me a story\" }],\n            stream: true,\n          });\n\n\n          // loop over the data as it is streamed and write to the writeable\n          for await (const part of stream) {\n            writer.write(\n              textEncoder.encode(part.choices[0]?.delta?.content || \"\"),\n            );\n          }\n          writer.close();\n        })(),\n      );\n\n\n      // Send the readable back to the browser\n      return new Response(readable);\n    },\n  } satisfies ExportedHandler<Env>;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from \"hono\";\n  import { streamText } from \"hono/streaming\";\n  import OpenAI from \"openai\";\n\n\n  interface Env {\n    OPENAI_API_KEY: string;\n  }\n\n\n  const app = new Hono<{ Bindings: Env }>();\n\n\n  app.get(\"*\", async (c) => {\n    const openai = new OpenAI({\n      apiKey: c.env.OPENAI_API_KEY,\n    });\n\n\n    const chatStream = await openai.chat.completions.create({\n      model: \"gpt-4o-mini\",\n      messages: [{ role: \"user\", content: \"Tell me a story\" }],\n      stream: true,\n    });\n\n\n    return streamText(c, async (stream) => {\n      for await (const message of chatStream) {\n        await stream.write(message.choices[0].delta.content || \"\");\n      }\n      stream.close();\n    });\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      /**\n       * Example someHost is set up to take in a JSON request\n       * Replace url with the host you wish to send requests to\n       * @param {string} url the URL to send the request to\n       * @param {BodyInit} body the JSON data to send in the request\n       */\n      const someHost = \"https://examples.cloudflareworkers.com/demos\";\n      const url = someHost + \"/requests/json\";\n      const body = {\n        results: [\"default data to send\"],\n        errors: null,\n        msg: \"I sent this to the fetch\",\n      };\n\n\n      /**\n       * gatherResponse awaits and returns a response body as a string.\n       * Use await gatherResponse(..) in an async function to get the response body\n       * @param {Response} response\n       */\n      async function gatherResponse(response) {\n        const { headers } = response;\n        const contentType = headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          return JSON.stringify(await response.json());\n        } else if (contentType.includes(\"application/text\")) {\n          return response.text();\n        } else if (contentType.includes(\"text/html\")) {\n          return response.text();\n        } else {\n          return response.text();\n        }\n      }\n\n\n      const init = {\n        body: JSON.stringify(body),\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      };\n      const response = await fetch(url, init);\n      const results = await gatherResponse(response);\n      return new Response(results, init);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * Example someHost is set up to take in a JSON request\n       * Replace url with the host you wish to send requests to\n       * @param {string} url the URL to send the request to\n       * @param {BodyInit} body the JSON data to send in the request\n       */\n      const someHost = \"https://examples.cloudflareworkers.com/demos\";\n      const url = someHost + \"/requests/json\";\n      const body = {\n        results: [\"default data to send\"],\n        errors: null,\n        msg: \"I sent this to the fetch\",\n      };\n\n\n      /**\n       * gatherResponse awaits and returns a response body as a string.\n       * Use await gatherResponse(..) in an async function to get the response body\n       * @param {Response} response\n       */\n      async function gatherResponse(response) {\n        const { headers } = response;\n        const contentType = headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          return JSON.stringify(await response.json());\n        } else if (contentType.includes(\"application/text\")) {\n          return response.text();\n        } else if (contentType.includes(\"text/html\")) {\n          return response.text();\n        } else {\n          return response.text();\n        }\n      }\n\n\n      const init = {\n        body: JSON.stringify(body),\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      };\n      const response = await fetch(url, init);\n      const results = await gatherResponse(response);\n      return new Response(results, init);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import json\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Object, fetch, Response, Headers\n\n\n  def to_js(obj):\n      return _to_js(obj, dict_converter=Object.fromEntries)\n\n\n  # gather_response returns both content-type & response body as a string\n  async def gather_response(response):\n      headers = response.headers\n      content_type = headers[\"content-type\"] or \"\"\n\n\n      if \"application/json\" in content_type:\n          return (content_type, json.dumps(dict(await response.json())))\n      return (content_type, await response.text())\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, _request):\n      url = \"https://jsonplaceholder.typicode.com/todos/1\"\n\n\n      body = {\n      \"results\": [\"default data to send\"],\n      \"errors\": None,\n      \"msg\": \"I sent this to the fetch\",\n      }\n\n\n      options = {\n      \"body\": json.dumps(body),\n      \"method\": \"POST\",\n      \"headers\": {\n        \"content-type\": \"application/json;charset=UTF-8\",\n      },\n      }\n\n\n      response = await fetch(url, to_js(options))\n      content_type, result = await gather_response(response)\n\n\n      headers = Headers.new({\"content-type\": content_type}.items())\n      return Response.new(result, headers=headers)",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  const app = new Hono();\n\n\n  app.get('*', async (c) => {\n    /**\n     * Example someHost is set up to take in a JSON request\n     * Replace url with the host you wish to send requests to\n     */\n    const someHost = \"https://examples.cloudflareworkers.com/demos\";\n    const url = someHost + \"/requests/json\";\n    const body = {\n      results: [\"default data to send\"],\n      errors: null,\n      msg: \"I sent this to the fetch\",\n    };\n\n\n    /**\n     * gatherResponse awaits and returns a response body as a string.\n     * Use await gatherResponse(..) in an async function to get the response body\n     */\n    async function gatherResponse(response: Response) {\n      const { headers } = response;\n      const contentType = headers.get(\"content-type\") || \"\";\n\n\n      if (contentType.includes(\"application/json\")) {\n        return { contentType, result: JSON.stringify(await response.json()) };\n      } else if (contentType.includes(\"application/text\")) {\n        return { contentType, result: await response.text() };\n      } else if (contentType.includes(\"text/html\")) {\n        return { contentType, result: await response.text() };\n      } else {\n        return { contentType, result: await response.text() };\n      }\n    }\n\n\n    const init = {\n      body: JSON.stringify(body),\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json;charset=UTF-8\",\n      },\n    };\n\n\n    const response = await fetch(url, init);\n    const { contentType, result } = await gatherResponse(response);\n\n\n    return new Response(result, {\n      headers: {\n        \"content-type\": contentType,\n      },\n    });\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "interface Environment {\n    MY_SECRET_VALUE?: string;\n  }\n\n\n  export default {\n    async fetch(req: Request, env: Environment) {\n      if (!env.MY_SECRET_VALUE) {\n        return new Response(\"Missing secret binding\", { status: 500 });\n      }\n\n\n      const authToken = req.headers.get(\"Authorization\") || \"\";\n\n\n      if (authToken.length !== env.MY_SECRET_VALUE.length) {\n        return new Response(\"Unauthorized\", { status: 401 });\n      }\n\n\n      const encoder = new TextEncoder();\n\n\n      const a = encoder.encode(authToken);\n      const b = encoder.encode(env.MY_SECRET_VALUE);\n\n\n      if (a.byteLength !== b.byteLength) {\n        return new Response(\"Unauthorized\", { status: 401 });\n      }\n\n\n      if (!crypto.subtle.timingSafeEqual(a, b)) {\n        return new Response(\"Unauthorized\", { status: 401 });\n      }\n\n\n      return new Response(\"Welcome!\");\n    },\n  };",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response\n  from js import TextEncoder, crypto\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          auth_token = request.headers[\"Authorization\"] or \"\"\n          secret = self.env.MY_SECRET_VALUE\n\n\n          if secret is None:\n              return Response(\"Missing secret binding\", status=500)\n\n\n          if len(auth_token) != len(secret):\n              return Response(\"Unauthorized\", status=401)\n\n\n          encoder = TextEncoder.new()\n          a = encoder.encode(auth_token)\n          b = encoder.encode(secret)\n\n\n          if a.byteLength != b.byteLength:\n              return Response(\"Unauthorized\", status=401)\n\n\n          if not crypto.subtle.timingSafeEqual(a, b):\n              return Response(\"Unauthorized\", status=401)\n\n\n          return Response(\"Welcome!\")",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n\n\n  interface Environment {\n    Bindings: {\n      MY_SECRET_VALUE?: string;\n    }\n  }\n\n\n  const app = new Hono<Environment>();\n\n\n  // Middleware to handle authentication with timing-safe comparison\n  app.use('*', async (c, next) => {\n    const secret = c.env.MY_SECRET_VALUE;\n\n\n    if (!secret) {\n      return c.text(\"Missing secret binding\", 500);\n    }\n\n\n    const authToken = c.req.header(\"Authorization\") || \"\";\n\n\n    // Early length check to avoid unnecessary processing\n    if (authToken.length !== secret.length) {\n      return c.text(\"Unauthorized\", 401);\n    }\n\n\n    const encoder = new TextEncoder();\n\n\n    const a = encoder.encode(authToken);\n    const b = encoder.encode(secret);\n\n\n    if (a.byteLength !== b.byteLength) {\n      return c.text(\"Unauthorized\", 401);\n    }\n\n\n    // Perform timing-safe comparison\n    if (!crypto.subtle.timingSafeEqual(a, b)) {\n      return c.text(\"Unauthorized\", 401);\n    }\n\n\n    // If we got here, the auth token is valid\n    await next();\n  });\n\n\n  // Protected route\n  app.get('*', (c) => {\n    return c.text(\"Welcome!\");\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      /**\n       * rawHtmlResponse returns HTML inputted directly\n       * into the worker script\n       * @param {string} html\n       */\n      function rawHtmlResponse(html) {\n        return new Response(html, {\n          headers: {\n            \"content-type\": \"text/html;charset=UTF-8\",\n          },\n        });\n      }\n\n\n      /**\n       * readRequestBody reads in the incoming request body\n       * Use await readRequestBody(..) in an async function to get the string\n       * @param {Request} request the incoming request to read from\n       */\n      async function readRequestBody(request) {\n        const contentType = request.headers.get(\"content-type\");\n        if (contentType.includes(\"application/json\")) {\n          return JSON.stringify(await request.json());\n        } else if (contentType.includes(\"application/text\")) {\n          return request.text();\n        } else if (contentType.includes(\"text/html\")) {\n          return request.text();\n        } else if (contentType.includes(\"form\")) {\n          const formData = await request.formData();\n          const body = {};\n          for (const entry of formData.entries()) {\n            body[entry[0]] = entry[1];\n          }\n          return JSON.stringify(body);\n        } else {\n          // Perhaps some other type of data was submitted in the form\n          // like an image, or some other binary data.\n          return \"a file\";\n        }\n      }\n\n\n      const { url } = request;\n      if (url.includes(\"form\")) {\n        return rawHtmlResponse(someForm);\n      }\n      if (request.method === \"POST\") {\n        const reqBody = await readRequestBody(request);\n        const retBody = `The request body sent in was ${reqBody}`;\n        return new Response(retBody);\n      } else if (request.method === \"GET\") {\n        return new Response(\"The request was a GET\");\n      }\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * rawHtmlResponse returns HTML inputted directly\n       * into the worker script\n       * @param {string} html\n       */\n      function rawHtmlResponse(html) {\n        return new Response(html, {\n          headers: {\n            \"content-type\": \"text/html;charset=UTF-8\",\n          },\n        });\n      }\n\n\n      /**\n       * readRequestBody reads in the incoming request body\n       * Use await readRequestBody(..) in an async function to get the string\n       * @param {Request} request the incoming request to read from\n       */\n      async function readRequestBody(request: Request) {\n        const contentType = request.headers.get(\"content-type\");\n        if (contentType.includes(\"application/json\")) {\n          return JSON.stringify(await request.json());\n        } else if (contentType.includes(\"application/text\")) {\n          return request.text();\n        } else if (contentType.includes(\"text/html\")) {\n          return request.text();\n        } else if (contentType.includes(\"form\")) {\n          const formData = await request.formData();\n          const body = {};\n          for (const entry of formData.entries()) {\n            body[entry[0]] = entry[1];\n          }\n          return JSON.stringify(body);\n        } else {\n          // Perhaps some other type of data was submitted in the form\n          // like an image, or some other binary data.\n          return \"a file\";\n        }\n      }\n\n\n      const { url } = request;\n      if (url.includes(\"form\")) {\n        return rawHtmlResponse(someForm);\n      }\n      if (request.method === \"POST\") {\n        const reqBody = await readRequestBody(request);\n        const retBody = `The request body sent in was ${reqBody}`;\n        return new Response(retBody);\n      } else if (request.method === \"GET\") {\n        return new Response(\"The request was a GET\");\n      }\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from js import Object, Response, Headers, JSON\n\n\n  async def read_request_body(request):\n      headers = request.headers\n      content_type = headers[\"content-type\"] or \"\"\n\n\n      if \"application/json\" in content_type:\n          return JSON.stringify(await request.json())\n      if \"form\" in content_type:\n          form = await request.formData()\n          data = Object.fromEntries(form.entries())\n          return JSON.stringify(data)\n      return await request.text()\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          def raw_html_response(html):\n              headers = Headers.new({\"content-type\": \"text/html;charset=UTF-8\"}.items())\n              return Response.new(html, headers=headers)\n\n\n          if \"form\" in request.url:\n              return raw_html_response(\"\")\n\n\n          if \"POST\" in request.method:\n              req_body = await read_request_body(request)\n              ret_body = f\"The request body sent in was {req_body}\"\n              return Response.new(ret_body)\n\n\n          return Response.new(\"The request was not POST\")",
      "language": "py"
    },
    {
      "code": "use serde::{Deserialize, Serialize};\n  use worker::*;\n\n\n  fn raw_html_response(html: &str) -> Result<Response> {\n      Response::from_html(html)\n  }\n\n\n  #[derive(Deserialize, Serialize, Debug)]\n  struct Payload {\n      msg: String,\n  }\n\n\n  async fn read_request_body(mut req: Request) -> String {\n      let ctype = req.headers().get(\"content-type\").unwrap().unwrap();\n      match ctype.as_str() {\n          \"application/json\" => format!(\"{:?}\", req.json::<Payload>().await.unwrap()),\n          \"text/html\" => req.text().await.unwrap(),\n          \"multipart/form-data\" => format!(\"{:?}\", req.form_data().await.unwrap()),\n          _ => String::from(\"a file\"),\n      }\n  }\n\n\n  #[event(fetch)]\n  async fn fetch(req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      if String::from(req.url()?).contains(\"form\") {\n          return raw_html_response(\"some html form\");\n      }\n\n\n      match req.method() {\n          Method::Post => {\n              let req_body = read_request_body(req).await;\n              Response::ok(format!(\"The request body sent in was {}\", req_body))\n          }\n          _ => Response::ok(format!(\"The result was a {:?}\", req.method())),\n      }\n  }",
      "language": "rs"
    },
    {
      "code": "import { Hono } from \"hono\";\n  import { html } from \"hono/html\";\n\n\n  const app = new Hono();\n\n\n  /**\n   * readRequestBody reads in the incoming request body\n   * @param {Request} request the incoming request to read from\n   */\n  async function readRequestBody(request: Request): Promise<string> {\n    const contentType = request.headers.get(\"content-type\") || \"\";\n\n\n    if (contentType.includes(\"application/json\")) {\n      const body = await request.json();\n      return JSON.stringify(body);\n    } else if (contentType.includes(\"application/text\")) {\n      return request.text();\n    } else if (contentType.includes(\"text/html\")) {\n      return request.text();\n    } else if (contentType.includes(\"form\")) {\n      const formData = await request.formData();\n      const body: Record<string, string> = {};\n      for (const [key, value] of formData.entries()) {\n        body[key] = value.toString();\n      }\n      return JSON.stringify(body);\n    } else {\n      // Perhaps some other type of data was submitted in the form\n      // like an image, or some other binary data.\n      return \"a file\";\n    }\n  }\n\n\n  const someForm = html`<!DOCTYPE html>\n    <html>\n      <body>\n        <form action=\"/\" method=\"post\">\n          <div>\n            <label for=\"message\">Message:</label>\n            <input id=\"message\" name=\"message\" type=\"text\" />\n          </div>\n          <div>\n            <button>Submit</button>\n          </div>\n        </form>\n      </body>\n    </html>`;\n\n\n  app.get(\"*\", async (c) => {\n    const url = c.req.url;\n\n\n    if (url.includes(\"form\")) {\n      return c.html(someForm);\n    }\n\n\n    return c.text(\"The request was a GET\");\n  });\n\n\n  app.post(\"*\", async (c) => {\n    const reqBody = await readRequestBody(c.req.raw);\n    const retBody = `The request body sent in was ${reqBody}`;\n    return c.text(retBody);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const destinationURL = \"https://example.com\";\n      const statusCode = 301;\n      return Response.redirect(destinationURL, statusCode);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const destinationURL = \"https://example.com\";\n      const statusCode = 301;\n      return Response.redirect(destinationURL, statusCode);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response\n\n\n  class Default(WorkerEntrypoint):\n      def fetch(self, request):\n          destinationURL = \"https://example.com\"\n          statusCode = 301\n          return Response.redirect(destinationURL, statusCode)",
      "language": "py"
    },
    {
      "code": "use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(_req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let destination_url = Url::parse(\"https://example.com\")?;\n      let status_code = 301;\n      Response::redirect_with_status(destination_url, status_code)\n  }",
      "language": "rs"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  app.all(\"*\", (c) => {\n    const destinationURL = \"https://example.com\";\n    const statusCode = 301;\n    return c.redirect(destinationURL, statusCode);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const base = \"https://example.com\";\n      const statusCode = 301;\n\n\n      const url = new URL(request.url);\n      const { pathname, search } = url;\n\n\n      const destinationURL = `${base}${pathname}${search}`;\n      console.log(destinationURL);\n\n\n      return Response.redirect(destinationURL, statusCode);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const base = \"https://example.com\";\n      const statusCode = 301;\n\n\n      const url = new URL(request.url);\n      const { pathname, search } = url;\n\n\n      const destinationURL = `${base}${pathname}${search}`;\n      console.log(destinationURL);\n\n\n      return Response.redirect(destinationURL, statusCode);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response\n  from urllib.parse import urlparse\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          base = \"https://example.com\"\n          statusCode = 301\n\n\n          url = urlparse(request.url)\n\n\n          destinationURL = f'{base}{url.path}{url.query}'\n          print(destinationURL)\n\n\n          return Response.redirect(destinationURL, statusCode)",
      "language": "py"
    },
    {
      "code": "use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let mut base = Url::parse(\"https://example.com\")?;\n      let status_code = 301;\n\n\n      let url = req.url()?;\n\n\n      base.set_path(url.path());\n      base.set_query(url.query());\n\n\n      console_log!(\"{:?}\", base.to_string());\n\n\n      Response::redirect_with_status(base, status_code)\n  }",
      "language": "rs"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  app.all(\"*\", (c) => {\n    const base = \"https://example.com\";\n    const statusCode = 301;\n\n\n    const { pathname, search } = new URL(c.req.url);\n\n\n    const destinationURL = `${base}${pathname}${search}`;\n    console.log(destinationURL);\n\n\n    return c.redirect(destinationURL, statusCode);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      function MethodNotAllowed(request) {\n        return new Response(`Method ${request.method} not allowed.`, {\n          status: 405,\n          headers: {\n            Allow: \"GET\",\n          },\n        });\n      }\n      // Only GET requests work with this proxy.\n      if (request.method !== \"GET\") return MethodNotAllowed(request);\n      return fetch(`https://example.com`);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      function MethodNotAllowed(request) {\n        return new Response(`Method ${request.method} not allowed.`, {\n          status: 405,\n          headers: {\n            Allow: \"GET\",\n          },\n        });\n      }\n      // Only GET requests work with this proxy.\n      if (request.method !== \"GET\") return MethodNotAllowed(request);\n      return fetch(`https://example.com`);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response, fetch\n\n\n  class Default(WorkerEntrypoint):\n      def fetch(self, request):\n          def method_not_allowed(request):\n              msg = f'Method {request.method} not allowed.'\n              headers = {\"Allow\": \"GET\"}\n              return Response(msg, headers=headers, status=405)\n\n\n          # Only GET requests work with this proxy.\n          if request.method != \"GET\":\n              return method_not_allowed(request)\n\n\n          return fetch(\"https://example.com\")",
      "language": "py"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const html = `<!DOCTYPE html>\n      <body>\n        <h1>Hello World</h1>\n        <p>This markup was generated by a Cloudflare Worker.</p>\n      </body>`;\n\n\n      return new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const html = `<!DOCTYPE html>\n      <body>\n        <h1>Hello World</h1>\n        <p>This markup was generated by a Cloudflare Worker.</p>\n      </body>`;\n\n\n      return new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          html = \"\"\"<!DOCTYPE html>\n          <body>\n            <h1>Hello World</h1>\n            <p>This markup was generated by a Cloudflare Worker.</p>\n          </body>\"\"\"\n\n\n          headers = {\"content-type\": \"text/html;charset=UTF-8\"}\n          return Response(html, headers=headers)",
      "language": "py"
    },
    {
      "code": "use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(_req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let html = r#\"<!DOCTYPE html>\n      <body>\n        <h1>Hello World</h1>\n        <p>This markup was generated by a Cloudflare Worker.</p>\n      </body>\n      \"#;\n      Response::from_html(html)\n  }",
      "language": "rs"
    },
    {
      "code": "import { Hono } from \"hono\";\n  import { html } from \"hono/html\";\n\n\n  const app = new Hono();\n\n\n  app.get(\"*\", (c) => {\n    const doc = html`<!DOCTYPE html>\n      <body>\n        <h1>Hello World</h1>\n        <p>This markup was generated by a Cloudflare Worker with Hono.</p>\n      </body>`;\n\n\n    return c.html(doc);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const data = {\n        hello: \"world\",\n      };\n\n\n      return Response.json(data);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const data = {\n        hello: \"world\",\n      };\n\n\n      return Response.json(data);\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response\n  import json\n\n\n  class Default(WorkerEntrypoint):\n      def fetch(self, request):\n          data = json.dumps({\"hello\": \"world\"})\n          headers = {\"content-type\": \"application/json\"}\n          return Response(data, headers=headers)",
      "language": "py"
    },
    {
      "code": "use serde::{Deserialize, Serialize};\n  use worker::*;\n\n\n  #[derive(Deserialize, Serialize, Debug)]\n  struct Json {\n      hello: String,\n  }\n\n\n  #[event(fetch)]\n  async fn fetch(_req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let data = Json {\n          hello: String::from(\"world\"),\n      };\n      Response::from_json(&data)\n  }",
      "language": "rs"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  const app = new Hono();\n\n\n  app.get(\"*\", (c) => {\n    const data = {\n      hello: \"world\",\n    };\n\n\n    return c.json(data);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const OLD_URL = \"developer.mozilla.org\";\n      const NEW_URL = \"mynewdomain.com\";\n\n\n      class AttributeRewriter {\n        constructor(attributeName) {\n          this.attributeName = attributeName;\n        }\n        element(element) {\n          const attribute = element.getAttribute(this.attributeName);\n          if (attribute) {\n            element.setAttribute(\n              this.attributeName,\n              attribute.replace(OLD_URL, NEW_URL),\n            );\n          }\n        }\n      }\n\n\n      const rewriter = new HTMLRewriter()\n        .on(\"a\", new AttributeRewriter(\"href\"))\n        .on(\"img\", new AttributeRewriter(\"src\"));\n\n\n      const res = await fetch(request);\n      const contentType = res.headers.get(\"Content-Type\");\n\n\n      // If the response is HTML, it can be transformed with\n      // HTMLRewriter -- otherwise, it should pass through\n      if (contentType.startsWith(\"text/html\")) {\n        return rewriter.transform(res);\n      } else {\n        return res;\n      }\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const OLD_URL = \"developer.mozilla.org\";\n      const NEW_URL = \"mynewdomain.com\";\n\n\n      class AttributeRewriter {\n        constructor(attributeName) {\n          this.attributeName = attributeName;\n        }\n        element(element) {\n          const attribute = element.getAttribute(this.attributeName);\n          if (attribute) {\n            element.setAttribute(\n              this.attributeName,\n              attribute.replace(OLD_URL, NEW_URL),\n            );\n          }\n        }\n      }\n\n\n      const rewriter = new HTMLRewriter()\n        .on(\"a\", new AttributeRewriter(\"href\"))\n        .on(\"img\", new AttributeRewriter(\"src\"));\n\n\n      const res = await fetch(request);\n      const contentType = res.headers.get(\"Content-Type\");\n\n\n      // If the response is HTML, it can be transformed with\n      // HTMLRewriter -- otherwise, it should pass through\n      if (contentType.startsWith(\"text/html\")) {\n        return rewriter.transform(res);\n      } else {\n        return res;\n      }\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from pyodide.ffi import create_proxy\n  from js import HTMLRewriter, fetch\n\n\n\n\n  class AttributeRewriter:\n      old_url = \"developer.mozilla.org\"\n      new_url = \"mynewdomain.com\"\n\n\n      def __init__(self, attr_name):\n          self.attr_name = attr_name\n\n\n      def element(self, element):\n          attr = element.getAttribute(self.attr_name)\n          if attr:\n              element.setAttribute(\n                  self.attr_name, attr.replace(self.old_url, self.new_url)\n              )\n\n\n\n\n  href = create_proxy(AttributeRewriter(\"href\"))\n  src = create_proxy(AttributeRewriter(\"src\"))\n  rewriter = HTMLRewriter.new().on(\"a\", href).on(\"img\", src)\n\n\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          res = await fetch(request)\n          content_type = res.headers[\"Content-Type\"]\n\n\n          # If the response is HTML, it can be transformed with\n          # HTMLRewriter -- otherwise, it should pass through\n          if content_type.startswith(\"text/html\"):\n              return rewriter.transform(res)\n          return res",
      "language": "py"
    },
    {
      "code": "import { Hono } from 'hono';\n  import { html } from 'hono/html';\n\n\n  const app = new Hono();\n\n\n  app.get('*', async (c) => {\n    const OLD_URL = \"developer.mozilla.org\";\n    const NEW_URL = \"mynewdomain.com\";\n\n\n    class AttributeRewriter {\n      attributeName: string;\n\n\n      constructor(attributeName: string) {\n        this.attributeName = attributeName;\n      }\n\n\n      element(element: Element) {\n        const attribute = element.getAttribute(this.attributeName);\n        if (attribute) {\n          element.setAttribute(\n            this.attributeName,\n            attribute.replace(OLD_URL, NEW_URL)\n          );\n        }\n      }\n    }\n\n\n    // Make a fetch request using the original request\n    const res = await fetch(c.req.raw);\n    const contentType = res.headers.get(\"Content-Type\") || \"\";\n\n\n    // If the response is HTML, transform it with HTMLRewriter\n    if (contentType.startsWith(\"text/html\")) {\n      const rewriter = new HTMLRewriter()\n        .on(\"a\", new AttributeRewriter(\"href\"))\n        .on(\"img\", new AttributeRewriter(\"src\"));\n\n\n      return new Response(rewriter.transform(res).body, {\n        headers: res.headers\n      });\n    } else {\n      // Pass through the response as is\n      return res;\n    }\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "export default {\n    async fetch(request) {\n      const DEFAULT_SECURITY_HEADERS = {\n        /*\n      Secure your application with Content-Security-Policy headers.\n      Enabling these headers will permit content from a trusted domain and all its subdomains.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy\n      \"Content-Security-Policy\": \"default-src 'self' example.com *.example.com\",\n      */\n        /*\n      You can also set Strict-Transport-Security headers.\n      These are not automatically set because your website might get added to Chrome's HSTS preload list.\n      Here's the code if you want to apply it:\n      \"Strict-Transport-Security\" : \"max-age=63072000; includeSubDomains; preload\",\n      */\n        /*\n      Permissions-Policy header provides the ability to allow or deny the use of browser features, such as opting out of FLoC - which you can use below:\n      \"Permissions-Policy\": \"interest-cohort=()\",\n      */\n        /*\n      X-XSS-Protection header prevents a page from loading if an XSS attack is detected.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-XSS-Protection\n      */\n        \"X-XSS-Protection\": \"0\",\n        /*\n      X-Frame-Options header prevents click-jacking attacks.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options\n      */\n        \"X-Frame-Options\": \"DENY\",\n        /*\n      X-Content-Type-Options header prevents MIME-sniffing.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options\n      */\n        \"X-Content-Type-Options\": \"nosniff\",\n        \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n        \"Cross-Origin-Embedder-Policy\": 'require-corp; report-to=\"default\";',\n        \"Cross-Origin-Opener-Policy\": 'same-site; report-to=\"default\";',\n        \"Cross-Origin-Resource-Policy\": \"same-site\",\n      };\n      const BLOCKED_HEADERS = [\n        \"Public-Key-Pins\",\n        \"X-Powered-By\",\n        \"X-AspNet-Version\",\n      ];\n\n\n      let response = await fetch(request);\n      let newHeaders = new Headers(response.headers);\n\n\n      const tlsVersion = request.cf.tlsVersion;\n      console.log(tlsVersion);\n      // This sets the headers for HTML responses:\n      if (\n        newHeaders.has(\"Content-Type\") &&\n        !newHeaders.get(\"Content-Type\").includes(\"text/html\")\n      ) {\n        return new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: newHeaders,\n        });\n      }\n\n\n      Object.keys(DEFAULT_SECURITY_HEADERS).map((name) => {\n        newHeaders.set(name, DEFAULT_SECURITY_HEADERS[name]);\n      });\n\n\n      BLOCKED_HEADERS.forEach((name) => {\n        newHeaders.delete(name);\n      });\n\n\n      if (tlsVersion !== \"TLSv1.2\" && tlsVersion !== \"TLSv1.3\") {\n        return new Response(\"You need to use TLS version 1.2 or higher.\", {\n          status: 400,\n        });\n      } else {\n        return new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: newHeaders,\n        });\n      }\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request): Promise<Response> {\n      const DEFAULT_SECURITY_HEADERS = {\n        /*\n      Secure your application with Content-Security-Policy headers.\n      Enabling these headers will permit content from a trusted domain and all its subdomains.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy\n      \"Content-Security-Policy\": \"default-src 'self' example.com *.example.com\",\n      */\n        /*\n      You can also set Strict-Transport-Security headers.\n      These are not automatically set because your website might get added to Chrome's HSTS preload list.\n      Here's the code if you want to apply it:\n      \"Strict-Transport-Security\" : \"max-age=63072000; includeSubDomains; preload\",\n      */\n        /*\n      Permissions-Policy header provides the ability to allow or deny the use of browser features, such as opting out of FLoC - which you can use below:\n      \"Permissions-Policy\": \"interest-cohort=()\",\n      */\n        /*\n      X-XSS-Protection header prevents a page from loading if an XSS attack is detected.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-XSS-Protection\n      */\n        \"X-XSS-Protection\": \"0\",\n        /*\n      X-Frame-Options header prevents click-jacking attacks.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options\n      */\n        \"X-Frame-Options\": \"DENY\",\n        /*\n      X-Content-Type-Options header prevents MIME-sniffing.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options\n      */\n        \"X-Content-Type-Options\": \"nosniff\",\n        \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n        \"Cross-Origin-Embedder-Policy\": 'require-corp; report-to=\"default\";',\n        \"Cross-Origin-Opener-Policy\": 'same-site; report-to=\"default\";',\n        \"Cross-Origin-Resource-Policy\": \"same-site\",\n      };\n      const BLOCKED_HEADERS = [\n        \"Public-Key-Pins\",\n        \"X-Powered-By\",\n        \"X-AspNet-Version\",\n      ];\n\n\n      let response = await fetch(request);\n      let newHeaders = new Headers(response.headers);\n\n\n      const tlsVersion = request.cf.tlsVersion;\n      console.log(tlsVersion);\n      // This sets the headers for HTML responses:\n      if (\n        newHeaders.has(\"Content-Type\") &&\n        !newHeaders.get(\"Content-Type\").includes(\"text/html\")\n      ) {\n        return new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: newHeaders,\n        });\n      }\n\n\n      Object.keys(DEFAULT_SECURITY_HEADERS).map((name) => {\n        newHeaders.set(name, DEFAULT_SECURITY_HEADERS[name]);\n      });\n\n\n      BLOCKED_HEADERS.forEach((name) => {\n        newHeaders.delete(name);\n      });\n\n\n      if (tlsVersion !== \"TLSv1.2\" && tlsVersion !== \"TLSv1.3\") {\n        return new Response(\"You need to use TLS version 1.2 or higher.\", {\n          status: 400,\n        });\n      } else {\n        return new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: newHeaders,\n        });\n      }\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint, Response, fetch\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          default_security_headers = {\n              # Secure your application with Content-Security-Policy headers.\n              #Enabling these headers will permit content from a trusted domain and all its subdomains.\n              #@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy\n              \"Content-Security-Policy\": \"default-src 'self' example.com *.example.com\",\n              #You can also set Strict-Transport-Security headers.\n              #These are not automatically set because your website might get added to Chrome's HSTS preload list.\n              #Here's the code if you want to apply it:\n              \"Strict-Transport-Security\" : \"max-age=63072000; includeSubDomains; preload\",\n              #Permissions-Policy header provides the ability to allow or deny the use of browser features, such as opting out of FLoC - which you can use below:\n              \"Permissions-Policy\": \"interest-cohort=()\",\n              #X-XSS-Protection header prevents a page from loading if an XSS attack is detected.\n              #@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-XSS-Protection\n              \"X-XSS-Protection\": \"0\",\n              #X-Frame-Options header prevents click-jacking attacks.\n              #@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options\n              \"X-Frame-Options\": \"DENY\",\n              #X-Content-Type-Options header prevents MIME-sniffing.\n              #@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options\n              \"X-Content-Type-Options\": \"nosniff\",\n              \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n              \"Cross-Origin-Embedder-Policy\": 'require-corp; report-to=\"default\";',\n              \"Cross-Origin-Opener-Policy\": 'same-site; report-to=\"default\";',\n              \"Cross-Origin-Resource-Policy\": \"same-site\",\n          }\n          blocked_headers = [\"Public-Key-Pins\", \"X-Powered-By\" ,\"X-AspNet-Version\"]\n\n\n          res = await fetch(request)\n          new_headers = res.headers\n\n\n          # This sets the headers for HTML responses\n          if \"text/html\" in new_headers[\"Content-Type\"]:\n              return Response(res.body, status=res.status, statusText=res.statusText, headers=new_headers)\n\n\n          for name in default_security_headers:\n              new_headers[name] = default_security_headers[name]\n\n\n          for name in blocked_headers:\n              del new_headers[\"name\"]\n\n\n          tls = request.cf.tlsVersion\n\n\n          if not tls in (\"TLSv1.2\", \"TLSv1.3\"):\n              return Response(\"You need to use TLS version 1.2 or higher.\", status=400)\n          return Response(res.body, status=res.status, statusText=res.statusText, headers=new_headers)",
      "language": "py"
    },
    {
      "code": "use std::collections::HashMap;\n  use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let default_security_headers = HashMap::from([\n          //Secure your application with Content-Security-Policy headers.\n          //Enabling these headers will permit content from a trusted domain and all its subdomains.\n          //@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy\n          (\n              \"Content-Security-Policy\",\n              \"default-src 'self' example.com *.example.com\",\n          ),\n          //You can also set Strict-Transport-Security headers.\n          //These are not automatically set because your website might get added to Chrome's HSTS preload list.\n          //Here's the code if you want to apply it:\n          (\n              \"Strict-Transport-Security\",\n              \"max-age=63072000; includeSubDomains; preload\",\n          ),\n          //Permissions-Policy header provides the ability to allow or deny the use of browser features, such as opting out of FLoC - which you can use below:\n          (\"Permissions-Policy\", \"interest-cohort=()\"),\n          //X-XSS-Protection header prevents a page from loading if an XSS attack is detected.\n          //@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-XSS-Protection\n          (\"X-XSS-Protection\", \"0\"),\n          //X-Frame-Options header prevents click-jacking attacks.\n          //@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options\n          (\"X-Frame-Options\", \"DENY\"),\n          //X-Content-Type-Options header prevents MIME-sniffing.\n          //@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options\n          (\"X-Content-Type-Options\", \"nosniff\"),\n          (\"Referrer-Policy\", \"strict-origin-when-cross-origin\"),\n          (\n              \"Cross-Origin-Embedder-Policy\",\n              \"require-corp; report-to='default';\",\n          ),\n          (\n              \"Cross-Origin-Opener-Policy\",\n              \"same-site; report-to='default';\",\n          ),\n          (\"Cross-Origin-Resource-Policy\", \"same-site\"),\n      ]);\n      let blocked_headers = [\"Public-Key-Pins\", \"X-Powered-By\", \"X-AspNet-Version\"];\n      let tls = req.cf().unwrap().tls_version();\n      let res = Fetch::Request(req).send().await?;\n      let mut new_headers = res.headers().clone();\n\n\n      // This sets the headers for HTML responses\n      if Some(String::from(\"text/html\")) == new_headers.get(\"Content-Type\")? {\n          return Ok(Response::from_body(res.body().clone())?\n              .with_headers(new_headers)\n              .with_status(res.status_code()));\n      }\n      for (k, v) in default_security_headers {\n          new_headers.set(k, v)?;\n      }\n\n\n      for k in blocked_headers {\n          new_headers.delete(k)?;\n      }\n\n\n      if !vec![\"TLSv1.2\", \"TLSv1.3\"].contains(&tls.as_str()) {\n          return Response::error(\"You need to use TLS version 1.2 or higher.\", 400);\n      }\n      Ok(Response::from_body(res.body().clone())?\n          .with_headers(new_headers)\n          .with_status(res.status_code()))\n\n\n  }",
      "language": "rs"
    },
    {
      "code": "import { Hono } from 'hono';\n  import { secureHeaders } from 'hono/secure-headers';\n\n\n  const app = new Hono();\n  app.use(secureHeaders());\n\n\n  // Handle all other requests by passing through to origin\n  app.all('*', async (c) => {\n    return fetch(c.req.raw);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "import { Buffer } from \"node:buffer\";\n\n\n  const encoder = new TextEncoder();\n\n\n  // How long an HMAC token should be valid for, in seconds\n  const EXPIRY = 60;\n\n\n  export default {\n    /**\n     *\n     * @param {Request} request\n     * @param {{SECRET_DATA: string}} env\n     * @returns\n     */\n    async fetch(request, env) {\n      // You will need some secret data to use as a symmetric key. This should be\n      // attached to your Worker as an encrypted secret.\n      // Refer to https://developers.cloudflare.com/workers/configuration/secrets/\n      const secretKeyData = encoder.encode(\n        env.SECRET_DATA ?? \"my secret symmetric key\",\n      );\n\n\n      // Import your secret as a CryptoKey for both 'sign' and 'verify' operations\n      const key = await crypto.subtle.importKey(\n        \"raw\",\n        secretKeyData,\n        { name: \"HMAC\", hash: \"SHA-256\" },\n        false,\n        [\"sign\", \"verify\"],\n      );\n\n\n      const url = new URL(request.url);\n\n\n      // This is a demonstration Worker that allows unauthenticated access to /generate\n      // In a real application you would want to make sure that\n      // users could only generate signed URLs when authenticated\n      if (url.pathname.startsWith(\"/generate/\")) {\n        url.pathname = url.pathname.replace(\"/generate/\", \"/\");\n\n\n        const timestamp = Math.floor(Date.now() / 1000);\n\n\n        // This contains all the data about the request that you want to be able to verify\n        // Here we only sign the timestamp and the pathname, but often you will want to\n        // include more data (for instance, the URL hostname or query parameters)\n        const dataToAuthenticate = `${url.pathname}${timestamp}`;\n\n\n        const mac = await crypto.subtle.sign(\n          \"HMAC\",\n          key,\n          encoder.encode(dataToAuthenticate),\n        );\n\n\n        // Refer to https://developers.cloudflare.com/workers/runtime-apis/nodejs/\n        // for more details on using Node.js APIs in Workers\n        const base64Mac = Buffer.from(mac).toString(\"base64\");\n\n\n        url.searchParams.set(\"verify\", `${timestamp}-${base64Mac}`);\n\n\n        return new Response(`${url.pathname}${url.search}`);\n        // Verify all non /generate requests\n      } else {\n        // Make sure you have the minimum necessary query parameters.\n        if (!url.searchParams.has(\"verify\")) {\n          return new Response(\"Missing query parameter\", { status: 403 });\n        }\n\n\n        const [timestamp, hmac] = url.searchParams.get(\"verify\").split(\"-\");\n\n\n        const assertedTimestamp = Number(timestamp);\n\n\n        const dataToAuthenticate = `${url.pathname}${assertedTimestamp}`;\n\n\n        const receivedMac = Buffer.from(hmac, \"base64\");\n\n\n        // Use crypto.subtle.verify() to guard against timing attacks. Since HMACs use\n        // symmetric keys, you could implement this by calling crypto.subtle.sign() and\n        // then doing a string comparison -- this is insecure, as string comparisons\n        // bail out on the first mismatch, which leaks information to potential\n        // attackers.\n        const verified = await crypto.subtle.verify(\n          \"HMAC\",\n          key,\n          receivedMac,\n          encoder.encode(dataToAuthenticate),\n        );\n\n\n        if (!verified) {\n          return new Response(\"Invalid MAC\", { status: 403 });\n        }\n\n\n        // Signed requests expire after one minute. Note that this value should depend on your specific use case\n        if (Date.now() / 1000 > assertedTimestamp + EXPIRY) {\n          return new Response(\n            `URL expired at ${new Date((assertedTimestamp + EXPIRY) * 1000)}`,\n            { status: 403 },\n          );\n        }\n      }\n\n\n      return fetch(new URL(url.pathname, \"https://example.com\"), request);\n    },\n  };",
      "language": "js"
    },
    {
      "code": "import { Buffer } from \"node:buffer\";\n\n\n  const encoder = new TextEncoder();\n\n\n  // How long an HMAC token should be valid for, in seconds\n  const EXPIRY = 60;\n\n\n  interface Env {\n    SECRET_DATA: string;\n  }\n  export default {\n    async fetch(request, env): Promise<Response> {\n      // You will need some secret data to use as a symmetric key. This should be\n      // attached to your Worker as an encrypted secret.\n      // Refer to https://developers.cloudflare.com/workers/configuration/secrets/\n      const secretKeyData = encoder.encode(\n        env.SECRET_DATA ?? \"my secret symmetric key\",\n      );\n\n\n      // Import your secret as a CryptoKey for both 'sign' and 'verify' operations\n      const key = await crypto.subtle.importKey(\n        \"raw\",\n        secretKeyData,\n        { name: \"HMAC\", hash: \"SHA-256\" },\n        false,\n        [\"sign\", \"verify\"],\n      );\n\n\n      const url = new URL(request.url);\n\n\n      // This is a demonstration Worker that allows unauthenticated access to /generate\n      // In a real application you would want to make sure that\n      // users could only generate signed URLs when authenticated\n      if (url.pathname.startsWith(\"/generate/\")) {\n        url.pathname = url.pathname.replace(\"/generate/\", \"/\");\n\n\n        const timestamp = Math.floor(Date.now() / 1000);\n\n\n        // This contains all the data about the request that you want to be able to verify\n        // Here we only sign the timestamp and the pathname, but often you will want to\n        // include more data (for instance, the URL hostname or query parameters)\n        const dataToAuthenticate = `${url.pathname}${timestamp}`;\n\n\n        const mac = await crypto.subtle.sign(\n          \"HMAC\",\n          key,\n          encoder.encode(dataToAuthenticate),\n        );\n\n\n        // Refer to https://developers.cloudflare.com/workers/runtime-apis/nodejs/\n        // for more details on using NodeJS APIs in Workers\n        const base64Mac = Buffer.from(mac).toString(\"base64\");\n\n\n        url.searchParams.set(\"verify\", `${timestamp}-${base64Mac}`);\n\n\n        return new Response(`${url.pathname}${url.search}`);\n        // Verify all non /generate requests\n      } else {\n        // Make sure you have the minimum necessary query parameters.\n        if (!url.searchParams.has(\"verify\")) {\n          return new Response(\"Missing query parameter\", { status: 403 });\n        }\n\n\n        const [timestamp, hmac] = url.searchParams.get(\"verify\").split(\"-\");\n\n\n        const assertedTimestamp = Number(timestamp);\n\n\n        const dataToAuthenticate = `${url.pathname}${assertedTimestamp}`;\n\n\n        const receivedMac = Buffer.from(hmac, \"base64\");\n\n\n        // Use crypto.subtle.verify() to guard against timing attacks. Since HMACs use\n        // symmetric keys, you could implement this by calling crypto.subtle.sign() and\n        // then doing a string comparison -- this is insecure, as string comparisons\n        // bail out on the first mismatch, which leaks information to potential\n        // attackers.\n        const verified = await crypto.subtle.verify(\n          \"HMAC\",\n          key,\n          receivedMac,\n          encoder.encode(dataToAuthenticate),\n        );\n\n\n        if (!verified) {\n          return new Response(\"Invalid MAC\", { status: 403 });\n        }\n\n\n        // Signed requests expire after one minute. Note that this value should depend on your specific use case\n        if (Date.now() / 1000 > assertedTimestamp + EXPIRY) {\n          return new Response(\n            `URL expired at ${new Date((assertedTimestamp + EXPIRY) * 1000)}`,\n            { status: 403 },\n          );\n        }\n      }\n\n\n      return fetch(new URL(url.pathname, \"https://example.com\"), request);\n    },\n  } satisfies ExportedHandler<Env>;",
      "language": "ts"
    },
    {
      "code": "import { Buffer } from \"node:buffer\";\n  import { Hono } from \"hono\";\n  import { proxy } from \"hono/proxy\";\n\n\n  const encoder = new TextEncoder();\n\n\n  // How long an HMAC token should be valid for, in seconds\n  const EXPIRY = 60;\n\n\n  interface Env {\n    SECRET_DATA: string;\n  }\n\n\n  const app = new Hono();\n\n\n  // Handle URL generation requests\n  app.get(\"/generate/*\", async (c) => {\n    const env = c.env;\n\n\n    // You will need some secret data to use as a symmetric key\n    const secretKeyData = encoder.encode(\n      env.SECRET_DATA ?? \"my secret symmetric key\",\n    );\n\n\n    // Import the secret as a CryptoKey for both 'sign' and 'verify' operations\n    const key = await crypto.subtle.importKey(\n      \"raw\",\n      secretKeyData,\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"sign\", \"verify\"],\n    );\n\n\n    // Replace \"/generate/\" prefix with \"/\"\n    let pathname = c.req.path.replace(\"/generate/\", \"/\");\n\n\n    const timestamp = Math.floor(Date.now() / 1000);\n\n\n    // Data to authenticate: pathname + timestamp\n    const dataToAuthenticate = `${pathname}${timestamp}`;\n\n\n    // Sign the data\n    const mac = await crypto.subtle.sign(\n      \"HMAC\",\n      key,\n      encoder.encode(dataToAuthenticate),\n    );\n\n\n    // Convert the signature to base64\n    const base64Mac = Buffer.from(mac).toString(\"base64\");\n\n\n    // Add verification parameter to URL\n    url.searchParams.set(\"verify\", `${timestamp}-${base64Mac}`);\n\n\n    return c.text(`${pathname}${url.search}`);\n  });\n\n\n  // Handle verification for all other requests\n  app.all(\"*\", async (c) => {\n    const env = c.env;\n    const url = c.req.url;\n\n\n    // You will need some secret data to use as a symmetric key\n    const secretKeyData = encoder.encode(\n      env.SECRET_DATA ?? \"my secret symmetric key\",\n    );\n\n\n    // Import the secret as a CryptoKey for both 'sign' and 'verify' operations\n    const key = await crypto.subtle.importKey(\n      \"raw\",\n      secretKeyData,\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"sign\", \"verify\"],\n    );\n\n\n    // Make sure the request has the verification parameter\n    if (!c.req.query(\"verify\")) {\n      return c.text(\"Missing query parameter\", 403);\n    }\n\n\n    // Extract timestamp and signature\n    const [timestamp, hmac] = c.req.query(\"verify\")!.split(\"-\");\n    const assertedTimestamp = Number(timestamp);\n\n\n    // Recreate the data that should have been signed\n    const dataToAuthenticate = `${c.req.path}${assertedTimestamp}`;\n\n\n    // Convert base64 signature back to ArrayBuffer\n    const receivedMac = Buffer.from(hmac, \"base64\");\n\n\n    // Verify the signature\n    const verified = await crypto.subtle.verify(\n      \"HMAC\",\n      key,\n      receivedMac,\n      encoder.encode(dataToAuthenticate),\n    );\n\n\n    // If verification fails, return 403\n    if (!verified) {\n      return c.text(\"Invalid MAC\", 403);\n    }\n\n\n    // Check if the signature has expired\n    if (Date.now() / 1000 > assertedTimestamp + EXPIRY) {\n      return c.text(\n        `URL expired at ${new Date((assertedTimestamp + EXPIRY) * 1000)}`,\n        403,\n      );\n    }\n\n\n    // If verification passes, proxy the request to example.com\n    return proxy(`https://example.com/${c.req.path}`, ...c.req);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Response, URL, TextEncoder, Buffer, fetch, Object, crypto\n\n\n  def to_js(x):\n      return _to_js(x, dict_converter=Object.fromEntries)\n\n\n  encoder = TextEncoder.new()\n\n\n  # How long an HMAC token should be valid for, in seconds\n  EXPIRY = 60\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # Get the secret key\n          secret_key_data = encoder.encode(getattr(self.env, \"SECRET_DATA\", None) or \"my secret symmetric key\")\n\n\n          # Import the secret as a CryptoKey for both 'sign' and 'verify' operations\n          key = await crypto.subtle.importKey(\n              \"raw\",\n              secret_key_data,\n              to_js({\"name\": \"HMAC\", \"hash\": \"SHA-256\"}),\n              False,\n              [\"sign\", \"verify\"]\n          )\n\n\n          url = URL.new(request.url)\n\n\n          if url.pathname.startswith(\"/generate/\"):\n              url.pathname = url.pathname.replace(\"/generate/\", \"/\", 1)\n\n\n              timestamp = int(Date.now() / 1000)\n\n\n              # Data to authenticate\n              data_to_authenticate = f\"{url.pathname}{timestamp}\"\n\n\n              # Sign the data\n              mac = await crypto.subtle.sign(\n                  \"HMAC\",\n                  key,\n                  encoder.encode(data_to_authenticate)\n              )\n\n\n              # Convert to base64\n              base64_mac = Buffer.from(mac).toString(\"base64\")\n\n\n              # Set the verification parameter\n              url.searchParams.set(\"verify\", f\"{timestamp}-{base64_mac}\")\n\n\n              return Response.new(f\"{url.pathname}{url.search}\")\n          else:\n              # Verify the request\n              if not \"verify\" in url.searchParams:\n                  return Response.new(\"Missing query parameter\", status=403)\n\n\n              verify_param = url.searchParams.get(\"verify\")\n              timestamp, hmac = verify_param.split(\"-\")\n\n\n              asserted_timestamp = int(timestamp)\n\n\n              data_to_authenticate = f\"{url.pathname}{asserted_timestamp}\"\n\n\n              received_mac = Buffer.from(hmac, \"base64\")\n\n\n              # Verify the signature\n              verified = await crypto.subtle.verify(\n                  \"HMAC\",\n                  key,\n                  received_mac,\n                  encoder.encode(data_to_authenticate)\n              )\n\n\n              if not verified:\n                  return Response.new(\"Invalid MAC\", status=403)\n\n\n              # Check expiration\n              if Date.now() / 1000 > asserted_timestamp + EXPIRY:\n                  expiry_date = Date.new((asserted_timestamp + EXPIRY) * 1000)\n                  return Response.new(f\"URL expired at {expiry_date}\", status=403)\n\n\n          # Proxy to example.com if verification passes\n          return fetch(URL.new(f\"https://example.com{url.pathname}\"), request)",
      "language": "py"
    },
    {
      "code": "npm install @streamparser/json-whatwg",
      "language": "sh"
    },
    {
      "code": "import { JSONParser } from \"@streamparser/json-whatwg\";\n\n\n  export default {\n    async fetch(request): Promise<Response> {\n      const parser = new JSONParser({ paths: [\"$.users.*\"] });\n\n\n      const users: string[] = [];\n\n\n      // Pipe the request body through the JSON parser\n      const reader = request.body\n        .pipeThrough(parser)\n        .getReader();\n\n\n      // Process matching JSON values as they stream in\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        // Extract only the name field from each user object\n        if (value.value?.name) {\n          users.push(value.value.name);\n        }\n      }\n\n\n      return Response.json({ userNames: users });\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { JSONParser } from \"@streamparser/json-whatwg\";\n\n\n  export default {\n    async fetch(request) {\n      const parser = new JSONParser({ paths: [\"$.users.*\"] });\n\n\n      const users = [];\n\n\n      // Pipe the request body through the JSON parser\n      const reader = request.body\n        .pipeThrough(parser)\n        .getReader();\n\n\n      // Process matching JSON values as they stream in\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        // Extract only the name field from each user object\n        if (value.value?.name) {\n          users.push(value.value.name);\n        }\n      }\n\n\n      return Response.json({ userNames: users });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "import { JSONParser } from \"@streamparser/json-whatwg\";\n\n\n  export default {\n    async fetch(request): Promise<Response> {\n      const response = await fetch(\"https://api.example.com/large-dataset.json\");\n\n\n      const parser = new JSONParser({ paths: [\"$.items.*\"] });\n\n\n      const { readable, writable } = new TransformStream();\n      const writer = writable.getWriter();\n      const encoder = new TextEncoder();\n\n\n      // Process the upstream response in the background\n      (async () => {\n        const reader = response.body\n          .pipeThrough(parser)\n          .getReader();\n\n\n        await writer.write(encoder.encode('{\"processedItems\":['));\n        let first = true;\n\n\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n\n\n          // Transform each item as it streams through\n          const item = value.value;\n          const transformed = {\n            id: item.id,\n            title: item.title.toUpperCase(),\n            processed: true,\n          };\n\n\n          if (!first) await writer.write(encoder.encode(\",\"));\n          first = false;\n          await writer.write(encoder.encode(JSON.stringify(transformed)));\n        }\n\n\n        await writer.write(encoder.encode(\"]}\"));\n        await writer.close();\n      })();\n\n\n      return new Response(readable, {\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    },\n  } satisfies ExportedHandler;",
      "language": "ts"
    },
    {
      "code": "import { JSONParser } from \"@streamparser/json-whatwg\";\n\n\n  export default {\n    async fetch(request) {\n      const response = await fetch(\"https://api.example.com/large-dataset.json\");\n\n\n      const parser = new JSONParser({ paths: [\"$.items.*\"] });\n\n\n      const { readable, writable } = new TransformStream();\n      const writer = writable.getWriter();\n      const encoder = new TextEncoder();\n\n\n      // Process the upstream response in the background\n      (async () => {\n        const reader = response.body\n          .pipeThrough(parser)\n          .getReader();\n\n\n        await writer.write(encoder.encode('{\"processedItems\":['));\n        let first = true;\n\n\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n\n\n          // Transform each item as it streams through\n          const item = value.value;\n          const transformed = {\n            id: item.id,\n            title: item.title.toUpperCase(),\n            processed: true,\n          };\n\n\n          if (!first) await writer.write(encoder.encode(\",\"));\n          first = false;\n          await writer.write(encoder.encode(JSON.stringify(transformed)));\n        }\n\n\n        await writer.write(encoder.encode(\"]}\"));\n        await writer.close();\n      })();\n\n\n      return new Response(readable, {\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request, env) {\n      const SITE_KEY = env.SITE_KEY; // The Turnstile Sitekey of your widget (pass as env or secret)\n      const TURNSTILE_ATTR_NAME = \"your_id_to_replace\"; // The id of the element to put a Turnstile widget in\n      let res = await fetch(request);\n\n\n      // Instantiate the API to run on specific elements, for example, `head`, `div`\n      let newRes = new HTMLRewriter()\n\n\n        // `.on` attaches the element handler and this allows you to match on element/attributes or to use the specific methods per the API\n        .on(\"head\", {\n          element(element) {\n            // In this case, you are using `append` to add a new script to the `head` element\n            element.append(\n              `<script src=\"https://challenges.cloudflare.com/turnstile/v0/api.js\" async defer></script>`,\n              { html: true },\n            );\n          },\n        })\n        .on(\"div\", {\n          element(element) {\n            // Add a turnstile widget element into if an element with the id of TURNSTILE_ATTR_NAME is found\n            if (element.getAttribute(\"id\") === TURNSTILE_ATTR_NAME) {\n              element.append(\n                `<div class=\"cf-turnstile\" data-sitekey=\"${SITE_KEY}\"></div>`,\n                { html: true },\n              );\n            }\n          },\n        })\n        .transform(res);\n      return newRes;\n    },\n  };",
      "language": "js"
    },
    {
      "code": "export default {\n    async fetch(request, env): Promise<Response> {\n      const SITE_KEY = env.SITE_KEY; // The Turnstile Sitekey of your widget (pass as env or secret)\n      const TURNSTILE_ATTR_NAME = \"your_id_to_replace\"; // The id of the element to put a Turnstile widget in\n\n\n      let res = await fetch(request);\n\n\n      // Instantiate the API to run on specific elements, for example, `head`, `div`\n      let newRes = new HTMLRewriter()\n\n\n        // `.on` attaches the element handler and this allows you to match on element/attributes or to use the specific methods per the API\n        .on(\"head\", {\n          element(element) {\n            // In this case, you are using `append` to add a new script to the `head` element\n            element.append(\n              `<script src=\"https://challenges.cloudflare.com/turnstile/v0/api.js\" async defer></script>`,\n              { html: true },\n            );\n          },\n        })\n        .on(\"div\", {\n          element(element) {\n            // Add a turnstile widget element into if an element with the id of TURNSTILE_ATTR_NAME is found\n            if (element.getAttribute(\"id\") === TURNSTILE_ATTR_NAME) {\n              element.append(\n                `<div class=\"cf-turnstile\" data-sitekey=\"${SITE_KEY}\" data-theme=\"light\"></div>`,\n                { html: true },\n              );\n            }\n          },\n        })\n        .transform(res);\n      return newRes;\n    },\n  } satisfies ExportedHandler<Env>;",
      "language": "ts"
    },
    {
      "code": "import { Hono } from \"hono\";\n\n\n  interface Env {\n    SITE_KEY: string;\n    SECRET_KEY: string;\n    TURNSTILE_ATTR_NAME?: string;\n  }\n\n\n  const app = new Hono<{ Bindings: Env }>();\n\n\n  // Middleware to inject Turnstile widget\n  app.use(\"*\", async (c, next) => {\n    const SITE_KEY = c.env.SITE_KEY; // The Turnstile Sitekey from environment\n    const TURNSTILE_ATTR_NAME = c.env.TURNSTILE_ATTR_NAME || \"your_id_to_replace\"; // The target element ID\n\n\n    // Process the request through the original endpoint\n    await next();\n\n\n    // Only process HTML responses\n    const contentType = c.res.headers.get(\"content-type\");\n    if (!contentType || !contentType.includes(\"text/html\")) {\n      return;\n    }\n\n\n    // Clone the response to make it modifiable\n    const originalResponse = c.res;\n    const responseBody = await originalResponse.text();\n\n\n    // Create an HTMLRewriter instance to modify the HTML\n    const rewriter = new HTMLRewriter()\n      // Add the Turnstile script to the head\n      .on(\"head\", {\n        element(element) {\n          element.append(\n            `<script src=\"https://challenges.cloudflare.com/turnstile/v0/api.js\" async defer></script>`,\n            { html: true },\n          );\n        },\n      })\n      // Add the Turnstile widget to the target div\n      .on(\"div\", {\n        element(element) {\n          if (element.getAttribute(\"id\") === TURNSTILE_ATTR_NAME) {\n            element.append(\n              `<div class=\"cf-turnstile\" data-sitekey=\"${SITE_KEY}\" data-theme=\"light\"></div>`,\n              { html: true },\n            );\n          }\n        },\n      });\n\n\n    // Create a new response with the same properties as the original\n    const modifiedResponse = new Response(responseBody, {\n      status: originalResponse.status,\n      statusText: originalResponse.statusText,\n      headers: originalResponse.headers,\n    });\n\n\n    // Transform the response using HTMLRewriter\n    c.res = rewriter.transform(modifiedResponse);\n  });\n\n\n  // Handle POST requests for form submission with Turnstile validation\n  app.post(\"*\", async (c) => {\n    const formData = await c.req.formData();\n    const token = formData.get(\"cf-turnstile-response\");\n    const ip = c.req.header(\"CF-Connecting-IP\");\n\n\n    // If no token, return an error\n    if (!token) {\n      return c.text(\"Missing Turnstile token\", 400);\n    }\n\n\n    // Prepare verification data\n    const verifyFormData = new FormData();\n    verifyFormData.append(\"secret\", c.env.SECRET_KEY || \"\");\n    verifyFormData.append(\"response\", token.toString());\n    if (ip) verifyFormData.append(\"remoteip\", ip);\n\n\n    // Verify the token with Turnstile API\n    const verifyResult = await fetch(\n      \"https://challenges.cloudflare.com/turnstile/v0/siteverify\",\n      {\n        method: \"POST\",\n        body: verifyFormData,\n      },\n    );\n\n\n    const outcome = await verifyResult.json<{ success: boolean }>;\n\n\n    // If verification fails, return an error\n    if (!outcome.success) {\n      return c.text(\"The provided Turnstile token was not valid!\", 401);\n    }\n\n\n    // If verification succeeds, proceed with the original request\n    // You would typically handle the form submission logic here\n\n\n    // For this example, we'll just send a success response\n    return c.text(\"Form submission successful!\");\n  });\n\n\n  // Default handler for GET requests\n  app.get(\"*\", async (c) => {\n    // Fetch the original content (you'd replace this with your actual content source)\n    return await fetch(c.req.raw);\n  });\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "from workers import WorkerEntrypoint\n  from pyodide.ffi import create_proxy\n  from js import HTMLRewriter, fetch\n\n\n  class Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          site_key = self.env.SITE_KEY\n          attr_name = self.env.TURNSTILE_ATTR_NAME\n          res = await fetch(request)\n\n\n          class Append:\n              def element(self, element):\n                  s = '<script src=\"https://challenges.cloudflare.com/turnstile/v0/api.js\" async defer></script>'\n                  element.append(s, {\"html\": True})\n\n\n          class AppendOnID:\n              def __init__(self, name):\n                  self.name = name\n              def element(self, element):\n                  # You are using the `getAttribute` method here to retrieve the `id` or `class` of an element\n                  if element.getAttribute(\"id\") == self.name:\n                      div = f'<div class=\"cf-turnstile\" data-sitekey=\"{site_key}\" data-theme=\"light\"></div>'\n                      element.append(div, { \"html\": True })\n\n\n          # Instantiate the API to run on specific elements, for example, `head`, `div`\n          head = create_proxy(Append())\n          div = create_proxy(AppendOnID(attr_name))\n          new_res = HTMLRewriter.new().on(\"head\", head).on(\"div\", div).transform(res)\n\n\n          return new_res",
      "language": "py"
    },
    {
      "code": "// In client-side JavaScript, connect to your Workers function using WebSockets:\nconst websocket = new WebSocket(\n  \"wss://example-websocket.signalnerve.workers.dev\",\n);",
      "language": "js"
    },
    {
      "code": "async function handleRequest(request) {\n    const upgradeHeader = request.headers.get('Upgrade');\n    if (!upgradeHeader || upgradeHeader !== 'websocket') {\n      return new Response('Expected Upgrade: websocket', { status: 426 });\n    }\n  }",
      "language": "js"
    },
    {
      "code": "use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(req: HttpRequest, _env: Env, _ctx: Context) -> Result<worker::Response> {\n      let upgrade_header = match req.headers().get(\"Upgrade\") {\n          Some(h) => h.to_str().unwrap(),\n          None => \"\",\n      };\n      if upgrade_header != \"websocket\" {\n          return worker::Response::error(\"Expected Upgrade: websocket\", 426);\n      }\n  }",
      "language": "rs"
    },
    {
      "code": "async function handleRequest(request) {\n    const upgradeHeader = request.headers.get('Upgrade');\n    if (!upgradeHeader || upgradeHeader !== 'websocket') {\n      return new Response('Expected Upgrade: websocket', { status: 426 });\n    }\n\n\n    const webSocketPair = new WebSocketPair();\n    const client = webSocketPair[0],\n      server = webSocketPair[1];\n\n\n    return new Response(null, {\n      status: 101,\n      webSocket: client,\n    });\n  }",
      "language": "js"
    },
    {
      "code": "use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(req: HttpRequest, _env: Env, _ctx: Context) -> Result<worker::Response> {\n      let upgrade_header = match req.headers().get(\"Upgrade\") {\n          Some(h) => h.to_str().unwrap(),\n          None => \"\",\n      };\n      if upgrade_header != \"websocket\" {\n          return worker::Response::error(\"Expected Upgrade: websocket\", 426);\n      }\n\n\n      let ws = WebSocketPair::new()?;\n      let client = ws.client;\n      let server = ws.server;\n      server.accept()?;\n\n\n      worker::Response::from_websocket(client)\n\n\n  }",
      "language": "rs"
    },
    {
      "code": "async function handleRequest(request) {\n    const upgradeHeader = request.headers.get('Upgrade');\n    if (!upgradeHeader || upgradeHeader !== 'websocket') {\n      return new Response('Expected Upgrade: websocket', { status: 426 });\n    }\n\n\n    const webSocketPair = new WebSocketPair();\n    const [client, server] = Object.values(webSocketPair);\n\n\n    server.accept();\n\n\n    return new Response(null, {\n      status: 101,\n      webSocket: client,\n    });\n  }",
      "language": "js"
    },
    {
      "code": "use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(req: HttpRequest, _env: Env, _ctx: Context) -> Result<worker::Response> {\n      let upgrade_header = match req.headers().get(\"Upgrade\") {\n          Some(h) => h.to_str().unwrap(),\n          None => \"\",\n      };\n      if upgrade_header != \"websocket\" {\n          return worker::Response::error(\"Expected Upgrade: websocket\", 426);\n      }\n\n\n      let ws = WebSocketPair::new()?;\n      let client = ws.client;\n      let server = ws.server;\n      server.accept()?;\n\n\n      worker::Response::from_websocket(client)\n\n\n  }",
      "language": "rs"
    },
    {
      "code": "async function handleRequest(request) {\n    const upgradeHeader = request.headers.get('Upgrade');\n    if (!upgradeHeader || upgradeHeader !== 'websocket') {\n      return new Response('Expected Upgrade: websocket', { status: 426 });\n    }\n\n\n    const webSocketPair = new WebSocketPair();\n    const [client, server] = Object.values(webSocketPair);\n\n\n    server.accept();\n    server.addEventListener('message', event => {\n      console.log(event.data);\n    });\n\n\n    return new Response(null, {\n      status: 101,\n      webSocket: client,\n    });\n  }",
      "language": "js"
    },
    {
      "code": "use futures::StreamExt;\n  use worker::*;\n\n\n  #[event(fetch)]\n  async fn fetch(req: HttpRequest, _env: Env, _ctx: Context) -> Result<worker::Response> {\n      let upgrade_header = match req.headers().get(\"Upgrade\") {\n          Some(h) => h.to_str().unwrap(),\n          None => \"\",\n      };\n      if upgrade_header != \"websocket\" {\n          return worker::Response::error(\"Expected Upgrade: websocket\", 426);\n      }\n\n\n      let ws = WebSocketPair::new()?;\n      let client = ws.client;\n      let server = ws.server;\n      server.accept()?;\n\n\n      wasm_bindgen_futures::spawn_local(async move {\n          let mut event_stream = server.events().expect(\"could not open stream\");\n          while let Some(event) = event_stream.next().await {\n              match event.expect(\"received error in websocket\") {\n                  WebsocketEvent::Message(msg) => server.send(&msg.text()).unwrap(),\n                  WebsocketEvent::Close(event) => console_log!(\"{:?}\", event),\n              }\n          }\n      });\n      worker::Response::from_websocket(client)\n\n\n  }",
      "language": "rs"
    },
    {
      "code": "import { Hono } from 'hono'\n  import { upgradeWebSocket } from 'hono/cloudflare-workers'\n\n\n  const app = new Hono()\n\n\n  app.get(\n    '*',\n    upgradeWebSocket((c) => {\n      return {\n        onMessage(event, ws) {\n          console.log('Received message from client:', event.data)\n          ws.send(`Echo: ${event.data}`)\n        },\n        onClose: () => {\n          console.log('WebSocket closed:', event)\n        },\n        onError: () => {\n          console.error('WebSocket error:', event)\n        },\n      }\n    })\n  )\n\n\n  export default app;",
      "language": "ts"
    },
    {
      "code": "const websocket = new WebSocket(\n  \"wss://websocket-example.signalnerve.workers.dev\",\n);\nwebsocket.addEventListener(\"message\", (event) => {\n  console.log(\"Message received from server\");\n  console.log(event.data);\n});",
      "language": "js"
    },
    {
      "code": "websocket.send(\"MESSAGE\");",
      "language": "js"
    },
    {
      "code": "websocket.close();",
      "language": "js"
    },
    {
      "code": "async function websocket(url) {\n  // Make a fetch request including `Upgrade: websocket` header.\n  // The Workers Runtime will automatically handle other requirements\n  // of the WebSocket protocol, like the Sec-WebSocket-Key header.\n  let resp = await fetch(url, {\n    headers: {\n      Upgrade: \"websocket\",\n    },\n  });\n\n\n  // If the WebSocket handshake completed successfully, then the\n  // response has a `webSocket` property.\n  let ws = resp.webSocket;\n  if (!ws) {\n    throw new Error(\"server didn't accept WebSocket\");\n  }\n\n\n  // Call accept() to indicate that you'll be handling the socket here\n  // in JavaScript, as opposed to returning it on to a client.\n  ws.accept();\n\n\n  // Now you can send and receive messages like before.\n  ws.send(\"hello\");\n  ws.addEventListener(\"message\", (msg) => {\n    console.log(msg.data);\n  });\n}",
      "language": "js"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "When to use Wrangler",
      "id": "when-to-use-wrangler"
    },
    {
      "level": "h2",
      "text": "When to use the Cloudflare Vite Plugin",
      "id": "when-to-use-the-cloudflare-vite-plugin"
    },
    {
      "level": "h2",
      "text": "Caching HTML resources",
      "id": "caching-html-resources"
    },
    {
      "level": "h2",
      "text": "Custom cache keys",
      "id": "custom-cache-keys"
    },
    {
      "level": "h2",
      "text": "Override based on origin response code",
      "id": "override-based-on-origin-response-code"
    },
    {
      "level": "h2",
      "text": "Customize cache behavior based on request file type",
      "id": "customize-cache-behavior-based-on-request-file-type"
    },
    {
      "level": "h2",
      "text": "Using the HTTP Cache API",
      "id": "using-the-http-cache-api"
    },
    {
      "level": "h2",
      "text": "Set Cron Triggers in Wrangler",
      "id": "set-cron-triggers-in-wrangler"
    },
    {
      "level": "h2",
      "text": "Test Cron Triggers using Wrangler",
      "id": "test-cron-triggers-using-wrangler"
    },
    {
      "level": "h2",
      "text": "Console-logging headers",
      "id": "console-logging-headers"
    },
    {
      "level": "h3",
      "text": "The problem",
      "id": "the-problem"
    },
    {
      "level": "h3",
      "text": "Pass headers through a Map",
      "id": "pass-headers-through-a-map"
    },
    {
      "level": "h3",
      "text": "Spread headers into an array",
      "id": "spread-headers-into-an-array"
    },
    {
      "level": "h3",
      "text": "Convert headers into an object with Object.fromEntries (ES2019)",
      "id": "convert-headers-into-an-object-with-object.fromentries-(es2019)"
    },
    {
      "level": "h2",
      "text": "Test Cron Triggers using Wrangler",
      "id": "test-cron-triggers-using-wrangler"
    },
    {
      "level": "h2",
      "text": "Redirect all requests to one URL",
      "id": "redirect-all-requests-to-one-url"
    },
    {
      "level": "h2",
      "text": "Redirect requests from one domain to another",
      "id": "redirect-requests-from-one-domain-to-another"
    },
    {
      "level": "h2",
      "text": "Validate signed requests using the WAF",
      "id": "validate-signed-requests-using-the-waf"
    },
    {
      "level": "h2",
      "text": "Stream a JSON request body",
      "id": "stream-a-json-request-body"
    },
    {
      "level": "h2",
      "text": "Stream and transform a JSON response",
      "id": "stream-and-transform-a-json-response"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Write a WebSocket Server",
      "id": "write-a-websocket-server"
    },
    {
      "level": "h3",
      "text": "Connect to the WebSocket server from a client",
      "id": "connect-to-the-websocket-server-from-a-client"
    },
    {
      "level": "h2",
      "text": "Write a WebSocket client",
      "id": "write-a-websocket-client"
    },
    {
      "level": "h2",
      "text": "WebSocket compression",
      "id": "websocket-compression"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "Setup",
      "id": "setup"
    },
    {
      "level": "h2",
      "text": "Continue development",
      "id": "continue-development"
    }
  ],
  "url": "llms-txt#when-to-use-wrangler-vs-vite",
  "links": []
}