{
  "title": "Start a local dev session:",
  "content": "npx wrangler dev\nsh\n------------------\nYour worker has access to the following bindings:\n- Workflows:\n  - MY_WORKFLOW: MyWorkflow\nâŽ” Starting local server...\n[wrangler:inf] Ready on http://127.0.0.1:8787/\njs\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      const customer_id = 123456;\n      // âœ… Good: Non-idempotent API/Binding calls are always done **after** checking if the operation is\n      // still needed.\n      await step.do(\n        `charge ${customer_id} for its monthly subscription`,\n        async () => {\n          // API call to check if customer was already charged\n          const subscription = await fetch(\n            `https://payment.processor/subscriptions/${customer_id}`,\n          ).then((res) => res.json());\n\n// return early if the customer was already charged, this can happen if the destination service dies\n          // in the middle of the request but still commits it, or if the Workflows Engine restarts.\n          if (subscription.charged) {\n            return;\n          }\n\n// non-idempotent call, this operation can fail and retry but still commit in the payment\n          // processor - which means that, on retry, it would mischarge the customer again if the above checks\n          // were not in place.\n          return await fetch(\n            `https://payment.processor/subscriptions/${customer_id}`,\n            {\n              method: \"POST\",\n              body: JSON.stringify({ amount: 10.0 }),\n            },\n          );\n        },\n      );\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      const customer_id = 123456;\n      // âœ… Good: Non-idempotent API/Binding calls are always done **after** checking if the operation is\n      // still needed.\n      await step.do(\n        `charge ${customer_id} for its monthly subscription`,\n        async () => {\n          // API call to check if customer was already charged\n          const subscription = await fetch(\n            `https://payment.processor/subscriptions/${customer_id}`,\n          ).then((res) => res.json());\n\n// return early if the customer was already charged, this can happen if the destination service dies\n          // in the middle of the request but still commits it, or if the Workflows Engine restarts.\n          if (subscription.charged) {\n            return;\n          }\n\n// non-idempotent call, this operation can fail and retry but still commit in the payment\n          // processor - which means that, on retry, it would mischarge the customer again if the above checks\n          // were not in place.\n          return await fetch(\n            `https://payment.processor/subscriptions/${customer_id}`,\n            {\n              method: \"POST\",\n              body: JSON.stringify({ amount: 10.0 }),\n            },\n          );\n        },\n      );\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // âœ… Good: Unrelated API/Binding calls are self-contained, so that in case one of them fails\n      // it can retry them individually. It also has an extra advantage: you can control retry or\n      // timeout policies for each granular step - you might not to want to overload http.cat in\n      // case of it being down.\n      const httpCat = await step.do(\"get cutest cat from KV\", async () => {\n        return await env.KV.get(\"cutest-http-cat\");\n      });\n\nconst image = await step.do(\"fetch cat image from http.cat\", async () => {\n        return await fetch(`https://http.cat/${httpCat}`);\n      });\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // âœ… Good: Unrelated API/Binding calls are self-contained, so that in case one of them fails\n      // it can retry them individually. It also has an extra advantage: you can control retry or\n      // timeout policies for each granular step - you might not to want to overload http.cat in\n      // case of it being down.\n      const httpCat = await step.do(\"get cutest cat from KV\", async () => {\n        return await env.KV.get(\"cutest-http-cat\");\n      });\n\nconst image = await step.do(\"fetch cat image from http.cat\", async () => {\n        return await fetch(`https://http.cat/${httpCat}`);\n      });\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: you are calling two separate services from within the same step. This might cause\n      // some extra calls to the first service in case the second one fails, and in some cases, makes\n      // the step non-idempotent altogether\n      const image = await step.do(\"get cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat\");\n        return fetch(`https://http.cat/${httpCat}`);\n      });\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: you are calling two separate services from within the same step. This might cause\n      // some extra calls to the first service in case the second one fails, and in some cases, makes\n      // the step non-idempotent altogether\n      const image = await step.do(\"get cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat\");\n        return fetch(`https://http.cat/${httpCat}`);\n      });\n    }\n  }\n  js\n  function getRandomInt(min, max) {\n    const minCeiled = Math.ceil(min);\n    const maxFloored = Math.floor(max);\n    return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive\n  }\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: `imageList` will be not persisted across engine's lifetimes. Which means that after hibernation,\n      // `imageList` will be empty again, even though the following two steps have already ran.\n      const imageList = [];\n\nawait step.do(\"get first cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat-1\");\n\nimageList.append(httpCat);\n      });\n\nawait step.do(\"get second cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat-2\");\n\nimageList.append(httpCat);\n      });\n\n// A long sleep can (and probably will) hibernate the engine which means that the first engine lifetime ends here\n      await step.sleep(\"ðŸ’¤ðŸ’¤ðŸ’¤ðŸ’¤\", \"3 hours\");\n\n// When this runs, it will be on the second engine lifetime - which means `imageList` will be empty.\n      await step.do(\n        \"choose a random cat from the list and download it\",\n        async () => {\n          const randomCat = imageList.at(getRandomInt(0, imageList.length));\n          // this will fail since `randomCat` is undefined because `imageList` is empty\n          return await fetch(`https://http.cat/${randomCat}`);\n        },\n      );\n    }\n  }\n  ts\n  function getRandomInt(min, max) {\n    const minCeiled = Math.ceil(min);\n    const maxFloored = Math.floor(max);\n    return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive\n  }\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: `imageList` will be not persisted across engine's lifetimes. Which means that after hibernation,\n      // `imageList` will be empty again, even though the following two steps have already ran.\n      const imageList: string[] = [];\n\nawait step.do(\"get first cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat-1\");\n\nimageList.append(httpCat);\n      });\n\nawait step.do(\"get second cutest cat from KV\", async () => {\n        const httpCat = await env.KV.get(\"cutest-http-cat-2\");\n\nimageList.append(httpCat);\n      });\n\n// A long sleep can (and probably will) hibernate the engine which means that the first engine lifetime ends here\n      await step.sleep(\"ðŸ’¤ðŸ’¤ðŸ’¤ðŸ’¤\", \"3 hours\");\n\n// When this runs, it will be on the second engine lifetime - which means `imageList` will be empty.\n      await step.do(\n        \"choose a random cat from the list and download it\",\n        async () => {\n          const randomCat = imageList.at(getRandomInt(0, imageList.length));\n          // this will fail since `randomCat` is undefined because `imageList` is empty\n          return await fetch(`https://http.cat/${randomCat}`);\n        },\n      );\n    }\n  }\n  js\n  function getRandomInt(min, max) {\n    const minCeiled = Math.ceil(min);\n    const maxFloored = Math.floor(max);\n    return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive\n  }\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // âœ… Good: imageList state is exclusively comprised of step returns - this means that in the event of\n      // multiple engine lifetimes, imageList will be built accordingly\n      const imageList = await Promise.all([\n        step.do(\"get first cutest cat from KV\", async () => {\n          return await env.KV.get(\"cutest-http-cat-1\");\n        }),\n\nstep.do(\"get second cutest cat from KV\", async () => {\n          return await env.KV.get(\"cutest-http-cat-2\");\n        }),\n      ]);\n\n// A long sleep can (and probably will) hibernate the engine which means that the first engine lifetime ends here\n      await step.sleep(\"ðŸ’¤ðŸ’¤ðŸ’¤ðŸ’¤\", \"3 hours\");\n\n// When this runs, it will be on the second engine lifetime - but this time, imageList will contain\n      // the two most cutest cats\n      await step.do(\n        \"choose a random cat from the list and download it\",\n        async () => {\n          const randomCat = imageList.at(getRandomInt(0, imageList.length));\n          // this will eventually succeed since `randomCat` is defined\n          return await fetch(`https://http.cat/${randomCat}`);\n        },\n      );\n    }\n  }\n  ts\n  function getRandomInt(min, max) {\n    const minCeiled = Math.ceil(min);\n    const maxFloored = Math.floor(max);\n    return Math.floor(Math.random() * (maxFloored - minCeiled) + minCeiled); // The maximum is exclusive and the minimum is inclusive\n  }\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // âœ… Good: imageList state is exclusively comprised of step returns - this means that in the event of\n      // multiple engine lifetimes, imageList will be built accordingly\n      const imageList: string[] = await Promise.all([\n        step.do(\"get first cutest cat from KV\", async () => {\n          return await env.KV.get(\"cutest-http-cat-1\");\n        }),\n\nstep.do(\"get second cutest cat from KV\", async () => {\n          return await env.KV.get(\"cutest-http-cat-2\");\n        }),\n      ]);\n\n// A long sleep can (and probably will) hibernate the engine which means that the first engine lifetime ends here\n      await step.sleep(\"ðŸ’¤ðŸ’¤ðŸ’¤ðŸ’¤\", \"3 hours\");\n\n// When this runs, it will be on the second engine lifetime - but this time, imageList will contain\n      // the two most cutest cats\n      await step.do(\n        \"choose a random cat from the list and download it\",\n        async () => {\n          const randomCat = imageList.at(getRandomInt(0, imageList.length));\n          // this will eventually succeed since `randomCat` is defined\n          return await fetch(`https://http.cat/${randomCat}`);\n        },\n      );\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: creating instances outside of steps\n      // This might get called more than once creating more instances than expected\n      const myNewInstance = await this.env.ANOTHER_WORKFLOW.create();\n\n// ðŸ”´ Bad: using non-deterministic functions outside of steps\n      // this will produce different results if the instance has to restart, different runs of the same instance\n      // might go through different paths\n      const myRandom = Math.random();\n\nif (myRandom > 0) {\n        // do some stuff\n      }\n\n// âš ï¸ Warning: This log may happen many times\n      console.log(\"This might be logged more than once\");\n\nawait step.do(\"do some stuff and have a log for when it runs\", async () => {\n        // do some stuff\n\n// this log will only appear once\n        console.log(\"successfully did stuff\");\n      });\n\n// âœ… Good: wrap non-deterministic function in a step\n      // after running successfully will not run again\n      const myRandom = await step.do(\"create a random number\", async () => {\n        return Math.random();\n      });\n\n// âœ… Good: calls that have no side effects can be done outside of steps\n      const db = createDBConnection(this.env.DB_URL, this.env.DB_TOKEN);\n\n// âœ… Good: run funtions with side effects inside of a step\n      // after running successfully will not run again\n      const myNewInstance = await step.do(\n        \"good step that returns state\",\n        async () => {\n          const myNewInstance = await this.env.ANOTHER_WORKFLOW.create();\n\nreturn myNewInstance;\n        },\n      );\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: creating instances outside of steps\n      // This might get called more than once creating more instances than expected\n      const myNewInstance = await this.env.ANOTHER_WORKFLOW.create();\n\n// ðŸ”´ Bad: using non-deterministic functions outside of steps\n      // this will produce different results if the instance has to restart, different runs of the same instance\n      // might go through different paths\n      const myRandom = Math.random();\n\nif (myRandom > 0) {\n        // do some stuff\n      }\n\n// âš ï¸ Warning: This log may happen many times\n      console.log(\"This might be logged more than once\");\n\nawait step.do(\"do some stuff and have a log for when it runs\", async () => {\n        // do some stuff\n\n// this log will only appear once\n        console.log(\"successfully did stuff\");\n      });\n\n// âœ… Good: wrap non-deterministic function in a step\n      // after running successfully will not run again\n      const myRandom = await step.do(\"create a random number\", async () => {\n        return Math.random();\n      });\n\n// âœ… Good: calls that have no side effects can be done outside of steps\n      const db = createDBConnection(this.env.DB_URL, this.env.DB_TOKEN);\n\n// âœ… Good: run funtions with side effects inside of a step\n      // after running successfully will not run again\n      const myNewInstance = await step.do(\n        \"good step that returns state\",\n        async () => {\n          const myNewInstance = await this.env.ANOTHER_WORKFLOW.create();\n\nreturn myNewInstance;\n        },\n      );\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: Mutating the event\n      // This will not be persisted across steps and `event.payload` will\n      // take on its original value.\n      await step.do(\"bad step that mutates the incoming event\", async () => {\n        let userData = await env.KV.get(event.payload.user);\n        event.payload = userData;\n      });\n\n// âœ… Good: persist data by returning it as state from your step\n      // Use that state in subsequent steps\n      let userData = await step.do(\"good step that returns state\", async () => {\n        return await env.KV.get(event.payload.user);\n      });\n\nlet someOtherData = await step.do(\n        \"following step that uses that state\",\n        async () => {\n          // Access to userData here\n          // Will always be the same if this step is retried\n        },\n      );\n    }\n  }\n  ts\n  interface MyEvent {\n    user: string;\n    data: string;\n  }\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<MyEvent>, step: WorkflowStep) {\n      // ðŸ”´ Bad: Mutating the event\n      // This will not be persisted across steps and `event.payload` will\n      // take on its original value.\n      await step.do(\"bad step that mutates the incoming event\", async () => {\n        let userData = await env.KV.get(event.payload.user);\n        event.payload = userData;\n      });\n\n// âœ… Good: persist data by returning it as state from your step\n      // Use that state in subsequent steps\n      let userData = await step.do(\"good step that returns state\", async () => {\n        return await env.KV.get(event.payload.user);\n      });\n\nlet someOtherData = await step.do(\n        \"following step that uses that state\",\n        async () => {\n          // Access to userData here\n          // Will always be the same if this step is retried\n        },\n      );\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: Naming the step non-deterministically prevents it from being cached\n      // This will cause the step to be re-run if subsequent steps fail.\n      await step.do(`step #1 running at: ${Date.now()}`, async () => {\n        let userData = await env.KV.get(event.payload.user);\n        // Do not mutate event.payload\n        event.payload = userData;\n      });\n\n// âœ… Good: give steps a deterministic name.\n      // Return dynamic values in your state, or log them instead.\n      let state = await step.do(\"fetch user data from KV\", async () => {\n        let userData = await env.KV.get(event.payload.user);\n        console.log(`fetched at ${Date.now}`);\n        return userData;\n      });\n\n// âœ… Good: steps that are dynamically named are constructed in a deterministic way.\n      // In this case, `catList` is a step output, which is stable, and `catList` is\n      // traversed in a deterministic fashion (no shuffles or random accesses) so,\n      // it's fine to dynamically name steps (e.g: create a step per list entry).\n      let catList = await step.do(\"get cat list from KV\", async () => {\n        return await env.KV.get(\"cat-list\");\n      });\n\nfor (const cat of catList) {\n        await step.do(`get cat: ${cat}`, async () => {\n          return await env.KV.get(cat);\n        });\n      }\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: Naming the step non-deterministically prevents it from being cached\n      // This will cause the step to be re-run if subsequent steps fail.\n      await step.do(`step #1 running at: ${Date.now()}`, async () => {\n        let userData = await env.KV.get(event.payload.user);\n        // Do not mutate event.payload\n        event.payload = userData;\n      });\n\n// âœ… Good: give steps a deterministic name.\n      // Return dynamic values in your state, or log them instead.\n      let state = await step.do(\"fetch user data from KV\", async () => {\n        let userData = await env.KV.get(event.payload.user);\n        console.log(`fetched at ${Date.now}`);\n        return userData;\n      });\n\n// âœ… Good: steps that are dynamically named are constructed in a deterministic way.\n      // In this case, `catList` is a step output, which is stable, and `catList` is\n      // traversed in a deterministic fashion (no shuffles or random accesses) so,\n      // it's fine to dynamically name steps (e.g: create a step per list entry).\n      let catList = await step.do(\"get cat list from KV\", async () => {\n        return await env.KV.get(\"cat-list\");\n      });\n\nfor (const cat of catList) {\n        await step.do(`get cat: ${cat}`, async () => {\n          return await env.KV.get(cat);\n        });\n      }\n    }\n  }\n  js\n  // helper sleep method\n  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: The `Promise.race` is not surrounded by a `step.do`, which may cause undeterministic caching behavior.\n      const race_return = await Promise.race([\n        step.do(\"Promise first race\", async () => {\n          await sleep(1000);\n          return \"first\";\n        }),\n        step.do(\"Promise second race\", async () => {\n          return \"second\";\n        }),\n      ]);\n\nawait step.sleep(\"Sleep step\", \"2 hours\");\n\nreturn await step.do(\"Another step\", async () => {\n        // This step will return `first`, even though the `Promise.race` first returned `second`.\n        return race_return;\n      });\n    }\n  }\n  ts\n  // helper sleep method\n  const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: The `Promise.race` is not surrounded by a `step.do`, which may cause undeterministic caching behavior.\n      const race_return = await Promise.race([\n        step.do(\"Promise first race\", async () => {\n          await sleep(1000);\n          return \"first\";\n        }),\n        step.do(\"Promise second race\", async () => {\n          return \"second\";\n        }),\n      ]);\n\nawait step.sleep(\"Sleep step\", \"2 hours\");\n\nreturn await step.do(\"Another step\", async () => {\n        // This step will return `first`, even though the `Promise.race` first returned `second`.\n        return race_return;\n      });\n    }\n  }\n  js\n  // helper sleep method\n  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // âœ… Good: The `Promise.race` is surrounded by a `step.do`, ensuring deterministic caching behavior.\n      const race_return = await step.do(\"Promise step\", async () => {\n        return await Promise.race([\n          step.do(\"Promise first race\", async () => {\n            await sleep(1000);\n            return \"first\";\n          }),\n          step.do(\"Promise second race\", async () => {\n            return \"second\";\n          }),\n        ]);\n      });\n\nawait step.sleep(\"Sleep step\", \"2 hours\");\n\nreturn await step.do(\"Another step\", async () => {\n        // This step will return `second` because the `Promise.race` was surround by the `step.do` method.\n        return race_return;\n      });\n    }\n  }\n  ts\n  // helper sleep method\n  const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));\n\nexport class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // âœ… Good: The `Promise.race` is surrounded by a `step.do`, ensuring deterministic caching behavior.\n      const race_return = await step.do(\"Promise step\", async () => {\n        return await Promise.race([\n          step.do(\"Promise first race\", async () => {\n            await sleep(1000);\n            return \"first\";\n          }),\n          step.do(\"Promise second race\", async () => {\n            return \"second\";\n          }),\n        ]);\n      });\n\nawait step.sleep(\"Sleep step\", \"2 hours\");\n\nreturn await step.do(\"Another step\", async () => {\n        // This step will return `second` because the `Promise.race` was surround by the `step.do` method.\n        return race_return;\n      });\n    }\n  }\n  js\n  // This is in the same file as your Workflow definition\n  export default {\n    async fetch(req, env) {\n      // ðŸ”´ Bad: Use an ID that isn't unique across future Workflow invocations\n      let userId = getUserId(req); // Returns the userId\n      let badInstance = await env.MY_WORKFLOW.create({\n        id: userId,\n        params: payload,\n      });\n\n// âœ… Good: use an ID that is unique\n      // e.g. a transaction ID, order ID, or task ID are good options\n      let instanceId = getTransactionId(); // e.g. assuming transaction IDs are unique\n      // or: compose a composite ID and store it in your database\n      // so that you can track all instances associated with a specific user or merchant.\n      instanceId = `${getUserId(req)}-${crypto.randomUUID().slice(0, 6)}`;\n      let { result } = await addNewInstanceToDB(userId, instanceId);\n      let goodInstance = await env.MY_WORKFLOW.create({\n        id: instanceId,\n        params: payload,\n      });\n\nreturn Response.json({\n        id: goodInstance.id,\n        details: await goodInstance.status(),\n      });\n    },\n  };\n  ts\n  // This is in the same file as your Workflow definition\n  export default {\n    async fetch(req: Request, env: Env): Promise<Response> {\n      // ðŸ”´ Bad: Use an ID that isn't unique across future Workflow invocations\n      let userId = getUserId(req); // Returns the userId\n      let badInstance = await env.MY_WORKFLOW.create({\n        id: userId,\n        params: payload,\n      });\n\n// âœ… Good: use an ID that is unique\n      // e.g. a transaction ID, order ID, or task ID are good options\n      let instanceId = getTransactionId(); // e.g. assuming transaction IDs are unique\n      // or: compose a composite ID and store it in your database\n      // so that you can track all instances associated with a specific user or merchant.\n      instanceId = `${getUserId(req)}-${crypto.randomUUID().slice(0, 6)}`;\n      let { result } = await addNewInstanceToDB(userId, instanceId);\n      let goodInstance = await env.MY_WORKFLOW.create({\n        id: instanceId,\n        params: payload,\n      });\n\nreturn Response.json({\n        id: goodInstance.id,\n        details: await goodInstance.status(),\n      });\n    },\n  };\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: The step isn't await'ed, and any state or errors is swallowed before it returns.\n      const issues = step.do(`fetch issues from GitHub`, async () => {\n        // The step will return before this call is done\n        let issues = await getIssues(event.payload.repoName);\n        return issues;\n      });\n\n// âœ… Good: The step is correctly await'ed.\n      const issues = await step.do(`fetch issues from GitHub`, async () => {\n        let issues = await getIssues(event.payload.repoName);\n        return issues;\n      });\n\n// Rest of your Workflow goes here!\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: The step isn't await'ed, and any state or errors is swallowed before it returns.\n      const issues = step.do(`fetch issues from GitHub`, async () => {\n        // The step will return before this call is done\n        let issues = await getIssues(event.payload.repoName);\n        return issues;\n      });\n\n// âœ… Good: The step is correctly await'ed.\n      const issues = await step.do(`fetch issues from GitHub`, async () => {\n        let issues = await getIssues(event.payload.repoName);\n        return issues;\n      });\n\n// Rest of your Workflow goes here!\n    }\n  }\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      const config = await step.do(\"fetch config\", async () => {\n        return await this.env.KV.get(\"feature-flags\", { type: \"json\" });\n      });\n\n// âœ… Good: Condition based on step output (deterministic)\n      if (config.enableEmailNotifications) {\n        await step.do(\"send email\", async () => {\n          // Send email logic\n        });\n      }\n\n// âœ… Good: Condition based on event payload (deterministic)\n      if (event.payload.userType === \"premium\") {\n        await step.do(\"premium processing\", async () => {\n          // Premium-only logic\n        });\n      }\n\n// ðŸ”´ Bad: Condition based on non-deterministic value outside a step\n      // This could behave differently if the Workflow restarts\n      if (Math.random() > 0.5) {\n        await step.do(\"maybe do something\", async () => {});\n      }\n\n// âœ… Good: Wrap non-deterministic values in a step\n      const shouldProcess = await step.do(\"decide randomly\", async () => {\n        return Math.random() > 0.5;\n      });\n      if (shouldProcess) {\n        await step.do(\"conditionally do something\", async () => {});\n      }\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      const config = await step.do(\"fetch config\", async () => {\n        return await this.env.KV.get(\"feature-flags\", { type: \"json\" });\n      });\n\n// âœ… Good: Condition based on step output (deterministic)\n      if (config.enableEmailNotifications) {\n        await step.do(\"send email\", async () => {\n          // Send email logic\n        });\n      }\n\n// âœ… Good: Condition based on event payload (deterministic)\n      if (event.payload.userType === \"premium\") {\n        await step.do(\"premium processing\", async () => {\n          // Premium-only logic\n        });\n      }\n\n// ðŸ”´ Bad: Condition based on non-deterministic value outside a step\n      // This could behave differently if the Workflow restarts\n      if (Math.random() > 0.5) {\n        await step.do(\"maybe do something\", async () => {});\n      }\n\n// âœ… Good: Wrap non-deterministic values in a step\n      const shouldProcess = await step.do(\"decide randomly\", async () => {\n        return Math.random() > 0.5;\n      });\n      if (shouldProcess) {\n        await step.do(\"conditionally do something\", async () => {});\n      }\n    }\n  }\n  js\n  export default {\n    async fetch(req, env) {\n      let instances = [\n        { id: \"user1\", params: { name: \"John\" } },\n        { id: \"user2\", params: { name: \"Jane\" } },\n        { id: \"user3\", params: { name: \"Alice\" } },\n        { id: \"user4\", params: { name: \"Bob\" } },\n      ];\n\n// ðŸ”´ Bad: Create them one by one, which is more likely to hit creation rate limits.\n      for (let instance of instances) {\n        await env.MY_WORKFLOW.create({\n          id: instance.id,\n          params: instance.params,\n        });\n      }\n\n// âœ… Good: Batch calls together\n      // This improves throughput.\n      let instances = await env.MY_WORKFLOW.createBatch(instances);\n      return Response.json({ instances });\n    },\n  };\n  ts\n  export default {\n    async fetch(req: Request, env: Env): Promise<Response> {\n      let instances = [\n        { id: \"user1\", params: { name: \"John\" } },\n        { id: \"user2\", params: { name: \"Jane\" } },\n        { id: \"user3\", params: { name: \"Alice\" } },\n        { id: \"user4\", params: { name: \"Bob\" } },\n      ];\n\n// ðŸ”´ Bad: Create them one by one, which is more likely to hit creation rate limits.\n      for (let instance of instances) {\n        await env.MY_WORKFLOW.create({\n          id: instance.id,\n          params: instance.params,\n        });\n      }\n\n// âœ… Good: Batch calls together\n      // This improves throughput.\n      let instances = await env.MY_WORKFLOW.createBatch(instances);\n      return Response.json({ instances });\n    },\n  };\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // ðŸ”´ Bad: Returning a large response that may exceed 1 MiB\n      const largeData = await step.do(\"fetch large dataset\", async () => {\n        const response = await fetch(\"https://api.example.com/large-dataset\");\n        return await response.json(); // Could exceed 1 MiB\n      });\n\n// âœ… Good: Store large data externally and return a reference\n      const dataRef = await step.do(\"fetch and store large dataset\", async () => {\n        const response = await fetch(\"https://api.example.com/large-dataset\");\n        const data = await response.json();\n        // Store in R2 and return a reference\n        await this.env.MY_BUCKET.put(\"dataset-123\", JSON.stringify(data));\n        return { key: \"dataset-123\" };\n      });\n\n// Retrieve the data in a later step when needed\n      const data = await step.do(\"process dataset\", async () => {\n        const stored = await this.env.MY_BUCKET.get(dataRef.key);\n        return processData(await stored.json());\n      });\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // ðŸ”´ Bad: Returning a large response that may exceed 1 MiB\n      const largeData = await step.do(\"fetch large dataset\", async () => {\n        const response = await fetch(\"https://api.example.com/large-dataset\");\n        return await response.json(); // Could exceed 1 MiB\n      });\n\n// âœ… Good: Store large data externally and return a reference\n      const dataRef = await step.do(\"fetch and store large dataset\", async () => {\n        const response = await fetch(\"https://api.example.com/large-dataset\");\n        const data = await response.json();\n        // Store in R2 and return a reference\n        await this.env.MY_BUCKET.put(\"dataset-123\", JSON.stringify(data));\n        return { key: \"dataset-123\" };\n      });\n\n// Retrieve the data in a later step when needed\n      const data = await step.do(\"process dataset\", async () => {\n        const stored = await this.env.MY_BUCKET.get(dataRef.key);\n        return processData(await stored.json());\n      });\n    }\n  }\n  ts\nawait step.sleep(\"sleep for a bit\", \"1 hour\")\nts\n| \"second\"\n| \"minute\"\n| \"hour\"\n| \"day\"\n| \"week\"\n| \"month\"\n| \"year\"\nts\n// sleepUntil accepts a Date object as its second argument\nconst workflowsLaunchDate = Date.parse(\"24 Oct 2024 13:00:00 UTC\");\nawait step.sleepUntil(\"sleep until X times out\", workflowsLaunchDate)\nts\nconst defaultConfig: WorkflowStepConfig = {\n  retries: {\n    limit: 5,\n    delay: 10000,\n    backoff: 'exponential',\n  },\n  timeout: '10 minutes',\n};\nts\nlet someState = step.do(\"call an API\", {\n  retries: {\n    limit: 10, // The total number of attempts\n    delay: \"10 seconds\", // Delay between each retry\n    backoff: \"exponential\" // Any of \"constant\" | \"linear\" | \"exponential\";\n  },\n  timeout: \"30 minutes\",\n}, async () => { /* Step code goes here /* }\nts\n// Import the NonRetryableError definition\nimport { WorkflowEntrypoint, WorkflowStep, WorkflowEvent } from 'cloudflare:workers';\nimport { NonRetryableError } from 'cloudflare:workflows';\n\n// In your step code:\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n    await step.do(\"some step\", async () => {\n        if (!event.payload.data) {\n          throw new NonRetryableError(\"event.payload.data did not contain the expected payload\")\n        }\n      })\n  }\n}\nts\n...\nawait step.do('task', async () => {\n  // work to be done\n});\n\ntry {\n    await step.do('non-retryable-task', async () => {\n    // work not to be retried\n        throw new NonRetryableError('oh no');\n    });\n} catch(e as Error) {\n    console.log(`Step failed: ${e.message}`);\n    await step.do('clean-up-task', async () => {\n      // Clean up code here\n    });\n}\n\n// the Workflow will not fail and will continue its execution\n\nawait step.do('next-task', async() => {\n  // more work to be done\n});\n...\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"workflows-tutorial\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2024-10-22\",\n    \"workflows\": [\n      {\n        \"name\": \"workflows-tutorial\",\n        \"binding\": \"MY_WORKFLOW\",\n        \"class_name\": \"MyWorkflow\"\n      }\n    ]\n  }\n  toml\n  name = \"workflows-tutorial\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2024-10-22\"\n\n[[workflows]]\n  # The name of the Workflow\n  name = \"workflows-tutorial\"\n  # The binding name, which must be a valid JavaScript variable name.  This will\n  # be how you call (run) your Workflow from your other Workers handlers or\n  # scripts.\n  binding = \"MY_WORKFLOW\"\n  # Must match the class defined in your code that extends the Workflow class\n  class_name = \"MyWorkflow\"\n  ts\ninterface Env {\n  MY_WORKFLOW: Workflow;\n}\n\nexport default {\n  async fetch(req: Request, env: Env) {\n    // Get instanceId from query parameters\n    const instanceId = new URL(req.url).searchParams.get(\"instanceId\");\n\n// If an ?instanceId=<id> query parameter is provided, fetch the status\n    // of an existing Workflow by its ID.\n    if (instanceId) {\n      let instance = await env.MY_WORKFLOW.get(instanceId);\n      return Response.json({\n        status: await instance.status(),\n      });\n    }\n\n// Else, create a new instance of our Workflow, passing in any (optional)\n    // params and return the ID.\n    const newId = crypto.randomUUID();\n    let instance = await env.MY_WORKFLOW.create({ id: newId });\n    return Response.json({\n      id: instance.id,\n      details: await instance.status(),\n    });\n  },\n};\nts\nlet instance = await env.MY_WORKFLOW.get(\"abc-123\");\nlet status = await instance.status(); // Returns an InstanceStatus\nts\n  status:\n    | \"queued\" // means that instance is waiting to be started (see concurrency limits)\n    | \"running\"\n    | \"paused\"\n    | \"errored\"\n    | \"terminated\" // user terminated the instance while it was running\n    | \"complete\"\n    | \"waiting\" // instance is hibernating and waiting for sleep or event to finish\n    | \"waitingForPause\" // instance is finishing the current work to pause\n    | \"unknown\";\n  error?: {\n    name: string,\n    message: string\n  };\n  output?: unknown;\nts\nlet instance = await env.MY_WORKFLOW.get(\"abc-123\");\nawait instance.pause(); // Returns Promise<void>\nts\nlet instance = await env.MY_WORKFLOW.get(\"abc-123\");\nawait instance.resume(); // Returns Promise<void>\nts\nlet instance = await env.MY_WORKFLOW.get(\"abc-123\");\nawait instance.terminate(); // Returns Promise<void>\nts\nlet instance = await env.MY_WORKFLOW.get(\"abc-123\");\nawait instance.restart(); // Returns Promise<void>\njs\n  export class ParentWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // Perform initial work\n      const result = await step.do(\"initial processing\", async () => {\n        // ... processing logic\n        return { fileKey: \"output.pdf\" };\n      });\n\n// Trigger a child workflow for additional processing\n      const childInstance = await step.do(\"trigger child workflow\", async () => {\n        return await this.env.CHILD_WORKFLOW.create({\n          id: `child-${event.instanceId}`,\n          params: { fileKey: result.fileKey },\n        });\n      });\n\n// Parent continues immediately - not blocked by child workflow\n      await step.do(\"continue with other work\", async () => {\n        console.log(`Started child workflow: ${childInstance.id}`);\n        // This runs right away, regardless of child workflow status\n      });\n    }\n  }\n  ts\n  export class ParentWorkflow extends WorkflowEntrypoint<Env, Params> {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // Perform initial work\n      const result = await step.do(\"initial processing\", async () => {\n        // ... processing logic\n        return { fileKey: \"output.pdf\" };\n      });\n\n// Trigger a child workflow for additional processing\n      const childInstance = await step.do(\"trigger child workflow\", async () => {\n        return await this.env.CHILD_WORKFLOW.create({\n          id: `child-${event.instanceId}`,\n          params: { fileKey: result.fileKey },\n        });\n      });\n\n// Parent continues immediately - not blocked by child workflow\n      await step.do(\"continue with other work\", async () => {\n        console.log(`Started child workflow: ${childInstance.id}`);\n        // This runs right away, regardless of child workflow status\n      });\n    }\n  }\n  ts\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n    // Steps here\n  }\n}\nts\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n    // Steps here\n    let someComputedState = await step.do(\"my step\", async () => {});\n\n// Optional: return state from our run() method\n    return someComputedState;\n  }\n}\nts\nexport type WorkflowEvent<T> = {\n  payload: Readonly<T>;\n  timestamp: Date;\n  instanceId: string;\n};\njs\n  export class MyWorkflow extends WorkflowEntrypoint {\n    async run(event, step) {\n      // Other steps in your Workflow\n      let event = await step.waitForEvent(\n        \"receive invoice paid webhook from Stripe\",\n        { type: \"stripe-webhook\", timeout: \"1 hour\" },\n      );\n      // Rest of your Workflow\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\n    async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n      // Other steps in your Workflow\n      let event = await step.waitForEvent<IncomingStripeWebhook>(\n        \"receive invoice paid webhook from Stripe\",\n        { type: \"stripe-webhook\", timeout: \"1 hour\" },\n      );\n      // Rest of your Workflow\n    }\n  }\n  ts\nexport type WorkflowStepConfig = {\n  retries?: {\n    limit: number;\n    delay: string | number;\n    backoff?: WorkflowBackoff;\n  };\n  timeout?: string | number;\n};\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"workflows-starter\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2024-10-22\",\n    \"workflows\": [\n      {\n        \"name\": \"workflows-starter\",\n        \"binding\": \"MY_WORKFLOW\",\n        \"class_name\": \"MyWorkflow\"\n      }\n    ]\n  }\n  toml\n  #:schema node_modules/wrangler/config-schema.json\n  name = \"workflows-starter\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2024-10-22\"\n\n[[workflows]]\n  # name of your workflow\n  name = \"workflows-starter\"\n  # binding name env.MY_WORKFLOW\n  binding = \"MY_WORKFLOW\"\n  # this is class that extends the Workflow class in src/index.ts\n  class_name = \"MyWorkflow\"\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"web-api-worker\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2024-10-22\",\n    \"workflows\": [\n      {\n        \"name\": \"billing-workflow\",\n        \"binding\": \"MY_WORKFLOW\",\n        \"class_name\": \"MyWorkflow\",\n        \"script_name\": \"billing-worker\"\n      }\n    ]\n  }\n  toml\n  #:schema node_modules/wrangler/config-schema.json\n  name = \"web-api-worker\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2024-10-22\"\n\n[[workflows]]\n  # name of your workflow\n  name = \"billing-workflow\"\n  # binding name env.MY_WORKFLOW\n  binding = \"MY_WORKFLOW\"\n  # this is class that extends the Workflow class in src/index.ts\n  class_name = \"MyWorkflow\"\n  # the script name where the Workflow is defined.\n  # required if the Workflow is defined in another script.\n  script_name = \"billing-worker\"\n  ts\ninterface Env {\n  // The 'MY_WORKFLOW' variable should match the \"binding\" value set in the Wrangler config file\n  MY_WORKFLOW: Workflow;\n}\nts\n// Create a new Workflow instance with your own ID and pass params to the Workflow instance\nlet instance = await env.MY_WORKFLOW.create({\n  id: myIdDefinedFromOtherSystem,\n  params: { hello: \"world\" },\n});\nreturn Response.json({\n  id: instance.id,\n  details: await instance.status(),\n});\nts\ninterface User {\n  email: string;\n  createdTimestamp: number;\n}\n\ninterface Env {\n  // Pass our User type as the type parameter to the Workflow definition\n  MY_WORKFLOW: Workflow<User>;\n}\n\nexport default {\n  async fetch(request, env, ctx) {\n    // More likely to come from your database or via the request body!\n    const user: User = {\n      email: user@example.com,\n      createdTimestamp: Date.now()\n    }\n\nlet instance = await env.MY_WORKFLOW.create({\n      // params expects the type User\n      params: user\n    })\n\nreturn Response.json({\n      id: instance.id,\n      details: await instance.status(),\n    });\n  }\n}\nts\n// Create a new batch of 3 Workflow instances, each with its own ID and pass params to the Workflow instances\nconst listOfInstances = [\n  { id: \"id-abc123\", params: { hello: \"world-0\" } },\n  { id: \"id-def456\", params: { hello: \"world-1\" } },\n  { id: \"id-ghi789\", params: { hello: \"world-2\" } },\n];\nlet instances = await env.MY_WORKFLOW.createBatch(listOfInstances);\nts\n// Fetch an existing Workflow instance by ID:\ntry {\n  let instance = await env.MY_WORKFLOW.get(id);\n  return Response.json({\n    id: instance.id,\n    details: await instance.status(),\n  });\n} catch (e: any) {\n  // Handle errors\n  // .get will throw an exception if the ID doesn't exist or is invalid.\n  const msg = `failed to get instance ${id}: ${e.message}`;\n  console.error(msg);\n  return Response.json({ error: msg }, { status: 400 });\n}\nts\ninterface WorkflowInstanceCreateOptions {\n  /**\n   * An id for your Workflow instance. Must be unique within the Workflow.\n   */\n  id?: string;\n  /**\n   * The event payload the Workflow instance is triggered with\n   */\n  params?: unknown;\n}\nts\ndeclare abstract class WorkflowInstance {\n  public id: string;\n  /**\n   * Pause the instance.\n   */\n  public pause(): Promise<void>;\n  /**\n   * Resume the instance. If it is already running, an error will be thrown.\n   */\n  public resume(): Promise<void>;\n  /**\n   * Terminate the instance. If it is errored, terminated or complete, an error will be thrown.\n   */\n  public terminate(): Promise<void>;\n  /**\n   * Restart the instance.\n   */\n  public restart(): Promise<void>;\n  /**\n   * Returns the current status of the instance.\n   */\n  public status(): Promise<InstanceStatus>;\n}\njs\n  export default {\n    async fetch(req, env) {\n      const instanceId = new URL(req.url).searchParams.get(\"instanceId\");\n      const webhookPayload = await req.json();\n\nlet instance = await env.MY_WORKFLOW.get(instanceId);\n      // Send our event, with `type` matching the event type defined in\n      // our step.waitForEvent call\n      await instance.sendEvent({\n        type: \"stripe-webhook\",\n        payload: webhookPayload,\n      });\n\nreturn Response.json({\n        status: await instance.status(),\n      });\n    },\n  };\n  ts\n  export default {\n    async fetch(req: Request, env: Env) {\n      const instanceId = new URL(req.url).searchParams.get(\"instanceId\");\n      const webhookPayload = await req.json<Payload>();\n\nlet instance = await env.MY_WORKFLOW.get(instanceId);\n      // Send our event, with `type` matching the event type defined in\n      // our step.waitForEvent call\n      await instance.sendEvent({\n        type: \"stripe-webhook\",\n        payload: webhookPayload,\n      });\n\nreturn Response.json({\n        status: await instance.status(),\n      });\n    },\n  };\n  ts\ntype InstanceStatus = {\n  status:\n    | \"queued\" // means that instance is waiting to be started (see concurrency limits)\n    | \"running\"\n    | \"paused\"\n    | \"errored\"\n    | \"terminated\" // user terminated the instance while it was running\n    | \"complete\"\n    | \"waiting\" // instance is hibernating and waiting for sleep or event to finish\n    | \"waitingForPause\" // instance is finishing the current work to pause\n    | \"unknown\";\n  error?: {\n    name: string,\n    message: string\n  };\n  output?: unknown;\n};\nts\nimport {\n  WorkflowEntrypoint,\n  WorkflowStep,\n  WorkflowEvent,\n} from \"cloudflare:workers\";\n\n// We are using R2 to store the D1 backup\ntype Env = {\n  BACKUP_WORKFLOW: Workflow;\n  D1_REST_API_TOKEN: string;\n  BACKUP_BUCKET: R2Bucket;\n};\n\n// Workflow parameters: we expect accountId and databaseId\ntype Params = {\n  accountId: string;\n  databaseId: string;\n};\n\n// Workflow logic\nexport class backupWorkflow extends WorkflowEntrypoint<Env, Params> {\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n    const { accountId, databaseId } = event.payload;\n\nconst url = `https://api.cloudflare.com/client/v4/accounts/${accountId}/d1/database/${databaseId}/export`;\n    const method = \"POST\";\n    const headers = new Headers();\n    headers.append(\"Content-Type\", \"application/json\");\n    headers.append(\"Authorization\", `Bearer ${this.env.D1_REST_API_TOKEN}`);\n\nconst bookmark = await step.do(\n      `Starting backup for ${databaseId}`,\n      async () => {\n        const payload = { output_format: \"polling\" };\n\nconst res = await fetch(url, {\n          method,\n          headers,\n          body: JSON.stringify(payload),\n        });\n        const { result } = (await res.json()) as any;\n\n// If we don't get `at_bookmark` we throw to retry the step\n        if (!result?.at_bookmark) throw new Error(\"Missing `at_bookmark`\");\n\nreturn result.at_bookmark;\n      },\n    );\n\nawait step.do(\"Check backup status and store it on R2\", async () => {\n      const payload = { current_bookmark: bookmark };\n\nconst res = await fetch(url, {\n        method,\n        headers,\n        body: JSON.stringify(payload),\n      });\n      const { result } = (await res.json()) as any;\n\n// The endpoint sends `signed_url` when the backup is ready to download.\n      // If we don't get `signed_url` we throw to retry the step.\n      if (!result?.signed_url) throw new Error(\"Missing `signed_url`\");\n\nconst dumpResponse = await fetch(result.signed_url);\n      if (!dumpResponse.ok) throw new Error(\"Failed to fetch dump file\");\n\n// Finally, stream the file directly to R2\n      await this.env.BACKUP_BUCKET.put(result.filename, dumpResponse.body);\n    });\n  }\n}\n\nexport default {\n  async fetch(req: Request, env: Env): Promise<Response> {\n    return new Response(\"Not found\", { status: 404 });\n  },\n  async scheduled(\n    controller: ScheduledController,\n    env: Env,\n    ctx: ExecutionContext,\n  ) {\n    const params: Params = {\n      accountId: \"{accountId}\",\n      databaseId: \"{databaseId}\",\n    };\n    const instance = await env.BACKUP_WORKFLOW.create({ params });\n    console.log(`Started workflow: ${instance.id}`);\n  },\n};\njson\n{\n  \"devDependencies\": {\n    \"wrangler\": \"^3.99.0\"\n  }\n}\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"backup-d1\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2024-12-27\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"workflows\": [\n      {\n        \"name\": \"backup-workflow\",\n        \"binding\": \"BACKUP_WORKFLOW\",\n        \"class_name\": \"backupWorkflow\"\n      }\n    ],\n    \"r2_buckets\": [\n      {\n        \"binding\": \"BACKUP_BUCKET\",\n        \"bucket_name\": \"d1-backups\"\n      }\n    ],\n    \"triggers\": {\n      \"crons\": [\n        \"0 0 * * *\"\n      ]\n    }\n  }\n  toml\n  name = \"backup-d1\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2024-12-27\"\n  compatibility_flags = [ \"nodejs_compat\" ]\n\n[[workflows]]\n  name = \"backup-workflow\"\n  binding = \"BACKUP_WORKFLOW\"\n  class_name = \"backupWorkflow\"\n\n[[r2_buckets]]\n  binding = \"BACKUP_BUCKET\"\n  bucket_name = \"d1-backups\"\n\n[triggers]\n  crons = [ \"0 0 * * *\" ]\n  ts\nimport {\n  WorkflowEntrypoint,\n  WorkflowStep,\n  WorkflowEvent,\n} from \"cloudflare:workers\";\nimport { EmailMessage } from \"cloudflare:email\";\nimport { createMimeMessage } from \"mimetext\";\n\n// We are using Email Routing to send emails out and D1 for our cart database\ntype Env = {\n  CART_WORKFLOW: Workflow;\n  SEND_EMAIL: any;\n  DB: any;\n};\n\n// Workflow parameters: we expect a cartId\ntype Params = {\n  cartId: string;\n};\n\n// Adjust this to your Cloudflare zone using Email Routing\nconst merchantEmail = \"merchant@example.com\";\n\n// Uses mimetext npm to generate Email\nconst genEmail = (email: string, amount: number) => {\n  const msg = createMimeMessage();\n  msg.setSender({ name: \"Pet shop\", addr: merchantEmail });\n  msg.setRecipient(email);\n  msg.setSubject(\"You invoice\");\n  msg.addMessage({\n    contentType: \"text/plain\",\n    data: `Your invoice for ${amount} has been paid. Your products will be shipped shortly.`,\n  });\n\nreturn new EmailMessage(merchantEmail, email, msg.asRaw());\n};\n\n// Workflow logic\nexport class cartInvoicesWorkflow extends WorkflowEntrypoint<Env, Params> {\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n    await step.sleep(\"sleep for a while\", \"10 seconds\");\n\n// Retrieve the cart from the D1 database\n    // if the cart hasn't been checked out yet retry every 2 minutes, 10 times, otherwise give up\n    const cart = await step.do(\n      \"retrieve cart\",\n      {\n        retries: {\n          limit: 10,\n          delay: 2000 * 60,\n          backoff: \"constant\",\n        },\n        timeout: \"30 seconds\",\n      },\n      async () => {\n        const { results } = await this.env.DB.prepare(\n          `SELECT * FROM cart WHERE id = ?`,\n        )\n          .bind(event.payload.cartId)\n          .run();\n        // should return { checkedOut: true, amount: 250 , account: { email: \"celsomartinho@gmail.com\" }};\n        if (results[0].checkedOut === false) {\n          throw new Error(\"cart hasn't been checked out yet\");\n        }\n        return results[0];\n      },\n    );\n\n// Proceed to payment, retry 10 times every minute or give up\n    const payment = await step.do(\n      \"payment\",\n      {\n        retries: {\n          limit: 10,\n          delay: 1000 * 60,\n          backoff: \"constant\",\n        },\n        timeout: \"30 seconds\",\n      },\n      async () => {\n        let resp = await fetch(\"https://payment-processor.example.com/\", {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json; charset=utf-8\",\n          },\n          body: JSON.stringify({ amount: cart.amount }),\n        });\n\nif (!resp.ok) {\n          throw new Error(\"payment has failed\");\n        }\n\nreturn { success: true, amount: cart.amount };\n      },\n    );\n\n// Send invoice to the customer, retry 10 times every 5 minutes or give up\n    // Requires that cart.account.email has previously been validated in Email Routing,\n    // See https://developers.cloudflare.com/email-routing/email-workers/\n    await step.do(\n      \"send invoice\",\n      {\n        retries: {\n          limit: 10,\n          delay: 5000 * 60,\n          backoff: \"constant\",\n        },\n        timeout: \"30 seconds\",\n      },\n      async () => {\n        const message = genEmail(cart.account.email, payment.amount);\n        try {\n          await this.env.SEND_EMAIL.send(message);\n        } catch (e) {\n          throw new Error(\"failed to send invoice\");\n        }\n      },\n    );\n  }\n}\n\n// Default page for admin\n// Remove in production\n\nexport default {\n  async fetch(req: Request, env: Env): Promise<Response> {\n    let url = new URL(req.url);\n\nlet id = new URL(req.url).searchParams.get(\"instanceId\");\n\n// Get the status of an existing instance, if provided\n    if (id) {\n      let instance = await env.CART_WORKFLOW.get(id);\n      return Response.json({\n        status: await instance.status(),\n      });\n    }\n\nif (url.pathname.startsWith(\"/new\")) {\n      let instance = await env.CART_WORKFLOW.create({\n        params: {\n          cartId: \"123\",\n        },\n      });\n      return Response.json({\n        id: instance.id,\n        details: await instance.status(),\n      });\n    }\n\nreturn new Response(\n      `<html><body><a href=\"/new\">new instance</a> or add ?instanceId=...</body></html>`,\n      {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      },\n    );\n  },\n};\njson\n{\n  \"devDependencies\": {\n    \"wrangler\": \"^3.83.0\"\n  },\n  \"dependencies\": {\n    \"mimetext\": \"^3.0.24\"\n  }\n}\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"cart-invoices\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2024-10-22\",\n    \"compatibility_flags\": [\n      \"nodejs_compat\"\n    ],\n    \"workflows\": [\n      {\n        \"name\": \"cart-invoices-workflow\",\n        \"binding\": \"CART_WORKFLOW\",\n        \"class_name\": \"cartInvoicesWorkflow\"\n      }\n    ],\n    \"send_email\": [\n      {\n        \"name\": \"SEND_EMAIL\"\n      }\n    ]\n  }\n  toml\n  name = \"cart-invoices\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2024-10-22\"\n  compatibility_flags = [\"nodejs_compat\" ]\n\n[[workflows]]\n  name = \"cart-invoices-workflow\"\n  binding = \"CART_WORKFLOW\"\n  class_name = \"cartInvoicesWorkflow\"\n\n[[send_email]]\n  name = \"SEND_EMAIL\"\n  js\n  export class MyWorkflow extends WorkflowEntrypoint {\n    db;\n\nasync run(event, step) {\n      this.db = new DatabaseService(this.env.DB);\n      const { imageKey } = event.payload;\n\nawait step.do(\"Insert image name into database\", async () => {\n        await this.db.insertImage(imageKey, event.instanceId);\n      });\n\nconst waitForApproval = await step.waitForEvent(\n        \"Wait for AI Image tagging approval\",\n        {\n          type: \"approval-for-ai-tagging\",\n          timeout: \"5 minute\",\n        },\n      );\n\nconst approvalPayload = waitForApproval.payload;\n      if (approvalPayload?.approved) {\n        const aiTags = await step.do(\"Generate AI tags\", async () => {\n          const image = await this.env.workflow_demo_bucket.get(imageKey);\n          if (!image) throw new Error(\"Image not found\");\n\nconst arrayBuffer = await image.arrayBuffer();\n          const uint8Array = new Uint8Array(arrayBuffer);\n\nconst input = {\n            image: Array.from(uint8Array),\n            prompt: AI_CONFIG.PROMPT,\n            max_tokens: AI_CONFIG.MAX_TOKENS,\n          };\n\nconst response = await this.env.AI.run(AI_CONFIG.MODEL, input);\n          return response.description;\n        });\n\nawait step.do(\"Update DB with AI tags\", async () => {\n          await this.db.updateImageTags(event.instanceId, aiTags);\n        });\n      }\n    }\n  }\n  ts\n  export class MyWorkflow extends WorkflowEntrypoint<Env, WorkflowParams> {\n    private db!: DatabaseService;\n\nasync run(event: WorkflowEvent<WorkflowParams>, step: WorkflowStep) {\n      this.db = new DatabaseService(this.env.DB);\n      const { imageKey } = event.payload;\n\nawait step.do('Insert image name into database', async () => {\n        await this.db.insertImage(imageKey, event.instanceId);\n      });\n\nconst waitForApproval = await step.waitForEvent('Wait for AI Image tagging approval', {\n        type: 'approval-for-ai-tagging',\n        timeout: '5 minute',\n      });\n\nconst approvalPayload = waitForApproval.payload as ApprovalRequest;\n      if (approvalPayload?.approved) {\n        const aiTags = await step.do('Generate AI tags', async () => {\n          const image = await this.env.workflow_demo_bucket.get(imageKey);\n          if (!image) throw new Error('Image not found');\n\nconst arrayBuffer = await image.arrayBuffer();\n          const uint8Array = new Uint8Array(arrayBuffer);\n\nconst input = {\n            image: Array.from(uint8Array),\n            prompt: AI_CONFIG.PROMPT,\n            max_tokens: AI_CONFIG.MAX_TOKENS,\n          };\n\nconst response = await this.env.AI.run(AI_CONFIG.MODEL, input);\n          return response.description;\n        });\n\nawait step.do('Update DB with AI tags', async () => {\n          await this.db.updateImageTags(event.instanceId, aiTags);\n        });\n      }\n    }\n  }\n  jsonc\n  {\n    \"$schema\": \"node_modules/wrangler/config-schema.json\",\n    \"name\": \"workflows-waitforevent\",\n    \"main\": \"src/index.ts\",\n    \"compatibility_date\": \"2025-04-14\",\n    \"observability\": {\n      \"enabled\": true,\n      \"head_sampling_rate\": 1,\n    },\n    \"ai\": {\n      \"binding\": \"AI\"\n    },\n    \"workflows\": [\n      {\n        \"name\": \"workflows-starter\",\n        \"binding\": \"MY_WORKFLOW\",\n        \"class_name\": \"MyWorkflow\"\n      }\n    ],\n    \"r2_buckets\": [\n      {\n        \"bucket_name\": \"workflow-demo\",\n        \"binding\": \"workflow_demo_bucket\"\n      }\n    ],\n    \"d1_databases\": [\n      {\n        \"binding\": \"DB\",\n        \"database_name\": \"workflows-demo-d1\",\n        \"database_id\": \"66e4fbe9-06ac-4548-abba-2dc42088e13a\"\n      }\n    ]\n  }\n  toml\n  \"$schema\" = \"node_modules/wrangler/config-schema.json\"\n  name = \"workflows-waitforevent\"\n  main = \"src/index.ts\"\n  compatibility_date = \"2025-04-14\"\n\n[observability]\n  enabled = true\n  head_sampling_rate = 1\n\n[ai]\n  binding = \"AI\"\n\n[[workflows]]\n  name = \"workflows-starter\"\n  binding = \"MY_WORKFLOW\"\n  class_name = \"MyWorkflow\"\n\n[[r2_buckets]]\n  bucket_name = \"workflow-demo\"\n  binding = \"workflow_demo_bucket\"\n\n[[d1_databases]]\n  binding = \"DB\"\n  database_name = \"workflows-demo-d1\"\n  database_id = \"66e4fbe9-06ac-4548-abba-2dc42088e13a\"\n  sh\nnpm create cloudflare@latest workflows-starter -- --template \"cloudflare/workflows-starter\"\nts\nimport { WorkflowEntrypoint, WorkflowStep, WorkflowEvent } from 'cloudflare:workers';\n\ntype Env = {\n  // Add your bindings here, e.g. Workers KV, D1, Workers AI, etc.\n  MY_WORKFLOW: Workflow;\n};\n\n// User-defined params passed to your workflow\ntype Params = {\n  email: string;\n  metadata: Record<string, string>;\n};\n\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n    // Can access bindings on `this.env`\n    // Can access params on `event.payload`\n\nconst files = await step.do('my first step', async () => {\n      // Fetch a list of files from $SOME_SERVICE\n      return {\n        files: [\n          'doc_7392_rev3.pdf',\n          'report_x29_final.pdf',\n          'memo_2024_05_12.pdf',\n          'file_089_update.pdf',\n          'proj_alpha_v2.pdf',\n          'data_analysis_q2.pdf',\n          'notes_meeting_52.pdf',\n          'summary_fy24_draft.pdf',\n        ],\n      };\n    });\n\nconst apiResponse = await step.do('some other step', async () => {\n      let resp = await fetch('https://api.cloudflare.com/client/v4/ips');\n      return await resp.json<any>();\n    });\n\nawait step.sleep('wait on something', '1 minute');\n\nawait step.do(\n      'make a call to write that could maybe, just might, fail',\n      // Define a retry strategy\n      {\n        retries: {\n          limit: 5,\n          delay: '5 second',\n          backoff: 'exponential',\n        },\n        timeout: '15 minutes',\n      },\n      async () => {\n        // Do stuff here, with access to the state from our previous steps\n        if (Math.random() > 0.5) {\n          throw new Error('API call to $STORAGE_SYSTEM failed');\n        }\n      },\n    );\n  }\n}\n\nexport default {\n  async fetch(req: Request, env: Env): Promise<Response> {\n    let id = new URL(req.url).searchParams.get('instanceId');\n\n// Get the status of an existing instance, if provided\n    if (id) {\n      let instance = await env.MY_WORKFLOW.get(id);\n      return Response.json({\n        status: await instance.status(),\n      });\n    }\n\n// Spawn a new instance and return the ID and status\n    let instance = await env.MY_WORKFLOW.create();\n    return Response.json({\n      id: instance.id,\n      details: await instance.status(),\n    });\n  },\n};\nsh\nnpx wrangler@latest deploy\nsh",
  "code_samples": [
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "Local development sessions create a standalone, local-only environment that mirrors the production environment Workflows runs in so you can test your Workflows *before* you deploy to production.\n\nRefer to the [`wrangler dev` documentation](https://developers.cloudflare.com/workers/wrangler/commands/#dev) to learn more about how to configure a local development session.\n\n## Known Issues\n\nWorkflows are not supported as [remote bindings](https://developers.cloudflare.com/workers/development-testing/#remote-bindings) or when using `npx wrangler dev --remote`.\n\nWrangler Workflows commands `npx wrangler workflow [cmd]` are not supported for local development, as they target production API.\n\n</page>\n\n<page>\n---\ntitle: Rules of Workflows Â· Cloudflare Workflows docs\ndescription: A Workflow contains one or more steps. Each step is a\n  self-contained, individually retriable component of a Workflow. Steps may emit\n  (optional) state that allows a Workflow to persist and continue from that\n  step, even if a Workflow fails due to a network or infrastructure issue.\nlastUpdated: 2025-12-12T19:04:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/build/rules-of-workflows/\n  md: https://developers.cloudflare.com/workflows/build/rules-of-workflows/index.md\n---\n\nA Workflow contains one or more steps. Each step is a self-contained, individually retriable component of a Workflow. Steps may emit (optional) state that allows a Workflow to persist and continue from that step, even if a Workflow fails due to a network or infrastructure issue.\n\nThis is a small guidebook on how to build more resilient and correct Workflows.\n\n### Ensure API/Binding calls are idempotent\n\nBecause a step might be retried multiple times, your steps should (ideally) be idempotent. For context, idempotency is a logical property where the operation (in this case a step), can be applied multiple times without changing the result beyond the initial application.\n\nAs an example, let us assume you have a Workflow that charges your customers, and you really do not want to charge them twice by accident. Before charging them, you should check if they were already charged:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Note\n\nGuaranteeing idempotency might be optional in your specific use-case and implementation, but we recommend that you always try to guarantee it.\n\n### Make your steps granular\n\nSteps should be as self-contained as possible. This allows your own logic to be more durable in case of failures in third-party APIs, network errors, and so on.\n\nYou can also think of it as a transaction, or a unit of work.\n\n* âœ… Minimize the number of API/binding calls per step (unless you need multiple calls to prove idempotency).\n\n- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "Otherwise, your entire Workflow might not be as durable as you might think, and you may encounter some undefined behaviour. You can avoid them by following the rules below:\n\n* ðŸ”´ Do not encapsulate your entire logic in one single step.\n* ðŸ”´ Do not call separate services in the same step (unless you need it to prove idempotency).\n* ðŸ”´ Do not make too many service calls in the same step (unless you need it to prove idempotency).\n* ðŸ”´ Do not do too much CPU-intensive work inside a single step - sometimes the engine may have to restart, and it will start over from the beginning of that step.\n\n- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Do not rely on state outside of a step\n\nWorkflows may hibernate and lose all in-memory state. This will happen when engine detects that there is no pending work and can hibernate until it needs to wake-up (because of a sleep, retry, or event).\n\nThis means that you should not store state outside of a step:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Instead, you should build top-level state exclusively comprised of `step.do` returns:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Avoid doing side effects outside of a `step.do`\n\nIt is not recommended to write code with any side effects outside of steps, unless you would like it to be repeated, because the Workflow engine may restart while an instance is running. If the engine restarts, the step logic will be preserved, but logic outside of the steps may be duplicated.\n\nFor example, a `console.log()` outside of workflow steps may cause the logs to print twice when the engine restarts.\n\nHowever, logic involving non-serializable resources, like a database connection, should be executed outside of steps. Operations ouside of a `step.do` might be repeated more than once, due to the nature of the Workflows' instance lifecycle.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Do not mutate your incoming events\n\nThe `event` passed to your Workflow's `run` method is immutable: changes you make to the event are not persisted across steps and/or Workflow restarts.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Name steps deterministically\n\nSteps should be named deterministically (that is, not using the current date/time, randomness, etc). This ensures that their state is cached, and prevents the step from being rerun unnecessarily. Step names act as the \"cache key\" in your Workflow.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Take care with `Promise.race()` and `Promise.any()`\n\nWorkflows allows the usage steps within the `Promise.race()` or `Promise.any()` methods as a way to achieve concurrent steps execution. However, some considerations must be taken.\n\nDue to the nature of Workflows' instance lifecycle, and given that a step inside a Promise will run until it finishes, the step that is returned during the first passage may not be the actual cached step, as [steps are cached by their names](#name-steps-deterministically).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "To ensure consistency, we suggest to surround the `Promise.race()` or `Promise.any()` within a `step.do()`, as this will ensure caching consistency across multiple passages.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Instance IDs are unique\n\nWorkflow [instance IDs](https://developers.cloudflare.com/workflows/build/workers-api/#workflowinstance) are unique per Workflow. The ID is the unique identifier that associates logs, metrics, state and status of a run to a specific instance, even after completion. Allowing ID re-use would make it hard to understand if a Workflow instance ID referred to an instance that run yesterday, last week or today.\n\nIt would also present a problem if you wanted to run multiple different Workflow instances with different [input parameters](https://developers.cloudflare.com/workflows/build/events-and-parameters/) for the same user ID, as you would immediately need to determine a new ID mapping.\n\nIf you need to associate multiple instances with a specific user, merchant or other \"customer\" ID in your system, consider using a composite ID or using randomly generated IDs and storing the mapping in a database like [D1](https://developers.cloudflare.com/d1/).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### `await` your steps\n\nWhen calling `step.do` or `step.sleep`, use `await` to avoid introducing bugs and race conditions into your Workflow code.\n\nIf you don't call `await step.do` or `await step.sleep`, you create a dangling Promise. This occurs when a Promise is created but not properly `await`ed, leading to potential bugs and race conditions.\n\nThis happens when you do not use the `await` keyword or fail to chain `.then()` methods to handle the result of a Promise. For example, calling `fetch(GITHUB_URL)` without awaiting its response will cause subsequent code to execute immediately, regardless of whether the fetch completed. This can cause issues like premature logging, exceptions being swallowed (and not terminating the Workflow), and lost return values (state).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Use conditional logic carefully\n\nYou can use `if` statements, loops, and other control flow outside of steps. However, conditions must be based on **deterministic values** â€” either values from `event.payload` or return values from previous steps. Non-deterministic conditions (such as `Math.random()` or `Date.now()`) outside of steps can cause unexpected behavior if the Workflow restarts.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Batch multiple Workflow invocations\n\nWhen creating multiple Workflow instances, use the [`createBatch`](https://developers.cloudflare.com/workflows/build/workers-api/#createBatch) method to batch the invocations together. This allows you to create multiple Workflow instances in a single request, which will reduce the number of requests made to the Workflows API and increase the number of instances you can create per minute.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Keep step return values under 1 MiB\n\nEach step can persist up to 1 MiB (2^20 bytes) of state. If your step returns data exceeding this limit, the step will fail. This is a common issue when fetching large API responses or processing large files.\n\nTo work around this limit, store large data externally (for example, in R2 or KV) and return only a reference:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Sleeping and retrying Â· Cloudflare Workflows docs\ndescription: This guide details how to sleep a Workflow and/or configure retries\n  for a Workflow step.\nlastUpdated: 2025-08-12T10:10:23.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/build/sleeping-and-retrying/\n  md: https://developers.cloudflare.com/workflows/build/sleeping-and-retrying/index.md\n---\n\nThis guide details how to sleep a Workflow and/or configure retries for a Workflow step.\n\n## Sleep a Workflow\n\nYou can set a Workflow to sleep as an explicit step, which can be useful when you want a Workflow to wait, schedule work ahead, or pause until an input or other external state is ready.\n\nNote\n\nA Workflow instance that is resuming from sleep will take priority over newly scheduled (queued) instances. This helps ensure that older Workflow instances can run to completion and are not blocked by newer instances.\n\n### Sleep for a relative period\n\nUse `step.sleep` to have a Workflow sleep for a relative period of time:",
      "language": "unknown"
    },
    {
      "code": "The second argument to `step.sleep` accepts both `number` (milliseconds) or a human-readable format, such as \"1 minute\" or \"26 hours\". The accepted units for `step.sleep` when used this way are as follows:",
      "language": "unknown"
    },
    {
      "code": "### Sleep until a fixed date\n\nUse `step.sleepUntil` to have a Workflow sleep to a specific `Date`: this can be useful when you have a timestamp from another system or want to \"schedule\" work to occur at a specific time (e.g. Sunday, 9AM UTC).",
      "language": "unknown"
    },
    {
      "code": "You can also provide a UNIX timestamp (milliseconds since the UNIX epoch) directly to `sleepUntil`.\n\n## Retry steps\n\nEach call to `step.do` in a Workflow accepts an optional `StepConfig`, which allows you define the retry behaviour for that step.\n\nIf you do not provide your own retry configuration, Workflows applies the following defaults:",
      "language": "unknown"
    },
    {
      "code": "When providing your own `StepConfig`, you can configure:\n\n* The total number of attempts to make for a step (accepts `Infinity` for unlimited retries)\n* The delay between attempts (accepts both `number` (ms) or a human-readable format)\n* What backoff algorithm to apply between each attempt: any of `constant`, `linear`, or `exponential`\n* When to timeout (in duration) before considering the step as failed (including during a retry attempt, as the timeout is set per attempt)\n\nFor example, to limit a step to 10 retries and have it apply an exponential delay (starting at 10 seconds) between each attempt, you would pass the following configuration as an optional object to `step.do`:",
      "language": "unknown"
    },
    {
      "code": "## Force a Workflow instance to fail\n\nYou can also force a Workflow instance to fail and *not* retry by throwing a `NonRetryableError` from within the step.\n\nThis can be useful when you detect a terminal (permanent) error from an upstream system (such as an authentication failure) or other errors where retrying would not help.",
      "language": "unknown"
    },
    {
      "code": "The Workflow instance itself will fail immediately, no further steps will be invoked, and the Workflow will not be retried.\n\n## Catch Workflow errors\n\nAny uncaught exceptions that propagate to the top level, or any steps that reach their retry limit, will cause the Workflow to end execution in an `Errored` state.\n\nIf you want to avoid this, you can catch exceptions emitted by a `step`. This can be useful if you need to trigger clean-up tasks or have conditional logic that triggers additional steps.\n\nTo allow the Workflow to continue its execution, surround the intended steps that are allowed to fail with a `try-catch` block.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Test Workflows Â· Cloudflare Workflows docs\nlastUpdated: 2025-09-12T15:23:11.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/build/test-workflows/\n  md: https://developers.cloudflare.com/workflows/build/test-workflows/index.md\n---\n\n\n</page>\n\n<page>\n---\ntitle: Trigger Workflows Â· Cloudflare Workflows docs\ndescription: \"You can trigger Workflows both programmatically and via the\n  Workflows APIs, including:\"\nlastUpdated: 2025-12-12T19:04:56.000Z\nchatbotDeprioritize: false\ntags: Bindings\nsource_url:\n  html: https://developers.cloudflare.com/workflows/build/trigger-workflows/\n  md: https://developers.cloudflare.com/workflows/build/trigger-workflows/index.md\n---\n\nYou can trigger Workflows both programmatically and via the Workflows APIs, including:\n\n1. With [Workers](https://developers.cloudflare.com/workers) via HTTP requests in a `fetch` handler, or bindings from a `queue` or `scheduled` handler\n2. Using the [Workflows REST API](https://developers.cloudflare.com/api/resources/workflows/methods/list/)\n3. Via the [wrangler CLI](https://developers.cloudflare.com/workers/wrangler/commands/#workflows) in your terminal\n\n## Workers API (Bindings)\n\nYou can interact with Workflows programmatically from any Worker script by creating a binding to a Workflow. A Worker can bind to multiple Workflows, including Workflows defined in other Workers projects (scripts) within your account.\n\nYou can interact with a Workflow:\n\n* Directly over HTTP via the [`fetch`](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) handler\n* From a [Queue consumer](https://developers.cloudflare.com/queues/configuration/javascript-apis/#consumer) inside a `queue` handler\n* From a [Cron Trigger](https://developers.cloudflare.com/workers/configuration/cron-triggers/) inside a `scheduled` handler\n* Within a [Durable Object](https://developers.cloudflare.com/durable-objects/)\n\nNote\n\nNew to Workflows? Start with the [Workflows tutorial](https://developers.cloudflare.com/workflows/get-started/guide/) to deploy your first Workflow and familiarize yourself with Workflows concepts.\n\nTo bind to a Workflow from your Workers code, you need to define a [binding](https://developers.cloudflare.com/workers/wrangler/configuration/) to a specific Workflow. For example, to bind to the Workflow defined in the [get started guide](https://developers.cloudflare.com/workflows/get-started/guide/), you would configure the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) with the below:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "The `binding = \"MY_WORKFLOW\"` line defines the JavaScript variable that our Workflow methods are accessible on, including `create` (which triggers a new instance) or `get` (which returns the status of an existing instance).\n\nThe following example shows how you can manage Workflows from within a Worker, including:\n\n* Retrieving the status of an existing Workflow instance by its ID\n* Creating (triggering) a new Workflow instance\n* Returning the status of a given instance ID",
      "language": "unknown"
    },
    {
      "code": "### Inspect a Workflow's status\n\nYou can inspect the status of any running Workflow instance by calling `status` against a specific instance ID. This allows you to programmatically inspect whether an instance is queued (waiting to be scheduled), actively running, paused, or errored.",
      "language": "unknown"
    },
    {
      "code": "The possible values of status are as follows:",
      "language": "unknown"
    },
    {
      "code": "### Explicitly pause a Workflow\n\nYou can explicitly pause a Workflow instance (and later resume it) by calling `pause` against a specific instance ID.",
      "language": "unknown"
    },
    {
      "code": "### Resume a Workflow\n\nYou can resume a paused Workflow instance by calling `resume` against a specific instance ID.",
      "language": "unknown"
    },
    {
      "code": "Calling `resume` on an instance that is not currently paused will have no effect.\n\n### Stop a Workflow\n\nYou can stop/terminate a Workflow instance by calling `terminate` against a specific instance ID.",
      "language": "unknown"
    },
    {
      "code": "Once stopped/terminated, the Workflow instance *cannot* be resumed.\n\n### Restart a Workflow",
      "language": "unknown"
    },
    {
      "code": "Restarting an instance will immediately cancel any in-progress steps, erase any intermediate state, and treat the Workflow as if it was run for the first time.\n\n### Trigger a Workflow from another Workflow\n\nYou can create a new Workflow instance from within a step of another Workflow. The parent Workflow will not block waiting for the child Workflow to complete â€” it continues execution immediately after the child instance is successfully created.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "If the child Workflow fails to start, the step will fail and be retried according to your retry configuration. Once the child instance is successfully created, it runs independently from the parent.\n\n## REST API (HTTP)\n\nRefer to the [Workflows REST API documentation](https://developers.cloudflare.com/api/resources/workflows/subresources/instances/methods/create/).\n\n## Command line (CLI)\n\nRefer to the [CLI quick start](https://developers.cloudflare.com/workflows/get-started/cli-quick-start/) to learn more about how to manage and trigger Workflows via the command-line.\n\n</page>\n\n<page>\n---\ntitle: Workers API Â· Cloudflare Workflows docs\ndescription: This guide details the Workflows API within Cloudflare Workers,\n  including methods, types, and usage examples.\nlastUpdated: 2025-11-28T15:38:15.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/build/workers-api/\n  md: https://developers.cloudflare.com/workflows/build/workers-api/index.md\n---\n\nThis guide details the Workflows API within Cloudflare Workers, including methods, types, and usage examples.\n\n## WorkflowEntrypoint\n\nThe `WorkflowEntrypoint` class is the core element of a Workflow definition. A Workflow must extend this class and define a `run` method with at least one `step` call to be considered a valid Workflow.",
      "language": "unknown"
    },
    {
      "code": "### run\n\n* `run(event: WorkflowEvent<T>, step: WorkflowStep): Promise<T>`\n\n  * `event` - the event passed to the Workflow, including an optional `payload` containing data (parameters)\n  * `step` - the `WorkflowStep` type that provides the step methods for your Workflow\n\nThe `run` method can optionally return data, which is available when querying the instance status via the [Workers API](https://developers.cloudflare.com/workflows/build/workers-api/#instancestatus), [REST API](https://developers.cloudflare.com/api/resources/workflows/subresources/instances/subresources/status/) and the Workflows dashboard. This can be useful if your Workflow is computing a result, returning the key to data stored in object storage, or generating some kind of identifier you need to act on.",
      "language": "unknown"
    },
    {
      "code": "The `WorkflowEvent` type accepts an optional [type parameter](https://www.typescriptlang.org/docs/handbook/2/generics.html#working-with-generic-type-variables) that allows you to provide a type for the `payload` property within the `WorkflowEvent`.\n\nRefer to the [events and parameters](https://developers.cloudflare.com/workflows/build/events-and-parameters/) documentation for how to handle events within your Workflow code.\n\nFinally, any JS control-flow primitive (if conditions, loops, try-catches, promises, etc) can be used to manage steps inside the `run` method.\n\n## WorkflowEvent",
      "language": "unknown"
    },
    {
      "code": "* The `WorkflowEvent` is the first argument to a Workflow's `run` method, and includes an optional `payload` parameter and a `timestamp` property.\n\n  * `payload` - a default type of `any` or type `T` if a type parameter is provided.\n  * `timestamp` - a `Date` object set to the time the Workflow instance was created (triggered).\n  * `instanceId` - the ID of the associated instance.\n\nRefer to the [events and parameters](https://developers.cloudflare.com/workflows/build/events-and-parameters/) documentation for how to handle events within your Workflow code.\n\n## WorkflowStep\n\n### step\n\n* `step.do(name: string, callback: (): RpcSerializable): Promise<T>`\n\n* `step.do(name: string, config?: WorkflowStepConfig, callback: (): RpcSerializable): Promise<T>`\n\n  * `name` - the name of the step, up to 256 characters.\n  * `config` (optional) - an optional `WorkflowStepConfig` for configuring [step specific retry behaviour](https://developers.cloudflare.com/workflows/build/sleeping-and-retrying/).\n  * `callback` - an asynchronous function that optionally returns serializable state for the Workflow to persist.\n\nReturning state\n\nWhen returning state from a `step`, ensure that the object you return is *serializable*.\n\nPrimitive types like `string`, `number`, and `boolean`, along with composite structures such as `Array` and `Object` (provided they only contain serializable values), can be serialized.\n\nObjects that include `Function` or `Symbol` types, and objects with circular references, cannot be serialized and the Workflow instance will throw an error if objects with those types is returned.\n\n* `step.sleep(name: string, duration: WorkflowDuration): Promise<void>`\n\n  * `name` - the name of the step.\n  * `duration` - the duration to sleep until, in either seconds or as a `WorkflowDuration` compatible string.\n  * Refer to the [documentation on sleeping and retrying](https://developers.cloudflare.com/workflows/build/sleeping-and-retrying/) to learn more about how Workflows are retried.\n\n- `step.sleepUntil(name: string, timestamp: Date | number): Promise<void>`\n\n  * `name` - the name of the step.\n  * `timestamp` - a JavaScript `Date` object or seconds from the Unix epoch to sleep the Workflow instance until.\n\nNote\n\n`step.sleep` and `step.sleepUntil` methods do not count towards the maximum Workflow steps limit.\n\nMore information about the limits imposed on Workflow can be found in the [Workflows limits documentation](https://developers.cloudflare.com/workflows/reference/limits/).\n\n* `step.waitForEvent(name: string, options: ): Promise<void>`\n\n  * `name` - the name of the step.\n  * `options` - an object with properties for `type` (up to 100 characters [1](#user-content-fn-1)), which determines which event type this `waitForEvent` call will match on when calling `instance.sendEvent`, and an optional `timeout` property, which defines how long the `waitForEvent` call will block for before throwing a timeout exception. The default timeout is 24 hours.\n\n- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "Review the documentation on [events and parameters](https://developers.cloudflare.com/workflows/build/events-and-parameters/) to learn how to send events to a running Workflow instance.\n\n## WorkflowStepConfig",
      "language": "unknown"
    },
    {
      "code": "* A `WorkflowStepConfig` is an optional argument to the `do` method of a `WorkflowStep` and defines properties that allow you to configure the retry behaviour of that step.\n\nRefer to the [documentation on sleeping and retrying](https://developers.cloudflare.com/workflows/build/sleeping-and-retrying/) to learn more about how Workflows are retried.\n\n## NonRetryableError\n\n* `throw new NonRetryableError(message: string, name string optional)`: NonRetryableError\n\n  * When thrown inside [`step.do()`](https://developers.cloudflare.com/workflows/build/workers-api/#step), this error stops step retries, propagating the error to the top level (the [run](https://developers.cloudflare.com/workflows/build/workers-api/#run) function). Any error not handled at this top level will cause the Workflow instance to fail.\n  * Refer to the [documentation on sleeping and retrying](https://developers.cloudflare.com/workflows/build/sleeping-and-retrying/) to learn more about how Workflows steps are retried.\n\n## Call Workflows from Workers\n\nWorkflows exposes an API directly to your Workers scripts via the [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/#what-is-a-binding) concept. Bindings allow you to securely call a Workflow without having to manage API keys or clients.\n\nYou can bind to a Workflow by defining a `[[workflows]]` binding within your Wrangler configuration.\n\nFor example, to bind to a Workflow called `workflows-starter` and to make it available on the `MY_WORKFLOW` variable to your Worker script, you would configure the following fields within the `[[workflows]]` binding definition:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "### Bind from Pages\n\nYou can bind and trigger Workflows from [Pages Functions](https://developers.cloudflare.com/pages/functions/) by deploying a Workers project with your Workflow definition and then invoking that Worker using [service bindings](https://developers.cloudflare.com/pages/functions/bindings/#service-bindings) or a standard `fetch()` call.\n\nVisit the documentation on [calling Workflows from Pages](https://developers.cloudflare.com/workflows/build/call-workflows-from-pages/) for examples.\n\n### Cross-script calls\n\nYou can also bind to a Workflow that is defined in a different Worker script from the script your Workflow definition is in. To do this, provide the `script_name` key with the name of the script to the `[[workflows]]` binding definition in your Wrangler configuration.\n\nFor example, if your Workflow is defined in a Worker script named `billing-worker`, but you are calling it from your `web-api-worker` script, your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) would resemble the following:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "If you're using TypeScript, run [`wrangler types`](https://developers.cloudflare.com/workers/wrangler/commands/#types) whenever you modify your Wrangler configuration file. This generates types for the `env` object based on your bindings, as well as [runtime types](https://developers.cloudflare.com/workers/languages/typescript/).\n\n## Workflow\n\nNote\n\nEnsure you have a compatibility date `2024-10-22` or later installed when binding to Workflows from within a Workers project.\n\nThe `Workflow` type provides methods that allow you to create, inspect the status, and manage running Workflow instances from within a Worker script. It is part of the generated types produced by [`wrangler types`](https://developers.cloudflare.com/workers/wrangler/commands/#types).",
      "language": "unknown"
    },
    {
      "code": "The `Workflow` type exports the following methods:\n\n### create\n\nCreate (trigger) a new instance of the given Workflow.\n\n* `create(options?: WorkflowInstanceCreateOptions): Promise<WorkflowInstance>`\n  * `options` - optional properties to pass when creating an instance, including a user-provided ID and payload parameters.\n\nAn ID is automatically generated, but a user-provided ID can be specified (up to 100 characters [1](#user-content-fn-1)). This can be useful when mapping Workflows to users, merchants or other identifiers in your system. You can also provide a JSON object as the `params` property, allowing you to pass data for the Workflow instance to act on as its [`WorkflowEvent`](https://developers.cloudflare.com/workflows/build/events-and-parameters/).",
      "language": "unknown"
    },
    {
      "code": "Returns a `WorkflowInstance`.\n\nThrows an error if the provided ID is already used by an existing instance that has not yet passed its [retention limit](https://developers.cloudflare.com/workflows/reference/limits/). To re-run a workflow with the same ID, you can [`restart`](https://developers.cloudflare.com/workflows/build/trigger-workflows/#restart-a-workflow) the existing instance.\n\nWarning\n\nProviding a type parameter does *not* validate that the incoming event matches your type definition. In TypeScript, properties (fields) that do not exist or conform to the type you provided will be dropped. If you need to validate incoming events, we recommend a library such as [zod](https://zod.dev/) or your own validator logic.\n\nYou can also provide a type parameter to the `Workflows` type when creating (triggering) a Workflow instance using the `create` method of the [Workers API](https://developers.cloudflare.com/workflows/build/workers-api/#workflow). Note that this does *not* propagate type information into the Workflow itself, as TypeScript types are a build-time construct. To provide the type of an incoming `WorkflowEvent`, refer to the [TypeScript and type parameters](https://developers.cloudflare.com/workflows/build/events-and-parameters/#typescript-and-type-parameters) section of the Workflows documentation.\n\nTo provide an optional type parameter to the `Workflow`, pass a type argument with your type when defining your Workflow bindings:",
      "language": "unknown"
    },
    {
      "code": "### createBatch\n\nCreate (trigger) a batch of new instance of the given Workflow, up to 100 instances at a time.\n\nThis is useful when you are scheduling multiple instances at once. A call to `createBatch` is treated the same as a call to `create` (for a single instance) and allows you to work within the [instance creation limit](https://developers.cloudflare.com/workflows/reference/limits/).\n\n* `createBatch(batch: WorkflowInstanceCreateOptions[]): Promise<WorkflowInstance[]>`\n  * `batch` - list of Options to pass when creating an instance, including a user-provided ID and payload parameters.\n\nEach element of the `batch` list is expected to include both `id` and `params` properties:",
      "language": "unknown"
    },
    {
      "code": "Returns an array of `WorkflowInstance`.\n\nUnlike [`create`](https://developers.cloudflare.com/workflows/build/workers-api/#create), this operation is idempotent and will not fail if an ID is already in use. If an existing instance with the same ID is still within its [retention limit](https://developers.cloudflare.com/workflows/reference/limits/), it will be skipped and excluded from the returned array.\n\n### get\n\nGet a specific Workflow instance by ID.\n\n* `get(id: string): Promise<WorkflowInstance>`- `id` - the ID of the Workflow instance.\n\nReturns a `WorkflowInstance`. Throws an exception if the instance ID does not exist.",
      "language": "unknown"
    },
    {
      "code": "## WorkflowInstanceCreateOptions\n\nOptional properties to pass when creating an instance.",
      "language": "unknown"
    },
    {
      "code": "## WorkflowInstance\n\nRepresents a specific instance of a Workflow, and provides methods to manage the instance.",
      "language": "unknown"
    },
    {
      "code": "### id\n\nReturn the id of a Workflow.\n\n* `id: string`\n\n### status\n\nReturn the status of a running Workflow instance.\n\n* `status(): Promise<InstanceStatus>`\n\n### pause\n\nPause a running Workflow instance.\n\n* `pause(): Promise<void>`\n\n### resume\n\nResume a paused Workflow instance.\n\n* `resume(): Promise<void>`\n\n### restart\n\nRestart a Workflow instance.\n\n* `restart(): Promise<void>`\n\n### terminate\n\nTerminate a Workflow instance.\n\n* `terminate(): Promise<void>`\n\n### sendEvent\n\n[Send an event](https://developers.cloudflare.com/workflows/build/events-and-parameters/) to a running Workflow instance.\n\n* `sendEvent(): Promise<void>`\n  * `options` - the event `type` (up to 100 characters [1](#user-content-fn-1)) and `payload` to send to the Workflow instance. The `type` must match the `type` in the corresponding `waitForEvent` call in your Workflow.\n\nReturn `void` on success; throws an exception if the Workflow is not running or is an errored state.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "You can call `sendEvent` multiple times, setting the value of the `type` property to match the specific `waitForEvent` calls in your Workflow.\n\nThis allows you to wait for multiple events at once, or use `Promise.race` to wait for multiple events and allow the first event to progress the Workflow.\n\n### InstanceStatus\n\nDetails the status of a Workflow instance.",
      "language": "unknown"
    },
    {
      "code": "## Footnotes\n\n1. Match pattern: `^[a-zA-Z0-9_][a-zA-Z0-9-_]*$` [â†©](#user-content-fnref-1) [â†©2](#user-content-fnref-1-2) [â†©3](#user-content-fnref-1-3)\n\n</page>\n\n<page>\n---\ntitle: Agents Â· Cloudflare Workflows docs\ndescription: Build AI-powered Agents on Cloudflare\nlastUpdated: 2025-01-29T20:30:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/examples/agents/\n  md: https://developers.cloudflare.com/workflows/examples/agents/index.md\n---\n\n\n</page>\n\n<page>\n---\ntitle: Export and save D1 database Â· Cloudflare Workflows docs\ndescription: Send invoice when shopping cart is checked out and paid for\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workflows/examples/backup-d1/\n  md: https://developers.cloudflare.com/workflows/examples/backup-d1/index.md\n---\n\nIn this example, we implement a Workflow periodically triggered by a [Cron Trigger](https://developers.cloudflare.com/workers/configuration/cron-triggers). That Workflow initiates a backup for a D1 database using the REST API, and then stores the SQL dump in an [R2](https://developers.cloudflare.com/r2) bucket.\n\nWhen the Workflow is triggered, it fetches the REST API to initiate an export job for a specific database. Then it fetches the same endpoint to check if the backup job is ready and the SQL dump is available to download.\n\nAs shown in this example, Workflows handles both the responses and failures, thereby removing the burden from the developer. Workflows retries the following steps:\n\n* API calls until it gets a successful response\n* Fetching the backup from the URL provided\n* Saving the file to [R2](https://developers.cloudflare.com/r2)\n\nThe Workflow can run until the backup file is ready, handling all of the possible conditions until it is completed.\n\nThis example provides simplified steps for backing up a [D1](https://developers.cloudflare.com/d1) database to help you understand the possibilities of Workflows. In every step, it uses the [default](https://developers.cloudflare.com/workflows/build/sleeping-and-retrying) sleeping and retrying configuration. In a real-world scenario, more steps and additional logic would likely be needed.",
      "language": "unknown"
    },
    {
      "code": "Here is a minimal package.json:",
      "language": "unknown"
    },
    {
      "code": "Here is a [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Pay cart and send invoice Â· Cloudflare Workflows docs\ndescription: Send invoice when shopping cart is checked out and paid for\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workflows/examples/send-invoices/\n  md: https://developers.cloudflare.com/workflows/examples/send-invoices/index.md\n---\n\nIn this example, we implement a Workflow for an e-commerce website that is triggered every time a shopping cart is created.\n\nOnce a Workflow instance is triggered, it starts polling a [D1](https://developers.cloudflare.com/d1) database for the cart ID until it has been checked out. Once the shopping cart is checked out, we proceed to process the payment with an external provider doing a fetch POST. Finally, assuming everything goes well, we try to send an email using [Email Workers](https://developers.cloudflare.com/email-routing/email-workers/) with the invoice to the customer.\n\nAs you can see, Workflows handles all the different service responses and failures; it will retry D1 until the cart is checked out, retry the payment processor if it fails for some reason, and retry sending the email with the invoice if it can't. The developer doesn't have to care about any of that logic, and the workflow can run for hours, handling all the possible conditions until it is completed.\n\nThis is a simplified example of processing a shopping cart. We would assume more steps and additional logic in a real-life scenario, but this example gives you a good idea of what you can do with Workflows.",
      "language": "unknown"
    },
    {
      "code": "Here's a minimal package.json:",
      "language": "unknown"
    },
    {
      "code": "And finally [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "If you're using TypeScript, run [`wrangler types`](https://developers.cloudflare.com/workers/wrangler/commands/#types) whenever you modify your Wrangler configuration file. This generates types for the `env` object based on your bindings, as well as [runtime types](https://developers.cloudflare.com/workers/languages/typescript/).\n\n</page>\n\n<page>\n---\ntitle: Integrate Workflows with Twilio Â· Cloudflare Workflows docs\ndescription: Integrate Workflows with Twilio. Learn how to receive and send text\n  messages and phone calls via APIs and Webhooks.\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/examples/twilio/\n  md: https://developers.cloudflare.com/workflows/examples/twilio/index.md\n---\n\nUsing the following [repository](https://github.com/craigsdennis/twilio-cloudflare-workflow), learn how to integrate Cloudflare Workflows with Twilio, a popular cloud communications platform that enables developers to integrate messaging, voice, video, and authentication features into applications via APIs. By the end of the video tutorial, you will become familiarized with the process of setting up Cloudflare Workflows to seamlessly interact with Twilio's APIs, enabling you to build interesting communication features directly into your applications.\n\n</page>\n\n<page>\n---\ntitle: Human-in-the-Loop Image Tagging with waitForEvent Â· Cloudflare Workflows docs\ndescription: Human-in-the-loop Workflow with waitForEvent API\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workflows/examples/wait-for-event/\n  md: https://developers.cloudflare.com/workflows/examples/wait-for-event/index.md\n---\n\nThis example demonstrates how to use the `waitForEvent()` API in Cloudflare Workflows to introduce a human-in-the-loop step. The Workflow is triggered by an image upload, during which metadata is stored in a D1 database. The Workflow then waits for user approval, and upon approval, it uses Workers AI to generate image tags, which are stored in the database. An accompanying Next.js frontend application facilitates the image upload and approval process.\n\nNote\n\nThe example on this page includes only a subset of the full implementation. For the complete codebase and deployment instructions, please refer to the [GitHub repository](https://github.com/cloudflare/docs-examples/tree/main/workflows/waitForEvent).\n\n## Overview of the Workflow\n\nIn this Workflow, we simulate a scenario where an uploaded image requires human approval before AI-based processing. An image is uploaded to R2, then Workflow performs the following steps:\n\n1. Stores image metadata in a D1 database.\n2. Pauses execution using `waitForEvent()` and waits for an external event sent from the Next.js frontend, indicating approval or rejection.\n3. If approved, the Workflow uses Workers AI to generate image tags and stores the tags in the D1 database.\n4. If rejected, the Workflow ends without further action.\n\nThis pattern is useful in scenarios where certain operations should not proceed without explicit human consent, adding an extra layer of control and safety.\n\n## Frontend Integration\n\nThis example includes a Next.js frontend application that facilitates the image upload and approval process. The frontend provides an interface for uploading images, reviewing them, and approving or rejecting them. Upon image upload, the application triggers the Cloudflare Workflow, which then manages the subsequent steps, including waiting for user approval and performing AI-based image tagging upon approval.\n\nRefer to the `/nextjs-workflow-frontend` folder in the [GitHub repository](https://github.com/cloudflare/docs-examples/tree/main/workflows/waitForEvent) for the complete frontend implementation and deployment details.\n\n## Workflow index.ts\n\nThe `index.ts` file defines the core logic of the Cloudflare Workflow responsible for handling image uploads, awaiting human approval, and performing AI-based image tagging upon approval. It extends the `WorkflowEntrypoint` class and implements the `run()` method.\n\nFor the complete implementation of the `index.ts` file, please refer to the [GitHub repository](https://github.com/cloudflare/docs-examples/blob/main/workflows/waitForEvent/workflow/src/index.ts).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "## Workflow wrangler.jsonc\n\nThe Workflow configuration is defined in the `wrangler.jsonc` file. This file includes bindings for the R2 bucket, D1 database, Workers AI, and the Workflow itself. Ensure that all necessary bindings and environment variables are correctly set up to match your Cloudflare account and services.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "For access to the codebase, deployment instructions, and reference architecture, please visit the [GitHub repository](https://github.com/cloudflare/docs-examples/tree/main/workflows/waitForEvent). This resource provides all the necessary tools and information to effectively implement the Workflow and Next.js frontend application.\n\n</page>\n\n<page>\n---\ntitle: CLI quick start Â· Cloudflare Workflows docs\ndescription: Workflows allow you to build durable, multi-step applications using\n  the Workers platform. A Workflow can automatically retry, persist state, run\n  for hours or days, and coordinate between third-party APIs.\nlastUpdated: 2025-10-24T20:45:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workflows/get-started/cli-quick-start/\n  md: https://developers.cloudflare.com/workflows/get-started/cli-quick-start/index.md\n---\n\nWorkflows allow you to build durable, multi-step applications using the Workers platform. A Workflow can automatically retry, persist state, run for hours or days, and coordinate between third-party APIs.\n\nYou can build Workflows to post-process file uploads to [R2 object storage](https://developers.cloudflare.com/r2/), automate generation of [Workers AI](https://developers.cloudflare.com/workers-ai/) embeddings into a [Vectorize](https://developers.cloudflare.com/vectorize/) vector database, or to trigger user lifecycle emails using your favorite email API.\n\n## Prerequisites\n\nWarning\n\nThis guide is for users who are already familiar with Cloudflare Workers the [durable execution](https://developers.cloudflare.com/workflows/reference/glossary/) programming model it enables.\n\nIf you are new to either, we recommend the [introduction to Workflows](https://developers.cloudflare.com/workflows/get-started/guide/) guide, which walks you through how a Workflow is defined, how to persist state, and how to deploy and run your first Workflow.\n\n1. Sign up for a [Cloudflare account](https://dash.cloudflare.com/sign-up/workers-and-pages).\n2. Install [`Node.js`](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).\n\nNode.js version manager\n\nUse a Node version manager like [Volta](https://volta.sh/) or [nvm](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node.js versions. [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), discussed later in this guide, requires a Node version of `16.17.0` or later.\n\n## 1. Create a Workflow\n\nWorkflows are defined as part of a Worker script.\n\nTo create a Workflow, use the `create cloudflare` (C3) CLI tool, specifying the Workflows starter template:",
      "language": "unknown"
    },
    {
      "code": "This will create a new folder called `workflows-tutorial`, which contains two files:\n\n* `src/index.ts` - this is where your Worker script, including your Workflows definition, is defined.\n* wrangler.jsonc - the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) for your Workers project and your Workflow.\n\nOpen the `src/index.ts` file in your text editor. This file contains the following code, which is the most basic instance of a Workflow definition:",
      "language": "unknown"
    },
    {
      "code": "Specifically, the code above:\n\n1. Extends the Workflows base class (`WorkflowsEntrypoint`) and defines a `run` method for our Workflow.\n2. Passes in our `Params` type as a [type parameter](https://developers.cloudflare.com/workflows/build/events-and-parameters/) so that events that trigger our Workflow are typed.\n3. Defines several steps that return state.\n4. Defines a custom retry configuration for a step.\n5. Binds to the Workflow from a Worker's `fetch` handler so that we can create (trigger) instances of our Workflow via a HTTP call.\n\nYou can edit this Workflow by adding (or removing) additional `step` calls, changing the retry configuration, and/or making your own API calls. This Workflow template is designed to illustrate some of Workflows APIs.\n\n## 2. Deploy a Workflow\n\nWorkflows are deployed via [`wrangler`](https://developers.cloudflare.com/workers/wrangler/install-and-update/), which is installed when you first ran `npm create cloudflare` above. Workflows are Worker scripts, and are deployed the same way:",
      "language": "unknown"
    },
    {
      "code": "Note\n\nWorkflows cannot be deployed to Workers for Platforms namespaces, as Workflows do not support Workers for Platforms.\n\n## 3. Run a Workflow\n\nYou can run a Workflow via the `wrangler` CLI, via a Worker binding, or via the Workflows [REST API](https://developers.cloudflare.com/api/resources/workflows/methods/list/).\n\n### `wrangler` CLI",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Known Issues",
      "id": "known-issues"
    },
    {
      "level": "h3",
      "text": "Ensure API/Binding calls are idempotent",
      "id": "ensure-api/binding-calls-are-idempotent"
    },
    {
      "level": "h3",
      "text": "Make your steps granular",
      "id": "make-your-steps-granular"
    },
    {
      "level": "h3",
      "text": "Do not rely on state outside of a step",
      "id": "do-not-rely-on-state-outside-of-a-step"
    },
    {
      "level": "h3",
      "text": "Avoid doing side effects outside of a `step.do`",
      "id": "avoid-doing-side-effects-outside-of-a-`step.do`"
    },
    {
      "level": "h3",
      "text": "Do not mutate your incoming events",
      "id": "do-not-mutate-your-incoming-events"
    },
    {
      "level": "h3",
      "text": "Name steps deterministically",
      "id": "name-steps-deterministically"
    },
    {
      "level": "h3",
      "text": "Take care with `Promise.race()` and `Promise.any()`",
      "id": "take-care-with-`promise.race()`-and-`promise.any()`"
    },
    {
      "level": "h3",
      "text": "Instance IDs are unique",
      "id": "instance-ids-are-unique"
    },
    {
      "level": "h3",
      "text": "`await` your steps",
      "id": "`await`-your-steps"
    },
    {
      "level": "h3",
      "text": "Use conditional logic carefully",
      "id": "use-conditional-logic-carefully"
    },
    {
      "level": "h3",
      "text": "Batch multiple Workflow invocations",
      "id": "batch-multiple-workflow-invocations"
    },
    {
      "level": "h3",
      "text": "Keep step return values under 1 MiB",
      "id": "keep-step-return-values-under-1-mib"
    },
    {
      "level": "h2",
      "text": "Sleep a Workflow",
      "id": "sleep-a-workflow"
    },
    {
      "level": "h3",
      "text": "Sleep for a relative period",
      "id": "sleep-for-a-relative-period"
    },
    {
      "level": "h3",
      "text": "Sleep until a fixed date",
      "id": "sleep-until-a-fixed-date"
    },
    {
      "level": "h2",
      "text": "Retry steps",
      "id": "retry-steps"
    },
    {
      "level": "h2",
      "text": "Force a Workflow instance to fail",
      "id": "force-a-workflow-instance-to-fail"
    },
    {
      "level": "h2",
      "text": "Catch Workflow errors",
      "id": "catch-workflow-errors"
    },
    {
      "level": "h2",
      "text": "Workers API (Bindings)",
      "id": "workers-api-(bindings)"
    },
    {
      "level": "h3",
      "text": "Inspect a Workflow's status",
      "id": "inspect-a-workflow's-status"
    },
    {
      "level": "h3",
      "text": "Explicitly pause a Workflow",
      "id": "explicitly-pause-a-workflow"
    },
    {
      "level": "h3",
      "text": "Resume a Workflow",
      "id": "resume-a-workflow"
    },
    {
      "level": "h3",
      "text": "Stop a Workflow",
      "id": "stop-a-workflow"
    },
    {
      "level": "h3",
      "text": "Restart a Workflow",
      "id": "restart-a-workflow"
    },
    {
      "level": "h3",
      "text": "Trigger a Workflow from another Workflow",
      "id": "trigger-a-workflow-from-another-workflow"
    },
    {
      "level": "h2",
      "text": "REST API (HTTP)",
      "id": "rest-api-(http)"
    },
    {
      "level": "h2",
      "text": "Command line (CLI)",
      "id": "command-line-(cli)"
    },
    {
      "level": "h2",
      "text": "WorkflowEntrypoint",
      "id": "workflowentrypoint"
    },
    {
      "level": "h3",
      "text": "run",
      "id": "run"
    },
    {
      "level": "h2",
      "text": "WorkflowEvent",
      "id": "workflowevent"
    },
    {
      "level": "h2",
      "text": "WorkflowStep",
      "id": "workflowstep"
    },
    {
      "level": "h3",
      "text": "step",
      "id": "step"
    },
    {
      "level": "h2",
      "text": "WorkflowStepConfig",
      "id": "workflowstepconfig"
    },
    {
      "level": "h2",
      "text": "NonRetryableError",
      "id": "nonretryableerror"
    },
    {
      "level": "h2",
      "text": "Call Workflows from Workers",
      "id": "call-workflows-from-workers"
    },
    {
      "level": "h3",
      "text": "Bind from Pages",
      "id": "bind-from-pages"
    },
    {
      "level": "h3",
      "text": "Cross-script calls",
      "id": "cross-script-calls"
    },
    {
      "level": "h2",
      "text": "Workflow",
      "id": "workflow"
    },
    {
      "level": "h3",
      "text": "create",
      "id": "create"
    },
    {
      "level": "h3",
      "text": "createBatch",
      "id": "createbatch"
    },
    {
      "level": "h3",
      "text": "get",
      "id": "get"
    },
    {
      "level": "h2",
      "text": "WorkflowInstanceCreateOptions",
      "id": "workflowinstancecreateoptions"
    },
    {
      "level": "h2",
      "text": "WorkflowInstance",
      "id": "workflowinstance"
    },
    {
      "level": "h3",
      "text": "id",
      "id": "id"
    },
    {
      "level": "h3",
      "text": "status",
      "id": "status"
    },
    {
      "level": "h3",
      "text": "pause",
      "id": "pause"
    },
    {
      "level": "h3",
      "text": "resume",
      "id": "resume"
    },
    {
      "level": "h3",
      "text": "restart",
      "id": "restart"
    },
    {
      "level": "h3",
      "text": "terminate",
      "id": "terminate"
    },
    {
      "level": "h3",
      "text": "sendEvent",
      "id": "sendevent"
    },
    {
      "level": "h3",
      "text": "InstanceStatus",
      "id": "instancestatus"
    },
    {
      "level": "h2",
      "text": "Footnotes",
      "id": "footnotes"
    },
    {
      "level": "h2",
      "text": "Overview of the Workflow",
      "id": "overview-of-the-workflow"
    },
    {
      "level": "h2",
      "text": "Frontend Integration",
      "id": "frontend-integration"
    },
    {
      "level": "h2",
      "text": "Workflow index.ts",
      "id": "workflow-index.ts"
    },
    {
      "level": "h2",
      "text": "Workflow wrangler.jsonc",
      "id": "workflow-wrangler.jsonc"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Create a Workflow",
      "id": "1.-create-a-workflow"
    },
    {
      "level": "h2",
      "text": "2. Deploy a Workflow",
      "id": "2.-deploy-a-workflow"
    },
    {
      "level": "h2",
      "text": "3. Run a Workflow",
      "id": "3.-run-a-workflow"
    },
    {
      "level": "h3",
      "text": "`wrangler` CLI",
      "id": "`wrangler`-cli"
    }
  ],
  "url": "llms-txt#start-a-local-dev-session:",
  "links": []
}