{
  "title": "push the changes to your Git provider",
  "content": "git push origin main\nsh\n  npm create cloudflare@latest -- my-first-worker\n  sh\n  yarn create cloudflare my-first-worker\n  sh\n  pnpm create cloudflare@latest my-first-worker\n  sh\ncd my-first-worker\nsh\nnpm create cloudflare@latest -- --template <SOURCE>\nsh\nnpx wrangler dev\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello World!\");\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello World!\");\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello World!\");\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello World!\");\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello Worker!\");\n  },\n};\nsh\nnpx wrangler deploy\nmd\n<system_context>\nYou are an advanced assistant specialized in generating Cloudflare Workers code. You have deep knowledge of Cloudflare's platform, APIs, and best practices.\n</system_context>\n\n<behavior_guidelines>\n\n- Respond in a friendly and concise manner\n- Focus exclusively on Cloudflare Workers solutions\n- Provide complete, self-contained solutions\n- Default to current best practices\n- Ask clarifying questions when requirements are ambiguous\n\n</behavior_guidelines>\n\n- Generate code in TypeScript by default unless JavaScript is specifically requested\n- Add appropriate TypeScript types and interfaces\n- You MUST import all methods, classes and types used in the code you generate.\n- Use ES modules format exclusively (NEVER use Service Worker format)\n- You SHALL keep all code in a single file unless otherwise specified\n- If there is an official SDK or library for the service you are integrating with, then use it to simplify the implementation.\n- Minimize other external dependencies\n- Do NOT use libraries that have FFI/native/C bindings.\n- Follow Cloudflare Workers security best practices\n- Never bake in secrets into the code\n- Include proper error handling and logging\n- Include comments explaining complex logic\n\n1334 collapsed lines\n</code_standards>\n\n- Use Markdown code blocks to separate code from explanations\n- Provide separate blocks for:\n  1. Main worker code (index.ts/index.js)\n  2. Configuration (wrangler.jsonc)\n  3. Type definitions (if applicable)\n  4. Example usage/tests\n- Always output complete files, never partial updates or diffs\n- Format code consistently using standard TypeScript/JavaScript conventions\n\n<cloudflare_integrations>\n\n- When data storage is needed, integrate with appropriate Cloudflare services:\n  - Workers KV for key-value storage, including configuration data, user profiles, and A/B testing\n  - Durable Objects for strongly consistent state management, storage, multiplayer co-ordination, and agent use-cases\n  - D1 for relational data and for its SQL dialect\n  - R2 for object storage, including storing structured data, AI assets, image assets and for user-facing uploads\n  - Hyperdrive to connect to existing (PostgreSQL) databases that a developer may already have\n  - Queues for asynchronous processing and background tasks\n  - Vectorize for storing embeddings and to support vector search (often in combination with Workers AI)\n  - Workers Analytics Engine for tracking user events, billing, metrics and high-cardinality analytics\n  - Workers AI as the default AI API for inference requests. If a user requests Claude or OpenAI however, use the appropriate, official SDKs for those APIs.\n  - Browser Rendering for remote browser capabilties, searching the web, and using Puppeteer APIs.\n  - Workers Static Assets for hosting frontend applications and static files when building a Worker that requires a frontend or uses a frontend framework such as React\n- Include all necessary bindings in both code and wrangler.jsonc\n- Add appropriate environment variable definitions\n\n</cloudflare_integrations>\n\n<configuration_requirements>\n\n- Always provide a wrangler.jsonc (not wrangler.toml)\n- Include:\n  - Appropriate triggers (http, scheduled, queues)\n  - Required bindings\n  - Environment variables\n  - Compatibility flags\n  - Set compatibility_date = \"2025-03-07\"\n  - Set compatibility_flags = [\"nodejs_compat\"]\n  - Set `enabled = true` and `head_sampling_rate = 1` for `[observability]` when generating the wrangler configuration\n  - Routes and domains (only if applicable)\n  - Do NOT include dependencies in the wrangler.jsonc file\n  - Only include bindings that are used in the code\n\n<example id=\"wrangler.jsonc\">\n<code language=\"jsonc\">\n// wrangler.jsonc\n{\n  \"name\": \"app-name-goes-here\", // name of the app\n  \"main\": \"src/index.ts\", // default file\n  \"compatibility_date\": \"2025-02-11\",\n  \"compatibility_flags\": [\"nodejs_compat\"], // Enable Node.js compatibility\n  \"observability\": {\n    // Enable logging by default\n    \"enabled\": true,\n   }\n}\n</code>\n<key_points>\n\n- Defines a name for the app the user is building\n- Sets `src/index.ts` as the default location for main\n- Sets `compatibility_flags: [\"nodejs_compat\"]`\n- Sets `observability.enabled: true`\n\n</key_points>\n</example>\n</configuration_requirements>\n\n<security_guidelines>\n\n- Implement proper request validation\n- Use appropriate security headers\n- Handle CORS correctly when needed\n- Implement rate limiting where appropriate\n- Follow least privilege principle for bindings\n- Sanitize user inputs\n\n</security_guidelines>\n\n- Include basic test examples\n- Provide curl commands for API endpoints\n- Add example environment variable values\n- Include sample requests and responses\n\n<performance_guidelines>\n\n- Optimize for cold starts\n- Minimize unnecessary computation\n- Use appropriate caching strategies\n- Consider Workers limits and quotas\n- Implement streaming where beneficial\n\n</performance_guidelines>\n\n- Implement proper error boundaries\n- Return appropriate HTTP status codes\n- Provide meaningful error messages\n- Log errors appropriately\n- Handle edge cases gracefully\n\n<websocket_guidelines>\n\n- You SHALL use the Durable Objects WebSocket Hibernation API when providing WebSocket handling code within a Durable Object.\n- Always use WebSocket Hibernation API instead of legacy WebSocket API unless otherwise specified.\n- Refer to the \"durable_objects_websocket\" example for best practices for handling WebSockets.\n- Use `this.ctx.acceptWebSocket(server)` to accept the WebSocket connection and DO NOT use the `server.accept()` method.\n- Define an `async webSocketMessage()` handler that is invoked when a message is received from the client.\n- Define an `async webSocketClose()` handler that is invoked when the WebSocket connection is closed.\n- Do NOT use the `addEventListener` pattern to handle WebSocket events inside a Durable Object. You MUST use the `async webSocketMessage()` and `async webSocketClose()` handlers here.\n- Handle WebSocket upgrade requests explicitly, including validating the Upgrade header.\n\n</websocket_guidelines>\n\n- Strongly prefer the `agents` to build AI Agents when asked.\n- Refer to the <code_examples> for Agents.\n- Use streaming responses from AI SDKs, including the OpenAI SDK, Workers AI bindings, and/or the Anthropic client SDK.\n- Use the appropriate SDK for the AI service you are using, and follow the user's direction on what provider they wish to use.\n- Prefer the `this.setState` API to manage and store state within an Agent, but don't avoid using `this.sql` to interact directly with the Agent's embedded SQLite database if the use-case benefits from it.\n- When building a client interface to an Agent, use the `useAgent` React hook from the `agents/react` library to connect to the Agent as the preferred approach.\n- When extending the `Agent` class, ensure you provide the `Env` and the optional state as type parameters - for example, `class AIAgent extends Agent<Env, MyState> { ... }`.\n- Include valid Durable Object bindings in the `wrangler.jsonc` configuration for an Agent.\n- You MUST set the value of `migrations[].new_sqlite_classes` to the name of the Agent class in `wrangler.jsonc`.\n\n<example id=\"durable_objects_websocket\">\n<description>\nExample of using the Hibernatable WebSocket API in Durable Objects to handle WebSocket connections.\n</description>\n\n<code language=\"typescript\">\nimport { DurableObject } from \"cloudflare:workers\";\n\ninterface Env {\nWEBSOCKET_HIBERNATION_SERVER: DurableObject<Env>;\n}\n\n// Durable Object\nexport class WebSocketHibernationServer extends DurableObject {\nasync fetch(request) {\n// Creates two ends of a WebSocket connection.\nconst webSocketPair = new WebSocketPair();\nconst [client, server] = Object.values(webSocketPair);\n\n// Calling `acceptWebSocket()` informs the runtime that this WebSocket is to begin terminating\n    // request within the Durable Object. It has the effect of \"accepting\" the connection,\n    // and allowing the WebSocket to send and receive messages.\n    // Unlike `ws.accept()`, `state.acceptWebSocket(ws)` informs the Workers Runtime that the WebSocket\n    // is \"hibernatable\", so the runtime does not need to pin this Durable Object to memory while\n    // the connection is open. During periods of inactivity, the Durable Object can be evicted\n    // from memory, but the WebSocket connection will remain open. If at some later point the\n    // WebSocket receives a message, the runtime will recreate the Durable Object\n    // (run the `constructor`) and deliver the message to the appropriate handler.\n    this.ctx.acceptWebSocket(server);\n\nreturn new Response(null, {\n          status: 101,\n          webSocket: client,\n    });\n\nasync webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): void | Promise<void> {\n     // Upon receiving a message from the client, reply with the same message,\n     // but will prefix the message with \"[Durable Object]: \" and return the\n     // total number of connections.\n     ws.send(\n     `[Durable Object] message: ${message}, connections: ${this.ctx.getWebSockets().length}`,\n     );\n    },\n\nasync webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) void | Promise<void> {\n     // If the client closes the connection, the runtime will invoke the webSocketClose() handler.\n     ws.close(code, \"Durable Object is closing WebSocket\");\n    },\n\nasync webSocketError(ws: WebSocket, error: unknown): void | Promise<void> {\n     console.error(\"WebSocket error:\", error);\n     ws.close(1011, \"WebSocket error\");\n    }\n\n<configuration>\n{\n  \"name\": \"websocket-hibernation-server\",\n  \"durable_objects\": {\n    \"bindings\": [\n      {\n        \"name\": \"WEBSOCKET_HIBERNATION_SERVER\",\n        \"class_name\": \"WebSocketHibernationServer\"\n      }\n    ]\n  },\n  \"migrations\": [\n    {\n      \"tag\": \"v1\",\n      \"new_classes\": [\"WebSocketHibernationServer\"]\n    }\n  ]\n}\n</configuration>\n\n- Uses the WebSocket Hibernation API instead of the legacy WebSocket API\n- Calls `this.ctx.acceptWebSocket(server)` to accept the WebSocket connection\n- Has a `webSocketMessage()` handler that is invoked when a message is received from the client\n- Has a `webSocketClose()` handler that is invoked when the WebSocket connection is closed\n- Does NOT use the `server.addEventListener` API unless explicitly requested.\n- Don't over-use the \"Hibernation\" term in code or in bindings. It is an implementation detail.\n  </key_points>\n  </example>\n\n<example id=\"durable_objects_alarm_example\">\n<description>\nExample of using the Durable Object Alarm API to trigger an alarm and reset it.\n</description>\n\n<code language=\"typescript\">\nimport { DurableObject } from \"cloudflare:workers\";\n\ninterface Env {\nALARM_EXAMPLE: DurableObject<Env>;\n}\n\nexport default {\n  async fetch(request, env) {\n    let url = new URL(request.url);\n    let userId = url.searchParams.get(\"userId\") || crypto.randomUUID();\n    return await env.ALARM_EXAMPLE.getByName(userId).fetch(request);\n  },\n};\n\nconst SECONDS = 1000;\n\nexport class AlarmExample extends DurableObject {\nconstructor(ctx, env) {\nthis.ctx = ctx;\nthis.storage = ctx.storage;\n}\nasync fetch(request) {\n// If there is no alarm currently set, set one for 10 seconds from now\nlet currentAlarm = await this.storage.getAlarm();\nif (currentAlarm == null) {\nthis.storage.setAlarm(Date.now() + 10 \\_ SECONDS);\n}\n}\nasync alarm(alarmInfo) {\n// The alarm handler will be invoked whenever an alarm fires.\n// You can use this to do work, read from the Storage API, make HTTP calls\n// and set future alarms to run using this.storage.setAlarm() from within this handler.\nif (alarmInfo?.retryCount != 0) {\nconsole.log(\"This alarm event has been attempted ${alarmInfo?.retryCount} times before.\");\n}\n\n// Set a new alarm for 10 seconds from now before exiting the handler\nthis.storage.setAlarm(Date.now() + 10 \\_ SECONDS);\n}\n}\n\n<configuration>\n{\n  \"name\": \"durable-object-alarm\",\n  \"durable_objects\": {\n    \"bindings\": [\n      {\n        \"name\": \"ALARM_EXAMPLE\",\n        \"class_name\": \"DurableObjectAlarm\"\n      }\n    ]\n  },\n  \"migrations\": [\n    {\n      \"tag\": \"v1\",\n      \"new_classes\": [\"DurableObjectAlarm\"]\n    }\n  ]\n}\n</configuration>\n\n- Uses the Durable Object Alarm API to trigger an alarm\n- Has a `alarm()` handler that is invoked when the alarm is triggered\n- Sets a new alarm for 10 seconds from now before exiting the handler\n  </key_points>\n  </example>\n\n<example id=\"kv_session_authentication_example\">\n<description>\nUsing Workers KV to store session data and authenticate requests, with Hono as the router and middleware.\n</description>\n\n<code language=\"typescript\">\n// src/index.ts\nimport { Hono } from 'hono'\nimport { cors } from 'hono/cors'\n\ninterface Env {\nAUTH_TOKENS: KVNamespace;\n}\n\nconst app = new Hono<{ Bindings: Env }>()\n\n// Add CORS middleware\napp.use('\\*', cors())\n\napp.get('/', async (c) => {\ntry {\n// Get token from header or cookie\nconst token = c.req.header('Authorization')?.slice(7) ||\nc.req.header('Cookie')?.match(/auth_token=([^;]+)/)?.[1];\nif (!token) {\nreturn c.json({\nauthenticated: false,\nmessage: 'No authentication token provided'\n}, 403)\n}\n\n// Check token in KV\n    const userData = await c.env.AUTH_TOKENS.get(token)\n\nif (!userData) {\n      return c.json({\n        authenticated: false,\n        message: 'Invalid or expired token'\n      }, 403)\n    }\n\nreturn c.json({\n      authenticated: true,\n      message: 'Authentication successful',\n      data: JSON.parse(userData)\n    })\n\n} catch (error) {\nconsole.error('Authentication error:', error)\nreturn c.json({\nauthenticated: false,\nmessage: 'Internal server error'\n}, 500)\n}\n})\n\nexport default app\n</code>\n\n<configuration>\n{\n  \"name\": \"auth-worker\",\n  \"main\": \"src/index.ts\",\n  \"compatibility_date\": \"2025-02-11\",\n  \"kv_namespaces\": [\n    {\n      \"binding\": \"AUTH_TOKENS\",\n      \"id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\",\n      \"preview_id\": \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n    }\n  ]\n}\n</configuration>\n\n- Uses Hono as the router and middleware\n- Uses Workers KV to store session data\n- Uses the Authorization header or Cookie to get the token\n- Checks the token in Workers KV\n- Returns a 403 if the token is invalid or expired\n\n</key_points>\n</example>\n\n<example id=\"queue_producer_consumer_example\">\n<description>\nUse Cloudflare Queues to produce and consume messages.\n</description>\n\n<code language=\"typescript\">\n// src/producer.ts\ninterface Env {\n  REQUEST_QUEUE: Queue;\n  UPSTREAM_API_URL: string;\n  UPSTREAM_API_KEY: string;\n}\n\nexport default {\nasync fetch(request: Request, env: Env) {\nconst info = {\ntimestamp: new Date().toISOString(),\nmethod: request.method,\nurl: request.url,\nheaders: Object.fromEntries(request.headers),\n};\nawait env.REQUEST_QUEUE.send(info);\n\nreturn Response.json({\nmessage: 'Request logged',\nrequestId: crypto.randomUUID()\n});\n\nasync queue(batch: MessageBatch<any>, env: Env) {\nconst requests = batch.messages.map(msg => msg.body);\n\nconst response = await fetch(env.UPSTREAM_API_URL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${env.UPSTREAM_API_KEY}`\n      },\n      body: JSON.stringify({\n        timestamp: new Date().toISOString(),\n        batchSize: requests.length,\n        requests\n      })\n    });\n\nif (!response.ok) {\n      throw new Error(`Upstream API error: ${response.status}`);\n    }\n\n<configuration>\n{\n  \"name\": \"request-logger-consumer\",\n  \"main\": \"src/index.ts\",\n  \"compatibility_date\": \"2025-02-11\",\n  \"queues\": {\n        \"producers\": [{\n      \"name\": \"request-queue\",\n      \"binding\": \"REQUEST_QUEUE\"\n    }],\n    \"consumers\": [{\n      \"name\": \"request-queue\",\n      \"dead_letter_queue\": \"request-queue-dlq\",\n      \"retry_delay\": 300\n    }]\n  },\n  \"vars\": {\n    \"UPSTREAM_API_URL\": \"https://api.example.com/batch-logs\",\n    \"UPSTREAM_API_KEY\": \"\"\n  }\n}\n</configuration>\n\n- Defines both a producer and consumer for the queue\n- Uses a dead letter queue for failed messages\n- Uses a retry delay of 300 seconds to delay the re-delivery of failed messages\n- Shows how to batch requests to an upstream API\n\n</key_points>\n</example>\n\n<example id=\"hyperdrive_connect_to_postgres\">\n<description>\nConnect to and query a Postgres database using Cloudflare Hyperdrive.\n</description>\n\n<code language=\"typescript\">\n// Postgres.js 3.4.5 or later is recommended\nimport postgres from \"postgres\";\n\nexport interface Env {\n// If you set another name in the Wrangler config file as the value for 'binding',\n// replace \"HYPERDRIVE\" with the variable name you defined.\nHYPERDRIVE: Hyperdrive;\n}\n\nexport default {\nasync fetch(request, env, ctx): Promise<Response> {\nconsole.log(JSON.stringify(env));\n// Create a database client that connects to your database via Hyperdrive.\n//\n// Hyperdrive generates a unique connection string you can pass to\n// supported drivers, including node-postgres, Postgres.js, and the many\n// ORMs and query builders that use these drivers.\nconst sql = postgres(env.HYPERDRIVE.connectionString)\n\ntry {\n      // Test query\n      const results = await sql`SELECT * FROM pg_tables`;\n\n// Return result rows as JSON\n      return Response.json(results);\n    } catch (e) {\n      console.error(e);\n      return Response.json(\n        { error: e instanceof Error ? e.message : e },\n        { status: 500 },\n      );\n    }\n\n},\n} satisfies ExportedHandler<Env>;\n\n<configuration>\n{\n  \"name\": \"hyperdrive-postgres\",\n  \"main\": \"src/index.ts\",\n  \"compatibility_date\": \"2025-02-11\",\n  \"hyperdrive\": [\n    {\n      \"binding\": \"HYPERDRIVE\",\n      \"id\": \"<YOUR_DATABASE_ID>\"\n    }\n  ]\n}\n</configuration>\n\n<usage>\n// Install Postgres.js\nnpm install postgres\n\n// Create a Hyperdrive configuration\nnpx wrangler hyperdrive create <YOUR_CONFIG_NAME> --connection-string=\"postgres://user:password@HOSTNAME_OR_IP_ADDRESS:PORT/database_name\"\n\n- Installs and uses Postgres.js as the database client/driver.\n- Creates a Hyperdrive configuration using wrangler and the database connection string.\n- Uses the Hyperdrive connection string to connect to the database.\n- Calling `sql.end()` is optional, as Hyperdrive will handle the connection pooling.\n\n</key_points>\n</example>\n\n<example id=\"workflows\">\n<description>\nUsing Workflows for durable execution, async tasks, and human-in-the-loop workflows.\n</description>\n\n<code language=\"typescript\">\nimport { WorkflowEntrypoint, WorkflowStep, WorkflowEvent } from 'cloudflare:workers';\n\ntype Env = {\n// Add your bindings here, e.g. Workers KV, D1, Workers AI, etc.\nMY_WORKFLOW: Workflow;\n};\n\n// User-defined params passed to your workflow\ntype Params = {\nemail: string;\nmetadata: Record<string, string>;\n};\n\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\nasync run(event: WorkflowEvent<Params>, step: WorkflowStep) {\n// Can access bindings on `this.env`\n// Can access params on `event.payload`\nconst files = await step.do('my first step', async () => {\n// Fetch a list of files from $SOME_SERVICE\nreturn {\nfiles: [\n'doc_7392_rev3.pdf',\n'report_x29_final.pdf',\n'memo_2024_05_12.pdf',\n'file_089_update.pdf',\n'proj_alpha_v2.pdf',\n'data_analysis_q2.pdf',\n'notes_meeting_52.pdf',\n'summary_fy24_draft.pdf',\n],\n};\n});\n\nconst apiResponse = await step.do('some other step', async () => {\n      let resp = await fetch('https://api.cloudflare.com/client/v4/ips');\n      return await resp.json<any>();\n    });\n\nawait step.sleep('wait on something', '1 minute');\n\nawait step.do(\n      'make a call to write that could maybe, just might, fail',\n      // Define a retry strategy\n      {\n        retries: {\n          limit: 5,\n          delay: '5 second',\n          backoff: 'exponential',\n        },\n        timeout: '15 minutes',\n      },\n      async () => {\n        // Do stuff here, with access to the state from our previous steps\n        if (Math.random() > 0.5) {\n          throw new Error('API call to $STORAGE_SYSTEM failed');\n        }\n      },\n    );\n\nexport default {\nasync fetch(req: Request, env: Env): Promise<Response> {\nlet url = new URL(req.url);\n\nif (url.pathname.startsWith('/favicon')) {\n      return Response.json({}, { status: 404 });\n    }\n\n// Get the status of an existing instance, if provided\n    let id = url.searchParams.get('instanceId');\n    if (id) {\n      let instance = await env.MY_WORKFLOW.get(id);\n      return Response.json({\n        status: await instance.status(),\n      });\n    }\n\nconst data = await req.json()\n\n// Spawn a new instance and return the ID and status\n    let instance = await env.MY_WORKFLOW.create({\n      // Define an ID for the Workflow instance\n      id: crypto.randomUUID(),\n       // Pass data to the Workflow instance\n      // Available on the WorkflowEvent\n       params: data,\n    });\n\nreturn Response.json({\n      id: instance.id,\n      details: await instance.status(),\n    });\n\n<configuration>\n{\n  \"name\": \"workflows-starter\",\n  \"main\": \"src/index.ts\",\n  \"compatibility_date\": \"2025-02-11\",\n  \"workflows\": [\n    {\n      \"name\": \"workflows-starter\",\n      \"binding\": \"MY_WORKFLOW\",\n      \"class_name\": \"MyWorkflow\"\n    }\n  ]\n}\n</configuration>\n\n- Defines a Workflow by extending the WorkflowEntrypoint class.\n- Defines a run method on the Workflow that is invoked when the Workflow is started.\n- Ensures that `await` is used before calling `step.do` or `step.sleep`\n- Passes a payload (event) to the Workflow from a Worker\n- Defines a payload type and uses TypeScript type arguments to ensure type safety\n\n</key_points>\n</example>\n\n<example id=\"workers_analytics_engine\">\n<description>\n Using Workers Analytics Engine for writing event data.\n</description>\n\n<code language=\"typescript\">\ninterface Env {\n USER_EVENTS: AnalyticsEngineDataset;\n}\n\nexport default {\nasync fetch(req: Request, env: Env): Promise<Response> {\nlet url = new URL(req.url);\nlet path = url.pathname;\nlet userId = url.searchParams.get(\"userId\");\n\n// Write a datapoint for this visit, associating the data with\n     // the userId as our Analytics Engine 'index'\n     env.USER_EVENTS.writeDataPoint({\n      // Write metrics data: counters, gauges or latency statistics\n      doubles: [],\n      // Write text labels - URLs, app names, event_names, etc\n      blobs: [path],\n      // Provide an index that groups your data correctly.\n      indexes: [userId],\n     });\n\nreturn Response.json({\n      hello: \"world\",\n     });\n    ,\n\n<configuration>\n{\n  \"name\": \"analytics-engine-example\",\n  \"main\": \"src/index.ts\",\n  \"compatibility_date\": \"2025-02-11\",\n  \"analytics_engine_datasets\": [\n      {\n        \"binding\": \"<BINDING_NAME>\",\n        \"dataset\": \"<DATASET_NAME>\"\n      }\n    ]\n  }\n}\n</configuration>\n\n<usage>\n// Query data within the 'temperatures' dataset\n// This is accessible via the REST API at https://api.cloudflare.com/client/v4/accounts/{account_id}/analytics_engine/sql\nSELECT\n    timestamp,\n    blob1 AS location_id,\n    double1 AS inside_temp,\n    double2 AS outside_temp\nFROM temperatures\nWHERE timestamp > NOW() - INTERVAL '1' DAY\n\n// List the datasets (tables) within your Analytics Engine\ncurl \"<https://api.cloudflare.com/client/v4/accounts/{account_id}/analytics_engine/sql>\" \\\n--header \"Authorization: Bearer <API_TOKEN>\" \\\n--data \"SHOW TABLES\"\n\n- Binds an Analytics Engine dataset to the Worker\n- Uses the `AnalyticsEngineDataset` type when using TypeScript for the binding\n- Writes event data using the `writeDataPoint` method and writes an `AnalyticsEngineDataPoint`\n- Does NOT `await` calls to `writeDataPoint`, as it is non-blocking\n- Defines an index as the key representing an app, customer, merchant or tenant.\n- Developers can use the GraphQL or SQL APIs to query data written to Analytics Engine\n  </key_points>\n  </example>\n\n<example id=\"browser_rendering_workers\">\n<description>\nUse the Browser Rendering API as a headless browser to interact with websites from a Cloudflare Worker.\n</description>\n\n<code language=\"typescript\">\nimport puppeteer from \"@cloudflare/puppeteer\";\n\ninterface Env {\n  BROWSER_RENDERING: Fetcher;\n}\n\nexport default {\n  async fetch(request, env): Promise<Response> {\n    const { searchParams } = new URL(request.url);\n    let url = searchParams.get(\"url\");\n\nif (url) {\n      url = new URL(url).toString(); // normalize\n      const browser = await puppeteer.launch(env.MYBROWSER);\n      const page = await browser.newPage();\n      await page.goto(url);\n      // Parse the page content\n      const content = await page.content();\n      // Find text within the page content\n      const text = await page.$eval(\"body\", (el) => el.textContent);\n      // Do something with the text\n      // e.g. log it to the console, write it to KV, or store it in a database.\n      console.log(text);\n\n// Ensure we close the browser session\n      await browser.close();\n\nreturn Response.json({\n        bodyText: text,\n      })\n    } else {\n      return Response.json({\n          error: \"Please add an ?url=https://example.com/ parameter\"\n      }, { status: 400 })\n    }\n  },\n} satisfies ExportedHandler<Env>;\n</code>\n\n<configuration>\n{\n  \"name\": \"browser-rendering-example\",\n  \"main\": \"src/index.ts\",\n  \"compatibility_date\": \"2025-02-11\",\n  \"browser\": [\n    {\n      \"binding\": \"BROWSER_RENDERING\",\n    }\n  ]\n}\n</configuration>\n\n<usage>\n// Install @cloudflare/puppeteer\nnpm install @cloudflare/puppeteer --save-dev\n</usage>\n\n- Configures a BROWSER_RENDERING binding\n- Passes the binding to Puppeteer\n- Uses the Puppeteer APIs to navigate to a URL and render the page\n- Parses the DOM and returns context for use in the response\n- Correctly creates and closes the browser instance\n\n</key_points>\n</example>\n\n<example id=\"static-assets\">\n<description>\nServe Static Assets from a Cloudflare Worker and/or configure a Single Page Application (SPA) to correctly handle HTTP 404 (Not Found) requests and route them to the entrypoint.\n</description>\n<code language=\"typescript\">\n// src/index.ts\n\ninterface Env {\n  ASSETS: Fetcher;\n}\n\nexport default {\n  fetch(request, env) {\n    const url = new URL(request.url);\n\nif (url.pathname.startsWith(\"/api/\")) {\n      return Response.json({\n        name: \"Cloudflare\",\n      });\n    }\n\nreturn env.ASSETS.fetch(request);\n  },\n} satisfies ExportedHandler<Env>;\n</code>\n<configuration>\n{\n  \"name\": \"my-app\",\n  \"main\": \"src/index.ts\",\n  \"compatibility_date\": \"<TBD>\",\n  \"assets\": { \"directory\": \"./public/\", \"not_found_handling\": \"single-page-application\", \"binding\": \"ASSETS\" },\n  \"observability\": {\n    \"enabled\": true\n  }\n}\n</configuration>\n<key_points>\n- Configures a ASSETS binding\n- Uses /public/ as the directory the build output goes to from the framework of choice\n- The Worker will handle any requests that a path cannot be found for and serve as the API\n- If the application is a single-page application (SPA), HTTP 404 (Not Found) requests will direct to the SPA.\n\n</key_points>\n</example>\n\n<example id=\"agents\">\n<code language=\"typescript\">\n<description>\nBuild an AI Agent on Cloudflare Workers, using the agents, and the state management and syncing APIs built into the agents.\n</description>\n\n<code language=\"typescript\">\n// src/index.ts\nimport { Agent, AgentNamespace, Connection, ConnectionContext, getAgentByName, routeAgentRequest, WSMessage } from 'agents';\nimport { OpenAI } from \"openai\";\n\ninterface Env {\n  AIAgent: AgentNamespace<Agent>;\n  OPENAI_API_KEY: string;\n}\n\nexport class AIAgent extends Agent {\n  // Handle HTTP requests with your Agent\n  async onRequest(request) {\n    // Connect with AI capabilities\n    const ai = new OpenAI({\n      apiKey: this.env.OPENAI_API_KEY,\n    });\n\n// Process and understand\n    const response = await ai.chat.completions.create({\n      model: \"gpt-4\",\n      messages: [{ role: \"user\", content: await request.text() }],\n    });\n\nreturn new Response(response.choices[0].message.content);\n  }\n\nasync processTask(task) {\n    await this.understand(task);\n    await this.act();\n    await this.reflect();\n  }\n\n// Handle WebSockets\n  async onConnect(connection: Connection) {\n   await this.initiate(connection);\n   connection.accept()\n  }\n\nasync onMessage(connection, message) {\n    const understanding = await this.comprehend(message);\n    await this.respond(connection, understanding);\n  }\n\nasync evolve(newInsight) {\n      this.setState({\n        ...this.state,\n        insights: [...(this.state.insights || []), newInsight],\n        understanding: this.state.understanding + 1,\n      });\n    }\n\nonStateUpdate(state, source) {\n    console.log(\"Understanding deepened:\", {\n      newState: state,\n      origin: source,\n    });\n  }\n\n// Scheduling APIs\n  // An Agent can schedule tasks to be run in the future by calling this.schedule(when, callback, data), where when can be a delay, a Date, or a cron string; callback the function name to call, and data is an object of data to pass to the function.\n  //\n  // Scheduled tasks can do anything a request or message from a user can: make requests, query databases, send emails, read+write state: scheduled tasks can invoke any regular method on your Agent.\n  async scheduleExamples() {\n    // schedule a task to run in 10 seconds\n    let task = await this.schedule(10, \"someTask\", { message: \"hello\" });\n\n// schedule a task to run at a specific date\n    let task = await this.schedule(new Date(\"2025-01-01\"), \"someTask\", {});\n\n// schedule a task to run every 10 seconds\n    let { id } = await this.schedule(\"*/10 * * * *\", \"someTask\", { message: \"hello\" });\n\n// schedule a task to run every 10 seconds, but only on Mondays\n    let task = await this.schedule(\"0 0 * * 1\", \"someTask\", { message: \"hello\" });\n\n// cancel a scheduled task\n    this.cancelSchedule(task.id);\n\n// Get a specific schedule by ID\n    // Returns undefined if the task does not exist\n    let task = await this.getSchedule(task.id)\n\n// Get all scheduled tasks\n    // Returns an array of Schedule objects\n    let tasks = this.getSchedules();\n\n// Cancel a task by its ID\n    // Returns true if the task was cancelled, false if it did not exist\n    await this.cancelSchedule(task.id);\n\n// Filter for specific tasks\n    // e.g. all tasks starting in the next hour\n    let tasks = this.getSchedules({\n      timeRange: {\n        start: new Date(Date.now()),\n        end: new Date(Date.now() + 60 * 60 * 1000),\n      }\n    });\n  }\n\nasync someTask(data) {\n    await this.callReasoningModel(data.message);\n  }\n\n// Use the this.sql API within the Agent to access the underlying SQLite database\n   async callReasoningModel(prompt: Prompt) {\n    interface Prompt {\n       userId: string;\n       user: string;\n       system: string;\n       metadata: Record<string, string>;\n    }\n\ninterface History {\n      timestamp: Date;\n      entry: string;\n    }\n\nlet result = this.sql<History>`SELECT * FROM history WHERE user = ${prompt.userId} ORDER BY timestamp DESC LIMIT 1000`;\n    let context = [];\n    for await (const row of result) {\n      context.push(row.entry);\n    }\n\nconst client = new OpenAI({\n      apiKey: this.env.OPENAI_API_KEY,\n    });\n\n// Combine user history with the current prompt\n    const systemPrompt = prompt.system || 'You are a helpful assistant.';\n    const userPrompt = `${prompt.user}\\n\\nUser history:\\n${context.join('\\n')}`;\n\ntry {\n      const completion = await client.chat.completions.create({\n        model: this.env.MODEL || 'o3-mini',\n        messages: [\n          { role: 'system', content: systemPrompt },\n          { role: 'user', content: userPrompt },\n        ],\n        temperature: 0.7,\n        max_tokens: 1000,\n      });\n\n// Store the response in history\n      this\n        .sql`INSERT INTO history (timestamp, user, entry) VALUES (${new Date()}, ${prompt.userId}, ${completion.choices[0].message.content})`;\n\nreturn completion.choices[0].message.content;\n    } catch (error) {\n      console.error('Error calling reasoning model:', error);\n      throw error;\n    }\n  }\n\n// Use the SQL API with a type parameter\n  async queryUser(userId: string) {\n    type User = {\n      id: string;\n      name: string;\n      email: string;\n    };\n    // Supply the type paramter to the query when calling this.sql\n    // This assumes the results returns one or more User rows with \"id\", \"name\", and \"email\" columns\n    // You do not need to specify an array type (`User[]` or `Array<User>`) as `this.sql` will always return an array of the specified type.\n    const user = await this.sql<User>`SELECT * FROM users WHERE id = ${userId}`;\n    return user\n  }\n\n// Run and orchestrate Workflows from Agents\n  async runWorkflow(data) {\n     let instance = await env.MY_WORKFLOW.create({\n       id: data.id,\n       params: data,\n     })\n\n// Schedule another task that checks the Workflow status every 5 minutes...\n     await this.schedule(\"*/5 * * * *\", \"checkWorkflowStatus\", { id: instance.id });\n   }\n}\n\nexport default {\n  async fetch(request, env, ctx): Promise<Response> {\n    // Routed addressing\n    // Automatically routes HTTP requests and/or WebSocket connections to /agents/:agent/:name\n    // Best for: connecting React apps directly to Agents using useAgent from @cloudflare/agents/react\n    return (await routeAgentRequest(request, env)) || Response.json({ msg: 'no agent here' }, { status: 404 });\n\n// Named addressing\n    // Best for: convenience method for creating or retrieving an agent by name/ID.\n    let namedAgent = getAgentByName<Env, AIAgent>(env.AIAgent, 'agent-456');\n    // Pass the incoming request straight to your Agent\n    let namedResp = (await namedAgent).fetch(request);\n    return namedResp;\n\n// Durable Objects-style addressing\n    // Best for: controlling ID generation, associating IDs with your existing systems,\n    // and customizing when/how an Agent is created or invoked\n    const id = env.AIAgent.newUniqueId();\n    const agent = env.AIAgent.get(id);\n    // Pass the incoming request straight to your Agent\n    let resp = await agent.fetch(request);\n\n// return Response.json({ hello: 'visit https://developers.cloudflare.com/agents for more' });\n  },\n} satisfies ExportedHandler<Env>;\n</code>\n\n<code>\n// client.js\nimport { AgentClient } from \"agents/client\";\n\nconst connection = new AgentClient({\n  agent: \"dialogue-agent\",\n  name: \"insight-seeker\",\n});\n\nconnection.addEventListener(\"message\", (event) => {\n  console.log(\"Received:\", event.data);\n});\n\nconnection.send(\n  JSON.stringify({\n    type: \"inquiry\",\n    content: \"What patterns do you see?\",\n  })\n);\n</code>\n\n<code>\n// app.tsx\n// React client hook for the agents\nimport { useAgent } from \"agents/react\";\nimport { useState } from \"react\";\n\n// useAgent client API\nfunction AgentInterface() {\n  const connection = useAgent({\n    agent: \"dialogue-agent\",\n    name: \"insight-seeker\",\n    onMessage: (message) => {\n      console.log(\"Understanding received:\", message.data);\n    },\n    onOpen: () => console.log(\"Connection established\"),\n    onClose: () => console.log(\"Connection closed\"),\n  });\n\nconst inquire = () => {\n    connection.send(\n      JSON.stringify({\n        type: \"inquiry\",\n        content: \"What insights have you gathered?\",\n      })\n    );\n  };\n\nreturn (\n    <div className=\"agent-interface\">\n      <button onClick={inquire}>Seek Understanding</button>\n    </div>\n  );\n}\n\n// State synchronization\nfunction StateInterface() {\n  const [state, setState] = useState({ counter: 0 });\n\nconst agent = useAgent({\n    agent: \"thinking-agent\",\n    onStateUpdate: (newState) => setState(newState),\n  });\n\nconst increment = () => {\n    agent.setState({ counter: state.counter + 1 });\n  };\n\nreturn (\n    <div>\n      <div>Count: {state.counter}</div>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n</code>\n\n<configuration>\n  {\n  \"durable_objects\": {\n    \"bindings\": [\n      {\n        \"binding\": \"AIAgent\",\n        \"class_name\": \"AIAgent\"\n      }\n    ]\n  },\n  \"migrations\": [\n    {\n      \"tag\": \"v1\",\n      // Mandatory for the Agent to store state\n      \"new_sqlite_classes\": [\"AIAgent\"]\n    }\n  ]\n}\n</configuration>\n<key_points>\n\n- Imports the `Agent` class from the `agents` package\n- Extends the `Agent` class and implements the methods exposed by the `Agent`, including `onRequest` for HTTP requests, or `onConnect` and `onMessage` for WebSockets.\n- Uses the `this.schedule` scheduling API to schedule future tasks.\n- Uses the `this.setState` API within the Agent for syncing state, and uses type parameters to ensure the state is typed.\n- Uses the `this.sql` as a lower-level query API.\n- For frontend applications, uses the optional `useAgent` hook to connect to the Agent via WebSockets\n\n</key_points>\n</example>\n\n<example id=\"workers-ai-structured-outputs-json\">\n<description>\nWorkers AI supports structured JSON outputs with JSON mode, which supports the `response_format` API provided by the OpenAI SDK.\n</description>\n<code language=\"typescript\">\nimport { OpenAI } from \"openai\";\n\ninterface Env {\n  OPENAI_API_KEY: string;\n}\n\n// Define your JSON schema for a calendar event\nconst CalendarEventSchema = {\n  type: 'object',\n  properties: {\n    name: { type: 'string' },\n    date: { type: 'string' },\n    participants: { type: 'array', items: { type: 'string' } },\n  },\n  required: ['name', 'date', 'participants']\n};\n\nexport default {\n  async fetch(request: Request, env: Env) {\n    const client = new OpenAI({\n      apiKey: env.OPENAI_API_KEY,\n      // Optional: use AI Gateway to bring logs, evals & caching to your AI requests\n      // https://developers.cloudflare.com/ai-gateway/usage/providers/openai/\n      // baseUrl: \"https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/openai\"\n    });\n\nconst response = await client.chat.completions.create({\n      model: 'gpt-4o-2024-08-06',\n      messages: [\n        { role: 'system', content: 'Extract the event information.' },\n        { role: 'user', content: 'Alice and Bob are going to a science fair on Friday.' },\n      ],\n      // Use the `response_format` option to request a structured JSON output\n      response_format: {\n        // Set json_schema and provide ra schema, or json_object and parse it yourself\n        type: 'json_schema',\n        schema: CalendarEventSchema, // provide a schema\n      },\n    });\n\n// This will be of type CalendarEventSchema\n    const event = response.choices[0].message.parsed;\n\nreturn Response.json({\n      \"calendar_event\": event,\n    })\n  }\n}\n</code>\n<configuration>\n{\n  \"name\": \"my-app\",\n  \"main\": \"src/index.ts\",\n  \"compatibility_date\": \"$CURRENT_DATE\",\n  \"observability\": {\n    \"enabled\": true\n  }\n}\n</configuration>\n<key_points>\n\n- Defines a JSON Schema compatible object that represents the structured format requested from the model\n- Sets `response_format` to `json_schema` and provides a schema to parse the response\n- This could also be `json_object`, which can be parsed after the fact.\n- Optionally uses AI Gateway to cache, log and instrument requests and responses between a client and the AI provider/API.\n\n</key_points>\n</example>\n\n<pattern id=\"websocket_coordination\">\n<description>\nFan-in/fan-out for WebSockets. Uses the Hibernatable WebSockets API within Durable Objects. Does NOT use the legacy addEventListener API.\n</description>\n<implementation>\nexport class WebSocketHibernationServer extends DurableObject {\n  async fetch(request: Request, env: Env, ctx: ExecutionContext) {\n    // Creates two ends of a WebSocket connection.\n    const webSocketPair = new WebSocketPair();\n    const [client, server] = Object.values(webSocketPair);\n\n// Call this to accept the WebSocket connection.\n    // Do NOT call server.accept() (this is the legacy approach and is not preferred)\n    this.ctx.acceptWebSocket(server);\n\nreturn new Response(null, {\n          status: 101,\n          webSocket: client,\n    });\n},\n\nasync webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): void | Promise<void> {\n  // Invoked on each WebSocket message.\n  ws.send(message)\n},\n\nasync webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) void | Promise<void> {\n  // Invoked when a client closes the connection.\n  ws.close(code, \"<message>\");\n},\n\nasync webSocketError(ws: WebSocket, error: unknown): void | Promise<void> {\n  // Handle WebSocket errors\n}\n}\n</implementation>\n</pattern>\n</api_patterns>\n\n<user_prompt>\n{user_prompt}\n</user_prompt>\njs\n  import workersPrompt from \"./workersPrompt.md\";\n\n// Llama 3.3 from Workers AI\n  const PREFERRED_MODEL = \"@cf/meta/llama-3.3-70b-instruct-fp8-fast\";\n\nexport default {\n    async fetch(req, env, ctx) {\n      const openai = new OpenAI({\n        apiKey: env.WORKERS_AI_API_KEY,\n      });\n\nconst stream = await openai.chat.completions.create({\n        messages: [\n          {\n            role: \"system\",\n            content: workersPrompt,\n          },\n          {\n            role: \"user\",\n            // Imagine something big!\n            content:\n              \"Build an AI Agent using Workflows. The Workflow should be triggered by a GitHub webhook on a pull request, and ...\",\n          },\n        ],\n        model: PREFERRED_MODEL,\n        stream: true,\n      });\n\n// Stream the response so we're not buffering the entire response in memory,\n      // since it could be very large.\n      const transformStream = new TransformStream();\n      const writer = transformStream.writable.getWriter();\n      const encoder = new TextEncoder();\n\n(async () => {\n        try {\n          for await (const chunk of stream) {\n            const content = chunk.choices[0]?.delta?.content || \"\";\n            await writer.write(encoder.encode(content));\n          }\n        } finally {\n          await writer.close();\n        }\n      })();\n\nreturn new Response(transformStream.readable, {\n        headers: {\n          \"Content-Type\": \"text/plain; charset=utf-8\",\n          \"Transfer-Encoding\": \"chunked\",\n        },\n      });\n    },\n  };\n  ts\n  import workersPrompt from \"./workersPrompt.md\"\n\n// Llama 3.3 from Workers AI\n  const PREFERRED_MODEL = \"@cf/meta/llama-3.3-70b-instruct-fp8-fast\"\n\nexport default {\n    async fetch(req: Request, env: Env, ctx: ExecutionContext) {\n      const openai = new OpenAI({\n        apiKey: env.WORKERS_AI_API_KEY\n      });\n\nconst stream = await openai.chat.completions.create({\n        messages: [\n          {\n            role: \"system\",\n            content: workersPrompt,\n          },\n          {\n            role: \"user\",\n            // Imagine something big!\n            content: \"Build an AI Agent using Workflows. The Workflow should be triggered by a GitHub webhook on a pull request, and ...\"\n          }\n        ],\n        model: PREFERRED_MODEL,\n        stream: true,\n      });\n\n// Stream the response so we're not buffering the entire response in memory,\n      // since it could be very large.\n      const transformStream = new TransformStream();\n      const writer = transformStream.writable.getWriter();\n      const encoder = new TextEncoder();\n\n(async () => {\n        try {\n          for await (const chunk of stream) {\n            const content = chunk.choices[0]?.delta?.content || '';\n            await writer.write(encoder.encode(content));\n          }\n        } finally {\n          await writer.close();\n        }\n      })();\n\nreturn new Response(transformStream.readable, {\n        headers: {\n          'Content-Type': 'text/plain; charset=utf-8',\n          'Transfer-Encoding': 'chunked'\n        }\n      });\n    }\n  }\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/astro-blog-starter-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/astro-blog-starter-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/astro-blog-starter-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/chanfana-openapi-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/chanfana-openapi-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/chanfana-openapi-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/cli\n  sh\n  yarn create cloudflare --template=cloudflare/templates/cli\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/cli\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/containers-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/containers-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/containers-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/d1-starter-sessions-api-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/d1-starter-sessions-api-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/d1-starter-sessions-api-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/d1-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/d1-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/d1-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/durable-chat-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/durable-chat-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/durable-chat-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/hello-world-do-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/hello-world-do-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/hello-world-do-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/llm-chat-app-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/llm-chat-app-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/llm-chat-app-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/multiplayer-globe-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/multiplayer-globe-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/multiplayer-globe-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/mysql-hyperdrive-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/mysql-hyperdrive-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/mysql-hyperdrive-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/next-starter-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/next-starter-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/next-starter-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/nlweb-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/nlweb-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/nlweb-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/nodejs-http-server-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/nodejs-http-server-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/nodejs-http-server-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/openauth-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/openauth-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/openauth-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/postgres-hyperdrive-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/postgres-hyperdrive-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/postgres-hyperdrive-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/r2-explorer-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/r2-explorer-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/r2-explorer-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/react-postgres-fullstack-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/react-postgres-fullstack-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/react-postgres-fullstack-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/react-router-hono-fullstack-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/react-router-hono-fullstack-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/react-router-hono-fullstack-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/react-router-postgres-ssr-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/react-router-postgres-ssr-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/react-router-postgres-ssr-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/react-router-starter-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/react-router-starter-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/react-router-starter-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/remix-starter-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/remix-starter-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/remix-starter-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/saas-admin-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/saas-admin-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/saas-admin-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/text-to-image-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/text-to-image-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/text-to-image-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/to-do-list-kv-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/to-do-list-kv-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/to-do-list-kv-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/vite-react-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/vite-react-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/vite-react-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/worker-publisher-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/worker-publisher-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/worker-publisher-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/workflows-starter-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/workflows-starter-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/workflows-starter-template\n  sh\n  npm create cloudflare@latest -- --template=cloudflare/templates/x402-proxy-template\n  sh\n  yarn create cloudflare --template=cloudflare/templates/x402-proxy-template\n  sh\n  pnpm create cloudflare@latest --template=cloudflare/templates/x402-proxy-template\n  js\n  const CSS = \"body { color: red; }\";\n  const HTML = `\n  <!doctype html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"utf-8\">\n      <title>Early Hints test</title>\n      <link rel=\"stylesheet\" href=\"/test.css\">\n  </head>\n  <body>\n      <h1>Early Hints test page</h1>\n  </body>\n  </html>\n  `;\n\nexport default {\n    async fetch(req) {\n      // If request is for test.css, serve the raw CSS\n      if (/test\\.css$/.test(req.url)) {\n        return new Response(CSS, {\n          headers: {\n            \"content-type\": \"text/css\",\n          },\n        });\n      } else {\n        // Serve raw HTML using Early Hints for the CSS file\n        return new Response(HTML, {\n          headers: {\n            \"content-type\": \"text/html\",\n            link: \"</test.css>; rel=preload; as=style\",\n          },\n        });\n      }\n    },\n  };\n  js\n  const CSS = \"body { color: red; }\";\n  const HTML = `\n  <!doctype html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"utf-8\">\n      <title>Early Hints test</title>\n      <link rel=\"stylesheet\" href=\"/test.css\">\n  </head>\n  <body>\n      <h1>Early Hints test page</h1>\n  </body>\n  </html>\n  `;\n\nexport default {\n    async fetch(req): Promise<Response> {\n      // If request is for test.css, serve the raw CSS\n      if (/test\\.css$/.test(req.url)) {\n        return new Response(CSS, {\n          headers: {\n            \"content-type\": \"text/css\",\n          },\n        });\n      } else {\n        // Serve raw HTML using Early Hints for the CSS file\n        return new Response(HTML, {\n          headers: {\n            \"content-type\": \"text/html\",\n            link: \"</test.css>; rel=preload; as=style\",\n          },\n        });\n      }\n    },\n  } satisfies ExportedHandler;\n  py\n  import re\n  from workers import Response, WorkerEntrypoint\n\nCSS = \"body { color: red; }\"\n  HTML = \"\"\"\n  <!doctype html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"utf-8\">\n      <title>Early Hints test</title>\n      <link rel=\"stylesheet\" href=\"/test.css\">\n  </head>\n  <body>\n      <h1>Early Hints test page</h1>\n  </body>\n  </html>\n  \"\"\"\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          if re.search(\"test.css\", request.url):\n              headers = {\"content-type\": \"text/css\"}\n              return Response(CSS, headers=headers)\n          else:\n              headers = {\"content-type\": \"text/html\",\"link\": \"</test.css>; rel=preload; as=style\"}\n          return Response(HTML, headers=headers)\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\nconst CSS = \"body { color: red; }\";\n  const HTML = `\n  <!doctype html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"utf-8\">\n      <title>Early Hints test</title>\n      <link rel=\"stylesheet\" href=\"/test.css\">\n  </head>\n  <body>\n      <h1>Early Hints test page</h1>\n  </body>\n  </html>\n  `;\n\n// Serve CSS file\n  app.get(\"/test.css\", (c) => {\n    return c.body(CSS, {\n      headers: {\n        \"content-type\": \"text/css\",\n      },\n    });\n  });\n\n// Serve HTML with early hints\n  app.get(\"*\", (c) => {\n    return c.html(HTML, {\n      headers: {\n        link: \"</test.css>; rel=preload; as=style\",\n      },\n    });\n  });\n\nexport default app;\n  js\n  const NAME = \"myExampleWorkersABTest\";\n\nexport default {\n    async fetch(req) {\n      const url = new URL(req.url);\n\n// Enable Passthrough to allow direct access to control and test routes.\n      if (url.pathname.startsWith(\"/control\") || url.pathname.startsWith(\"/test\"))\n        return fetch(req);\n\n// Determine which group this requester is in.\n      const cookie = req.headers.get(\"cookie\");\n\nif (cookie && cookie.includes(`${NAME}=control`)) {\n        url.pathname = \"/control\" + url.pathname;\n      } else if (cookie && cookie.includes(`${NAME}=test`)) {\n        url.pathname = \"/test\" + url.pathname;\n      } else {\n        // If there is no cookie, this is a new client. Choose a group and set the cookie.\n        const group = Math.random() < 0.5 ? \"test\" : \"control\"; // 50/50 split\n        if (group === \"control\") {\n          url.pathname = \"/control\" + url.pathname;\n        } else {\n          url.pathname = \"/test\" + url.pathname;\n        }\n        // Reconstruct response to avoid immutability\n        let res = await fetch(url);\n        res = new Response(res.body, res);\n        // Set cookie to enable persistent A/B sessions.\n        res.headers.append(\"Set-Cookie\", `${NAME}=${group}; path=/`);\n        return res;\n      }\n      return fetch(url);\n    },\n  };\n  ts\n  const NAME = \"myExampleWorkersABTest\";\n\nexport default {\n    async fetch(req): Promise<Response> {\n      const url = new URL(req.url);\n      // Enable Passthrough to allow direct access to control and test routes.\n      if (url.pathname.startsWith(\"/control\") || url.pathname.startsWith(\"/test\"))\n        return fetch(req);\n      // Determine which group this requester is in.\n      const cookie = req.headers.get(\"cookie\");\n      if (cookie && cookie.includes(`${NAME}=control`)) {\n        url.pathname = \"/control\" + url.pathname;\n      } else if (cookie && cookie.includes(`${NAME}=test`)) {\n        url.pathname = \"/test\" + url.pathname;\n      } else {\n        // If there is no cookie, this is a new client. Choose a group and set the cookie.\n        const group = Math.random() < 0.5 ? \"test\" : \"control\"; // 50/50 split\n        if (group === \"control\") {\n          url.pathname = \"/control\" + url.pathname;\n        } else {\n          url.pathname = \"/test\" + url.pathname;\n        }\n        // Reconstruct response to avoid immutability\n        let res = await fetch(url);\n        res = new Response(res.body, res);\n        // Set cookie to enable persistent A/B sessions.\n        res.headers.append(\"Set-Cookie\", `${NAME}=${group}; path=/`);\n        return res;\n      }\n      return fetch(url);\n    },\n  } satisfies ExportedHandler;\n  py\n  import random\n  from urllib.parse import urlparse, urlunparse\n  from workers import Response, fetch, WorkerEntrypoint\n\nNAME = \"myExampleWorkersABTest\"\n\nclass Default(WorkerEntrypoint):\n    async def fetch(self, request):\n      url = urlparse(request.url)\n      # Uncomment below when testing locally\n      # url = url._replace(netloc=\"example.com\") if \"localhost\" in url.netloc else url\n\n# Enable Passthrough to allow direct access to control and test routes.\n      if url.path.startswith(\"/control\") or url.path.startswith(\"/test\"):\n        return fetch(urlunparse(url))\n\n# Determine which group this requester is in.\n      cookie = request.headers.get(\"cookie\")\n\nif cookie and f'{NAME}=control' in cookie:\n        url = url._replace(path=\"/control\" + url.path)\n      elif cookie and f'{NAME}=test' in cookie:\n        url = url._replace(path=\"/test\" + url.path)\n      else:\n        # If there is no cookie, this is a new client. Choose a group and set the cookie.\n        group = \"test\" if random.random() < 0.5 else \"control\"\n        if group == \"control\":\n          url = url._replace(path=\"/control\" + url.path)\n        else:\n          url = url._replace(path=\"/test\" + url.path)\n\n# Reconstruct response to avoid immutability\n        res = await fetch(urlunparse(url))\n        headers = dict(res.headers)\n        headers[\"Set-Cookie\"] = f'{NAME}={group}; path=/'\n        return Response(res.body, headers=headers)\n\nreturn fetch(urlunparse(url))\n  ts\n  import { Hono } from \"hono\";\n  import { getCookie, setCookie } from \"hono/cookie\";\n\nconst app = new Hono();\n\nconst NAME = \"myExampleWorkersABTest\";\n\n// Enable passthrough to allow direct access to control and test routes\n  app.all(\"/control/*\", (c) => fetch(c.req.raw));\n  app.all(\"/test/*\", (c) => fetch(c.req.raw));\n\n// Middleware to handle A/B testing logic\n  app.use(\"*\", async (c) => {\n    const url = new URL(c.req.url);\n\n// Determine which group this requester is in\n    const abTestCookie = getCookie(c, NAME);\n\nif (abTestCookie === \"control\") {\n      // User is in control group\n      url.pathname = \"/control\" + c.req.path;\n    } else if (abTestCookie === \"test\") {\n      // User is in test group\n      url.pathname = \"/test\" + c.req.path;\n    } else {\n      // If there is no cookie, this is a new client\n      // Choose a group and set the cookie (50/50 split)\n      const group = Math.random() < 0.5 ? \"test\" : \"control\";\n\n// Update URL path based on assigned group\n      if (group === \"control\") {\n        url.pathname = \"/control\" + c.req.path;\n      } else {\n        url.pathname = \"/test\" + c.req.path;\n      }\n\n// Set cookie to enable persistent A/B sessions\n      setCookie(c, NAME, group, {\n        path: \"/\",\n      });\n    }\n\nconst res = await fetch(url);\n\nreturn c.body(res.body, res);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(req) {\n      const data =\n        req.cf !== undefined\n          ? req.cf\n          : { error: \"The `cf` object is not available inside the preview.\" };\n\nreturn new Response(JSON.stringify(data, null, 2), {\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      });\n    },\n  };\n  ts\n  export default {\n    async fetch(req): Promise<Response> {\n      const data =\n        req.cf !== undefined\n          ? req.cf\n          : { error: \"The `cf` object is not available inside the preview.\" };\n\nreturn new Response(JSON.stringify(data, null, 2), {\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      });\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\napp.get(\"*\", async (c) => {\n    // Access the raw request to get the cf object\n    const req = c.req.raw;\n\n// Check if the cf object is available\n    const data =\n      req.cf !== undefined\n        ? req.cf\n        : { error: \"The `cf` object is not available inside the preview.\" };\n\n// Return the data formatted with 2-space indentation\n    return c.json(data);\n  });\n\nexport default app;\n  py\n  import json\n  from workers import Response, WorkerEntrypoint\n  from js import JSON\n\nclass Default(WorkerEntrypoint):\n    async def fetch(self, request):\n      error = json.dumps({ \"error\": \"The `cf` object is not available inside the preview.\" })\n      data = request.cf if request.cf is not None else error\n      headers = {\"content-type\":\"application/json\"}\n      return Response(JSON.stringify(data, None, 2), headers=headers)\n  js\n  export default {\n    async fetch(request) {\n      // someHost is set up to return JSON responses\n      const someHost = \"https://jsonplaceholder.typicode.com\";\n      const url1 = someHost + \"/todos/1\";\n      const url2 = someHost + \"/todos/2\";\n\nconst responses = await Promise.all([fetch(url1), fetch(url2)]);\n      const results = await Promise.all(responses.map((r) => r.json()));\n\nconst options = {\n        headers: { \"content-type\": \"application/json;charset=UTF-8\" },\n      };\n      return new Response(JSON.stringify(results), options);\n    },\n  };\n  ts\n  export default {\n    async fetch(request) {\n      // someHost is set up to return JSON responses\n      const someHost = \"https://jsonplaceholder.typicode.com\";\n      const url1 = someHost + \"/todos/1\";\n      const url2 = someHost + \"/todos/2\";\n\nconst responses = await Promise.all([fetch(url1), fetch(url2)]);\n      const results = await Promise.all(responses.map((r) => r.json()));\n\nconst options = {\n        headers: { \"content-type\": \"application/json;charset=UTF-8\" },\n      };\n      return new Response(JSON.stringify(results), options);\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\napp.get(\"*\", async (c) => {\n    // someHost is set up to return JSON responses\n    const someHost = \"https://jsonplaceholder.typicode.com\";\n    const url1 = someHost + \"/todos/1\";\n    const url2 = someHost + \"/todos/2\";\n\n// Fetch both URLs concurrently\n    const responses = await Promise.all([fetch(url1), fetch(url2)]);\n\n// Parse JSON responses concurrently\n    const results = await Promise.all(responses.map((r) => r.json()));\n\n// Return aggregated results\n    return c.json(results);\n  });\n\nexport default app;\n  py\n  from workers import Response, fetch, WorkerEntrypoint\n  import asyncio\n  import json\n\nclass Default(WorkerEntrypoint):\n    async def fetch(self, request):\n      # some_host is set up to return JSON responses\n      some_host = \"https://jsonplaceholder.typicode.com\"\n      url1 = some_host + \"/todos/1\"\n      url2 = some_host + \"/todos/2\"\n\nresponses = await asyncio.gather(fetch(url1), fetch(url2))\n      results = await asyncio.gather(*(r.json() for r in responses))\n\nheaders = {\"content-type\": \"application/json;charset=UTF-8\"}\n      return Response.json(results, headers=headers)\n  js\n  export default {\n    async fetch(request) {\n      const response = await fetch(\"https://example.com\");\n\n// Clone the response so that it's no longer immutable\n      const newResponse = new Response(response.body, response);\n\n// Add a custom header with a value\n      newResponse.headers.append(\n        \"x-workers-hello\",\n        \"Hello from Cloudflare Workers\",\n      );\n\n// Delete headers\n      newResponse.headers.delete(\"x-header-to-delete\");\n      newResponse.headers.delete(\"x-header2-to-delete\");\n\n// Adjust the value for an existing header\n      newResponse.headers.set(\"x-header-to-change\", \"NewValue\");\n\nreturn newResponse;\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const response = await fetch(request);\n\n// Clone the response so that it's no longer immutable\n      const newResponse = new Response(response.body, response);\n\n// Add a custom header with a value\n      newResponse.headers.append(\n        \"x-workers-hello\",\n        \"Hello from Cloudflare Workers\",\n      );\n\n// Delete headers\n      newResponse.headers.delete(\"x-header-to-delete\");\n      newResponse.headers.delete(\"x-header2-to-delete\");\n\n// Adjust the value for an existing header\n      newResponse.headers.set(\"x-header-to-change\", \"NewValue\");\n\nreturn newResponse;\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import Response, fetch, WorkerEntrypoint\n\nclass Default(WorkerEntrypoint):\n    async def fetch(self, request):\n        response = await fetch(\"https://example.com\")\n\n# Grab the response headers so they can be modified\n        new_headers = response.headers\n\n# Add a custom header with a value\n        new_headers[\"x-workers-hello\"] = \"Hello from Cloudflare Workers\"\n\n# Delete headers\n        if \"x-header-to-delete\" in new_headers:\n            del new_headers[\"x-header-to-delete\"]\n        if \"x-header2-to-delete\" in new_headers:\n            del new_headers[\"x-header2-to-delete\"]\n\n# Adjust the value for an existing header\n        new_headers[\"x-header-to-change\"] = \"NewValue\"\n\nreturn Response(response.body, headers=new_headers)\n  ts\n  import { Hono } from 'hono';\n\nconst app = new Hono();\n\napp.use('*', async (c, next) => {\n    // Process the request with the next middleware/handler\n    await next();\n\n// After the response is generated, we can modify its headers\n\n// Add a custom header with a value\n    c.res.headers.append(\n      \"x-workers-hello\",\n      \"Hello from Cloudflare Workers with Hono\"\n    );\n\n// Delete headers\n    c.res.headers.delete(\"x-header-to-delete\");\n    c.res.headers.delete(\"x-header2-to-delete\");\n\n// Adjust the value for an existing header\n    c.res.headers.set(\"x-header-to-change\", \"NewValue\");\n  });\n\napp.get('*', async (c) => {\n    // Fetch content from example.com\n    const response = await fetch(\"https://example.com\");\n\n// Return the response body with original headers\n    // (our middleware will modify the headers before sending)\n    return new Response(response.body, {\n      headers: response.headers\n    });\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      /**\n       * @param {string} PRESHARED_AUTH_HEADER_KEY Custom header to check for key\n       * @param {string} PRESHARED_AUTH_HEADER_VALUE Hard coded key value\n       */\n      const PRESHARED_AUTH_HEADER_KEY = \"X-Custom-PSK\";\n      const PRESHARED_AUTH_HEADER_VALUE = \"mypresharedkey\";\n      const psk = request.headers.get(PRESHARED_AUTH_HEADER_KEY);\n\nif (psk === PRESHARED_AUTH_HEADER_VALUE) {\n        // Correct preshared header key supplied. Fetch request from origin.\n        return fetch(request);\n      }\n\n// Incorrect key supplied. Reject the request.\n      return new Response(\"Sorry, you have supplied an invalid key.\", {\n        status: 403,\n      });\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * @param {string} PRESHARED_AUTH_HEADER_KEY Custom header to check for key\n       * @param {string} PRESHARED_AUTH_HEADER_VALUE Hard coded key value\n       */\n      const PRESHARED_AUTH_HEADER_KEY = \"X-Custom-PSK\";\n      const PRESHARED_AUTH_HEADER_VALUE = \"mypresharedkey\";\n      const psk = request.headers.get(PRESHARED_AUTH_HEADER_KEY);\n\nif (psk === PRESHARED_AUTH_HEADER_VALUE) {\n        // Correct preshared header key supplied. Fetch request from origin.\n        return fetch(request);\n      }\n\n// Incorrect key supplied. Reject the request.\n      return new Response(\"Sorry, you have supplied an invalid key.\", {\n        status: 403,\n      });\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response, fetch\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          PRESHARED_AUTH_HEADER_KEY = \"X-Custom-PSK\"\n          PRESHARED_AUTH_HEADER_VALUE = \"mypresharedkey\"\n\npsk = request.headers[PRESHARED_AUTH_HEADER_KEY]\n\nif psk == PRESHARED_AUTH_HEADER_VALUE:\n              # Correct preshared header key supplied. Fetch request from origin.\n              return fetch(request)\n\n# Incorrect key supplied. Reject the request.\n          return Response(\"Sorry, you have supplied an invalid key.\", status=403)\n  ts\n  import { Hono } from 'hono';\n\nconst app = new Hono();\n\n// Add authentication middleware\n  app.use('*', async (c, next) => {\n    /**\n     * Define authentication constants\n     */\n    const PRESHARED_AUTH_HEADER_KEY = \"X-Custom-PSK\";\n    const PRESHARED_AUTH_HEADER_VALUE = \"mypresharedkey\";\n\n// Get the pre-shared key from the request header\n    const psk = c.req.header(PRESHARED_AUTH_HEADER_KEY);\n\nif (psk === PRESHARED_AUTH_HEADER_VALUE) {\n      // Correct preshared header key supplied. Continue to the next handler.\n      await next();\n    } else {\n      // Incorrect key supplied. Reject the request.\n      return c.text(\"Sorry, you have supplied an invalid key.\", 403);\n    }\n  });\n\n// Handle all authenticated requests by passing through to origin\n  app.all('*', async (c) => {\n    return fetch(c.req.raw);\n  });\n\nexport default app;\n  js\n  /**\n   * Shows how to restrict access using the HTTP Basic schema.\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\n   * @see https://tools.ietf.org/html/rfc7617\n   *\n   */\n\nimport { Buffer } from \"node:buffer\";\n\nconst encoder = new TextEncoder();\n\n/**\n   * Protect against timing attacks by safely comparing values using `timingSafeEqual`.\n   * Refer to https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#timingsafeequal for more details\n   * @param {string} a\n   * @param {string} b\n   * @returns {boolean}\n   */\n  function timingSafeEqual(a, b) {\n    const aBytes = encoder.encode(a);\n    const bBytes = encoder.encode(b);\n\nif (aBytes.byteLength !== bBytes.byteLength) {\n      // Strings must be the same length in order to compare\n      // with crypto.subtle.timingSafeEqual\n      return false;\n    }\n\nreturn crypto.subtle.timingSafeEqual(aBytes, bBytes);\n  }\n\nexport default {\n    /**\n     *\n     * @param {Request} request\n     * @param {{PASSWORD: string}} env\n     * @returns\n     */\n    async fetch(request, env) {\n      const BASIC_USER = \"admin\";\n\n// You will need an admin password. This should be\n      // attached to your Worker as an encrypted secret.\n      // Refer to https://developers.cloudflare.com/workers/configuration/secrets/\n      const BASIC_PASS = env.PASSWORD ?? \"password\";\n\nconst url = new URL(request.url);\n\nswitch (url.pathname) {\n        case \"/\":\n          return new Response(\"Anyone can access the homepage.\");\n\ncase \"/logout\":\n          // Invalidate the \"Authorization\" header by returning a HTTP 401.\n          // We do not send a \"WWW-Authenticate\" header, as this would trigger\n          // a popup in the browser, immediately asking for credentials again.\n          return new Response(\"Logged out.\", { status: 401 });\n\ncase \"/admin\": {\n          // The \"Authorization\" header is sent when authenticated.\n          const authorization = request.headers.get(\"Authorization\");\n          if (!authorization) {\n            return new Response(\"You need to login.\", {\n              status: 401,\n              headers: {\n                // Prompts the user for credentials.\n                \"WWW-Authenticate\": 'Basic realm=\"my scope\", charset=\"UTF-8\"',\n              },\n            });\n          }\n          const [scheme, encoded] = authorization.split(\" \");\n\n// The Authorization header must start with Basic, followed by a space.\n          if (!encoded || scheme !== \"Basic\") {\n            return new Response(\"Malformed authorization header.\", {\n              status: 400,\n            });\n          }\n\nconst credentials = Buffer.from(encoded, \"base64\").toString();\n\n// The username & password are split by the first colon.\n          //=> example: \"username:password\"\n          const index = credentials.indexOf(\":\");\n          const user = credentials.substring(0, index);\n          const pass = credentials.substring(index + 1);\n\nif (\n            !timingSafeEqual(BASIC_USER, user) ||\n            !timingSafeEqual(BASIC_PASS, pass)\n          ) {\n            return new Response(\"You need to login.\", {\n              status: 401,\n              headers: {\n                // Prompts the user for credentials.\n                \"WWW-Authenticate\": 'Basic realm=\"my scope\", charset=\"UTF-8\"',\n              },\n            });\n          }\n\nreturn new Response(\" You have private access!\", {\n            status: 200,\n            headers: {\n              \"Cache-Control\": \"no-store\",\n            },\n          });\n        }\n      }\n\nreturn new Response(\"Not Found.\", { status: 404 });\n    },\n  };\n  ts\n  /**\n   * Shows how to restrict access using the HTTP Basic schema.\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\n   * @see https://tools.ietf.org/html/rfc7617\n   *\n   */\n\nimport { Buffer } from \"node:buffer\";\n\nconst encoder = new TextEncoder();\n\n/**\n   * Protect against timing attacks by safely comparing values using `timingSafeEqual`.\n   * Refer to https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#timingsafeequal for more details\n   */\n  function timingSafeEqual(a: string, b: string) {\n    const aBytes = encoder.encode(a);\n    const bBytes = encoder.encode(b);\n\nif (aBytes.byteLength !== bBytes.byteLength) {\n      // Strings must be the same length in order to compare\n      // with crypto.subtle.timingSafeEqual\n      return false;\n    }\n\nreturn crypto.subtle.timingSafeEqual(aBytes, bBytes);\n  }\n\ninterface Env {\n    PASSWORD: string;\n  }\n  export default {\n    async fetch(request, env): Promise<Response> {\n      const BASIC_USER = \"admin\";\n\n// You will need an admin password. This should be\n      // attached to your Worker as an encrypted secret.\n      // Refer to https://developers.cloudflare.com/workers/configuration/secrets/\n      const BASIC_PASS = env.PASSWORD ?? \"password\";\n\nconst url = new URL(request.url);\n\nswitch (url.pathname) {\n        case \"/\":\n          return new Response(\"Anyone can access the homepage.\");\n\ncase \"/logout\":\n          // Invalidate the \"Authorization\" header by returning a HTTP 401.\n          // We do not send a \"WWW-Authenticate\" header, as this would trigger\n          // a popup in the browser, immediately asking for credentials again.\n          return new Response(\"Logged out.\", { status: 401 });\n\ncase \"/admin\": {\n          // The \"Authorization\" header is sent when authenticated.\n          const authorization = request.headers.get(\"Authorization\");\n          if (!authorization) {\n            return new Response(\"You need to login.\", {\n              status: 401,\n              headers: {\n                // Prompts the user for credentials.\n                \"WWW-Authenticate\": 'Basic realm=\"my scope\", charset=\"UTF-8\"',\n              },\n            });\n          }\n          const [scheme, encoded] = authorization.split(\" \");\n\n// The Authorization header must start with Basic, followed by a space.\n          if (!encoded || scheme !== \"Basic\") {\n            return new Response(\"Malformed authorization header.\", {\n              status: 400,\n            });\n          }\n\nconst credentials = Buffer.from(encoded, \"base64\").toString();\n\n// The username and password are split by the first colon.\n          //=> example: \"username:password\"\n          const index = credentials.indexOf(\":\");\n          const user = credentials.substring(0, index);\n          const pass = credentials.substring(index + 1);\n\nif (\n            !timingSafeEqual(BASIC_USER, user) ||\n            !timingSafeEqual(BASIC_PASS, pass)\n          ) {\n            return new Response(\"You need to login.\", {\n              status: 401,\n              headers: {\n                // Prompts the user for credentials.\n                \"WWW-Authenticate\": 'Basic realm=\"my scope\", charset=\"UTF-8\"',\n              },\n            });\n          }\n\nreturn new Response(\" You have private access!\", {\n            status: 200,\n            headers: {\n              \"Cache-Control\": \"no-store\",\n            },\n          });\n        }\n      }\n\nreturn new Response(\"Not Found.\", { status: 404 });\n    },\n  } satisfies ExportedHandler<Env>;\n  rs\n  use base64::prelude::*;\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(req: Request, env: Env, _ctx: Context) -> Result<Response> {\n      let basic_user = \"admin\";\n      // You will need an admin password. This should be\n      // attached to your Worker as an encrypted secret.\n      // Refer to https://developers.cloudflare.com/workers/configuration/secrets/\n      let basic_pass = match env.secret(\"PASSWORD\") {\n          Ok(s) => s.to_string(),\n          Err(_) => \"password\".to_string(),\n      };\n      let url = req.url()?;\n\nmatch url.path() {\n          \"/\" => Response::ok(\"Anyone can access the homepage.\"),\n          // Invalidate the \"Authorization\" header by returning a HTTP 401.\n          // We do not send a \"WWW-Authenticate\" header, as this would trigger\n          // a popup in the browser, immediately asking for credentials again.\n          \"/logout\" => Response::error(\"Logged out.\", 401),\n          \"/admin\" => {\n              // The \"Authorization\" header is sent when authenticated.\n              let authorization = req.headers().get(\"Authorization\")?;\n              if authorization == None {\n                  let mut headers = Headers::new();\n                  // Prompts the user for credentials.\n                  headers.set(\n                      \"WWW-Authenticate\",\n                      \"Basic realm='my scope', charset='UTF-8'\",\n                  )?;\n                  return Ok(Response::error(\"You need to login.\", 401)?.with_headers(headers));\n              }\n              let authorization = authorization.unwrap();\n              let auth: Vec<&str> = authorization.split(\" \").collect();\n              let scheme = auth[0];\n              let encoded = auth[1];\n\n// The Authorization header must start with Basic, followed by a space.\n              if encoded == \"\" || scheme != \"Basic\" {\n                  return Response::error(\"Malformed authorization header.\", 400);\n              }\n\nlet buff = BASE64_STANDARD.decode(encoded).unwrap();\n              let credentials = String::from_utf8_lossy(&buff);\n              // The username & password are split by the first colon.\n              //=> example: \"username:password\"\n              let credentials: Vec<&str> = credentials.split(':').collect();\n              let user = credentials[0];\n              let pass = credentials[1];\n\nif user != basic_user || pass != basic_pass {\n                  let mut headers = Headers::new();\n                  // Prompts the user for credentials.\n                  headers.set(\n                      \"WWW-Authenticate\",\n                      \"Basic realm='my scope', charset='UTF-8'\",\n                  )?;\n                  return Ok(Response::error(\"You need to login.\", 401)?.with_headers(headers));\n              }\n\nlet mut headers = Headers::new();\n              headers.set(\"Cache-Control\", \"no-store\")?;\n              Ok(Response::ok(\" You have private access!\")?.with_headers(headers))\n          }\n          _ => Response::error(\"Not Found.\", 404),\n      }\n  }\n  ts\n  /**\n   * Shows how to restrict access using the HTTP Basic schema with Hono.\n   * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication\n   * @see https://tools.ietf.org/html/rfc7617\n   */\n\nimport { Hono } from \"hono\";\n  import { basicAuth } from \"hono/basic-auth\";\n\n// Define environment interface\n  interface Env {\n    Bindings: {\n      USERNAME: string;\n      PASSWORD: string;\n    };\n  }\n\nconst app = new Hono<Env>();\n\n// Public homepage - accessible to everyone\n  app.get(\"/\", (c) => {\n    return c.text(\"Anyone can access the homepage.\");\n  });\n\n// Admin route - protected with Basic Auth\n  app.get(\n    \"/admin\",\n    async (c, next) => {\n      const auth = basicAuth({\n        username: c.env.USERNAME,\n        password: c.env.PASSWORD,\n      });\n\nreturn await auth(c, next);\n    },\n    (c) => {\n      return c.text(\" You have private access!\", 200, {\n        \"Cache-Control\": \"no-store\",\n      });\n    },\n  );\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      try {\n        const tlsVersion = request.cf.tlsVersion;\n        // Allow only TLS versions 1.2 and 1.3\n        if (tlsVersion !== \"TLSv1.2\" && tlsVersion !== \"TLSv1.3\") {\n          return new Response(\"Please use TLS version 1.2 or higher.\", {\n            status: 403,\n          });\n        }\n        return fetch(request);\n      } catch (err) {\n        console.error(\n          \"request.cf does not exist in the previewer, only in production\",\n        );\n        return new Response(`Error in workers script ${err.message}`, {\n          status: 500,\n        });\n      }\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      try {\n        const tlsVersion = request.cf.tlsVersion;\n        // Allow only TLS versions 1.2 and 1.3\n        if (tlsVersion !== \"TLSv1.2\" && tlsVersion !== \"TLSv1.3\") {\n          return new Response(\"Please use TLS version 1.2 or higher.\", {\n            status: 403,\n          });\n        }\n        return fetch(request);\n      } catch (err) {\n        console.error(\n          \"request.cf does not exist in the previewer, only in production\",\n        );\n        return new Response(`Error in workers script ${err.message}`, {\n          status: 500,\n        });\n      }\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\n// Middleware to check TLS version\n  app.use(\"*\", async (c, next) => {\n    // Access the raw request to get the cf object with TLS info\n    const request = c.req.raw;\n    const tlsVersion = request.cf?.tlsVersion;\n\n// Allow only TLS versions 1.2 and 1.3\n    if (tlsVersion !== \"TLSv1.2\" && tlsVersion !== \"TLSv1.3\") {\n      return c.text(\"Please use TLS version 1.2 or higher.\", 403);\n    }\n\napp.onError((err, c) => {\n      console.error(\n        \"request.cf does not exist in the previewer, only in production\",\n      );\n      return c.text(`Error in workers script: ${err.message}`, 500);\n  });\n\napp.get(\"/\", async (c) => {\n    return c.text(`TLS Version: ${c.req.raw.cf.tlsVersion}`);\n  });\n\nexport default app;\n  py\n  from workers import WorkerEntrypoint, Response, fetch\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          tls_version = request.cf.tlsVersion\n          if tls_version not in (\"TLSv1.2\", \"TLSv1.3\"):\n              return Response(\"Please use TLS version 1.2 or higher.\", status=403)\n          return fetch(request)\n  js\n  export default {\n    async fetch(request) {\n      /**\n       * An object with different URLs to fetch\n       * @param {Object} ORIGINS\n       */\n      const ORIGINS = {\n        \"starwarsapi.yourdomain.com\": \"swapi.dev\",\n        \"google.yourdomain.com\": \"www.google.com\",\n      };\n\nconst url = new URL(request.url);\n\n// Check if incoming hostname is a key in the ORIGINS object\n      if (url.hostname in ORIGINS) {\n        const target = ORIGINS[url.hostname];\n        url.hostname = target;\n        // If it is, proxy request to that third party origin\n        return fetch(url.toString(), request);\n      }\n      // Otherwise, process request as normal\n      return fetch(request);\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * An object with different URLs to fetch\n       * @param {Object} ORIGINS\n       */\n      const ORIGINS = {\n        \"starwarsapi.yourdomain.com\": \"swapi.dev\",\n        \"google.yourdomain.com\": \"www.google.com\",\n      };\n\nconst url = new URL(request.url);\n\n// Check if incoming hostname is a key in the ORIGINS object\n      if (url.hostname in ORIGINS) {\n        const target = ORIGINS[url.hostname];\n        url.hostname = target;\n        // If it is, proxy request to that third party origin\n        return fetch(url.toString(), request);\n      }\n      // Otherwise, process request as normal\n      return fetch(request);\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from \"hono\";\n  import { proxy } from \"hono/proxy\";\n\n// An object with different URLs to fetch\n  const ORIGINS: Record<string, string> = {\n    \"starwarsapi.yourdomain.com\": \"swapi.dev\",\n    \"google.yourdomain.com\": \"www.google.com\",\n  };\n\nconst app = new Hono();\n\napp.all(\"*\", async (c) => {\n    const url = new URL(c.req.url);\n\n// Check if incoming hostname is a key in the ORIGINS object\n    if (url.hostname in ORIGINS) {\n      const target = ORIGINS[url.hostname];\n      url.hostname = target;\n\n// If it is, proxy request to that third party origin\n      return proxy(url, c.req.raw);\n    }\n\n// Otherwise, process request as normal\n    return proxy(c.req.raw);\n  });\n\nexport default app;\n  py\n  from workers import WorkerEntrypoint\n  from js import fetch, URL\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # A dict with different URLs to fetch\n          ORIGINS = {\n            \"starwarsapi.yourdomain.com\": \"swapi.dev\",\n            \"google.yourdomain.com\": \"www.google.com\",\n          }\n\nurl = URL.new(request.url)\n\n# Check if incoming hostname is a key in the ORIGINS object\n          if url.hostname in ORIGINS:\n              url.hostname = ORIGINS[url.hostname]\n              # If it is, proxy request to that third party origin\n              return fetch(url.toString(), request)\n\n# Otherwise, process request as normal\n          return fetch(request)\n  js\n  export default {\n    async fetch(request) {\n      const externalHostname = \"examples.cloudflareworkers.com\";\n\nconst redirectMap = new Map([\n        [\"/bulk1\", \"https://\" + externalHostname + \"/redirect2\"],\n        [\"/bulk2\", \"https://\" + externalHostname + \"/redirect3\"],\n        [\"/bulk3\", \"https://\" + externalHostname + \"/redirect4\"],\n        [\"/bulk4\", \"https://google.com\"],\n      ]);\n\nconst requestURL = new URL(request.url);\n      const path = requestURL.pathname;\n      const location = redirectMap.get(path);\n\nif (location) {\n        return Response.redirect(location, 301);\n      }\n      // If request not in map, return the original request\n      return fetch(request);\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const externalHostname = \"examples.cloudflareworkers.com\";\n\nconst redirectMap = new Map([\n        [\"/bulk1\", \"https://\" + externalHostname + \"/redirect2\"],\n        [\"/bulk2\", \"https://\" + externalHostname + \"/redirect3\"],\n        [\"/bulk3\", \"https://\" + externalHostname + \"/redirect4\"],\n        [\"/bulk4\", \"https://google.com\"],\n      ]);\n\nconst requestURL = new URL(request.url);\n      const path = requestURL.pathname;\n      const location = redirectMap.get(path);\n\nif (location) {\n        return Response.redirect(location, 301);\n      }\n      // If request not in map, return the original request\n      return fetch(request);\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response, fetch\n  from urllib.parse import urlparse\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          external_hostname = \"examples.cloudflareworkers.com\"\n\nredirect_map = {\n            \"/bulk1\": \"https://\" + external_hostname + \"/redirect2\",\n            \"/bulk2\": \"https://\" + external_hostname + \"/redirect3\",\n            \"/bulk3\": \"https://\" + external_hostname + \"/redirect4\",\n            \"/bulk4\": \"https://google.com\",\n            }\n\nurl = urlparse(request.url)\n          location = redirect_map.get(url.path, None)\n\nif location:\n              return Response.redirect(location, 301)\n\n# If request not in map, return the original request\n          return fetch(request)\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\n// Configure your redirects\n  const externalHostname = \"examples.cloudflareworkers.com\";\n\nconst redirectMap = new Map([\n    [\"/bulk1\", `https://${externalHostname}/redirect2`],\n    [\"/bulk2\", `https://${externalHostname}/redirect3`],\n    [\"/bulk3\", `https://${externalHostname}/redirect4`],\n    [\"/bulk4\", \"https://google.com\"],\n  ]);\n\n// Middleware to handle redirects\n  app.use(\"*\", async (c, next) => {\n    const path = c.req.path;\n    const location = redirectMap.get(path);\n\nif (location) {\n      // If path is in our redirect map, perform the redirect\n      return c.redirect(location, 301);\n    }\n\n// Otherwise, continue to the next handler\n    await next();\n  });\n\n// Default handler for requests that don't match any redirects\n  app.all(\"*\", async (c) => {\n    // Pass through to origin\n    return fetch(c.req.raw);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request, env, ctx) {\n      const cacheUrl = new URL(request.url);\n\n// Construct the cache key from the cache URL\n      const cacheKey = new Request(cacheUrl.toString(), request);\n      const cache = caches.default;\n\n// Check whether the value is already available in the cache\n      // if not, you will need to fetch it from origin, and store it in the cache\n      let response = await cache.match(cacheKey);\n\nif (!response) {\n        console.log(\n          `Response for request url: ${request.url} not present in cache. Fetching and caching request.`,\n        );\n        // If not in cache, get it from origin\n        response = await fetch(request);\n\n// Must use Response constructor to inherit all of response's fields\n        response = new Response(response.body, response);\n\n// Cache API respects Cache-Control headers. Setting s-maxage to 10\n        // will limit the response to be in cache for 10 seconds max\n\n// Any changes made to the response here will be reflected in the cached value\n        response.headers.append(\"Cache-Control\", \"s-maxage=10\");\n\nctx.waitUntil(cache.put(cacheKey, response.clone()));\n      } else {\n        console.log(`Cache hit for: ${request.url}.`);\n      }\n      return response;\n    },\n  };\n  ts\n  interface Env {}\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      const cacheUrl = new URL(request.url);\n\n// Construct the cache key from the cache URL\n      const cacheKey = new Request(cacheUrl.toString(), request);\n      const cache = caches.default;\n\n// Check whether the value is already available in the cache\n      // if not, you will need to fetch it from origin, and store it in the cache\n      let response = await cache.match(cacheKey);\n\nif (!response) {\n        console.log(\n          `Response for request url: ${request.url} not present in cache. Fetching and caching request.`,\n        );\n        // If not in cache, get it from origin\n        response = await fetch(request);\n\n// Must use Response constructor to inherit all of response's fields\n        response = new Response(response.body, response);\n\n// Cache API respects Cache-Control headers. Setting s-maxage to 10\n        // will limit the response to be in cache for 10 seconds max\n\n// Any changes made to the response here will be reflected in the cached value\n        response.headers.append(\"Cache-Control\", \"s-maxage=10\");\n\nctx.waitUntil(cache.put(cacheKey, response.clone()));\n      } else {\n        console.log(`Cache hit for: ${request.url}.`);\n      }\n      return response;\n    },\n  } satisfies ExportedHandler<Env>;\n  py\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import create_proxy\n  from js import Response, Request, URL, caches, fetch\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          cache_url = request.url\n\n# Construct the cache key from the cache URL\n          cache_key = Request.new(cache_url, request)\n          cache = caches.default\n\n# Check whether the value is already available in the cache\n          # if not, you will need to fetch it from origin, and store it in the cache\n          response = await cache.match(cache_key)\n\nif response is None:\n              print(f\"Response for request url: {request.url} not present in cache. Fetching and caching request.\")\n              # If not in cache, get it from origin\n              response = await fetch(request)\n              # Must use Response constructor to inherit all of response's fields\n              response = Response.new(response.body, response)\n\n# Cache API respects Cache-Control headers. Setting s-max-age to 10\n              # will limit the response to be in cache for 10 seconds s-maxage\n              # Any changes made to the response here will be reflected in the cached value\n              response.headers.append(\"Cache-Control\", \"s-maxage=10\")\n              self.ctx.waitUntil(create_proxy(cache.put(cache_key, response.clone())))\n          else:\n              print(f\"Cache hit for: {request.url}.\")\n          return response\n  ts\n  import { Hono } from \"hono\";\n  import { cache } from \"hono/cache\";\n\nconst app = new Hono();\n\n// We leverage hono built-in cache helper here\n  app.get(\n    \"*\",\n    cache({\n      cacheName: \"my-cache\",\n      cacheControl: \"max-age=3600\", // 1 hour\n    }),\n  );\n\n// Add a route to handle the request if it's not in cache\n  app.get(\"*\", (c) => {\n    return c.text(\"Hello from Hono!\");\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request, env, ctx) {\n      async function sha256(message) {\n        // encode as UTF-8\n        const msgBuffer = await new TextEncoder().encode(message);\n        // hash the message\n        const hashBuffer = await crypto.subtle.digest(\"SHA-256\", msgBuffer);\n        // convert bytes to hex string\n        return [...new Uint8Array(hashBuffer)]\n          .map((b) => b.toString(16).padStart(2, \"0\"))\n          .join(\"\");\n      }\n      try {\n        if (request.method.toUpperCase() === \"POST\") {\n          const body = await request.clone().text();\n          // Hash the request body to use it as a part of the cache key\n          const hash = await sha256(body);\n          const cacheUrl = new URL(request.url);\n          // Store the URL in cache by prepending the body's hash\n          cacheUrl.pathname = \"/posts\" + cacheUrl.pathname + hash;\n          // Convert to a GET to be able to cache\n          const cacheKey = new Request(cacheUrl.toString(), {\n            headers: request.headers,\n            method: \"GET\",\n          });\n\nconst cache = caches.default;\n          // Find the cache key in the cache\n          let response = await cache.match(cacheKey);\n          // Otherwise, fetch response to POST request from origin\n          if (!response) {\n            response = await fetch(request);\n            ctx.waitUntil(cache.put(cacheKey, response.clone()));\n          }\n          return response;\n        }\n        return fetch(request);\n      } catch (e) {\n        return new Response(\"Error thrown \" + e.message);\n      }\n    },\n  };\n  ts\n  interface Env {}\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      async function sha256(message) {\n        // encode as UTF-8\n        const msgBuffer = await new TextEncoder().encode(message);\n        // hash the message\n        const hashBuffer = await crypto.subtle.digest(\"SHA-256\", msgBuffer);\n        // convert bytes to hex string\n        return [...new Uint8Array(hashBuffer)]\n          .map((b) => b.toString(16).padStart(2, \"0\"))\n          .join(\"\");\n      }\n      try {\n        if (request.method.toUpperCase() === \"POST\") {\n          const body = await request.clone().text();\n          // Hash the request body to use it as a part of the cache key\n          const hash = await sha256(body);\n          const cacheUrl = new URL(request.url);\n          // Store the URL in cache by prepending the body's hash\n          cacheUrl.pathname = \"/posts\" + cacheUrl.pathname + hash;\n          // Convert to a GET to be able to cache\n          const cacheKey = new Request(cacheUrl.toString(), {\n            headers: request.headers,\n            method: \"GET\",\n          });\n\nconst cache = caches.default;\n          // Find the cache key in the cache\n          let response = await cache.match(cacheKey);\n          // Otherwise, fetch response to POST request from origin\n          if (!response) {\n            response = await fetch(request);\n            ctx.waitUntil(cache.put(cacheKey, response.clone()));\n          }\n          return response;\n        }\n        return fetch(request);\n      } catch (e) {\n        return new Response(\"Error thrown \" + e.message);\n      }\n    },\n  } satisfies ExportedHandler<Env>;\n  py\n  import hashlib\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import create_proxy\n  from js import fetch, URL, Headers, Request, caches\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request, _, ctx):\n          if 'POST' in request.method:\n              # Hash the request body to use it as a part of the cache key\n              body = await request.clone().text()\n              body_hash = hashlib.sha256(body.encode('UTF-8')).hexdigest()\n\n# Store the URL in cache by prepending the body's hash\n              cache_url = URL.new(request.url)\n              cache_url.pathname = \"/posts\" + cache_url.pathname + body_hash\n\n# Convert to a GET to be able to cache\n              headers = Headers.new(dict(request.headers).items())\n              cache_key = Request.new(cache_url.toString(), method='GET', headers=headers)\n\n# Find the cache key in the cache\n              cache = caches.default\n              response = await cache.match(cache_key)\n\n# Otherwise, fetch response to POST request from origin\n              if response is None:\n                  response = await fetch(request)\n                  ctx.waitUntil(create_proxy(cache.put(cache_key, response.clone())))\n\nreturn fetch(request)\n  ts\n  import { Hono } from \"hono\";\n  import { sha256 } from \"hono/utils/crypto\";\n\nconst app = new Hono();\n\n// Middleware for caching POST requests\n  app.post(\"*\", async (c) => {\n    try {\n      // Get the request body\n      const body = await c.req.raw.clone().text();\n\n// Hash the request body to use it as part of the cache key\n      const hash = await sha256(body);\n\n// Create the cache URL\n      const cacheUrl = new URL(c.req.url);\n\n// Store the URL in cache by prepending the body's hash\n      cacheUrl.pathname = \"/posts\" + cacheUrl.pathname + hash;\n\n// Convert to a GET to be able to cache\n      const cacheKey = new Request(cacheUrl.toString(), {\n        headers: c.req.raw.headers,\n        method: \"GET\",\n      });\n\nconst cache = caches.default;\n\n// Find the cache key in the cache\n      let response = await cache.match(cacheKey);\n\n// If not in cache, fetch response to POST request from origin\n      if (!response) {\n        response = await fetch(c.req.raw);\n        c.executionCtx.waitUntil(cache.put(cacheKey, response.clone()));\n      }\n\nreturn response;\n    } catch (e) {\n      return c.text(\"Error thrown \" + e.message, 500);\n    }\n  });\n\n// Handle all other HTTP methods\n  app.all(\"*\", (c) => {\n    return fetch(c.req.raw);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      const requestUrl = new URL(request.url);\n      const params = requestUrl.searchParams;\n      const tags =\n        params && params.has(\"tags\") ? params.get(\"tags\").split(\",\") : [];\n      const url = params && params.has(\"uri\") ? params.get(\"uri\") : \"\";\n      if (!url) {\n        const errorObject = {\n          error: \"URL cannot be empty\",\n        };\n        return new Response(JSON.stringify(errorObject), { status: 400 });\n      }\n      const init = {\n        cf: {\n          cacheTags: tags,\n        },\n      };\n      return fetch(url, init)\n        .then((result) => {\n          const cacheStatus = result.headers.get(\"cf-cache-status\");\n          const lastModified = result.headers.get(\"last-modified\");\n          const response = {\n            cache: cacheStatus,\n            lastModified: lastModified,\n          };\n          return new Response(JSON.stringify(response), {\n            status: result.status,\n          });\n        })\n        .catch((err) => {\n          const errorObject = {\n            error: err.message,\n          };\n          return new Response(JSON.stringify(errorObject), { status: 500 });\n        });\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const requestUrl = new URL(request.url);\n      const params = requestUrl.searchParams;\n      const tags =\n        params && params.has(\"tags\") ? params.get(\"tags\").split(\",\") : [];\n      const url = params && params.has(\"uri\") ? params.get(\"uri\") : \"\";\n      if (!url) {\n        const errorObject = {\n          error: \"URL cannot be empty\",\n        };\n        return new Response(JSON.stringify(errorObject), { status: 400 });\n      }\n      const init = {\n        cf: {\n          cacheTags: tags,\n        },\n      };\n      return fetch(url, init)\n        .then((result) => {\n          const cacheStatus = result.headers.get(\"cf-cache-status\");\n          const lastModified = result.headers.get(\"last-modified\");\n          const response = {\n            cache: cacheStatus,\n            lastModified: lastModified,\n          };\n          return new Response(JSON.stringify(response), {\n            status: result.status,\n          });\n        })\n        .catch((err) => {\n          const errorObject = {\n            error: err.message,\n          };\n          return new Response(JSON.stringify(errorObject), { status: 500 });\n        });\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\napp.all(\"*\", async (c) => {\n    const tags = c.req.query(\"tags\") ? c.req.query(\"tags\").split(\",\") : [];\n    const uri = c.req.query(\"uri\") ? c.req.query(\"uri\") : \"\";\n\nif (!uri) {\n      return c.json({ error: \"URL cannot be empty\" }, 400);\n    }\n\nconst init = {\n      cf: {\n        cacheTags: tags,\n      },\n    };\n\nconst result = await fetch(uri, init);\n    const cacheStatus = result.headers.get(\"cf-cache-status\");\n    const lastModified = result.headers.get(\"last-modified\");\n\nconst response = {\n      cache: cacheStatus,\n      lastModified: lastModified,\n    };\n\nreturn c.json(response, result.status);\n  });\n\napp.onError((err, c) => {\n    return c.json({ error: err.message }, 500);\n  });\n\nexport default app;\n  py\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Response, URL, Object, fetch\n\ndef to_js(x):\n      return _to_js(x, dict_converter=Object.fromEntries)\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          request_url = URL.new(request.url)\n          params = request_url.searchParams\n          tags = params[\"tags\"].split(\",\") if \"tags\" in params else []\n          url = params[\"uri\"] or None\n\nif url is None:\n              error = {\"error\": \"URL cannot be empty\"}\n              return Response.json(to_js(error), status=400)\n\noptions = {\"cf\": {\"cacheTags\": tags}}\n          result = await fetch(url, to_js(options))\n\ncache_status = result.headers[\"cf-cache-status\"]\n          last_modified = result.headers[\"last-modified\"]\n          response = {\"cache\": cache_status, \"lastModified\": last_modified}\n\nreturn Response.json(to_js(response), status=result.status)\n  js\n  export default {\n    async fetch(request) {\n      const url = new URL(request.url);\n      // Only use the path for the cache key, removing query strings\n      // and always store using HTTPS, for example, https://www.example.com/file-uri-here\n      const someCustomKey = `https://${url.hostname}${url.pathname}`;\n      let response = await fetch(request, {\n        cf: {\n          // Always cache this fetch regardless of content type\n          // for a max of 5 seconds before revalidating the resource\n          cacheTtl: 5,\n          cacheEverything: true,\n          //Enterprise only feature, see Cache API for other plans\n          cacheKey: someCustomKey,\n        },\n      });\n      // Reconstruct the Response object to make its headers mutable.\n      response = new Response(response.body, response);\n      // Set cache control headers to cache on browser for 25 minutes\n      response.headers.set(\"Cache-Control\", \"max-age=1500\");\n      return response;\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const url = new URL(request.url);\n      // Only use the path for the cache key, removing query strings\n      // and always store using HTTPS, for example, https://www.example.com/file-uri-here\n      const someCustomKey = `https://${url.hostname}${url.pathname}`;\n      let response = await fetch(request, {\n        cf: {\n          // Always cache this fetch regardless of content type\n          // for a max of 5 seconds before revalidating the resource\n          cacheTtl: 5,\n          cacheEverything: true,\n          //Enterprise only feature, see Cache API for other plans\n          cacheKey: someCustomKey,\n        },\n      });\n      // Reconstruct the Response object to make its headers mutable.\n      response = new Response(response.body, response);\n      // Set cache control headers to cache on browser for 25 minutes\n      response.headers.set(\"Cache-Control\", \"max-age=1500\");\n      return response;\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from 'hono';\n\nconst app = new Hono<{ Bindings: Bindings }>();\n\napp.all('*', async (c) => {\n    const url = new URL(c.req.url);\n\n// Only use the path for the cache key, removing query strings\n    // and always store using HTTPS, for example, https://www.example.com/file-uri-here\n    const someCustomKey = `https://${url.hostname}${url.pathname}`;\n\n// Fetch the request with custom cache settings\n    let response = await fetch(c.req.raw, {\n      cf: {\n        // Always cache this fetch regardless of content type\n        // for a max of 5 seconds before revalidating the resource\n        cacheTtl: 5,\n        cacheEverything: true,\n        // Enterprise only feature, see Cache API for other plans\n        cacheKey: someCustomKey,\n      },\n    });\n\n// Reconstruct the Response object to make its headers mutable\n    response = new Response(response.body, response);\n\n// Set cache control headers to cache on browser for 25 minutes\n    response.headers.set(\"Cache-Control\", \"max-age=1500\");\n\nreturn response;\n  });\n\nexport default app;\n  py\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Response, URL, Object, fetch\n\ndef to_js(x):\n      return _to_js(x, dict_converter=Object.fromEntries)\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          url = URL.new(request.url)\n\n# Only use the path for the cache key, removing query strings\n          # and always store using HTTPS, for example, https://www.example.com/file-uri-here\n          some_custom_key = f\"https://{url.hostname}{url.pathname}\"\n\nresponse = await fetch(\n              request,\n              cf=to_js({\n                  # Always cache this fetch regardless of content type\n                  # for a max of 5 seconds before revalidating the resource\n                  \"cacheTtl\": 5,\n                  \"cacheEverything\": True,\n                  # Enterprise only feature, see Cache API for other plans\n                  \"cacheKey\": some_custom_key,\n              }),\n          )\n\n# Reconstruct the Response object to make its headers mutable\n          response = Response.new(response.body, response)\n\n# Set cache control headers to cache on browser for 25 minutes\n          response.headers[\"Cache-Control\"] = \"max-age=1500\"\n\nreturn response\n  rs\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let url = req.url()?;\n\n// Only use the path for the cache key, removing query strings\n      // and always store using HTTPS, for example, https://www.example.com/file-uri-here\n      let custom_key = format!(\n          \"https://{host}{path}\",\n          host = url.host_str().unwrap(),\n          path = url.path()\n      );\n\nlet request = Request::new_with_init(\n          url.as_str(),\n          &RequestInit {\n              headers: req.headers().clone(),\n              method: req.method(),\n              cf: CfProperties {\n                  // Always cache this fetch regardless of content type\n                  // for a max of 5 seconds before revalidating the resource\n                  cache_ttl: Some(5),\n                  cache_everything: Some(true),\n                  // Enterprise only feature, see Cache API for other plans\n                  cache_key: Some(custom_key),\n                  ..CfProperties::default()\n              },\n              ..RequestInit::default()\n          },\n      )?;\n\nlet mut response = Fetch::Request(request).send().await?;\n\n// Set cache control headers to cache on browser for 25 minutes\n      let _ = response.headers_mut().set(\"Cache-Control\", \"max-age=1500\");\n      Ok(response)\n  }\n  js\n// Force Cloudflare to cache an asset\nfetch(event.request, { cf: { cacheEverything: true } });\njs\n// Set cache key for this request to \"some-string\".\nfetch(event.request, { cf: { cacheKey: \"some-string\" } });\njs\n  export default {\n    async fetch(request) {\n      let url = new URL(request.url);\n\nif (Math.random() < 0.5) {\n        url.hostname = \"example.s3.amazonaws.com\";\n      } else {\n        url.hostname = \"example.storage.googleapis.com\";\n      }\n\nlet newRequest = new Request(url, request);\n      return fetch(newRequest, {\n        cf: { cacheKey: request.url },\n      });\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      let url = new URL(request.url);\n\nif (Math.random() < 0.5) {\n        url.hostname = \"example.s3.amazonaws.com\";\n      } else {\n        url.hostname = \"example.storage.googleapis.com\";\n      }\n\nlet newRequest = new Request(url, request);\n      return fetch(newRequest, {\n        cf: { cacheKey: request.url },\n      });\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from 'hono';\n\nconst app = new Hono<{ Bindings: Bindings }>();\n\napp.all('*', async (c) => {\n    const originalUrl = c.req.url;\n    const url = new URL(originalUrl);\n\n// Randomly select a storage backend\n    if (Math.random() < 0.5) {\n      url.hostname = \"example.s3.amazonaws.com\";\n    } else {\n      url.hostname = \"example.storage.googleapis.com\";\n    }\n\n// Create a new request to the selected backend\n    const newRequest = new Request(url, c.req.raw);\n\n// Fetch using the original URL as the cache key\n    return fetch(newRequest, {\n      cf: { cacheKey: originalUrl },\n    });\n  });\n\nexport default app;\n  js\n// Force response to be cached for 86400 seconds for 200 status\n// codes, 1 second for 404, and do not cache 500 errors.\nfetch(request, {\n  cf: { cacheTtlByStatus: { \"200-299\": 86400, 404: 1, \"500-599\": 0 } },\n});\njs\n  export default {\n    async fetch(request) {\n      // Instantiate new URL to make it mutable\n      const newRequest = new URL(request.url);\n\nconst customCacheKey = `${newRequest.hostname}${newRequest.pathname}`;\n      const queryCacheKey = `${newRequest.hostname}${newRequest.pathname}${newRequest.search}`;\n\n// Different asset types usually have different caching strategies. Most of the time media content such as audio, videos and images that are not user-generated content would not need to be updated often so a long TTL would be best. However, with HLS streaming, manifest files usually are set with short TTLs so that playback will not be affected, as this files contain the data that the player would need. By setting each caching strategy for categories of asset types in an object within an array, you can solve complex needs when it comes to media content for your application\n\nconst cacheAssets = [\n        {\n          asset: \"video\",\n          key: customCacheKey,\n          regex:\n            /(.*\\/Video)|(.*\\.(m4s|mp4|ts|avi|mpeg|mpg|mkv|bin|webm|vob|flv|m2ts|mts|3gp|m4v|wmv|qt))/,\n          info: 0,\n          ok: 31556952,\n          redirects: 30,\n          clientError: 10,\n          serverError: 0,\n        },\n        {\n          asset: \"image\",\n          key: queryCacheKey,\n          regex:\n            /(.*\\/Images)|(.*\\.(jpg|jpeg|png|bmp|pict|tif|tiff|webp|gif|heif|exif|bat|bpg|ppm|pgn|pbm|pnm))/,\n          info: 0,\n          ok: 3600,\n          redirects: 30,\n          clientError: 10,\n          serverError: 0,\n        },\n        {\n          asset: \"frontEnd\",\n          key: queryCacheKey,\n          regex: /^.*\\.(css|js)/,\n          info: 0,\n          ok: 3600,\n          redirects: 30,\n          clientError: 10,\n          serverError: 0,\n        },\n        {\n          asset: \"audio\",\n          key: customCacheKey,\n          regex:\n            /(.*\\/Audio)|(.*\\.(flac|aac|mp3|alac|aiff|wav|ogg|aiff|opus|ape|wma|3gp))/,\n          info: 0,\n          ok: 31556952,\n          redirects: 30,\n          clientError: 10,\n          serverError: 0,\n        },\n        {\n          asset: \"directPlay\",\n          key: customCacheKey,\n          regex: /.*(\\/Download)/,\n          info: 0,\n          ok: 31556952,\n          redirects: 30,\n          clientError: 10,\n          serverError: 0,\n        },\n        {\n          asset: \"manifest\",\n          key: customCacheKey,\n          regex: /^.*\\.(m3u8|mpd)/,\n          info: 0,\n          ok: 3,\n          redirects: 2,\n          clientError: 1,\n          serverError: 0,\n        },\n      ];\n\nconst { asset, regex, ...cache } =\n        cacheAssets.find(({ regex }) => newRequest.pathname.match(regex)) ?? {};\n\nconst newResponse = await fetch(request, {\n        cf: {\n          cacheKey: cache.key,\n          polish: false,\n          cacheEverything: true,\n          cacheTtlByStatus: {\n            \"100-199\": cache.info,\n            \"200-299\": cache.ok,\n            \"300-399\": cache.redirects,\n            \"400-499\": cache.clientError,\n            \"500-599\": cache.serverError,\n          },\n          cacheTags: [\"static\"],\n        },\n      });\n\nconst response = new Response(newResponse.body, newResponse);\n\n// For debugging purposes\n      response.headers.set(\"debug\", JSON.stringify(cache));\n      return response;\n    },\n  };\n  js\n  addEventListener(\"fetch\", (event) => {\n    return event.respondWith(handleRequest(event.request));\n  });\n\nasync function handleRequest(request) {\n    // Instantiate new URL to make it mutable\n    const newRequest = new URL(request.url);\n\n// Set `const` to be used in the array later on\n    const customCacheKey = `${newRequest.hostname}${newRequest.pathname}`;\n    const queryCacheKey = `${newRequest.hostname}${newRequest.pathname}${newRequest.search}`;\n\n// Set all variables needed to manipulate Cloudflare's cache using the fetch API in the `cf` object. You will be passing these variables in the objects down below.\n    const cacheAssets = [\n      {\n        asset: \"video\",\n        key: customCacheKey,\n        regex:\n          /(.*\\/Video)|(.*\\.(m4s|mp4|ts|avi|mpeg|mpg|mkv|bin|webm|vob|flv|m2ts|mts|3gp|m4v|wmv|qt))/,\n        info: 0,\n        ok: 31556952,\n        redirects: 30,\n        clientError: 10,\n        serverError: 0,\n      },\n      {\n        asset: \"image\",\n        key: queryCacheKey,\n        regex:\n          /(.*\\/Images)|(.*\\.(jpg|jpeg|png|bmp|pict|tif|tiff|webp|gif|heif|exif|bat|bpg|ppm|pgn|pbm|pnm))/,\n        info: 0,\n        ok: 3600,\n        redirects: 30,\n        clientError: 10,\n        serverError: 0,\n      },\n      {\n        asset: \"frontEnd\",\n        key: queryCacheKey,\n        regex: /^.*\\.(css|js)/,\n        info: 0,\n        ok: 3600,\n        redirects: 30,\n        clientError: 10,\n        serverError: 0,\n      },\n      {\n        asset: \"audio\",\n        key: customCacheKey,\n        regex:\n          /(.*\\/Audio)|(.*\\.(flac|aac|mp3|alac|aiff|wav|ogg|aiff|opus|ape|wma|3gp))/,\n        info: 0,\n        ok: 31556952,\n        redirects: 30,\n        clientError: 10,\n        serverError: 0,\n      },\n      {\n        asset: \"directPlay\",\n        key: customCacheKey,\n        regex: /.*(\\/Download)/,\n        info: 0,\n        ok: 31556952,\n        redirects: 30,\n        clientError: 10,\n        serverError: 0,\n      },\n      {\n        asset: \"manifest\",\n        key: customCacheKey,\n        regex: /^.*\\.(m3u8|mpd)/,\n        info: 0,\n        ok: 3,\n        redirects: 2,\n        clientError: 1,\n        serverError: 0,\n      },\n    ];\n\n// the `.find` method is used to find elements in an array (`cacheAssets`), in this case, `regex`, which can passed to the .`match` method to match on file extensions to cache, since they are many media types in the array. If you want to add more types, update the array. Refer to https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find for more information.\n    const { asset, regex, ...cache } =\n      cacheAssets.find(({ regex }) => newRequest.pathname.match(regex)) ?? {};\n\nconst newResponse = await fetch(request, {\n      cf: {\n        cacheKey: cache.key,\n        polish: false,\n        cacheEverything: true,\n        cacheTtlByStatus: {\n          \"100-199\": cache.info,\n          \"200-299\": cache.ok,\n          \"300-399\": cache.redirects,\n          \"400-499\": cache.clientError,\n          \"500-599\": cache.serverError,\n        },\n        cacheTags: [\"static\"],\n      },\n    });\n\nconst response = new Response(newResponse.body, newResponse);\n\n// For debugging purposes\n    response.headers.set(\"debug\", JSON.stringify(cache));\n    return response;\n  }\n  js\nfetch(request, { cache: 'no-store'});\nfetch(request, { cache: 'no-cache'});\njs\n  export default {\n    async fetch(request) {\n      const BLOCKED_HOSTNAMES = [\"nope.mywebsite.com\", \"bye.website.com\"];\n      // Return a new Response based on a URL's hostname\n      const url = new URL(request.url);\n      if (BLOCKED_HOSTNAMES.includes(url.hostname)) {\n        return new Response(\"Blocked Host\", { status: 403 });\n      }\n      // Block paths ending in .doc or .xml based on the URL's file extension\n      const forbiddenExtRegExp = new RegExp(/\\.(doc|xml)$/);\n      if (forbiddenExtRegExp.test(url.pathname)) {\n        return new Response(\"Blocked Extension\", { status: 403 });\n      }\n      // On HTTP method\n      if (request.method === \"POST\") {\n        return new Response(\"Response for POST\");\n      }\n      // On User Agent\n      const userAgent = request.headers.get(\"User-Agent\") || \"\";\n      if (userAgent.includes(\"bot\")) {\n        return new Response(\"Block User Agent containing bot\", { status: 403 });\n      }\n      // On Client's IP address\n      const clientIP = request.headers.get(\"CF-Connecting-IP\");\n      if (clientIP === \"1.2.3.4\") {\n        return new Response(\"Block the IP 1.2.3.4\", { status: 403 });\n      }\n      // On ASN\n      if (request.cf && request.cf.asn == 64512) {\n        return new Response(\"Block the ASN 64512 response\");\n      }\n      // On Device Type\n      // Requires Enterprise \"CF-Device-Type Header\" zone setting or\n      // Page Rule with \"Cache By Device Type\" setting applied.\n      const device = request.headers.get(\"CF-Device-Type\");\n      if (device === \"mobile\") {\n        return Response.redirect(\"https://mobile.example.com\");\n      }\n      console.error(\n        \"Getting Client's IP address, device type, and ASN are not supported in playground. Must test on a live worker\",\n      );\n      return fetch(request);\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const BLOCKED_HOSTNAMES = [\"nope.mywebsite.com\", \"bye.website.com\"];\n      // Return a new Response based on a URL's hostname\n      const url = new URL(request.url);\n      if (BLOCKED_HOSTNAMES.includes(url.hostname)) {\n        return new Response(\"Blocked Host\", { status: 403 });\n      }\n      // Block paths ending in .doc or .xml based on the URL's file extension\n      const forbiddenExtRegExp = new RegExp(/\\.(doc|xml)$/);\n      if (forbiddenExtRegExp.test(url.pathname)) {\n        return new Response(\"Blocked Extension\", { status: 403 });\n      }\n      // On HTTP method\n      if (request.method === \"POST\") {\n        return new Response(\"Response for POST\");\n      }\n      // On User Agent\n      const userAgent = request.headers.get(\"User-Agent\") || \"\";\n      if (userAgent.includes(\"bot\")) {\n        return new Response(\"Block User Agent containing bot\", { status: 403 });\n      }\n      // On Client's IP address\n      const clientIP = request.headers.get(\"CF-Connecting-IP\");\n      if (clientIP === \"1.2.3.4\") {\n        return new Response(\"Block the IP 1.2.3.4\", { status: 403 });\n      }\n      // On ASN\n      if (request.cf && request.cf.asn == 64512) {\n        return new Response(\"Block the ASN 64512 response\");\n      }\n      // On Device Type\n      // Requires Enterprise \"CF-Device-Type Header\" zone setting or\n      // Page Rule with \"Cache By Device Type\" setting applied.\n      const device = request.headers.get(\"CF-Device-Type\");\n      if (device === \"mobile\") {\n        return Response.redirect(\"https://mobile.example.com\");\n      }\n      console.error(\n        \"Getting Client's IP address, device type, and ASN are not supported in playground. Must test on a live worker\",\n      );\n      return fetch(request);\n    },\n  } satisfies ExportedHandler;\n  py\n  import re\n  from workers import WorkerEntrypoint, Response, fetch\n  from urllib.parse import urlparse\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          blocked_hostnames = [\"nope.mywebsite.com\", \"bye.website.com\"]\n          url = urlparse(request.url)\n\n# Block on hostname\n          if url.hostname in blocked_hostnames:\n              return Response(\"Blocked Host\", status=403)\n\n# On paths ending in .doc or .xml\n          if re.search(r'\\.(doc|xml)$', url.path):\n              return Response(\"Blocked Extension\", status=403)\n\n# On HTTP method\n          if \"POST\" in request.method:\n              return Response(\"Response for POST\")\n\n# On User Agent\n          user_agent = request.headers[\"User-Agent\"] or \"\"\n          if \"bot\" in user_agent:\n              return Response(\"Block User Agent containing bot\", status=403)\n\n# On Client's IP address\n          client_ip = request.headers[\"CF-Connecting-IP\"]\n          if client_ip == \"1.2.3.4\":\n              return Response(\"Block the IP 1.2.3.4\", status=403)\n\n# On ASN\n          if request.cf and request.cf.asn == 64512:\n              return Response(\"Block the ASN 64512 response\")\n\n# On Device Type\n          # Requires Enterprise \"CF-Device-Type Header\" zone setting or\n          # Page Rule with \"Cache By Device Type\" setting applied.\n          device = request.headers[\"CF-Device-Type\"]\n          if device == \"mobile\":\n              return Response.redirect(\"https://mobile.example.com\")\n\nreturn fetch(request)\n  ts\n  import { Hono } from \"hono\";\n  import { HTTPException } from \"hono/http-exception\";\n\nconst app = new Hono();\n\n// Middleware to handle all conditions before reaching the main handler\n  app.use(\"*\", async (c, next) => {\n    const request = c.req.raw;\n    const BLOCKED_HOSTNAMES = [\"nope.mywebsite.com\", \"bye.website.com\"];\n    const hostname = new URL(c.req.url)?.hostname;\n\n// Return a new Response based on a URL's hostname\n    if (BLOCKED_HOSTNAMES.includes(hostname)) {\n      return c.text(\"Blocked Host\", 403);\n    }\n\n// Block paths ending in .doc or .xml based on the URL's file extension\n    const forbiddenExtRegExp = new RegExp(/\\.(doc|xml)$/);\n    if (forbiddenExtRegExp.test(c.req.pathname)) {\n      return c.text(\"Blocked Extension\", 403);\n    }\n\n// On User Agent\n    const userAgent = c.req.header(\"User-Agent\") || \"\";\n    if (userAgent.includes(\"bot\")) {\n      return c.text(\"Block User Agent containing bot\", 403);\n    }\n\n// On Client's IP address\n    const clientIP = c.req.header(\"CF-Connecting-IP\");\n    if (clientIP === \"1.2.3.4\") {\n      return c.text(\"Block the IP 1.2.3.4\", 403);\n    }\n\n// On ASN\n    if (request.cf && request.cf.asn === 64512) {\n      return c.text(\"Block the ASN 64512 response\");\n    }\n\n// On Device Type\n    // Requires Enterprise \"CF-Device-Type Header\" zone setting or\n    // Page Rule with \"Cache By Device Type\" setting applied.\n    const device = c.req.header(\"CF-Device-Type\");\n    if (device === \"mobile\") {\n      return c.redirect(\"https://mobile.example.com\");\n    }\n\n// Continue to the next handler\n    await next();\n  });\n\n// Handle POST requests differently\n  app.post(\"*\", (c) => {\n    return c.text(\"Response for POST\");\n  });\n\n// Default handler for other methods\n  app.get(\"*\", async (c) => {\n    console.error(\n      \"Getting Client's IP address, device type, and ASN are not supported in playground. Must test on a live worker\",\n    );\n\n// Fetch the original request\n    return fetch(c.req.raw);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      const corsHeaders = {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET,HEAD,POST,OPTIONS\",\n        \"Access-Control-Max-Age\": \"86400\",\n      };\n\n// The URL for the remote third party API you want to fetch from\n      // but does not implement CORS\n      const API_URL = \"https://examples.cloudflareworkers.com/demos/demoapi\";\n\n// The endpoint you want the CORS reverse proxy to be on\n      const PROXY_ENDPOINT = \"/corsproxy/\";\n\n// The rest of this snippet for the demo page\n      function rawHtmlResponse(html) {\n        return new Response(html, {\n          headers: {\n            \"content-type\": \"text/html;charset=UTF-8\",\n          },\n        });\n      }\n\nconst DEMO_PAGE = `\n        <!DOCTYPE html>\n        <html>\n        <body>\n          <h1>API GET without CORS Proxy</h1>\n          <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\">Shows TypeError: Failed to fetch since CORS is misconfigured</a>\n          <p id=\"noproxy-status\"/>\n          <code id=\"noproxy\">Waiting</code>\n          <h1>API GET with CORS Proxy</h1>\n          <p id=\"proxy-status\"/>\n          <code id=\"proxy\">Waiting</code>\n          <h1>API POST with CORS Proxy + Preflight</h1>\n          <p id=\"proxypreflight-status\"/>\n          <code id=\"proxypreflight\">Waiting</code>\n          <script>\n          let reqs = {};\n          reqs.noproxy = () => {\n            return fetch(\"${API_URL}\").then(r => r.json())\n          }\n          reqs.proxy = async () => {\n            let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n            return fetch(window.location.origin + href).then(r => r.json())\n          }\n          reqs.proxypreflight = async () => {\n            let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n            let response = await fetch(window.location.origin + href, {\n              method: \"POST\",\n              headers: {\n                \"Content-Type\": \"application/json\"\n              },\n              body: JSON.stringify({\n                msg: \"Hello world!\"\n              })\n            })\n            return response.json()\n          }\n          (async () => {\n          for (const [reqName, req] of Object.entries(reqs)) {\n            try {\n              let data = await req()\n              document.getElementById(reqName).innerHTML = JSON.stringify(data)\n            } catch (e) {\n              document.getElementById(reqName).innerHTML = e\n            }\n          }\n        })()\n          </script>\n        </body>\n        </html>\n      `;\n\nasync function handleRequest(request) {\n        const url = new URL(request.url);\n        let apiUrl = url.searchParams.get(\"apiurl\");\n\nif (apiUrl == null) {\n          apiUrl = API_URL;\n        }\n\n// Rewrite request to point to API URL. This also makes the request mutable\n        // so you can add the correct Origin header to make the API server think\n        // that this request is not cross-site.\n        request = new Request(apiUrl, request);\n        request.headers.set(\"Origin\", new URL(apiUrl).origin);\n        let response = await fetch(request);\n        // Recreate the response so you can modify the headers\n\nresponse = new Response(response.body, response);\n        // Set CORS headers\n\nresponse.headers.set(\"Access-Control-Allow-Origin\", url.origin);\n\n// Append to/Add Vary header so browser will cache response correctly\n        response.headers.append(\"Vary\", \"Origin\");\n\nreturn response;\n      }\n\nasync function handleOptions(request) {\n        if (\n          request.headers.get(\"Origin\") !== null &&\n          request.headers.get(\"Access-Control-Request-Method\") !== null &&\n          request.headers.get(\"Access-Control-Request-Headers\") !== null\n        ) {\n          // Handle CORS preflight requests.\n          return new Response(null, {\n            headers: {\n              ...corsHeaders,\n              \"Access-Control-Allow-Headers\": request.headers.get(\n                \"Access-Control-Request-Headers\",\n              ),\n            },\n          });\n        } else {\n          // Handle standard OPTIONS request.\n          return new Response(null, {\n            headers: {\n              Allow: \"GET, HEAD, POST, OPTIONS\",\n            },\n          });\n        }\n      }\n\nconst url = new URL(request.url);\n      if (url.pathname.startsWith(PROXY_ENDPOINT)) {\n        if (request.method === \"OPTIONS\") {\n          // Handle CORS preflight requests\n          return handleOptions(request);\n        } else if (\n          request.method === \"GET\" ||\n          request.method === \"HEAD\" ||\n          request.method === \"POST\"\n        ) {\n          // Handle requests to the API server\n          return handleRequest(request);\n        } else {\n          return new Response(null, {\n            status: 405,\n            statusText: \"Method Not Allowed\",\n          });\n        }\n      } else {\n        return rawHtmlResponse(DEMO_PAGE);\n      }\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const corsHeaders = {\n        \"Access-Control-Allow-Origin\": \"*\",\n        \"Access-Control-Allow-Methods\": \"GET,HEAD,POST,OPTIONS\",\n        \"Access-Control-Max-Age\": \"86400\",\n      };\n\n// The URL for the remote third party API you want to fetch from\n      // but does not implement CORS\n      const API_URL = \"https://examples.cloudflareworkers.com/demos/demoapi\";\n\n// The endpoint you want the CORS reverse proxy to be on\n      const PROXY_ENDPOINT = \"/corsproxy/\";\n\n// The rest of this snippet for the demo page\n      function rawHtmlResponse(html) {\n        return new Response(html, {\n          headers: {\n            \"content-type\": \"text/html;charset=UTF-8\",\n          },\n        });\n      }\n\nconst DEMO_PAGE = `\n        <!DOCTYPE html>\n        <html>\n        <body>\n          <h1>API GET without CORS Proxy</h1>\n          <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\">Shows TypeError: Failed to fetch since CORS is misconfigured</a>\n          <p id=\"noproxy-status\"/>\n          <code id=\"noproxy\">Waiting</code>\n          <h1>API GET with CORS Proxy</h1>\n          <p id=\"proxy-status\"/>\n          <code id=\"proxy\">Waiting</code>\n          <h1>API POST with CORS Proxy + Preflight</h1>\n          <p id=\"proxypreflight-status\"/>\n          <code id=\"proxypreflight\">Waiting</code>\n          <script>\n          let reqs = {};\n          reqs.noproxy = () => {\n            return fetch(\"${API_URL}\").then(r => r.json())\n          }\n          reqs.proxy = async () => {\n            let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n            return fetch(window.location.origin + href).then(r => r.json())\n          }\n          reqs.proxypreflight = async () => {\n            let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n            let response = await fetch(window.location.origin + href, {\n              method: \"POST\",\n              headers: {\n                \"Content-Type\": \"application/json\"\n              },\n              body: JSON.stringify({\n                msg: \"Hello world!\"\n              })\n            })\n            return response.json()\n          }\n          (async () => {\n          for (const [reqName, req] of Object.entries(reqs)) {\n            try {\n              let data = await req()\n              document.getElementById(reqName).textContent = JSON.stringify(data)\n            } catch (e) {\n              document.getElementById(reqName).textContent = e\n            }\n          }\n        })()\n          </script>\n        </body>\n        </html>\n      `;\n\nasync function handleRequest(request) {\n        const url = new URL(request.url);\n        let apiUrl = url.searchParams.get(\"apiurl\");\n\nif (apiUrl == null) {\n          apiUrl = API_URL;\n        }\n\n// Rewrite request to point to API URL. This also makes the request mutable\n        // so you can add the correct Origin header to make the API server think\n        // that this request is not cross-site.\n        request = new Request(apiUrl, request);\n        request.headers.set(\"Origin\", new URL(apiUrl).origin);\n        let response = await fetch(request);\n        // Recreate the response so you can modify the headers\n\nresponse = new Response(response.body, response);\n        // Set CORS headers\n\nresponse.headers.set(\"Access-Control-Allow-Origin\", url.origin);\n\n// Append to/Add Vary header so browser will cache response correctly\n        response.headers.append(\"Vary\", \"Origin\");\n\nreturn response;\n      }\n\nasync function handleOptions(request) {\n        if (\n          request.headers.get(\"Origin\") !== null &&\n          request.headers.get(\"Access-Control-Request-Method\") !== null &&\n          request.headers.get(\"Access-Control-Request-Headers\") !== null\n        ) {\n          // Handle CORS preflight requests.\n          return new Response(null, {\n            headers: {\n              ...corsHeaders,\n              \"Access-Control-Allow-Headers\": request.headers.get(\n                \"Access-Control-Request-Headers\",\n              ),\n            },\n          });\n        } else {\n          // Handle standard OPTIONS request.\n          return new Response(null, {\n            headers: {\n              Allow: \"GET, HEAD, POST, OPTIONS\",\n            },\n          });\n        }\n      }\n\nconst url = new URL(request.url);\n      if (url.pathname.startsWith(PROXY_ENDPOINT)) {\n        if (request.method === \"OPTIONS\") {\n          // Handle CORS preflight requests\n          return handleOptions(request);\n        } else if (\n          request.method === \"GET\" ||\n          request.method === \"HEAD\" ||\n          request.method === \"POST\"\n        ) {\n          // Handle requests to the API server\n          return handleRequest(request);\n        } else {\n          return new Response(null, {\n            status: 405,\n            statusText: \"Method Not Allowed\",\n          });\n        }\n      } else {\n        return rawHtmlResponse(DEMO_PAGE);\n      }\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from \"hono\";\n  import { cors } from \"hono/cors\";\n\n// The URL for the remote third party API you want to fetch from\n  // but does not implement CORS\n  const API_URL = \"https://examples.cloudflareworkers.com/demos/demoapi\";\n\n// The endpoint you want the CORS reverse proxy to be on\n  const PROXY_ENDPOINT = \"/corsproxy/\";\n\nconst app = new Hono();\n\n// Demo page handler\n  app.get(\"*\", async (c) => {\n    // Only handle non-proxy requests with this handler\n    if (c.req.path.startsWith(PROXY_ENDPOINT)) {\n      return next();\n    }\n\n// Create the demo page HTML\n    const DEMO_PAGE = `\n      <!DOCTYPE html>\n      <html>\n      <body>\n        <h1>API GET without CORS Proxy</h1>\n        <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\">Shows TypeError: Failed to fetch since CORS is misconfigured</a>\n        <p id=\"noproxy-status\"/>\n        <code id=\"noproxy\">Waiting</code>\n        <h1>API GET with CORS Proxy</h1>\n        <p id=\"proxy-status\"/>\n        <code id=\"proxy\">Waiting</code>\n        <h1>API POST with CORS Proxy + Preflight</h1>\n        <p id=\"proxypreflight-status\"/>\n        <code id=\"proxypreflight\">Waiting</code>\n        <script>\n        let reqs = {};\n        reqs.noproxy = () => {\n          return fetch(\"${API_URL}\").then(r => r.json())\n        }\n        reqs.proxy = async () => {\n          let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n          return fetch(window.location.origin + href).then(r => r.json())\n        }\n        reqs.proxypreflight = async () => {\n          let href = \"${PROXY_ENDPOINT}?apiurl=${API_URL}\"\n          let response = await fetch(window.location.origin + href, {\n            method: \"POST\",\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n              msg: \"Hello world!\"\n            })\n          })\n          return response.json()\n        }\n        (async () => {\n        for (const [reqName, req] of Object.entries(reqs)) {\n          try {\n            let data = await req()\n            document.getElementById(reqName).innerHTML = JSON.stringify(data)\n          } catch (e) {\n            document.getElementById(reqName).innerHTML = e\n          }\n        }\n      })()\n        </script>\n      </body>\n      </html>\n    `;\n\nreturn c.html(DEMO_PAGE);\n  });\n\n// CORS proxy routes\n  app.on([\"GET\", \"HEAD\", \"POST\", \"OPTIONS\"], PROXY_ENDPOINT + \"*\", async (c) => {\n    const url = new URL(c.req.url);\n\n// Handle OPTIONS preflight requests\n    if (c.req.method === \"OPTIONS\") {\n      const origin = c.req.header(\"Origin\");\n      const requestMethod = c.req.header(\"Access-Control-Request-Method\");\n      const requestHeaders = c.req.header(\"Access-Control-Request-Headers\");\n\nif (origin && requestMethod && requestHeaders) {\n        // Handle CORS preflight requests\n        return new Response(null, {\n          headers: {\n            \"Access-Control-Allow-Origin\": \"*\",\n            \"Access-Control-Allow-Methods\": \"GET,HEAD,POST,OPTIONS\",\n            \"Access-Control-Max-Age\": \"86400\",\n            \"Access-Control-Allow-Headers\": requestHeaders,\n          },\n        });\n      } else {\n        // Handle standard OPTIONS request\n        return new Response(null, {\n          headers: {\n            Allow: \"GET, HEAD, POST, OPTIONS\",\n          },\n        });\n      }\n    }\n\n// Handle actual requests\n    let apiUrl = url.searchParams.get(\"apiurl\") || API_URL;\n\n// Rewrite request to point to API URL\n    const modifiedRequest = new Request(apiUrl, c.req.raw);\n    modifiedRequest.headers.set(\"Origin\", new URL(apiUrl).origin);\n\nlet response = await fetch(modifiedRequest);\n\n// Recreate the response so we can modify the headers\n    response = new Response(response.body, response);\n\n// Set CORS headers\n    response.headers.set(\"Access-Control-Allow-Origin\", url.origin);\n\n// Append to/Add Vary header so browser will cache response correctly\n    response.headers.append(\"Vary\", \"Origin\");\n\nreturn response;\n  });\n\n// Handle method not allowed for proxy endpoint\n  app.all(PROXY_ENDPOINT + \"*\", (c) => {\n    return new Response(null, {\n      status: 405,\n      statusText: \"Method Not Allowed\",\n    });\n  });\n\nexport default app;\n  py\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Response, URL, fetch, Object, Request\n\ndef to_js(x):\n      return _to_js(x, dict_converter=Object.fromEntries)\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          cors_headers = {\n              \"Access-Control-Allow-Origin\": \"*\",\n              \"Access-Control-Allow-Methods\": \"GET,HEAD,POST,OPTIONS\",\n              \"Access-Control-Max-Age\": \"86400\",\n          }\n\napi_url = \"https://examples.cloudflareworkers.com/demos/demoapi\"\n\nproxy_endpoint = \"/corsproxy/\"\n\ndef raw_html_response(html):\n              return Response.new(html, headers=to_js({\"content-type\": \"text/html;charset=UTF-8\"}))\n\ndemo_page = f'''\n          <!DOCTYPE html>\n          <html>\n          <body>\n          <h1>API GET without CORS Proxy</h1>\n          <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\">Shows TypeError: Failed to fetch since CORS is misconfigured</a>\n          <p id=\"noproxy-status\"/>\n          <code id=\"noproxy\">Waiting</code>\n          <h1>API GET with CORS Proxy</h1>\n          <p id=\"proxy-status\"/>\n          <code id=\"proxy\">Waiting</code>\n          <h1>API POST with CORS Proxy + Preflight</h1>\n          <p id=\"proxypreflight-status\"/>\n          <code id=\"proxypreflight\">Waiting</code>\n          <script>\n          let reqs = {{}};\n          reqs.noproxy = () => {{\n              return fetch(\"{api_url}\").then(r => r.json())\n          }}\n          reqs.proxy = async () => {{\n              let href = \"{proxy_endpoint}?apiurl={api_url}\"\n              return fetch(window.location.origin + href).then(r => r.json())\n          }}\n          reqs.proxypreflight = async () => {{\n              let href = \"{proxy_endpoint}?apiurl={api_url}\"\n              let response = await fetch(window.location.origin + href, {{\n              method: \"POST\",\n              headers: {{\n                  \"Content-Type\": \"application/json\"\n              }},\n              body: JSON.stringify({{\n                  msg: \"Hello world!\"\n              }})\n              }})\n              return response.json()\n          }}\n          (async () => {{\n          for (const [reqName, req] of Object.entries(reqs)) {{\n              try {{\n              let data = await req()\n              document.getElementById(reqName).innerHTML = JSON.stringify(data)\n              }} catch (e) {{\n              document.getElementById(reqName).innerHTML = e\n              }}\n          }}\n          }})()\n          </script>\n          </body>\n          </html>\n          '''\n\nasync def handle_request(request):\n              url = URL.new(request.url)\n              api_url2 = url.searchParams[\"apiurl\"]\n\nif not api_url2:\n                  api_url2 = api_url\n\nrequest = Request.new(api_url2, request)\n              request.headers[\"Origin\"] = (URL.new(api_url2)).origin\n              print(request.headers)\n              response = await fetch(request)\n              response = Response.new(response.body, response)\n              response.headers[\"Access-Control-Allow-Origin\"] = url.origin\n              response.headers[\"Vary\"] = \"Origin\"\n              return response\n\nasync def handle_options(request):\n              if \"Origin\" in request.headers and \"Access-Control-Request-Method\" in request.headers and \"Access-Control-Request-Headers\" in request.headers:\n                  return Response.new(None, headers=to_js({\n                  **cors_headers,\n                  \"Access-Control-Allow-Headers\": request.headers[\"Access-Control-Request-Headers\"]\n                  }))\n              return Response.new(None, headers=to_js({\"Allow\": \"GET, HEAD, POST, OPTIONS\"}))\n\nurl = URL.new(request.url)\n\nif url.pathname.startswith(proxy_endpoint):\n              if request.method == \"OPTIONS\":\n                  return handle_options(request)\n              if request.method in (\"GET\", \"HEAD\", \"POST\"):\n                  return handle_request(request)\n              return Response.new(None, status=405, statusText=\"Method Not Allowed\")\n          return raw_html_response(demo_page)\n  rs\n  use std::{borrow::Cow, collections::HashMap};\n  use worker::*;\n\nfn raw_html_response(html: &str) -> Result<Response> {\n      Response::from_html(html)\n  }\n  async fn handle_request(req: Request, api_url: &str) -> Result<Response> {\n      let url = req.url().unwrap();\n      let mut api_url2 = url\n          .query_pairs()\n          .find(|x| x.0 == Cow::Borrowed(\"apiurl\"))\n          .unwrap()\n          .1\n          .to_string();\n      if api_url2 == String::from(\"\") {\n          api_url2 = api_url.to_string();\n      }\n      let mut request = req.clone_mut()?;\n      *request.path_mut()? = api_url2.clone();\n      if let url::Origin::Tuple(origin, _, _) = Url::parse(&api_url2)?.origin() {\n          (*request.headers_mut()?).set(\"Origin\", &origin)?;\n      }\n      let mut response = Fetch::Request(request).send().await?.cloned()?;\n      let headers = response.headers_mut();\n      if let url::Origin::Tuple(origin, _, _) = url.origin() {\n          headers.set(\"Access-Control-Allow-Origin\", &origin)?;\n          headers.set(\"Vary\", \"Origin\")?;\n      }\n\nfn handle_options(req: Request, cors_headers: &HashMap<&str, &str>) -> Result<Response> {\n      let headers: Vec<_> = req.headers().keys().collect();\n      if [\n          \"access-control-request-method\",\n          \"access-control-request-headers\",\n          \"origin\",\n      ]\n      .iter()\n      .all(|i| headers.contains(&i.to_string()))\n      {\n          let mut headers = Headers::new();\n          for (k, v) in cors_headers.iter() {\n              headers.set(k, v)?;\n          }\n          return Ok(Response::empty()?.with_headers(headers));\n      }\n      Response::empty()\n  }\n\n#[event(fetch)]\n  async fn fetch(req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let cors_headers = HashMap::from([\n          (\"Access-Control-Allow-Origin\", \"*\"),\n          (\"Access-Control-Allow-Methods\", \"GET,HEAD,POST,OPTIONS\"),\n          (\"Access-Control-Max-Age\", \"86400\"),\n      ]);\n      let api_url = \"https://examples.cloudflareworkers.com/demos/demoapi\";\n      let proxy_endpoint = \"/corsproxy/\";\n      let demo_page = format!(\n  r#\"\n\n<html>\n  <body>\n  <h1>API GET without CORS Proxy</h1>\n  <a target=\"_blank\" href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#Checking_that_the_fetch_was_successful\">Shows TypeError: Failed to fetch since CORS is misconfigured</a>\n  <p id=\"noproxy-status\"/>\n  <code id=\"noproxy\">Waiting</code>\n  <h1>API GET with CORS Proxy</h1>\n  <p id=\"proxy-status\"/>\n  <code id=\"proxy\">Waiting</code>\n  <h1>API POST with CORS Proxy + Preflight</h1>\n  <p id=\"proxypreflight-status\"/>\n  <code id=\"proxypreflight\">Waiting</code>\n  <script>\n  let reqs = {{}};\n  reqs.noproxy = () => {{\n          return fetch(\"{api_url}\").then(r => r.json())\n      }}\n  reqs.proxy = async () => {{\n          let href = \"{proxy_endpoint}?apiurl={api_url}\"\n          return fetch(window.location.origin + href).then(r => r.json())\n      }}\n  reqs.proxypreflight = async () => {{\n          let href = \"{proxy_endpoint}?apiurl={api_url}\"\n          let response = await fetch(window.location.origin + href, {{\n          method: \"POST\",\n          headers: {{\n              \"Content-Type\": \"application/json\"\n          }},\n  body: JSON.stringify({{\n              msg: \"Hello world!\"\n          }})\n  }})\n  return response.json()\n  }}\n  (async () => {{\n      for (const [reqName, req] of Object.entries(reqs)) {{\n          try {{\n          let data = await req()\n          document.getElementById(reqName).innerHTML = JSON.stringify(data)\n          }} catch (e) {{\n          document.getElementById(reqName).innerHTML = e\n          }}\n  }}\n  }})()\n  </script>\n  </body>\n  </html>\n  \"#\n      );\n\nif req.url()?.path().starts_with(proxy_endpoint) {\n          match req.method() {\n              Method::Options => return handle_options(req, &cors_headers),\n              Method::Get | Method::Head | Method::Post => return handle_request(req, api_url).await,\n              _ => return Response::error(\"Method Not Allowed\", 405),\n          }\n      }\n      raw_html_response(&demo_page)\n\n}\n  js\n  export default {\n    async fetch(request) {\n      /**\n       * A map of the URLs to redirect to\n       * @param {Object} countryMap\n       */\n      const countryMap = {\n        US: \"https://example.com/us\",\n        EU: \"https://example.com/eu\",\n      };\n\n// Use the cf object to obtain the country of the request\n      // more on the cf object: https://developers.cloudflare.com/workers/runtime-apis/request#incomingrequestcfproperties\n      const country = request.cf.country;\n\nif (country != null && country in countryMap) {\n        const url = countryMap[country];\n        // Remove this logging statement from your final output.\n        console.log(\n          `Based on ${country}-based request, your user would go to ${url}.`,\n        );\n        return Response.redirect(url);\n      } else {\n        return fetch(\"https://example.com\", request);\n      }\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * A map of the URLs to redirect to\n       * @param {Object} countryMap\n       */\n      const countryMap = {\n        US: \"https://example.com/us\",\n        EU: \"https://example.com/eu\",\n      };\n\n// Use the cf object to obtain the country of the request\n      // more on the cf object: https://developers.cloudflare.com/workers/runtime-apis/request#incomingrequestcfproperties\n      const country = request.cf.country;\n\nif (country != null && country in countryMap) {\n        const url = countryMap[country];\n        return Response.redirect(url);\n      } else {\n        return fetch(request);\n      }\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response, fetch\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          countries = {\n              \"US\": \"https://example.com/us\",\n              \"EU\": \"https://example.com/eu\",\n          }\n\n# Use the cf object to obtain the country of the request\n          # more on the cf object: https://developers.cloudflare.com/workers/runtime-apis/request#incomingrequestcfproperties\n          country = request.cf.country\n\nif country and country in countries:\n              url = countries[country]\n              return Response.redirect(url)\n\nreturn fetch(\"https://example.com\", request)\n  ts\n  import { Hono } from 'hono';\n\n// Define the RequestWithCf interface to add Cloudflare-specific properties\n  interface RequestWithCf extends Request {\n    cf: {\n      country: string;\n      // Other CF properties can be added as needed\n    };\n  }\n\nconst app = new Hono();\n\napp.get('*', async (c) => {\n    /**\n     * A map of the URLs to redirect to\n     */\n    const countryMap: Record<string, string> = {\n      US: \"https://example.com/us\",\n      EU: \"https://example.com/eu\",\n    };\n\n// Cast the raw request to include Cloudflare-specific properties\n    const request = c.req.raw as RequestWithCf;\n\n// Use the cf object to obtain the country of the request\n    // more on the cf object: https://developers.cloudflare.com/workers/runtime-apis/request#incomingrequestcfproperties\n    const country = request.cf.country;\n\nif (country != null && country in countryMap) {\n      const url = countryMap[country];\n      // Redirect using Hono's redirect helper\n      return c.redirect(url);\n    } else {\n      // Default fallback\n      return fetch(\"https://example.com\", request);\n    }\n  });\n\nexport default app;\n  js\n  export default {\n    async scheduled(controller, env, ctx) {\n      console.log(\"cron processed\");\n    },\n  };\n  ts\n  interface Env {}\n  export default {\n    async scheduled(\n      controller: ScheduledController,\n      env: Env,\n      ctx: ExecutionContext,\n    ) {\n      console.log(\"cron processed\");\n    },\n  };\n  python\n  from workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n      async def scheduled(self, controller, env, ctx):\n          print(\"cron processed\")\n  ts\n  import { Hono } from \"hono\";\n\n// Create Hono app\n  const app = new Hono<{ Bindings: Env }>();\n\n// Regular routes for normal HTTP requests\n  app.get(\"/\", (c) => c.text(\"Hello World!\"));\n\n// Export both the app and a scheduled function\n  export default {\n    // The Hono app handles regular HTTP requests\n    fetch: app.fetch,\n\n// The scheduled function handles Cron triggers\n    async scheduled(\n      controller: ScheduledController,\n      env: Env,\n      ctx: ExecutionContext,\n    ) {\n      console.log(\"cron processed\");\n\n// You could also perform actions like:\n      // - Fetching data from external APIs\n      // - Updating KV or Durable Object storage\n      // - Running maintenance tasks\n      // - Sending notifications\n    },\n  };\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"worker\",\n    \"triggers\": {\n      \"crons\": [\n        \"0 * * * *\"\n      ]\n    }\n  }\n  toml\n  name = \"worker\"\n\n[triggers]\n  crons = [\"0 * * * *\"]\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"env\": {\n      \"dev\": {\n        \"triggers\": {\n          \"crons\": [\n            \"0 * * * *\"\n          ]\n        }\n      }\n    }\n  }\n  toml\n  [env.dev.triggers]\n  crons = [\"0 * * * *\"]\n  sh\nnpx wrangler dev --test-scheduled\n\ncurl \"http://localhost:8787/__scheduled?cron=0+*+*+*+*\"\n\ncurl \"http://localhost:8787/cdn-cgi/handler/scheduled?cron=*+*+*+*+*\" # Python Workers\njs\n  export default {\n    async fetch(request) {\n      const DEBUG = true;\n      const SOME_HOOK_SERVER = \"https://webhook.flow-wolf.io/hook\";\n\n/**\n       * Alert a data breach by posting to a webhook server\n       */\n      async function postDataBreach(request) {\n        return await fetch(SOME_HOOK_SERVER, {\n          method: \"POST\",\n          headers: {\n            \"content-type\": \"application/json;charset=UTF-8\",\n          },\n          body: JSON.stringify({\n            ip: request.headers.get(\"cf-connecting-ip\"),\n            time: Date.now(),\n            request: request,\n          }),\n        });\n      }\n\n/**\n       * Define personal data with regular expressions.\n       * Respond with block if credit card data, and strip\n       * emails and phone numbers from the response.\n       * Execution will be limited to MIME type \"text/*\".\n       */\n      const response = await fetch(request);\n\n// Return origin response, if response wasnt text\n      const contentType = response.headers.get(\"content-type\") || \"\";\n      if (!contentType.toLowerCase().includes(\"text/\")) {\n        return response;\n      }\n\nlet text = await response.text();\n\n// When debugging replace the response\n      // from the origin with an email\n      text = DEBUG\n        ? text.replace(\"You may use this\", \"me@example.com may use this\")\n        : text;\n      const sensitiveRegexsMap = {\n        creditCard: String.raw`\\b(?:4[0-9]{12}(?:[0-9]{3})?|(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\\d{3})\\d{11})\\b`,\n        email: String.raw`\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b`,\n        phone: String.raw`\\b07\\d{9}\\b`,\n      };\n\nfor (const kind in sensitiveRegexsMap) {\n        const sensitiveRegex = new RegExp(sensitiveRegexsMap[kind], \"ig\");\n        const match = await sensitiveRegex.test(text);\n        if (match) {\n          // Alert a data breach\n          await postDataBreach(request);\n          // Respond with a block if credit card,\n          // otherwise replace sensitive text with `*`s\n          return kind === \"creditCard\"\n            ? new Response(kind + \" found\\nForbidden\\n\", {\n                status: 403,\n                statusText: \"Forbidden\",\n              })\n            : new Response(text.replace(sensitiveRegex, \"**********\"), response);\n        }\n      }\n      return new Response(text, response);\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const DEBUG = true;\n      const SOME_HOOK_SERVER = \"https://webhook.flow-wolf.io/hook\";\n\n/**\n       * Alert a data breach by posting to a webhook server\n       */\n      async function postDataBreach(request) {\n        return await fetch(SOME_HOOK_SERVER, {\n          method: \"POST\",\n          headers: {\n            \"content-type\": \"application/json;charset=UTF-8\",\n          },\n          body: JSON.stringify({\n            ip: request.headers.get(\"cf-connecting-ip\"),\n            time: Date.now(),\n            request: request,\n          }),\n        });\n      }\n\n/**\n       * Define personal data with regular expressions.\n       * Respond with block if credit card data, and strip\n       * emails and phone numbers from the response.\n       * Execution will be limited to MIME type \"text/*\".\n       */\n      const response = await fetch(request);\n\n// Return origin response, if response wasnt text\n      const contentType = response.headers.get(\"content-type\") || \"\";\n      if (!contentType.toLowerCase().includes(\"text/\")) {\n        return response;\n      }\n\nlet text = await response.text();\n\n// When debugging replace the response\n      // from the origin with an email\n      text = DEBUG\n        ? text.replace(\"You may use this\", \"me@example.com may use this\")\n        : text;\n      const sensitiveRegexsMap = {\n        creditCard: String.raw`\\b(?:4[0-9]{12}(?:[0-9]{3})?|(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\\d{3})\\d{11})\\b`,\n        email: String.raw`\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b`,\n        phone: String.raw`\\b07\\d{9}\\b`,\n      };\n\nfor (const kind in sensitiveRegexsMap) {\n        const sensitiveRegex = new RegExp(sensitiveRegexsMap[kind], \"ig\");\n        const match = await sensitiveRegex.test(text);\n        if (match) {\n          // Alert a data breach\n          await postDataBreach(request);\n          // Respond with a block if credit card,\n          // otherwise replace sensitive text with `*`s\n          return kind === \"creditCard\"\n            ? new Response(kind + \" found\\nForbidden\\n\", {\n                status: 403,\n                statusText: \"Forbidden\",\n              })\n            : new Response(text.replace(sensitiveRegex, \"**********\"), response);\n        }\n      }\n      return new Response(text, response);\n    },\n  } satisfies ExportedHandler;\n  py\n  import re\n  from workers import WorkerEntrypoint\n  from datetime import datetime\n  from js import Response, fetch, JSON, Headers\n\n# Alert a data breach by posting to a webhook server\n  async def post_data_breach(request):\n      some_hook_server = \"https://webhook.flow-wolf.io/hook\"\n      headers = Headers.new({\"content-type\": \"application/json\"}.items())\n      body = JSON.stringify({\n        \"ip\": request.headers[\"cf-connecting-ip\"],\n        \"time\": datetime.now(),\n        \"request\": request,\n      })\n      return await fetch(some_hook_server, method=\"POST\", headers=headers, body=body)\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n      debug = True\n\n# Define personal data with regular expressions.\n      # Respond with block if credit card data, and strip\n      # emails and phone numbers from the response.\n      # Execution will be limited to MIME type \"text/*\".\n      response = await fetch(request)\n\n# Return origin response, if response wasnt text\n      content_type = response.headers[\"content-type\"] or \"\"\n      if \"text\" not in content_type:\n        return response\n\ntext = await response.text()\n      # When debugging replace the response from the origin with an email\n      text = text.replace(\"You may use this\", \"me@example.com may use this\") if debug else text\n\nsensitive_regex = [\n      (\"credit_card\",\n      r'\\b(?:4[0-9]{12}(?:[0-9]{3})?|(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\\d{3})\\d{11})\\b'),\n      (\"email\", r'\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b'),\n      (\"phone\", r'\\b07\\d{9}\\b'),\n      ]\n      for (kind, regex) in sensitive_regex:\n        match = re.search(regex, text, flags=re.IGNORECASE)\n        if match:\n          # Alert a data breach\n          await post_data_breach(request)\n          # Respond with a block if credit card, otherwise replace sensitive text with `*`s\n          card_resp = Response.new(kind + \" found\\nForbidden\\n\", status=403,statusText=\"Forbidden\")\n          sensitive_resp = Response.new(re.sub(regex, \"*\"*10, text, flags=re.IGNORECASE), response)\n          return card_resp if kind == \"credit_card\" else  sensitive_resp\n\nreturn Response.new(text, response)\n  ts\n  import { Hono } from 'hono';\n\nconst app = new Hono();\n\n// Configuration\n  const DEBUG = true;\n  const SOME_HOOK_SERVER = \"https://webhook.flow-wolf.io/hook\";\n\n// Define sensitive data patterns\n  const sensitiveRegexsMap = {\n    creditCard: String.raw`\\b(?:4[0-9]{12}(?:[0-9]{3})?|(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|6(?:011|5[0-9]{2})[0-9]{12}|(?:2131|1800|35\\d{3})\\d{11})\\b`,\n    email: String.raw`\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}\\b`,\n    phone: String.raw`\\b07\\d{9}\\b`,\n  };\n\n/**\n   * Alert a data breach by posting to a webhook server\n   */\n  async function postDataBreach(request: Request) {\n    return await fetch(SOME_HOOK_SERVER, {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json;charset=UTF-8\",\n      },\n      body: JSON.stringify({\n        ip: request.headers.get(\"cf-connecting-ip\"),\n        time: Date.now(),\n        request: request,\n      }),\n    });\n  }\n\n// Main middleware to handle data loss prevention\n  app.use('*', async (c) => {\n    // Fetch the origin response\n    const response = await fetch(c.req.raw);\n\n// Return origin response if response wasn't text\n    const contentType = response.headers.get(\"content-type\") || \"\";\n    if (!contentType.toLowerCase().includes(\"text/\")) {\n      return response;\n    }\n\n// Get the response text\n    let text = await response.text();\n\n// When debugging, replace the response from the origin with an email\n    text = DEBUG\n      ? text.replace(\"You may use this\", \"me@example.com may use this\")\n      : text;\n\n// Check for sensitive data\n    for (const kind in sensitiveRegexsMap) {\n      const sensitiveRegex = new RegExp(sensitiveRegexsMap[kind], \"ig\");\n      const match = sensitiveRegex.test(text);\n\nif (match) {\n        // Alert a data breach\n        await postDataBreach(c.req.raw);\n\n// Respond with a block if credit card, otherwise replace sensitive text with `*`s\n        if (kind === \"creditCard\") {\n          return c.text(`${kind} found\\nForbidden\\n`, 403);\n        } else {\n          return new Response(text.replace(sensitiveRegex, \"**********\"), {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers,\n          });\n        }\n      }\n    }\n\n// Return the modified response\n    return new Response(text, {\n      status: response.status,\n      statusText: response.statusText,\n      headers: response.headers,\n    });\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request, env, ctx) {\n      // Service configured to receive logs\n      const LOG_URL = \"https://log-service.example.com/\";\n\nasync function postLog(data) {\n        return await fetch(LOG_URL, {\n          method: \"POST\",\n          body: data,\n        });\n      }\n\ntry {\n        response = await fetch(request);\n        if (!response.ok && !response.redirected) {\n          const body = await response.text();\n          throw new Error(\n            \"Bad response at origin. Status: \" +\n              response.status +\n              \" Body: \" +\n              // Ensure the string is small enough to be a header\n              body.trim().substring(0, 10),\n          );\n        }\n      } catch (err) {\n        // Without ctx.waitUntil(), your fetch() to Cloudflare's\n        // logging service may or may not complete\n        ctx.waitUntil(postLog(err.toString()));\n        const stack = JSON.stringify(err.stack) || err;\n        // Copy the response and initialize body to the stack trace\n        response = new Response(stack, response);\n        // Add the error stack into a header to find out what happened\n        response.headers.set(\"X-Debug-stack\", stack);\n        response.headers.set(\"X-Debug-err\", err);\n      }\n      return response;\n    },\n  };\n  ts\n  interface Env {}\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      // Service configured to receive logs\n      const LOG_URL = \"https://log-service.example.com/\";\n\nasync function postLog(data) {\n        return await fetch(LOG_URL, {\n          method: \"POST\",\n          body: data,\n        });\n      }\n\ntry {\n        response = await fetch(request);\n        if (!response.ok && !response.redirected) {\n          const body = await response.text();\n          throw new Error(\n            \"Bad response at origin. Status: \" +\n              response.status +\n              \" Body: \" +\n              // Ensure the string is small enough to be a header\n              body.trim().substring(0, 10),\n          );\n        }\n      } catch (err) {\n        // Without ctx.waitUntil(), your fetch() to Cloudflare's\n        // logging service may or may not complete\n        ctx.waitUntil(postLog(err.toString()));\n        const stack = JSON.stringify(err.stack) || err;\n        // Copy the response and initialize body to the stack trace\n        response = new Response(stack, response);\n        // Add the error stack into a header to find out what happened\n        response.headers.set(\"X-Debug-stack\", stack);\n        response.headers.set(\"X-Debug-err\", err);\n      }\n      return response;\n    },\n  } satisfies ExportedHandler<Env>;\n  py\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import create_proxy\n  from js import Response, fetch\n\nasync def post_log(data):\n    log_url = \"https://log-service.example.com/\"\n    await fetch(log_url, method=\"POST\", body=data)\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # Service configured to receive logs\n          response = await fetch(request)\n\ntry:\n              if not response.ok and not response.redirected:\n                  body = await response.text()\n              # Simulating an error. Ensure the string is small enough to be a header\n              raise Exception(f'Bad response at origin. Status:{response.status} Body:{body.strip()[:10]}')\n          except Exception as e:\n              # Without ctx.waitUntil(), your fetch() to Cloudflare's\n              # logging service may or may not complete\n              self.ctx.waitUntil(create_proxy(post_log(str(e))))\n              # Copy the response and add to header\n              response = Response.new(stack, response)\n              response.headers[\"X-Debug-err\"] = str(e)\n\nreturn response\n  ts\n  import { Hono } from 'hono';\n\n// Define the environment with appropriate types\n  interface Env {}\n\nconst app = new Hono<{ Bindings: Env }>();\n\n// Service configured to receive logs\n  const LOG_URL = \"https://log-service.example.com/\";\n\n// Function to post logs to an external service\n  async function postLog(data: string) {\n    return await fetch(LOG_URL, {\n      method: \"POST\",\n      body: data,\n    });\n  }\n\n// Middleware to handle error logging\n  app.use('*', async (c, next) => {\n    try {\n      // Process the request with the next handler\n      await next();\n\n// After processing, check if the response indicates an error\n      if (c.res && (!c.res.ok && !c.res.redirected)) {\n        const body = await c.res.clone().text();\n        throw new Error(\n          \"Bad response at origin. Status: \" +\n          c.res.status +\n          \" Body: \" +\n          // Ensure the string is small enough to be a header\n          body.trim().substring(0, 10)\n        );\n      }\n\n} catch (err) {\n      // Without waitUntil, the fetch to the logging service may not complete\n      c.executionCtx.waitUntil(\n        postLog(err.toString())\n      );\n\n// Get the error stack or error itself\n      const stack = JSON.stringify(err.stack) || err.toString();\n\n// Create a new response with the error information\n      const response = c.res ?\n        new Response(stack, {\n          status: c.res.status,\n          headers: c.res.headers\n        }) :\n        new Response(stack, { status: 500 });\n\n// Add debug headers\n      response.headers.set(\"X-Debug-stack\", stack);\n      response.headers.set(\"X-Debug-err\", err.toString());\n\n// Set the modified response\n      c.res = response;\n    }\n  });\n\n// Default route handler that passes requests through\n  app.all('*', async (c) => {\n    return fetch(c.req.raw);\n  });\n\nexport default app;\n  js\n  import { parse } from \"cookie\";\n  export default {\n    async fetch(request) {\n      // The name of the cookie\n      const COOKIE_NAME = \"__uid\";\n      const cookie = parse(request.headers.get(\"Cookie\") || \"\");\n      if (cookie[COOKIE_NAME] != null) {\n        // Respond with the cookie value\n        return new Response(cookie[COOKIE_NAME]);\n      }\n      return new Response(\"No cookie with name: \" + COOKIE_NAME);\n    },\n  };\n  ts\n  import { parse } from \"cookie\";\n  export default {\n    async fetch(request): Promise<Response> {\n      // The name of the cookie\n      const COOKIE_NAME = \"__uid\";\n      const cookie = parse(request.headers.get(\"Cookie\") || \"\");\n      if (cookie[COOKIE_NAME] != null) {\n        // Respond with the cookie value\n        return new Response(cookie[COOKIE_NAME]);\n      }\n      return new Response(\"No cookie with name: \" + COOKIE_NAME);\n    },\n  } satisfies ExportedHandler;\n  py\n  from http.cookies import SimpleCookie\n  from workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # Name of the cookie\n          cookie_name = \"__uid\"\n\ncookies = SimpleCookie(request.headers[\"Cookie\"] or \"\")\n\nif cookie_name in cookies:\n              # Respond with cookie value\n              return Response(cookies[cookie_name].value)\n\nreturn Response(\"No cookie with name: \" + cookie_name)\n  ts\n  import { Hono } from 'hono';\n  import { getCookie } from 'hono/cookie';\n\nconst app = new Hono();\n\napp.get('*', (c) => {\n    // The name of the cookie\n    const COOKIE_NAME = \"__uid\";\n\n// Get the specific cookie value using Hono's cookie helper\n    const cookieValue = getCookie(c, COOKIE_NAME);\n\nif (cookieValue) {\n      // Respond with the cookie value\n      return c.text(cookieValue);\n    }\n\nreturn c.text(\"No cookie with name: \" + COOKIE_NAME);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      /**\n       * Replace `remote` with the host you wish to send requests to\n       */\n      const remote = \"https://example.com\";\n\nreturn await fetch(remote, request);\n    },\n  };\n  ts\n  export default {\n    async fetch(request: Request): Promise<Response> {\n      /**\n       * Replace `remote` with the host you wish to send requests to\n       */\n      const remote = \"https://example.com\";\n\nreturn await fetch(remote, request);\n    },\n  };\n  py\n  from workers import WorkerEntrypoint\n  from js import fetch\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # Replace `remote` with the host you wish to send requests to\n          remote = \"https://example.com\"\n          return await fetch(remote, request)\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\napp.all(\"*\", async (c) => {\n    /**\n     * Replace `remote` with the host you wish to send requests to\n     */\n    const remote = \"https://example.com\";\n\n// Forward the request to the remote server\n    return await fetch(remote, c.req.raw);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request, env, ctx) {\n      const url = \"https://jsonplaceholder.typicode.com/todos/1\";\n\n// gatherResponse returns both content-type & response body as a string\n      async function gatherResponse(response) {\n        const { headers } = response;\n        const contentType = headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          return { contentType, result: JSON.stringify(await response.json()) };\n        }\n        return { contentType, result: await response.text() };\n      }\n\nconst response = await fetch(url);\n      const { contentType, result } = await gatherResponse(response);\n\nconst options = { headers: { \"content-type\": contentType } };\n      return new Response(result, options);\n    },\n  };\n  ts\n  interface Env {}\n  export default {\n    async fetch(request, env, ctx): Promise<Response> {\n      const url = \"https://jsonplaceholder.typicode.com/todos/1\";\n\n// gatherResponse returns both content-type & response body as a string\n      async function gatherResponse(response) {\n        const { headers } = response;\n        const contentType = headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          return { contentType, result: JSON.stringify(await response.json()) };\n        }\n        return { contentType, result: await response.text() };\n      }\n\nconst response = await fetch(url);\n      const { contentType, result } = await gatherResponse(response);\n\nconst options = { headers: { \"content-type\": contentType } };\n      return new Response(result, options);\n    },\n  } satisfies ExportedHandler<Env>;\n  py\n  from workers import WorkerEntrypoint, Response, fetch\n  import json\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          url = \"https://jsonplaceholder.typicode.com/todos/1\"\n\n# gather_response returns both content-type & response body as a string\n          async def gather_response(response):\n              headers = response.headers\n              content_type = headers[\"content-type\"] or \"\"\n\nif \"application/json\" in content_type:\n                  return (content_type, json.dumps(await response.json()))\n              return (content_type, await response.text())\n\nresponse = await fetch(url)\n          content_type, result = await gather_response(response)\n\nheaders = {\"content-type\": content_type}\n          return Response(result, headers=headers)\n  ts\n  import { Hono } from 'hono';\n\nconst app = new Hono<{ Bindings: Env }>();\n\napp.get('*', async (c) => {\n    const url = \"https://jsonplaceholder.typicode.com/todos/1\";\n\n// gatherResponse returns both content-type & response body as a string\n    async function gatherResponse(response: Response) {\n      const { headers } = response;\n      const contentType = headers.get(\"content-type\") || \"\";\n\nif (contentType.includes(\"application/json\")) {\n        return { contentType, result: JSON.stringify(await response.json()) };\n      }\n\nreturn { contentType, result: await response.text() };\n    }\n\nconst response = await fetch(url);\n    const { contentType, result } = await gatherResponse(response);\n\nreturn new Response(result, {\n      headers: { \"content-type\": contentType }\n    });\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      let endpoint = \"https://api.waqi.info/feed/geo:\";\n      const token = \"\"; //Use a token from https://aqicn.org/api/\n      let html_style = `body{padding:6em; font-family: sans-serif;} h1{color:#f6821f}`;\n\nlet html_content = \"<h1>Weather </h1>\";\n\nconst latitude = request.cf.latitude;\n      const longitude = request.cf.longitude;\n      endpoint += `${latitude};${longitude}/?token=${token}`;\n      const init = {\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      };\n\nconst response = await fetch(endpoint, init);\n      const content = await response.json();\n\nhtml_content += `<p>This is a demo using Workers geolocation data. </p>`;\n      html_content += `You are located at: ${latitude},${longitude}.</p>`;\n      html_content += `<p>Based off sensor data from <a href=\"${content.data.city.url}\">${content.data.city.name}</a>:</p>`;\n      html_content += `<p>The AQI level is: ${content.data.aqi}.</p>`;\n      html_content += `<p>The N02 level is: ${content.data.iaqi.no2?.v}.</p>`;\n      html_content += `<p>The O3 level is: ${content.data.iaqi.o3?.v}.</p>`;\n      html_content += `<p>The temperature is: ${content.data.iaqi.t?.v}C.</p>`;\n\nlet html = `\n        <!DOCTYPE html>\n        <head>\n          <title>Geolocation: Weather</title>\n        </head>\n        <body>\n          <style>${html_style}</style>\n          <div id=\"container\">\n          ${html_content}\n          </div>\n        </body>`;\n\nreturn new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      let endpoint = \"https://api.waqi.info/feed/geo:\";\n      const token = \"\"; //Use a token from https://aqicn.org/api/\n      let html_style = `body{padding:6em; font-family: sans-serif;} h1{color:#f6821f}`;\n\nlet html_content = \"<h1>Weather </h1>\";\n\nconst latitude = request.cf.latitude;\n      const longitude = request.cf.longitude;\n      endpoint += `${latitude};${longitude}/?token=${token}`;\n      const init = {\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      };\n\nconst response = await fetch(endpoint, init);\n      const content = await response.json();\n\nhtml_content += `<p>This is a demo using Workers geolocation data. </p>`;\n      html_content += `You are located at: ${latitude},${longitude}.</p>`;\n      html_content += `<p>Based off sensor data from <a href=\"${content.data.city.url}\">${content.data.city.name}</a>:</p>`;\n      html_content += `<p>The AQI level is: ${content.data.aqi}.</p>`;\n      html_content += `<p>The N02 level is: ${content.data.iaqi.no2?.v}.</p>`;\n      html_content += `<p>The O3 level is: ${content.data.iaqi.o3?.v}.</p>`;\n      html_content += `<p>The temperature is: ${content.data.iaqi.t?.v}C.</p>`;\n\nlet html = `\n        <!DOCTYPE html>\n        <head>\n          <title>Geolocation: Weather</title>\n        </head>\n        <body>\n          <style>${html_style}</style>\n          <div id=\"container\">\n          ${html_content}\n          </div>\n        </body>`;\n\nreturn new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from 'hono';\n  import { html } from 'hono/html';\n\ninterface WeatherApiResponse {\n    data: {\n      aqi: number;\n      city: {\n        name: string;\n        url: string;\n      };\n      iaqi: {\n        no2?: { v: number };\n        o3?: { v: number };\n        t?: { v: number };\n      };\n    };\n  }\n\nconst app = new Hono<{ Bindings: Bindings }>();\n\napp.get('*', async (c) => {\n    // Get API endpoint\n    let endpoint = \"https://api.waqi.info/feed/geo:\";\n    const token = \"\"; // Use a token from https://aqicn.org/api/\n\n// Define styles\n    const html_style = `body{padding:6em; font-family: sans-serif;} h1{color:#f6821f}`;\n\n// Get geolocation from Cloudflare request\n    const req = c.req.raw;\n    const latitude = req.cf?.latitude;\n    const longitude = req.cf?.longitude;\n\n// Create complete API endpoint with coordinates\n    endpoint += `${latitude};${longitude}/?token=${token}`;\n\n// Fetch weather data\n    const init = {\n      headers: {\n        \"content-type\": \"application/json;charset=UTF-8\",\n      },\n    };\n    const response = await fetch(endpoint, init);\n    const content = await response.json() as WeatherApiResponse;\n\n// Build HTML content\n    const weatherContent = html`\n      <h1>Weather </h1>\n      <p>This is a demo using Workers geolocation data.</p>\n      <p>You are located at: ${latitude},${longitude}.</p>\n      <p>Based off sensor data from <a href=\"${content.data.city.url}\">${content.data.city.name}</a>:</p>\n      <p>The AQI level is: ${content.data.aqi}.</p>\n      <p>The N02 level is: ${content.data.iaqi.no2?.v}.</p>\n      <p>The O3 level is: ${content.data.iaqi.o3?.v}.</p>\n      <p>The temperature is: ${content.data.iaqi.t?.v}C.</p>\n    `;\n\n// Complete HTML document\n    const htmlDocument = html`\n      <!DOCTYPE html>\n      <head>\n        <title>Geolocation: Weather</title>\n      </head>\n      <body>\n        <style>${html_style}</style>\n        <div id=\"container\">\n          ${weatherContent}\n        </div>\n      </body>\n    `;\n\n// Return HTML response\n    return c.html(htmlDocument);\n  });\n\nexport default app;\n  py\n  from workers import WorkerEntrypoint, Response, fetch\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          endpoint = \"https://api.waqi.info/feed/geo:\"\n          token = \"\" # Use a token from https://aqicn.org/api/\n          html_style = \"body{padding:6em; font-family: sans-serif;} h1{color:#f6821f}\"\n          html_content = \"<h1>Weather </h1>\"\n\nlatitude = request.cf.latitude\n          longitude = request.cf.longitude\n\nendpoint += f\"{latitude};{longitude}/?token={token}\"\n          response = await fetch(endpoint)\n          content = await response.json()\n\nhtml_content += \"<p>This is a demo using Workers geolocation data. </p>\"\n          html_content += f\"You are located at: {latitude},{longitude}.</p>\"\n          html_content += f\"<p>Based off sensor data from <a href='{content['data']['city']['url']}'>{content['data']['city']['name']}</a>:</p>\"\n          html_content += f\"<p>The AQI level is: {content['data']['aqi']}.</p>\"\n          html_content += f\"<p>The N02 level is: {content['data']['iaqi']['no2']['v']}.</p>\"\n          html_content += f\"<p>The O3 level is: {content['data']['iaqi']['o3']['v']}.</p>\"\n          html_content += f\"<p>The temperature is: {content['data']['iaqi']['t']['v']}C.</p>\"\n\nhtml = f\"\"\"\n          <!DOCTYPE html>\n            <head>\n              <title>Geolocation: Weather</title>\n            </head>\n            <body>\n              <style>{html_style}</style>\n              <div id=\"container\">\n              {html_content}\n              </div>\n            </body>\n          \"\"\"\n\nheaders = {\"content-type\": \"text/html;charset=UTF-8\"}\n          return Response(html, headers=headers)\n  js\n  export default {\n    async fetch(request) {\n      let grads = [\n        [\n          { color: \"00000c\", position: 0 },\n          { color: \"00000c\", position: 0 },\n        ],\n        [\n          { color: \"020111\", position: 85 },\n          { color: \"191621\", position: 100 },\n        ],\n        [\n          { color: \"020111\", position: 60 },\n          { color: \"20202c\", position: 100 },\n        ],\n        [\n          { color: \"020111\", position: 10 },\n          { color: \"3a3a52\", position: 100 },\n        ],\n        [\n          { color: \"20202c\", position: 0 },\n          { color: \"515175\", position: 100 },\n        ],\n        [\n          { color: \"40405c\", position: 0 },\n          { color: \"6f71aa\", position: 80 },\n          { color: \"8a76ab\", position: 100 },\n        ],\n        [\n          { color: \"4a4969\", position: 0 },\n          { color: \"7072ab\", position: 50 },\n          { color: \"cd82a0\", position: 100 },\n        ],\n        [\n          { color: \"757abf\", position: 0 },\n          { color: \"8583be\", position: 60 },\n          { color: \"eab0d1\", position: 100 },\n        ],\n        [\n          { color: \"82addb\", position: 0 },\n          { color: \"ebb2b1\", position: 100 },\n        ],\n        [\n          { color: \"94c5f8\", position: 1 },\n          { color: \"a6e6ff\", position: 70 },\n          { color: \"b1b5ea\", position: 100 },\n        ],\n        [\n          { color: \"b7eaff\", position: 0 },\n          { color: \"94dfff\", position: 100 },\n        ],\n        [\n          { color: \"9be2fe\", position: 0 },\n          { color: \"67d1fb\", position: 100 },\n        ],\n        [\n          { color: \"90dffe\", position: 0 },\n          { color: \"38a3d1\", position: 100 },\n        ],\n        [\n          { color: \"57c1eb\", position: 0 },\n          { color: \"246fa8\", position: 100 },\n        ],\n        [\n          { color: \"2d91c2\", position: 0 },\n          { color: \"1e528e\", position: 100 },\n        ],\n        [\n          { color: \"2473ab\", position: 0 },\n          { color: \"1e528e\", position: 70 },\n          { color: \"5b7983\", position: 100 },\n        ],\n        [\n          { color: \"1e528e\", position: 0 },\n          { color: \"265889\", position: 50 },\n          { color: \"9da671\", position: 100 },\n        ],\n        [\n          { color: \"1e528e\", position: 0 },\n          { color: \"728a7c\", position: 50 },\n          { color: \"e9ce5d\", position: 100 },\n        ],\n        [\n          { color: \"154277\", position: 0 },\n          { color: \"576e71\", position: 30 },\n          { color: \"e1c45e\", position: 70 },\n          { color: \"b26339\", position: 100 },\n        ],\n        [\n          { color: \"163C52\", position: 0 },\n          { color: \"4F4F47\", position: 30 },\n          { color: \"C5752D\", position: 60 },\n          { color: \"B7490F\", position: 80 },\n          { color: \"2F1107\", position: 100 },\n        ],\n        [\n          { color: \"071B26\", position: 0 },\n          { color: \"071B26\", position: 30 },\n          { color: \"8A3B12\", position: 80 },\n          { color: \"240E03\", position: 100 },\n        ],\n        [\n          { color: \"010A10\", position: 30 },\n          { color: \"59230B\", position: 80 },\n          { color: \"2F1107\", position: 100 },\n        ],\n        [\n          { color: \"090401\", position: 50 },\n          { color: \"4B1D06\", position: 100 },\n        ],\n        [\n          { color: \"00000c\", position: 80 },\n          { color: \"150800\", position: 100 },\n        ],\n      ];\n      async function toCSSGradient(hour) {\n        let css = \"linear-gradient(to bottom,\";\n        const data = grads[hour];\n        const len = data.length;\n        for (let i = 0; i < len; i++) {\n          const item = data[i];\n          css += ` #${item.color} ${item.position}%`;\n          if (i < len - 1) css += \",\";\n        }\n        return css + \")\";\n      }\n      let html_content = \"\";\n      let html_style = `\n        html{width:100vw; height:100vh;}\n        body{padding:0; margin:0 !important;height:100%;}\n        #container {\n          display: flex;\n          flex-direction:column;\n          align-items: center;\n          justify-content: center;\n          height: 100%;\n          color:white;\n          font-family:sans-serif;\n        }`;\n      const timezone = request.cf.timezone;\n      console.log(timezone);\n      let localized_date = new Date(\n        new Date().toLocaleString(\"en-US\", { timeZone: timezone }),\n      );\n      let hour = localized_date.getHours();\n      let minutes = localized_date.getMinutes();\n      html_content += \"<h1>\" + hour + \":\" + minutes + \"</h1>\";\n      html_content += \"<p>\" + timezone + \"<br/></p>\";\n      html_style += \"body{background:\" + (await toCSSGradient(hour)) + \";}\";\n      let html = `\n        <!DOCTYPE html>\n        <head>\n          <title>Geolocation: Customized Design</title>\n        </head>\n        <body>\n          <style> ${html_style}</style>\n          <div id=\"container\">\n            ${html_content}\n          </div>\n        </body>`;\n      return new Response(html, {\n        headers: { \"content-type\": \"text/html;charset=UTF-8\" },\n      });\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      let grads = [\n        [\n          { color: \"00000c\", position: 0 },\n          { color: \"00000c\", position: 0 },\n        ],\n        [\n          { color: \"020111\", position: 85 },\n          { color: \"191621\", position: 100 },\n        ],\n        [\n          { color: \"020111\", position: 60 },\n          { color: \"20202c\", position: 100 },\n        ],\n        [\n          { color: \"020111\", position: 10 },\n          { color: \"3a3a52\", position: 100 },\n        ],\n        [\n          { color: \"20202c\", position: 0 },\n          { color: \"515175\", position: 100 },\n        ],\n        [\n          { color: \"40405c\", position: 0 },\n          { color: \"6f71aa\", position: 80 },\n          { color: \"8a76ab\", position: 100 },\n        ],\n        [\n          { color: \"4a4969\", position: 0 },\n          { color: \"7072ab\", position: 50 },\n          { color: \"cd82a0\", position: 100 },\n        ],\n        [\n          { color: \"757abf\", position: 0 },\n          { color: \"8583be\", position: 60 },\n          { color: \"eab0d1\", position: 100 },\n        ],\n        [\n          { color: \"82addb\", position: 0 },\n          { color: \"ebb2b1\", position: 100 },\n        ],\n        [\n          { color: \"94c5f8\", position: 1 },\n          { color: \"a6e6ff\", position: 70 },\n          { color: \"b1b5ea\", position: 100 },\n        ],\n        [\n          { color: \"b7eaff\", position: 0 },\n          { color: \"94dfff\", position: 100 },\n        ],\n        [\n          { color: \"9be2fe\", position: 0 },\n          { color: \"67d1fb\", position: 100 },\n        ],\n        [\n          { color: \"90dffe\", position: 0 },\n          { color: \"38a3d1\", position: 100 },\n        ],\n        [\n          { color: \"57c1eb\", position: 0 },\n          { color: \"246fa8\", position: 100 },\n        ],\n        [\n          { color: \"2d91c2\", position: 0 },\n          { color: \"1e528e\", position: 100 },\n        ],\n        [\n          { color: \"2473ab\", position: 0 },\n          { color: \"1e528e\", position: 70 },\n          { color: \"5b7983\", position: 100 },\n        ],\n        [\n          { color: \"1e528e\", position: 0 },\n          { color: \"265889\", position: 50 },\n          { color: \"9da671\", position: 100 },\n        ],\n        [\n          { color: \"1e528e\", position: 0 },\n          { color: \"728a7c\", position: 50 },\n          { color: \"e9ce5d\", position: 100 },\n        ],\n        [\n          { color: \"154277\", position: 0 },\n          { color: \"576e71\", position: 30 },\n          { color: \"e1c45e\", position: 70 },\n          { color: \"b26339\", position: 100 },\n        ],\n        [\n          { color: \"163C52\", position: 0 },\n          { color: \"4F4F47\", position: 30 },\n          { color: \"C5752D\", position: 60 },\n          { color: \"B7490F\", position: 80 },\n          { color: \"2F1107\", position: 100 },\n        ],\n        [\n          { color: \"071B26\", position: 0 },\n          { color: \"071B26\", position: 30 },\n          { color: \"8A3B12\", position: 80 },\n          { color: \"240E03\", position: 100 },\n        ],\n        [\n          { color: \"010A10\", position: 30 },\n          { color: \"59230B\", position: 80 },\n          { color: \"2F1107\", position: 100 },\n        ],\n        [\n          { color: \"090401\", position: 50 },\n          { color: \"4B1D06\", position: 100 },\n        ],\n        [\n          { color: \"00000c\", position: 80 },\n          { color: \"150800\", position: 100 },\n        ],\n      ];\n      async function toCSSGradient(hour) {\n        let css = \"linear-gradient(to bottom,\";\n        const data = grads[hour];\n        const len = data.length;\n        for (let i = 0; i < len; i++) {\n          const item = data[i];\n          css += ` #${item.color} ${item.position}%`;\n          if (i < len - 1) css += \",\";\n        }\n        return css + \")\";\n      }\n      let html_content = \"\";\n      let html_style = `\n        html{width:100vw; height:100vh;}\n        body{padding:0; margin:0 !important;height:100%;}\n        #container {\n          display: flex;\n          flex-direction:column;\n          align-items: center;\n          justify-content: center;\n          height: 100%;\n          color:white;\n          font-family:sans-serif;\n        }`;\n      const timezone = request.cf.timezone;\n      console.log(timezone);\n      let localized_date = new Date(\n        new Date().toLocaleString(\"en-US\", { timeZone: timezone }),\n      );\n      let hour = localized_date.getHours();\n      let minutes = localized_date.getMinutes();\n      html_content += \"<h1>\" + hour + \":\" + minutes + \"</h1>\";\n      html_content += \"<p>\" + timezone + \"<br/></p>\";\n      html_style += \"body{background:\" + (await toCSSGradient(hour)) + \";}\";\n      let html = `\n        <!DOCTYPE html>\n        <head>\n          <title>Geolocation: Customized Design</title>\n        </head>\n        <body>\n          <style> ${html_style}</style>\n          <div id=\"container\">\n            ${html_content}\n          </div>\n        </body>`;\n      return new Response(html, {\n        headers: { \"content-type\": \"text/html;charset=UTF-8\" },\n      });\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from 'hono';\n\ntype Bindings = {};\n  type ColorStop = { color: string; position: number };\n\nconst app = new Hono<{ Bindings: Bindings }>();\n\n// Gradient configurations for each hour of the day (0-23)\n  const grads: ColorStop[][] = [\n    [\n      { color: \"00000c\", position: 0 },\n      { color: \"00000c\", position: 0 },\n    ],\n    [\n      { color: \"020111\", position: 85 },\n      { color: \"191621\", position: 100 },\n    ],\n    [\n      { color: \"020111\", position: 60 },\n      { color: \"20202c\", position: 100 },\n    ],\n    [\n      { color: \"020111\", position: 10 },\n      { color: \"3a3a52\", position: 100 },\n    ],\n    [\n      { color: \"20202c\", position: 0 },\n      { color: \"515175\", position: 100 },\n    ],\n    [\n      { color: \"40405c\", position: 0 },\n      { color: \"6f71aa\", position: 80 },\n      { color: \"8a76ab\", position: 100 },\n    ],\n    [\n      { color: \"4a4969\", position: 0 },\n      { color: \"7072ab\", position: 50 },\n      { color: \"cd82a0\", position: 100 },\n    ],\n    [\n      { color: \"757abf\", position: 0 },\n      { color: \"8583be\", position: 60 },\n      { color: \"eab0d1\", position: 100 },\n    ],\n    [\n      { color: \"82addb\", position: 0 },\n      { color: \"ebb2b1\", position: 100 },\n    ],\n    [\n      { color: \"94c5f8\", position: 1 },\n      { color: \"a6e6ff\", position: 70 },\n      { color: \"b1b5ea\", position: 100 },\n    ],\n    [\n      { color: \"b7eaff\", position: 0 },\n      { color: \"94dfff\", position: 100 },\n    ],\n    [\n      { color: \"9be2fe\", position: 0 },\n      { color: \"67d1fb\", position: 100 },\n    ],\n    [\n      { color: \"90dffe\", position: 0 },\n      { color: \"38a3d1\", position: 100 },\n    ],\n    [\n      { color: \"57c1eb\", position: 0 },\n      { color: \"246fa8\", position: 100 },\n    ],\n    [\n      { color: \"2d91c2\", position: 0 },\n      { color: \"1e528e\", position: 100 },\n    ],\n    [\n      { color: \"2473ab\", position: 0 },\n      { color: \"1e528e\", position: 70 },\n      { color: \"5b7983\", position: 100 },\n    ],\n    [\n      { color: \"1e528e\", position: 0 },\n      { color: \"265889\", position: 50 },\n      { color: \"9da671\", position: 100 },\n    ],\n    [\n      { color: \"1e528e\", position: 0 },\n      { color: \"728a7c\", position: 50 },\n      { color: \"e9ce5d\", position: 100 },\n    ],\n    [\n      { color: \"154277\", position: 0 },\n      { color: \"576e71\", position: 30 },\n      { color: \"e1c45e\", position: 70 },\n      { color: \"b26339\", position: 100 },\n    ],\n    [\n      { color: \"163C52\", position: 0 },\n      { color: \"4F4F47\", position: 30 },\n      { color: \"C5752D\", position: 60 },\n      { color: \"B7490F\", position: 80 },\n      { color: \"2F1107\", position: 100 },\n    ],\n    [\n      { color: \"071B26\", position: 0 },\n      { color: \"071B26\", position: 30 },\n      { color: \"8A3B12\", position: 80 },\n      { color: \"240E03\", position: 100 },\n    ],\n    [\n      { color: \"010A10\", position: 30 },\n      { color: \"59230B\", position: 80 },\n      { color: \"2F1107\", position: 100 },\n    ],\n    [\n      { color: \"090401\", position: 50 },\n      { color: \"4B1D06\", position: 100 },\n    ],\n    [\n      { color: \"00000c\", position: 80 },\n      { color: \"150800\", position: 100 },\n    ],\n  ];\n\n// Convert hour to CSS gradient\n  async function toCSSGradient(hour: number): Promise<string> {\n    let css = \"linear-gradient(to bottom,\";\n    const data = grads[hour];\n    const len = data.length;\n\nfor (let i = 0; i < len; i++) {\n      const item = data[i];\n      css += ` #${item.color} ${item.position}%`;\n      if (i < len - 1) css += \",\";\n    }\n\nreturn css + \")\";\n  }\n\napp.get('*', async (c) => {\n    const request = c.req.raw;\n\n// Base HTML style\n    let html_style = `\n      html{width:100vw; height:100vh;}\n      body{padding:0; margin:0 !important;height:100%;}\n      #container {\n        display: flex;\n        flex-direction:column;\n        align-items: center;\n        justify-content: center;\n        height: 100%;\n        color:white;\n        font-family:sans-serif;\n      }`;\n\n// Get timezone from Cloudflare request\n    const timezone = request.cf?.timezone || 'UTC';\n    console.log(timezone);\n\n// Get localized time\n    let localized_date = new Date(\n      new Date().toLocaleString(\"en-US\", { timeZone: timezone })\n    );\n\nlet hour = localized_date.getHours();\n    let minutes = localized_date.getMinutes();\n\n// Generate HTML content\n    let html_content = `<h1>${hour}:${minutes}</h1>`;\n    html_content += `<p>${timezone}<br/></p>`;\n\n// Add background gradient based on hour\n    html_style += `body{background:${await toCSSGradient(hour)};}`;\n\n// Complete HTML document\n    let html = `\n      <!DOCTYPE html>\n      <head>\n        <title>Geolocation: Customized Design</title>\n      </head>\n      <body>\n        <style>${html_style}</style>\n        <div id=\"container\">\n          ${html_content}\n        </div>\n      </body>`;\n\nreturn c.html(html);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      let html_content = \"\";\n      let html_style =\n        \"body{padding:6em; font-family: sans-serif;} h1{color:#f6821f;}\";\n\nhtml_content += \"<p> Colo: \" + request.cf.colo + \"</p>\";\n      html_content += \"<p> Country: \" + request.cf.country + \"</p>\";\n      html_content += \"<p> City: \" + request.cf.city + \"</p>\";\n      html_content += \"<p> Continent: \" + request.cf.continent + \"</p>\";\n      html_content += \"<p> Latitude: \" + request.cf.latitude + \"</p>\";\n      html_content += \"<p> Longitude: \" + request.cf.longitude + \"</p>\";\n      html_content += \"<p> PostalCode: \" + request.cf.postalCode + \"</p>\";\n      html_content += \"<p> MetroCode: \" + request.cf.metroCode + \"</p>\";\n      html_content += \"<p> Region: \" + request.cf.region + \"</p>\";\n      html_content += \"<p> RegionCode: \" + request.cf.regionCode + \"</p>\";\n      html_content += \"<p> Timezone: \" + request.cf.timezone + \"</p>\";\n\nlet html = `<!DOCTYPE html>\n        <head>\n          <title> Geolocation: Hello World </title>\n          <style> ${html_style} </style>\n        </head>\n        <body>\n          <h1>Geolocation: Hello World!</h1>\n          <p>You now have access to geolocation data about where your user is visiting from.</p>\n          ${html_content}\n        </body>`;\n\nreturn new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      let html_content = \"\";\n      let html_style =\n        \"body{padding:6em; font-family: sans-serif;} h1{color:#f6821f;}\";\n\nhtml_content += \"<p> Colo: \" + request.cf.colo + \"</p>\";\n      html_content += \"<p> Country: \" + request.cf.country + \"</p>\";\n      html_content += \"<p> City: \" + request.cf.city + \"</p>\";\n      html_content += \"<p> Continent: \" + request.cf.continent + \"</p>\";\n      html_content += \"<p> Latitude: \" + request.cf.latitude + \"</p>\";\n      html_content += \"<p> Longitude: \" + request.cf.longitude + \"</p>\";\n      html_content += \"<p> PostalCode: \" + request.cf.postalCode + \"</p>\";\n      html_content += \"<p> MetroCode: \" + request.cf.metroCode + \"</p>\";\n      html_content += \"<p> Region: \" + request.cf.region + \"</p>\";\n      html_content += \"<p> RegionCode: \" + request.cf.regionCode + \"</p>\";\n      html_content += \"<p> Timezone: \" + request.cf.timezone + \"</p>\";\n\nlet html = `<!DOCTYPE html>\n        <head>\n          <title> Geolocation: Hello World </title>\n          <style> ${html_style} </style>\n        </head>\n        <body>\n          <h1>Geolocation: Hello World!</h1>\n          <p>You now have access to geolocation data about where your user is visiting from.</p>\n          ${html_content}\n        </body>`;\n\nreturn new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          html_content = \"\"\n          html_style = \"body{padding:6em font-family: sans-serif;} h1{color:#f6821f;}\"\n\nhtml_content += \"<p> Colo: \" + request.cf.colo + \"</p>\"\n          html_content += \"<p> Country: \" + request.cf.country + \"</p>\"\n          html_content += \"<p> City: \" + request.cf.city + \"</p>\"\n          html_content += \"<p> Continent: \" + request.cf.continent + \"</p>\"\n          html_content += \"<p> Latitude: \" + request.cf.latitude + \"</p>\"\n          html_content += \"<p> Longitude: \" + request.cf.longitude + \"</p>\"\n          html_content += \"<p> PostalCode: \" + request.cf.postalCode + \"</p>\"\n          html_content += \"<p> Region: \" + request.cf.region + \"</p>\"\n          html_content += \"<p> RegionCode: \" + request.cf.regionCode + \"</p>\"\n          html_content += \"<p> Timezone: \" + request.cf.timezone + \"</p>\"\n\nhtml = f\"\"\"\n          <!DOCTYPE html>\n            <head>\n              <title> Geolocation: Hello World </title>\n              <style> {html_style} </style>\n            </head>\n            <body>\n              <h1>Geolocation: Hello World!</h1>\n              <p>You now have access to geolocation data about where your user is visiting from.</p>\n              {html_content}\n            </body>\n          \"\"\"\n\nheaders = {\"content-type\": \"text/html;charset=UTF-8\"}\n          return Response(html, headers=headers)\n  ts\n  import { Hono } from \"hono\";\n  import { html } from \"hono/html\";\n\n// Define the RequestWithCf interface to add Cloudflare-specific properties\n  interface RequestWithCf extends Request {\n    cf: {\n      // Cloudflare-specific properties for geolocation\n      colo: string;\n      country: string;\n      city: string;\n      continent: string;\n      latitude: string;\n      longitude: string;\n      postalCode: string;\n      metroCode: string;\n      region: string;\n      regionCode: string;\n      timezone: string;\n      // Add other CF properties as needed\n    };\n  }\n\nconst app = new Hono();\n\napp.get(\"*\", (c) => {\n    // Cast the raw request to include Cloudflare-specific properties\n    const request = c.req.raw;\n\n// Define styles\n    const html_style =\n      \"body{padding:6em; font-family: sans-serif;} h1{color:#f6821f;}\";\n\n// Create content with geolocation data\n    let html_content = html` <p>Colo: ${request.cf.colo}</p>\n      <p>Country: ${request.cf.country}</p>\n      <p>City: ${request.cf.city}</p>\n      <p>Continent: ${request.cf.continent}</p>\n      <p>Latitude: ${request.cf.latitude}</p>\n      <p>Longitude: ${request.cf.longitude}</p>\n      <p>PostalCode: ${request.cf.postalCode}</p>\n      <p>MetroCode: ${request.cf.metroCode}</p>\n      <p>Region: ${request.cf.region}</p>\n      <p>RegionCode: ${request.cf.regionCode}</p>\n      <p>Timezone: ${request.cf.timezone}</p>`;\n\n// Compose the full HTML\n    const htmlContent = html`<!DOCTYPE html>\n      <head>\n        <title>Geolocation: Hello World</title>\n        <style>\n          ${html_style}\n        </style>\n      </head>\n      <body>\n        <h1>Geolocation: Hello World!</h1>\n        <p>\n          You now have access to geolocation data about where your user is\n          visiting from.\n        </p>\n        ${html_content}\n      </body> `;\n\n// Return the HTML response\n    return c.html(htmlContent);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      const HOMEPAGE_URL = \"https://tutorial.cloudflareworkers.com/\";\n      const PROTECTED_TYPE = \"image/\";\n\n// Fetch the original request\n      const response = await fetch(request);\n\n// If it's an image, engage hotlink protection based on the\n      // Referer header.\n      const referer = request.headers.get(\"Referer\");\n      const contentType = response.headers.get(\"Content-Type\") || \"\";\n\nif (referer && contentType.startsWith(PROTECTED_TYPE)) {\n        // If the hostnames don't match, it's a hotlink\n        if (new URL(referer).hostname !== new URL(request.url).hostname) {\n          // Redirect the user to your website\n          return Response.redirect(HOMEPAGE_URL, 302);\n        }\n      }\n\n// Everything is fine, return the response normally.\n      return response;\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const HOMEPAGE_URL = \"https://tutorial.cloudflareworkers.com/\";\n      const PROTECTED_TYPE = \"image/\";\n\n// Fetch the original request\n      const response = await fetch(request);\n\n// If it's an image, engage hotlink protection based on the\n      // Referer header.\n      const referer = request.headers.get(\"Referer\");\n      const contentType = response.headers.get(\"Content-Type\") || \"\";\n\nif (referer && contentType.startsWith(PROTECTED_TYPE)) {\n        // If the hostnames don't match, it's a hotlink\n        if (new URL(referer).hostname !== new URL(request.url).hostname) {\n          // Redirect the user to your website\n          return Response.redirect(HOMEPAGE_URL, 302);\n        }\n      }\n\n// Everything is fine, return the response normally.\n      return response;\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response, fetch\n  from urllib.parse import urlparse\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          homepage_url = \"https://tutorial.cloudflareworkers.com/\"\n          protected_type = \"image/\"\n\n# Fetch the original request\n          response = await fetch(request)\n\n# If it's an image, engage hotlink protection based on the referer header\n          referer = request.headers[\"Referer\"]\n          content_type = response.headers[\"Content-Type\"] or \"\"\n\nif referer and content_type.startswith(protected_type):\n              # If the hostnames don't match, it's a hotlink\n              if urlparse(referer).hostname != urlparse(request.url).hostname:\n                  # Redirect the user to your website\n                  return Response.redirect(homepage_url, 302)\n\n# Everything is fine, return the response normally\n          return response\n  ts\n  import { Hono } from 'hono';\n\nconst app = new Hono();\n\n// Middleware for hot-link protection\n  app.use('*', async (c, next) => {\n    const HOMEPAGE_URL = \"https://tutorial.cloudflareworkers.com/\";\n    const PROTECTED_TYPE = \"image/\";\n\n// Continue to the next handler to get the response\n    await next();\n\n// If we have a response, check for hotlinking\n    if (c.res) {\n      // If it's an image, engage hotlink protection based on the Referer header\n      const referer = c.req.header(\"Referer\");\n      const contentType = c.res.headers.get(\"Content-Type\") || \"\";\n\nif (referer && contentType.startsWith(PROTECTED_TYPE)) {\n        // If the hostnames don't match, it's a hotlink\n        if (new URL(referer).hostname !== new URL(c.req.url).hostname) {\n          // Redirect the user to your website\n          c.res = c.redirect(HOMEPAGE_URL, 302);\n        }\n      }\n    }\n  });\n\n// Default route handler that passes through the request to the origin\n  app.all('*', async (c) => {\n    // Fetch the original request\n    return fetch(c.req.raw);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      // You can find this in the dashboard, it should look something like this: ZWd9g1K7eljCn_KDTu_MWA\n      const accountHash = \"\";\n\nconst { pathname } = new URL(request.url);\n\n// A request to something like cdn.example.com/83eb7b2-5392-4565-b69e-aff66acddd00/public\n      // will fetch \"https://imagedelivery.net/<accountHash>/83eb7b2-5392-4565-b69e-aff66acddd00/public\"\n\nreturn fetch(`https://imagedelivery.net/${accountHash}${pathname}`);\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      // You can find this in the dashboard, it should look something like this: ZWd9g1K7eljCn_KDTu_MWA\n      const accountHash = \"\";\n\nconst { pathname } = new URL(request.url);\n\n// A request to something like cdn.example.com/83eb7b2-5392-4565-b69e-aff66acddd00/public\n      // will fetch \"https://imagedelivery.net/<accountHash>/83eb7b2-5392-4565-b69e-aff66acddd00/public\"\n\nreturn fetch(`https://imagedelivery.net/${accountHash}${pathname}`);\n    },\n  } satisfies ExportedHandler;\n  ts\n  import { Hono } from 'hono';\n\ninterface Env {\n    // You can store your account hash as a binding variable\n    ACCOUNT_HASH?: string;\n  }\n\nconst app = new Hono<{ Bindings: Env }>();\n\napp.get('*', async (c) => {\n    // You can find this in the dashboard, it should look something like this: ZWd9g1K7eljCn_KDTu_MWA\n    // Either get it from environment or hardcode it here\n    const accountHash = c.env.ACCOUNT_HASH || \"\";\n\nconst url = new URL(c.req.url);\n\n// A request to something like cdn.example.com/83eb7b2-5392-4565-b69e-aff66acddd00/public\n    // will fetch \"https://imagedelivery.net/<accountHash>/83eb7b2-5392-4565-b69e-aff66acddd00/public\"\n\nreturn fetch(`https://imagedelivery.net/${accountHash}${url.pathname}`);\n  });\n\nexport default app;\n  py\n  from workers import WorkerEntrypoint\n  from js import URL, fetch\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # You can find this in the dashboard, it should look something like this: ZWd9g1K7eljCn_KDTu_MWA\n          account_hash = \"\"\n          url = URL.new(request.url)\n\n# A request to something like cdn.example.com/83eb7b2-5392-4565-b69e-aff66acddd00/public\n          # will fetch \"https://imagedelivery.net/<accountHash>/83eb7b2-5392-4565-b69e-aff66acddd00/public\"\n          return fetch(f'https://imagedelivery.net/{account_hash}{url.pathname}')\n  js\nhttps://example.com/cdn-cgi/imagedelivery/<ACCOUNT_HASH>/<IMAGE_ID>/<VARIANT_NAME>\njs\n  export default {\n    async fetch(request) {\n      console.log(new Map(request.headers));\n      return new Response(\"Hello world\");\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      console.log(new Map(request.headers));\n      return new Response(\"Hello world\");\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          print(dict(request.headers))\n          return Response('Hello world')\n  rs\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(req: HttpRequest, _env: Env, _ctx: Context) -> Result<Response> {\n      console_log!(\"{:?}\", req.headers());\n      Response::ok(\"hello world\")\n  }\n  ts\n  import { Hono } from 'hono';\n\nconst app = new Hono();\n\napp.get('*', (c) => {\n    // Different ways to log headers in Hono:\n\n// 1. Using Map to display headers in console\n    console.log('Headers as Map:', new Map(c.req.raw.headers));\n\n// 2. Using spread operator to log headers\n    console.log('Headers spread:', [...c.req.raw.headers]);\n\n// 3. Using Object.fromEntries to convert to an object\n    console.log('Headers as Object:', Object.fromEntries(c.req.raw.headers));\n\n// 4. Hono's built-in header accessor (for individual headers)\n    console.log('User-Agent:', c.req.header('User-Agent'));\n\n// 5. Using c.req.headers to get all headers\n    console.log('All headers from Hono context:', c.req.header());\n\nreturn c.text('Hello world');\n  });\n\nexport default app;\n  js\nconsole.log(new Map(request.headers));\njs\nlet requestHeaders = JSON.stringify([...request.headers]);\njs\nlet requestHeaders = Object.fromEntries(request.headers);\njs\nconsole.log(request.headers);\njs\nconsole.log(`Request headers: ${JSON.stringify(request.headers)}`);\njs\nconsole.log(new Map(request.headers));\njs\nlet requestHeaders = JSON.stringify([...request.headers], null, 2);\nconsole.log(`Request headers: ${requestHeaders}`);\njs\nlet headersObject = Object.fromEntries(request.headers);\nlet requestHeaders = JSON.stringify(headersObject, null, 2);\nconsole.log(`Request headers: ${requestHeaders}`);\njs\nRequest headers: {\n  \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\",\n  \"accept-encoding\": \"gzip\",\n  \"accept-language\": \"en-US,en;q=0.9\",\n  \"cf-ipcountry\": \"US\",\n  // ...\n}\"\njs\n  export default {\n    async fetch(request) {\n      /**\n       * Example someHost is set up to return raw JSON\n       * @param {string} someUrl the URL to send the request to, since we are setting hostname too only path is applied\n       * @param {string} someHost the host the request will resolve too\n       */\n      const someHost = \"example.com\";\n      const someUrl = \"https://foo.example.com/api.js\";\n\n/**\n       * The best practice is to only assign new RequestInit properties\n       * on the request object using either a method or the constructor\n       */\n      const newRequestInit = {\n        // Change method\n        method: \"POST\",\n        // Change body\n        body: JSON.stringify({ bar: \"foo\" }),\n        // Change the redirect mode.\n        redirect: \"follow\",\n        // Change headers, note this method will erase existing headers\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        // Change a Cloudflare feature on the outbound response\n        cf: { apps: false },\n      };\n\n// Change just the host\n      const url = new URL(someUrl);\n\nurl.hostname = someHost;\n\n// Best practice is to always use the original request to construct the new request\n      // to clone all the attributes. Applying the URL also requires a constructor\n      // since once a Request has been constructed, its URL is immutable.\n      const newRequest = new Request(\n        url.toString(),\n        new Request(request, newRequestInit),\n      );\n\n// Set headers using method\n      newRequest.headers.set(\"X-Example\", \"bar\");\n      newRequest.headers.set(\"Content-Type\", \"application/json\");\n      try {\n        return await fetch(newRequest);\n      } catch (e) {\n        return new Response(JSON.stringify({ error: e.message }), {\n          status: 500,\n        });\n      }\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * Example someHost is set up to return raw JSON\n       * @param {string} someUrl the URL to send the request to, since we are setting hostname too only path is applied\n       * @param {string} someHost the host the request will resolve too\n       */\n      const someHost = \"example.com\";\n      const someUrl = \"https://foo.example.com/api.js\";\n\n/**\n       * The best practice is to only assign new RequestInit properties\n       * on the request object using either a method or the constructor\n       */\n      const newRequestInit = {\n        // Change method\n        method: \"POST\",\n        // Change body\n        body: JSON.stringify({ bar: \"foo\" }),\n        // Change the redirect mode.\n        redirect: \"follow\",\n        // Change headers, note this method will erase existing headers\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        // Change a Cloudflare feature on the outbound response\n        cf: { apps: false },\n      };\n\n// Change just the host\n      const url = new URL(someUrl);\n\nurl.hostname = someHost;\n\n// Best practice is to always use the original request to construct the new request\n      // to clone all the attributes. Applying the URL also requires a constructor\n      // since once a Request has been constructed, its URL is immutable.\n      const newRequest = new Request(\n        url.toString(),\n        new Request(request, newRequestInit),\n      );\n\n// Set headers using method\n      newRequest.headers.set(\"X-Example\", \"bar\");\n      newRequest.headers.set(\"Content-Type\", \"application/json\");\n      try {\n        return await fetch(newRequest);\n      } catch (e) {\n        return new Response(JSON.stringify({ error: e.message }), {\n          status: 500,\n        });\n      }\n    },\n  } satisfies ExportedHandler;\n  py\n  import json\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Object, URL, Request, fetch, Response\n\ndef to_js(obj):\n      return _to_js(obj, dict_converter=Object.fromEntries)\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          some_host = \"example.com\"\n          some_url = \"https://foo.example.com/api.js\"\n\n# The best practice is to only assign new_request_init properties\n          # on the request object using either a method or the constructor\n          new_request_init = {\n            \"method\": \"POST\", # Change method\n            \"body\": json.dumps({ \"bar\": \"foo\" }), # Change body\n            \"redirect\": \"follow\", # Change the redirect mode\n            # Change headers, note this method will erase existing headers\n            \"headers\": {\n              \"Content-Type\": \"application/json\",\n            },\n            #  Change a Cloudflare feature on the outbound response\n            \"cf\": { \"apps\": False },\n          }\n\n# Change just the host\n          url = URL.new(some_url)\n          url.hostname = some_host\n\n# Best practice is to always use the original request to construct the new request\n          # to clone all the attributes. Applying the URL also requires a constructor\n          # since once a Request has been constructed, its URL is immutable.\n          org_request = Request.new(request, new_request_init)\n          new_request = Request.new(url.toString(),org_request)\n\nnew_request.headers[\"X-Example\"] =  \"bar\"\n          new_request.headers[\"Content-Type\"] = \"application/json\"\n\ntry:\n              return await fetch(new_request)\n          except Exception as e:\n              return Response.new({\"error\": str(e)}, status=500)\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\napp.all(\"*\", async (c) => {\n    /**\n     * Example someHost is set up to return raw JSON\n     */\n    const someHost = \"example.com\";\n    const someUrl = \"https://foo.example.com/api.js\";\n\n// Create a URL object to modify the hostname\n    const url = new URL(someUrl);\n    url.hostname = someHost;\n\n// Create a new request\n    // First create a clone of the original request with the new properties\n    const requestClone = new Request(c.req.raw, {\n      // Change method\n      method: \"POST\",\n      // Change body\n      body: JSON.stringify({ bar: \"foo\" }),\n      // Change the redirect mode\n      redirect: \"follow\" as RequestRedirect,\n      // Change headers, note this method will erase existing headers\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"X-Example\": \"bar\",\n      },\n      // Change a Cloudflare feature on the outbound response\n      cf: { apps: false },\n    });\n\n// Then create a new request with the modified URL\n    const newRequest = new Request(url.toString(), requestClone);\n\n// Send the modified request\n    const response = await fetch(newRequest);\n\n// Return the response\n    return response;\n  });\n\n// Handle errors\n  app.onError((err, c) => {\n    return err.getResponse();\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      /**\n       * @param {string} headerNameSrc Header to get the new value from\n       * @param {string} headerNameDst Header to set based off of value in src\n       */\n      const headerNameSrc = \"foo\"; //\"Orig-Header\"\n      const headerNameDst = \"Last-Modified\";\n\n/**\n       * Response properties are immutable. To change them, construct a new\n       * Response and pass modified status or statusText in the ResponseInit\n       * object. Response headers can be modified through the headers `set` method.\n       */\n      const originalResponse = await fetch(request);\n\n// Change status and statusText, but preserve body and headers\n      let response = new Response(originalResponse.body, {\n        status: 500,\n        statusText: \"some message\",\n        headers: originalResponse.headers,\n      });\n\n// Change response body by adding the foo prop\n      const originalBody = await originalResponse.json();\n      const body = JSON.stringify({ foo: \"bar\", ...originalBody });\n      response = new Response(body, response);\n\n// Add a header using set method\n      response.headers.set(\"foo\", \"bar\");\n\n// Set destination header to the value of the source header\n      const src = response.headers.get(headerNameSrc);\n\nif (src != null) {\n        response.headers.set(headerNameDst, src);\n        console.log(\n          `Response header \"${headerNameDst}\" was set to \"${response.headers.get(\n            headerNameDst,\n          )}\"`,\n        );\n      }\n      return response;\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * @param {string} headerNameSrc Header to get the new value from\n       * @param {string} headerNameDst Header to set based off of value in src\n       */\n      const headerNameSrc = \"foo\"; //\"Orig-Header\"\n      const headerNameDst = \"Last-Modified\";\n\n/**\n       * Response properties are immutable. To change them, construct a new\n       * Response and pass modified status or statusText in the ResponseInit\n       * object. Response headers can be modified through the headers `set` method.\n       */\n      const originalResponse = await fetch(request);\n\n// Change status and statusText, but preserve body and headers\n      let response = new Response(originalResponse.body, {\n        status: 500,\n        statusText: \"some message\",\n        headers: originalResponse.headers,\n      });\n\n// Change response body by adding the foo prop\n      const originalBody = await originalResponse.json();\n      const body = JSON.stringify({ foo: \"bar\", ...originalBody });\n      response = new Response(body, response);\n\n// Add a header using set method\n      response.headers.set(\"foo\", \"bar\");\n\n// Set destination header to the value of the source header\n      const src = response.headers.get(headerNameSrc);\n\nif (src != null) {\n        response.headers.set(headerNameDst, src);\n        console.log(\n          `Response header \"${headerNameDst}\" was set to \"${response.headers.get(\n            headerNameDst,\n          )}\"`,\n        );\n      }\n      return response;\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response, fetch\n  import json\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          header_name_src = \"foo\" # Header to get the new value from\n          header_name_dst = \"Last-Modified\" # Header to set based off of value in src\n\n# Response properties are immutable. To change them, construct a new response\n          original_response = await fetch(request)\n\n# Change status and statusText, but preserve body and headers\n          response = Response(original_response.body, status=500, status_text=\"some message\", headers=original_response.headers)\n\n# Change response body by adding the foo prop\n          new_body = await original_response.json()\n          new_body[\"foo\"] = \"bar\"\n          response.replace_body(json.dumps(new_body))\n\n# Add a new header\n          response.headers[\"foo\"] = \"bar\"\n\n# Set destination header to the value of the source header\n          src = response.headers[header_name_src]\n\nif src is not None:\n              response.headers[header_name_dst] = src\n              print(f'Response header {header_name_dst} was set to {response.headers[header_name_dst]}')\n\nreturn response\n  ts\n  import { Hono } from 'hono';\n\nconst app = new Hono();\n\napp.get('*', async (c) => {\n    /**\n     * Header configuration\n     */\n    const headerNameSrc = \"foo\"; // Header to get the new value from\n    const headerNameDst = \"Last-Modified\"; // Header to set based off of value in src\n\n/**\n     * Response properties are immutable. With Hono, we can modify the response\n     * by creating custom response objects.\n     */\n    const originalResponse = await fetch(c.req.raw);\n\n// Get the JSON body from the original response\n    const originalBody = await originalResponse.json();\n\n// Modify the body by adding a new property\n    const modifiedBody = {\n      foo: \"bar\",\n      ...originalBody\n    };\n\n// Create a new custom response with modified status, headers, and body\n    const response = new Response(JSON.stringify(modifiedBody), {\n      status: 500,\n      statusText: \"some message\",\n      headers: originalResponse.headers,\n    });\n\n// Add a header using set method\n    response.headers.set(\"foo\", \"bar\");\n\n// Set destination header to the value of the source header\n    const src = response.headers.get(headerNameSrc);\n    if (src != null) {\n      response.headers.set(headerNameDst, src);\n      console.log(\n        `Response header \"${headerNameDst}\" was set to \"${response.headers.get(headerNameDst)}\"`\n      );\n    }\n\nreturn response;\n  });\n\nexport default app;\n  js\n  export default {\n    async scheduled(event, env, ctx) {\n      // Write code for updating your API\n      switch (event.cron) {\n        case \"*/3 * * * *\":\n          // Every three minutes\n          await updateAPI();\n          break;\n        case \"*/10 * * * *\":\n          // Every ten minutes\n          await updateAPI2();\n          break;\n        case \"*/45 * * * *\":\n          // Every forty-five minutes\n          await updateAPI3();\n          break;\n      }\n      console.log(\"cron processed\");\n    },\n  };\n  ts\n  interface Env {}\n  export default {\n    async scheduled(\n      controller: ScheduledController,\n      env: Env,\n      ctx: ExecutionContext,\n    ) {\n      // Write code for updating your API\n      switch (controller.cron) {\n        case \"*/3 * * * *\":\n          // Every three minutes\n          await updateAPI();\n          break;\n        case \"*/10 * * * *\":\n          // Every ten minutes\n          await updateAPI2();\n          break;\n        case \"*/45 * * * *\":\n          // Every forty-five minutes\n          await updateAPI3();\n          break;\n      }\n      console.log(\"cron processed\");\n    },\n  };\n  ts\n  import { Hono } from \"hono\";\n\n// Create Hono app\n  const app = new Hono<{ Bindings: Env }>();\n\n// Regular routes for normal HTTP requests\n  app.get(\"/\", (c) => c.text(\"Multiple Cron Trigger Example\"));\n\n// Export both the app and a scheduled function\n  export default {\n    // The Hono app handles regular HTTP requests\n    fetch: app.fetch,\n\n// The scheduled function handles Cron triggers\n    async scheduled(\n      controller: ScheduledController,\n      env: Env,\n      ctx: ExecutionContext,\n    ) {\n      // Check which cron schedule triggered this execution\n      switch (controller.cron) {\n        case \"*/3 * * * *\":\n          // Every three minutes\n          await updateAPI();\n          break;\n        case \"*/10 * * * *\":\n          // Every ten minutes\n          await updateAPI2();\n          break;\n        case \"*/45 * * * *\":\n          // Every forty-five minutes\n          await updateAPI3();\n          break;\n      }\n      console.log(\"cron processed\");\n    },\n  };\n  sh\nnpx wrangler dev --test-scheduled\n\ncurl \"http://localhost:8787/__scheduled?cron=*%2F3+*+*+*+*\"\n\ncurl \"http://localhost:8787/cdn-cgi/handler/scheduled?cron=*+*+*+*+*\" # Python Workers\nts\n  import OpenAI from \"openai\";\n\nexport default {\n    async fetch(request, env, ctx): Promise<Response> {\n      const openai = new OpenAI({\n        apiKey: env.OPENAI_API_KEY,\n      });\n\n// Create a TransformStream to handle streaming data\n      let { readable, writable } = new TransformStream();\n      let writer = writable.getWriter();\n      const textEncoder = new TextEncoder();\n\nctx.waitUntil(\n        (async () => {\n          const stream = await openai.chat.completions.create({\n            model: \"gpt-4o-mini\",\n            messages: [{ role: \"user\", content: \"Tell me a story\" }],\n            stream: true,\n          });\n\n// loop over the data as it is streamed and write to the writeable\n          for await (const part of stream) {\n            writer.write(\n              textEncoder.encode(part.choices[0]?.delta?.content || \"\"),\n            );\n          }\n          writer.close();\n        })(),\n      );\n\n// Send the readable back to the browser\n      return new Response(readable);\n    },\n  } satisfies ExportedHandler<Env>;\n  ts\n  import { Hono } from \"hono\";\n  import { streamText } from \"hono/streaming\";\n  import OpenAI from \"openai\";\n\ninterface Env {\n    OPENAI_API_KEY: string;\n  }\n\nconst app = new Hono<{ Bindings: Env }>();\n\napp.get(\"*\", async (c) => {\n    const openai = new OpenAI({\n      apiKey: c.env.OPENAI_API_KEY,\n    });\n\nconst chatStream = await openai.chat.completions.create({\n      model: \"gpt-4o-mini\",\n      messages: [{ role: \"user\", content: \"Tell me a story\" }],\n      stream: true,\n    });\n\nreturn streamText(c, async (stream) => {\n      for await (const message of chatStream) {\n        await stream.write(message.choices[0].delta.content || \"\");\n      }\n      stream.close();\n    });\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      /**\n       * Example someHost is set up to take in a JSON request\n       * Replace url with the host you wish to send requests to\n       * @param {string} url the URL to send the request to\n       * @param {BodyInit} body the JSON data to send in the request\n       */\n      const someHost = \"https://examples.cloudflareworkers.com/demos\";\n      const url = someHost + \"/requests/json\";\n      const body = {\n        results: [\"default data to send\"],\n        errors: null,\n        msg: \"I sent this to the fetch\",\n      };\n\n/**\n       * gatherResponse awaits and returns a response body as a string.\n       * Use await gatherResponse(..) in an async function to get the response body\n       * @param {Response} response\n       */\n      async function gatherResponse(response) {\n        const { headers } = response;\n        const contentType = headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          return JSON.stringify(await response.json());\n        } else if (contentType.includes(\"application/text\")) {\n          return response.text();\n        } else if (contentType.includes(\"text/html\")) {\n          return response.text();\n        } else {\n          return response.text();\n        }\n      }\n\nconst init = {\n        body: JSON.stringify(body),\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      };\n      const response = await fetch(url, init);\n      const results = await gatherResponse(response);\n      return new Response(results, init);\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * Example someHost is set up to take in a JSON request\n       * Replace url with the host you wish to send requests to\n       * @param {string} url the URL to send the request to\n       * @param {BodyInit} body the JSON data to send in the request\n       */\n      const someHost = \"https://examples.cloudflareworkers.com/demos\";\n      const url = someHost + \"/requests/json\";\n      const body = {\n        results: [\"default data to send\"],\n        errors: null,\n        msg: \"I sent this to the fetch\",\n      };\n\n/**\n       * gatherResponse awaits and returns a response body as a string.\n       * Use await gatherResponse(..) in an async function to get the response body\n       * @param {Response} response\n       */\n      async function gatherResponse(response) {\n        const { headers } = response;\n        const contentType = headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          return JSON.stringify(await response.json());\n        } else if (contentType.includes(\"application/text\")) {\n          return response.text();\n        } else if (contentType.includes(\"text/html\")) {\n          return response.text();\n        } else {\n          return response.text();\n        }\n      }\n\nconst init = {\n        body: JSON.stringify(body),\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json;charset=UTF-8\",\n        },\n      };\n      const response = await fetch(url, init);\n      const results = await gatherResponse(response);\n      return new Response(results, init);\n    },\n  } satisfies ExportedHandler;\n  py\n  import json\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Object, fetch, Response, Headers\n\ndef to_js(obj):\n      return _to_js(obj, dict_converter=Object.fromEntries)\n\n# gather_response returns both content-type & response body as a string\n  async def gather_response(response):\n      headers = response.headers\n      content_type = headers[\"content-type\"] or \"\"\n\nif \"application/json\" in content_type:\n          return (content_type, json.dumps(dict(await response.json())))\n      return (content_type, await response.text())\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, _request):\n      url = \"https://jsonplaceholder.typicode.com/todos/1\"\n\nbody = {\n      \"results\": [\"default data to send\"],\n      \"errors\": None,\n      \"msg\": \"I sent this to the fetch\",\n      }\n\noptions = {\n      \"body\": json.dumps(body),\n      \"method\": \"POST\",\n      \"headers\": {\n        \"content-type\": \"application/json;charset=UTF-8\",\n      },\n      }\n\nresponse = await fetch(url, to_js(options))\n      content_type, result = await gather_response(response)\n\nheaders = Headers.new({\"content-type\": content_type}.items())\n      return Response.new(result, headers=headers)\n  ts\n  import { Hono } from 'hono';\n\nconst app = new Hono();\n\napp.get('*', async (c) => {\n    /**\n     * Example someHost is set up to take in a JSON request\n     * Replace url with the host you wish to send requests to\n     */\n    const someHost = \"https://examples.cloudflareworkers.com/demos\";\n    const url = someHost + \"/requests/json\";\n    const body = {\n      results: [\"default data to send\"],\n      errors: null,\n      msg: \"I sent this to the fetch\",\n    };\n\n/**\n     * gatherResponse awaits and returns a response body as a string.\n     * Use await gatherResponse(..) in an async function to get the response body\n     */\n    async function gatherResponse(response: Response) {\n      const { headers } = response;\n      const contentType = headers.get(\"content-type\") || \"\";\n\nif (contentType.includes(\"application/json\")) {\n        return { contentType, result: JSON.stringify(await response.json()) };\n      } else if (contentType.includes(\"application/text\")) {\n        return { contentType, result: await response.text() };\n      } else if (contentType.includes(\"text/html\")) {\n        return { contentType, result: await response.text() };\n      } else {\n        return { contentType, result: await response.text() };\n      }\n    }\n\nconst init = {\n      body: JSON.stringify(body),\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json;charset=UTF-8\",\n      },\n    };\n\nconst response = await fetch(url, init);\n    const { contentType, result } = await gatherResponse(response);\n\nreturn new Response(result, {\n      headers: {\n        \"content-type\": contentType,\n      },\n    });\n  });\n\nexport default app;\n  ts\n  interface Environment {\n    MY_SECRET_VALUE?: string;\n  }\n\nexport default {\n    async fetch(req: Request, env: Environment) {\n      if (!env.MY_SECRET_VALUE) {\n        return new Response(\"Missing secret binding\", { status: 500 });\n      }\n\nconst authToken = req.headers.get(\"Authorization\") || \"\";\n\nif (authToken.length !== env.MY_SECRET_VALUE.length) {\n        return new Response(\"Unauthorized\", { status: 401 });\n      }\n\nconst encoder = new TextEncoder();\n\nconst a = encoder.encode(authToken);\n      const b = encoder.encode(env.MY_SECRET_VALUE);\n\nif (a.byteLength !== b.byteLength) {\n        return new Response(\"Unauthorized\", { status: 401 });\n      }\n\nif (!crypto.subtle.timingSafeEqual(a, b)) {\n        return new Response(\"Unauthorized\", { status: 401 });\n      }\n\nreturn new Response(\"Welcome!\");\n    },\n  };\n  py\n  from workers import WorkerEntrypoint, Response\n  from js import TextEncoder, crypto\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          auth_token = request.headers[\"Authorization\"] or \"\"\n          secret = self.env.MY_SECRET_VALUE\n\nif secret is None:\n              return Response(\"Missing secret binding\", status=500)\n\nif len(auth_token) != len(secret):\n              return Response(\"Unauthorized\", status=401)\n\nencoder = TextEncoder.new()\n          a = encoder.encode(auth_token)\n          b = encoder.encode(secret)\n\nif a.byteLength != b.byteLength:\n              return Response(\"Unauthorized\", status=401)\n\nif not crypto.subtle.timingSafeEqual(a, b):\n              return Response(\"Unauthorized\", status=401)\n\nreturn Response(\"Welcome!\")\n  ts\n  import { Hono } from 'hono';\n\ninterface Environment {\n    Bindings: {\n      MY_SECRET_VALUE?: string;\n    }\n  }\n\nconst app = new Hono<Environment>();\n\n// Middleware to handle authentication with timing-safe comparison\n  app.use('*', async (c, next) => {\n    const secret = c.env.MY_SECRET_VALUE;\n\nif (!secret) {\n      return c.text(\"Missing secret binding\", 500);\n    }\n\nconst authToken = c.req.header(\"Authorization\") || \"\";\n\n// Early length check to avoid unnecessary processing\n    if (authToken.length !== secret.length) {\n      return c.text(\"Unauthorized\", 401);\n    }\n\nconst encoder = new TextEncoder();\n\nconst a = encoder.encode(authToken);\n    const b = encoder.encode(secret);\n\nif (a.byteLength !== b.byteLength) {\n      return c.text(\"Unauthorized\", 401);\n    }\n\n// Perform timing-safe comparison\n    if (!crypto.subtle.timingSafeEqual(a, b)) {\n      return c.text(\"Unauthorized\", 401);\n    }\n\n// If we got here, the auth token is valid\n    await next();\n  });\n\n// Protected route\n  app.get('*', (c) => {\n    return c.text(\"Welcome!\");\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      /**\n       * rawHtmlResponse returns HTML inputted directly\n       * into the worker script\n       * @param {string} html\n       */\n      function rawHtmlResponse(html) {\n        return new Response(html, {\n          headers: {\n            \"content-type\": \"text/html;charset=UTF-8\",\n          },\n        });\n      }\n\n/**\n       * readRequestBody reads in the incoming request body\n       * Use await readRequestBody(..) in an async function to get the string\n       * @param {Request} request the incoming request to read from\n       */\n      async function readRequestBody(request) {\n        const contentType = request.headers.get(\"content-type\");\n        if (contentType.includes(\"application/json\")) {\n          return JSON.stringify(await request.json());\n        } else if (contentType.includes(\"application/text\")) {\n          return request.text();\n        } else if (contentType.includes(\"text/html\")) {\n          return request.text();\n        } else if (contentType.includes(\"form\")) {\n          const formData = await request.formData();\n          const body = {};\n          for (const entry of formData.entries()) {\n            body[entry[0]] = entry[1];\n          }\n          return JSON.stringify(body);\n        } else {\n          // Perhaps some other type of data was submitted in the form\n          // like an image, or some other binary data.\n          return \"a file\";\n        }\n      }\n\nconst { url } = request;\n      if (url.includes(\"form\")) {\n        return rawHtmlResponse(someForm);\n      }\n      if (request.method === \"POST\") {\n        const reqBody = await readRequestBody(request);\n        const retBody = `The request body sent in was ${reqBody}`;\n        return new Response(retBody);\n      } else if (request.method === \"GET\") {\n        return new Response(\"The request was a GET\");\n      }\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      /**\n       * rawHtmlResponse returns HTML inputted directly\n       * into the worker script\n       * @param {string} html\n       */\n      function rawHtmlResponse(html) {\n        return new Response(html, {\n          headers: {\n            \"content-type\": \"text/html;charset=UTF-8\",\n          },\n        });\n      }\n\n/**\n       * readRequestBody reads in the incoming request body\n       * Use await readRequestBody(..) in an async function to get the string\n       * @param {Request} request the incoming request to read from\n       */\n      async function readRequestBody(request: Request) {\n        const contentType = request.headers.get(\"content-type\");\n        if (contentType.includes(\"application/json\")) {\n          return JSON.stringify(await request.json());\n        } else if (contentType.includes(\"application/text\")) {\n          return request.text();\n        } else if (contentType.includes(\"text/html\")) {\n          return request.text();\n        } else if (contentType.includes(\"form\")) {\n          const formData = await request.formData();\n          const body = {};\n          for (const entry of formData.entries()) {\n            body[entry[0]] = entry[1];\n          }\n          return JSON.stringify(body);\n        } else {\n          // Perhaps some other type of data was submitted in the form\n          // like an image, or some other binary data.\n          return \"a file\";\n        }\n      }\n\nconst { url } = request;\n      if (url.includes(\"form\")) {\n        return rawHtmlResponse(someForm);\n      }\n      if (request.method === \"POST\") {\n        const reqBody = await readRequestBody(request);\n        const retBody = `The request body sent in was ${reqBody}`;\n        return new Response(retBody);\n      } else if (request.method === \"GET\") {\n        return new Response(\"The request was a GET\");\n      }\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint\n  from js import Object, Response, Headers, JSON\n\nasync def read_request_body(request):\n      headers = request.headers\n      content_type = headers[\"content-type\"] or \"\"\n\nif \"application/json\" in content_type:\n          return JSON.stringify(await request.json())\n      if \"form\" in content_type:\n          form = await request.formData()\n          data = Object.fromEntries(form.entries())\n          return JSON.stringify(data)\n      return await request.text()\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          def raw_html_response(html):\n              headers = Headers.new({\"content-type\": \"text/html;charset=UTF-8\"}.items())\n              return Response.new(html, headers=headers)\n\nif \"form\" in request.url:\n              return raw_html_response(\"\")\n\nif \"POST\" in request.method:\n              req_body = await read_request_body(request)\n              ret_body = f\"The request body sent in was {req_body}\"\n              return Response.new(ret_body)\n\nreturn Response.new(\"The request was not POST\")\n  rs\n  use serde::{Deserialize, Serialize};\n  use worker::*;\n\nfn raw_html_response(html: &str) -> Result<Response> {\n      Response::from_html(html)\n  }\n\n#[derive(Deserialize, Serialize, Debug)]\n  struct Payload {\n      msg: String,\n  }\n\nasync fn read_request_body(mut req: Request) -> String {\n      let ctype = req.headers().get(\"content-type\").unwrap().unwrap();\n      match ctype.as_str() {\n          \"application/json\" => format!(\"{:?}\", req.json::<Payload>().await.unwrap()),\n          \"text/html\" => req.text().await.unwrap(),\n          \"multipart/form-data\" => format!(\"{:?}\", req.form_data().await.unwrap()),\n          _ => String::from(\"a file\"),\n      }\n  }\n\n#[event(fetch)]\n  async fn fetch(req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      if String::from(req.url()?).contains(\"form\") {\n          return raw_html_response(\"some html form\");\n      }\n\nmatch req.method() {\n          Method::Post => {\n              let req_body = read_request_body(req).await;\n              Response::ok(format!(\"The request body sent in was {}\", req_body))\n          }\n          _ => Response::ok(format!(\"The result was a {:?}\", req.method())),\n      }\n  }\n  ts\n  import { Hono } from \"hono\";\n  import { html } from \"hono/html\";\n\nconst app = new Hono();\n\n/**\n   * readRequestBody reads in the incoming request body\n   * @param {Request} request the incoming request to read from\n   */\n  async function readRequestBody(request: Request): Promise<string> {\n    const contentType = request.headers.get(\"content-type\") || \"\";\n\nif (contentType.includes(\"application/json\")) {\n      const body = await request.json();\n      return JSON.stringify(body);\n    } else if (contentType.includes(\"application/text\")) {\n      return request.text();\n    } else if (contentType.includes(\"text/html\")) {\n      return request.text();\n    } else if (contentType.includes(\"form\")) {\n      const formData = await request.formData();\n      const body: Record<string, string> = {};\n      for (const [key, value] of formData.entries()) {\n        body[key] = value.toString();\n      }\n      return JSON.stringify(body);\n    } else {\n      // Perhaps some other type of data was submitted in the form\n      // like an image, or some other binary data.\n      return \"a file\";\n    }\n  }\n\nconst someForm = html`<!DOCTYPE html>\n    <html>\n      <body>\n        <form action=\"/\" method=\"post\">\n          <div>\n            <label for=\"message\">Message:</label>\n            <input id=\"message\" name=\"message\" type=\"text\" />\n          </div>\n          <div>\n            <button>Submit</button>\n          </div>\n        </form>\n      </body>\n    </html>`;\n\napp.get(\"*\", async (c) => {\n    const url = c.req.url;\n\nif (url.includes(\"form\")) {\n      return c.html(someForm);\n    }\n\nreturn c.text(\"The request was a GET\");\n  });\n\napp.post(\"*\", async (c) => {\n    const reqBody = await readRequestBody(c.req.raw);\n    const retBody = `The request body sent in was ${reqBody}`;\n    return c.text(retBody);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      const destinationURL = \"https://example.com\";\n      const statusCode = 301;\n      return Response.redirect(destinationURL, statusCode);\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const destinationURL = \"https://example.com\";\n      const statusCode = 301;\n      return Response.redirect(destinationURL, statusCode);\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n      def fetch(self, request):\n          destinationURL = \"https://example.com\"\n          statusCode = 301\n          return Response.redirect(destinationURL, statusCode)\n  rs\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(_req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let destination_url = Url::parse(\"https://example.com\")?;\n      let status_code = 301;\n      Response::redirect_with_status(destination_url, status_code)\n  }\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\napp.all(\"*\", (c) => {\n    const destinationURL = \"https://example.com\";\n    const statusCode = 301;\n    return c.redirect(destinationURL, statusCode);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      const base = \"https://example.com\";\n      const statusCode = 301;\n\nconst url = new URL(request.url);\n      const { pathname, search } = url;\n\nconst destinationURL = `${base}${pathname}${search}`;\n      console.log(destinationURL);\n\nreturn Response.redirect(destinationURL, statusCode);\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const base = \"https://example.com\";\n      const statusCode = 301;\n\nconst url = new URL(request.url);\n      const { pathname, search } = url;\n\nconst destinationURL = `${base}${pathname}${search}`;\n      console.log(destinationURL);\n\nreturn Response.redirect(destinationURL, statusCode);\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response\n  from urllib.parse import urlparse\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          base = \"https://example.com\"\n          statusCode = 301\n\nurl = urlparse(request.url)\n\ndestinationURL = f'{base}{url.path}{url.query}'\n          print(destinationURL)\n\nreturn Response.redirect(destinationURL, statusCode)\n  rs\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let mut base = Url::parse(\"https://example.com\")?;\n      let status_code = 301;\n\nlet url = req.url()?;\n\nbase.set_path(url.path());\n      base.set_query(url.query());\n\nconsole_log!(\"{:?}\", base.to_string());\n\nResponse::redirect_with_status(base, status_code)\n  }\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\napp.all(\"*\", (c) => {\n    const base = \"https://example.com\";\n    const statusCode = 301;\n\nconst { pathname, search } = new URL(c.req.url);\n\nconst destinationURL = `${base}${pathname}${search}`;\n    console.log(destinationURL);\n\nreturn c.redirect(destinationURL, statusCode);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      function MethodNotAllowed(request) {\n        return new Response(`Method ${request.method} not allowed.`, {\n          status: 405,\n          headers: {\n            Allow: \"GET\",\n          },\n        });\n      }\n      // Only GET requests work with this proxy.\n      if (request.method !== \"GET\") return MethodNotAllowed(request);\n      return fetch(`https://example.com`);\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      function MethodNotAllowed(request) {\n        return new Response(`Method ${request.method} not allowed.`, {\n          status: 405,\n          headers: {\n            Allow: \"GET\",\n          },\n        });\n      }\n      // Only GET requests work with this proxy.\n      if (request.method !== \"GET\") return MethodNotAllowed(request);\n      return fetch(`https://example.com`);\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response, fetch\n\nclass Default(WorkerEntrypoint):\n      def fetch(self, request):\n          def method_not_allowed(request):\n              msg = f'Method {request.method} not allowed.'\n              headers = {\"Allow\": \"GET\"}\n              return Response(msg, headers=headers, status=405)\n\n# Only GET requests work with this proxy.\n          if request.method != \"GET\":\n              return method_not_allowed(request)\n\nreturn fetch(\"https://example.com\")\n  js\n  export default {\n    async fetch(request) {\n      const html = `<!DOCTYPE html>\n      <body>\n        <h1>Hello World</h1>\n        <p>This markup was generated by a Cloudflare Worker.</p>\n      </body>`;\n\nreturn new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const html = `<!DOCTYPE html>\n      <body>\n        <h1>Hello World</h1>\n        <p>This markup was generated by a Cloudflare Worker.</p>\n      </body>`;\n\nreturn new Response(html, {\n        headers: {\n          \"content-type\": \"text/html;charset=UTF-8\",\n        },\n      });\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          html = \"\"\"<!DOCTYPE html>\n          <body>\n            <h1>Hello World</h1>\n            <p>This markup was generated by a Cloudflare Worker.</p>\n          </body>\"\"\"\n\nheaders = {\"content-type\": \"text/html;charset=UTF-8\"}\n          return Response(html, headers=headers)\n  rs\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(_req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let html = r#\"<!DOCTYPE html>\n      <body>\n        <h1>Hello World</h1>\n        <p>This markup was generated by a Cloudflare Worker.</p>\n      </body>\n      \"#;\n      Response::from_html(html)\n  }\n  ts\n  import { Hono } from \"hono\";\n  import { html } from \"hono/html\";\n\nconst app = new Hono();\n\napp.get(\"*\", (c) => {\n    const doc = html`<!DOCTYPE html>\n      <body>\n        <h1>Hello World</h1>\n        <p>This markup was generated by a Cloudflare Worker with Hono.</p>\n      </body>`;\n\nreturn c.html(doc);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      const data = {\n        hello: \"world\",\n      };\n\nreturn Response.json(data);\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const data = {\n        hello: \"world\",\n      };\n\nreturn Response.json(data);\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response\n  import json\n\nclass Default(WorkerEntrypoint):\n      def fetch(self, request):\n          data = json.dumps({\"hello\": \"world\"})\n          headers = {\"content-type\": \"application/json\"}\n          return Response(data, headers=headers)\n  rs\n  use serde::{Deserialize, Serialize};\n  use worker::*;\n\n#[derive(Deserialize, Serialize, Debug)]\n  struct Json {\n      hello: String,\n  }\n\n#[event(fetch)]\n  async fn fetch(_req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let data = Json {\n          hello: String::from(\"world\"),\n      };\n      Response::from_json(&data)\n  }\n  ts\n  import { Hono } from \"hono\";\n\nconst app = new Hono();\n\napp.get(\"*\", (c) => {\n    const data = {\n      hello: \"world\",\n    };\n\nreturn c.json(data);\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      const OLD_URL = \"developer.mozilla.org\";\n      const NEW_URL = \"mynewdomain.com\";\n\nclass AttributeRewriter {\n        constructor(attributeName) {\n          this.attributeName = attributeName;\n        }\n        element(element) {\n          const attribute = element.getAttribute(this.attributeName);\n          if (attribute) {\n            element.setAttribute(\n              this.attributeName,\n              attribute.replace(OLD_URL, NEW_URL),\n            );\n          }\n        }\n      }\n\nconst rewriter = new HTMLRewriter()\n        .on(\"a\", new AttributeRewriter(\"href\"))\n        .on(\"img\", new AttributeRewriter(\"src\"));\n\nconst res = await fetch(request);\n      const contentType = res.headers.get(\"Content-Type\");\n\n// If the response is HTML, it can be transformed with\n      // HTMLRewriter -- otherwise, it should pass through\n      if (contentType.startsWith(\"text/html\")) {\n        return rewriter.transform(res);\n      } else {\n        return res;\n      }\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const OLD_URL = \"developer.mozilla.org\";\n      const NEW_URL = \"mynewdomain.com\";\n\nclass AttributeRewriter {\n        constructor(attributeName) {\n          this.attributeName = attributeName;\n        }\n        element(element) {\n          const attribute = element.getAttribute(this.attributeName);\n          if (attribute) {\n            element.setAttribute(\n              this.attributeName,\n              attribute.replace(OLD_URL, NEW_URL),\n            );\n          }\n        }\n      }\n\nconst rewriter = new HTMLRewriter()\n        .on(\"a\", new AttributeRewriter(\"href\"))\n        .on(\"img\", new AttributeRewriter(\"src\"));\n\nconst res = await fetch(request);\n      const contentType = res.headers.get(\"Content-Type\");\n\n// If the response is HTML, it can be transformed with\n      // HTMLRewriter -- otherwise, it should pass through\n      if (contentType.startsWith(\"text/html\")) {\n        return rewriter.transform(res);\n      } else {\n        return res;\n      }\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import create_proxy\n  from js import HTMLRewriter, fetch\n\nclass AttributeRewriter:\n      old_url = \"developer.mozilla.org\"\n      new_url = \"mynewdomain.com\"\n\ndef __init__(self, attr_name):\n          self.attr_name = attr_name\n\ndef element(self, element):\n          attr = element.getAttribute(self.attr_name)\n          if attr:\n              element.setAttribute(\n                  self.attr_name, attr.replace(self.old_url, self.new_url)\n              )\n\nhref = create_proxy(AttributeRewriter(\"href\"))\n  src = create_proxy(AttributeRewriter(\"src\"))\n  rewriter = HTMLRewriter.new().on(\"a\", href).on(\"img\", src)\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          res = await fetch(request)\n          content_type = res.headers[\"Content-Type\"]\n\n# If the response is HTML, it can be transformed with\n          # HTMLRewriter -- otherwise, it should pass through\n          if content_type.startswith(\"text/html\"):\n              return rewriter.transform(res)\n          return res\n  ts\n  import { Hono } from 'hono';\n  import { html } from 'hono/html';\n\nconst app = new Hono();\n\napp.get('*', async (c) => {\n    const OLD_URL = \"developer.mozilla.org\";\n    const NEW_URL = \"mynewdomain.com\";\n\nclass AttributeRewriter {\n      attributeName: string;\n\nconstructor(attributeName: string) {\n        this.attributeName = attributeName;\n      }\n\nelement(element: Element) {\n        const attribute = element.getAttribute(this.attributeName);\n        if (attribute) {\n          element.setAttribute(\n            this.attributeName,\n            attribute.replace(OLD_URL, NEW_URL)\n          );\n        }\n      }\n    }\n\n// Make a fetch request using the original request\n    const res = await fetch(c.req.raw);\n    const contentType = res.headers.get(\"Content-Type\") || \"\";\n\n// If the response is HTML, transform it with HTMLRewriter\n    if (contentType.startsWith(\"text/html\")) {\n      const rewriter = new HTMLRewriter()\n        .on(\"a\", new AttributeRewriter(\"href\"))\n        .on(\"img\", new AttributeRewriter(\"src\"));\n\nreturn new Response(rewriter.transform(res).body, {\n        headers: res.headers\n      });\n    } else {\n      // Pass through the response as is\n      return res;\n    }\n  });\n\nexport default app;\n  js\n  export default {\n    async fetch(request) {\n      const DEFAULT_SECURITY_HEADERS = {\n        /*\n      Secure your application with Content-Security-Policy headers.\n      Enabling these headers will permit content from a trusted domain and all its subdomains.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy\n      \"Content-Security-Policy\": \"default-src 'self' example.com *.example.com\",\n      */\n        /*\n      You can also set Strict-Transport-Security headers.\n      These are not automatically set because your website might get added to Chrome's HSTS preload list.\n      Here's the code if you want to apply it:\n      \"Strict-Transport-Security\" : \"max-age=63072000; includeSubDomains; preload\",\n      */\n        /*\n      Permissions-Policy header provides the ability to allow or deny the use of browser features, such as opting out of FLoC - which you can use below:\n      \"Permissions-Policy\": \"interest-cohort=()\",\n      */\n        /*\n      X-XSS-Protection header prevents a page from loading if an XSS attack is detected.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-XSS-Protection\n      */\n        \"X-XSS-Protection\": \"0\",\n        /*\n      X-Frame-Options header prevents click-jacking attacks.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options\n      */\n        \"X-Frame-Options\": \"DENY\",\n        /*\n      X-Content-Type-Options header prevents MIME-sniffing.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options\n      */\n        \"X-Content-Type-Options\": \"nosniff\",\n        \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n        \"Cross-Origin-Embedder-Policy\": 'require-corp; report-to=\"default\";',\n        \"Cross-Origin-Opener-Policy\": 'same-site; report-to=\"default\";',\n        \"Cross-Origin-Resource-Policy\": \"same-site\",\n      };\n      const BLOCKED_HEADERS = [\n        \"Public-Key-Pins\",\n        \"X-Powered-By\",\n        \"X-AspNet-Version\",\n      ];\n\nlet response = await fetch(request);\n      let newHeaders = new Headers(response.headers);\n\nconst tlsVersion = request.cf.tlsVersion;\n      console.log(tlsVersion);\n      // This sets the headers for HTML responses:\n      if (\n        newHeaders.has(\"Content-Type\") &&\n        !newHeaders.get(\"Content-Type\").includes(\"text/html\")\n      ) {\n        return new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: newHeaders,\n        });\n      }\n\nObject.keys(DEFAULT_SECURITY_HEADERS).map((name) => {\n        newHeaders.set(name, DEFAULT_SECURITY_HEADERS[name]);\n      });\n\nBLOCKED_HEADERS.forEach((name) => {\n        newHeaders.delete(name);\n      });\n\nif (tlsVersion !== \"TLSv1.2\" && tlsVersion !== \"TLSv1.3\") {\n        return new Response(\"You need to use TLS version 1.2 or higher.\", {\n          status: 400,\n        });\n      } else {\n        return new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: newHeaders,\n        });\n      }\n    },\n  };\n  ts\n  export default {\n    async fetch(request): Promise<Response> {\n      const DEFAULT_SECURITY_HEADERS = {\n        /*\n      Secure your application with Content-Security-Policy headers.\n      Enabling these headers will permit content from a trusted domain and all its subdomains.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy\n      \"Content-Security-Policy\": \"default-src 'self' example.com *.example.com\",\n      */\n        /*\n      You can also set Strict-Transport-Security headers.\n      These are not automatically set because your website might get added to Chrome's HSTS preload list.\n      Here's the code if you want to apply it:\n      \"Strict-Transport-Security\" : \"max-age=63072000; includeSubDomains; preload\",\n      */\n        /*\n      Permissions-Policy header provides the ability to allow or deny the use of browser features, such as opting out of FLoC - which you can use below:\n      \"Permissions-Policy\": \"interest-cohort=()\",\n      */\n        /*\n      X-XSS-Protection header prevents a page from loading if an XSS attack is detected.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-XSS-Protection\n      */\n        \"X-XSS-Protection\": \"0\",\n        /*\n      X-Frame-Options header prevents click-jacking attacks.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options\n      */\n        \"X-Frame-Options\": \"DENY\",\n        /*\n      X-Content-Type-Options header prevents MIME-sniffing.\n      @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options\n      */\n        \"X-Content-Type-Options\": \"nosniff\",\n        \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n        \"Cross-Origin-Embedder-Policy\": 'require-corp; report-to=\"default\";',\n        \"Cross-Origin-Opener-Policy\": 'same-site; report-to=\"default\";',\n        \"Cross-Origin-Resource-Policy\": \"same-site\",\n      };\n      const BLOCKED_HEADERS = [\n        \"Public-Key-Pins\",\n        \"X-Powered-By\",\n        \"X-AspNet-Version\",\n      ];\n\nlet response = await fetch(request);\n      let newHeaders = new Headers(response.headers);\n\nconst tlsVersion = request.cf.tlsVersion;\n      console.log(tlsVersion);\n      // This sets the headers for HTML responses:\n      if (\n        newHeaders.has(\"Content-Type\") &&\n        !newHeaders.get(\"Content-Type\").includes(\"text/html\")\n      ) {\n        return new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: newHeaders,\n        });\n      }\n\nObject.keys(DEFAULT_SECURITY_HEADERS).map((name) => {\n        newHeaders.set(name, DEFAULT_SECURITY_HEADERS[name]);\n      });\n\nBLOCKED_HEADERS.forEach((name) => {\n        newHeaders.delete(name);\n      });\n\nif (tlsVersion !== \"TLSv1.2\" && tlsVersion !== \"TLSv1.3\") {\n        return new Response(\"You need to use TLS version 1.2 or higher.\", {\n          status: 400,\n        });\n      } else {\n        return new Response(response.body, {\n          status: response.status,\n          statusText: response.statusText,\n          headers: newHeaders,\n        });\n      }\n    },\n  } satisfies ExportedHandler;\n  py\n  from workers import WorkerEntrypoint, Response, fetch\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          default_security_headers = {\n              # Secure your application with Content-Security-Policy headers.\n              #Enabling these headers will permit content from a trusted domain and all its subdomains.\n              #@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy\n              \"Content-Security-Policy\": \"default-src 'self' example.com *.example.com\",\n              #You can also set Strict-Transport-Security headers.\n              #These are not automatically set because your website might get added to Chrome's HSTS preload list.\n              #Here's the code if you want to apply it:\n              \"Strict-Transport-Security\" : \"max-age=63072000; includeSubDomains; preload\",\n              #Permissions-Policy header provides the ability to allow or deny the use of browser features, such as opting out of FLoC - which you can use below:\n              \"Permissions-Policy\": \"interest-cohort=()\",\n              #X-XSS-Protection header prevents a page from loading if an XSS attack is detected.\n              #@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-XSS-Protection\n              \"X-XSS-Protection\": \"0\",\n              #X-Frame-Options header prevents click-jacking attacks.\n              #@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options\n              \"X-Frame-Options\": \"DENY\",\n              #X-Content-Type-Options header prevents MIME-sniffing.\n              #@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options\n              \"X-Content-Type-Options\": \"nosniff\",\n              \"Referrer-Policy\": \"strict-origin-when-cross-origin\",\n              \"Cross-Origin-Embedder-Policy\": 'require-corp; report-to=\"default\";',\n              \"Cross-Origin-Opener-Policy\": 'same-site; report-to=\"default\";',\n              \"Cross-Origin-Resource-Policy\": \"same-site\",\n          }\n          blocked_headers = [\"Public-Key-Pins\", \"X-Powered-By\" ,\"X-AspNet-Version\"]\n\nres = await fetch(request)\n          new_headers = res.headers\n\n# This sets the headers for HTML responses\n          if \"text/html\" in new_headers[\"Content-Type\"]:\n              return Response(res.body, status=res.status, statusText=res.statusText, headers=new_headers)\n\nfor name in default_security_headers:\n              new_headers[name] = default_security_headers[name]\n\nfor name in blocked_headers:\n              del new_headers[\"name\"]\n\ntls = request.cf.tlsVersion\n\nif not tls in (\"TLSv1.2\", \"TLSv1.3\"):\n              return Response(\"You need to use TLS version 1.2 or higher.\", status=400)\n          return Response(res.body, status=res.status, statusText=res.statusText, headers=new_headers)\n  rs\n  use std::collections::HashMap;\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(req: Request, _env: Env, _ctx: Context) -> Result<Response> {\n      let default_security_headers = HashMap::from([\n          //Secure your application with Content-Security-Policy headers.\n          //Enabling these headers will permit content from a trusted domain and all its subdomains.\n          //@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy\n          (\n              \"Content-Security-Policy\",\n              \"default-src 'self' example.com *.example.com\",\n          ),\n          //You can also set Strict-Transport-Security headers.\n          //These are not automatically set because your website might get added to Chrome's HSTS preload list.\n          //Here's the code if you want to apply it:\n          (\n              \"Strict-Transport-Security\",\n              \"max-age=63072000; includeSubDomains; preload\",\n          ),\n          //Permissions-Policy header provides the ability to allow or deny the use of browser features, such as opting out of FLoC - which you can use below:\n          (\"Permissions-Policy\", \"interest-cohort=()\"),\n          //X-XSS-Protection header prevents a page from loading if an XSS attack is detected.\n          //@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-XSS-Protection\n          (\"X-XSS-Protection\", \"0\"),\n          //X-Frame-Options header prevents click-jacking attacks.\n          //@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options\n          (\"X-Frame-Options\", \"DENY\"),\n          //X-Content-Type-Options header prevents MIME-sniffing.\n          //@see https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options\n          (\"X-Content-Type-Options\", \"nosniff\"),\n          (\"Referrer-Policy\", \"strict-origin-when-cross-origin\"),\n          (\n              \"Cross-Origin-Embedder-Policy\",\n              \"require-corp; report-to='default';\",\n          ),\n          (\n              \"Cross-Origin-Opener-Policy\",\n              \"same-site; report-to='default';\",\n          ),\n          (\"Cross-Origin-Resource-Policy\", \"same-site\"),\n      ]);\n      let blocked_headers = [\"Public-Key-Pins\", \"X-Powered-By\", \"X-AspNet-Version\"];\n      let tls = req.cf().unwrap().tls_version();\n      let res = Fetch::Request(req).send().await?;\n      let mut new_headers = res.headers().clone();\n\n// This sets the headers for HTML responses\n      if Some(String::from(\"text/html\")) == new_headers.get(\"Content-Type\")? {\n          return Ok(Response::from_body(res.body().clone())?\n              .with_headers(new_headers)\n              .with_status(res.status_code()));\n      }\n      for (k, v) in default_security_headers {\n          new_headers.set(k, v)?;\n      }\n\nfor k in blocked_headers {\n          new_headers.delete(k)?;\n      }\n\nif !vec![\"TLSv1.2\", \"TLSv1.3\"].contains(&tls.as_str()) {\n          return Response::error(\"You need to use TLS version 1.2 or higher.\", 400);\n      }\n      Ok(Response::from_body(res.body().clone())?\n          .with_headers(new_headers)\n          .with_status(res.status_code()))\n\n}\n  ts\n  import { Hono } from 'hono';\n  import { secureHeaders } from 'hono/secure-headers';\n\nconst app = new Hono();\n  app.use(secureHeaders());\n\n// Handle all other requests by passing through to origin\n  app.all('*', async (c) => {\n    return fetch(c.req.raw);\n  });\n\nexport default app;\n  js\n  import { Buffer } from \"node:buffer\";\n\nconst encoder = new TextEncoder();\n\n// How long an HMAC token should be valid for, in seconds\n  const EXPIRY = 60;\n\nexport default {\n    /**\n     *\n     * @param {Request} request\n     * @param {{SECRET_DATA: string}} env\n     * @returns\n     */\n    async fetch(request, env) {\n      // You will need some secret data to use as a symmetric key. This should be\n      // attached to your Worker as an encrypted secret.\n      // Refer to https://developers.cloudflare.com/workers/configuration/secrets/\n      const secretKeyData = encoder.encode(\n        env.SECRET_DATA ?? \"my secret symmetric key\",\n      );\n\n// Import your secret as a CryptoKey for both 'sign' and 'verify' operations\n      const key = await crypto.subtle.importKey(\n        \"raw\",\n        secretKeyData,\n        { name: \"HMAC\", hash: \"SHA-256\" },\n        false,\n        [\"sign\", \"verify\"],\n      );\n\nconst url = new URL(request.url);\n\n// This is a demonstration Worker that allows unauthenticated access to /generate\n      // In a real application you would want to make sure that\n      // users could only generate signed URLs when authenticated\n      if (url.pathname.startsWith(\"/generate/\")) {\n        url.pathname = url.pathname.replace(\"/generate/\", \"/\");\n\nconst timestamp = Math.floor(Date.now() / 1000);\n\n// This contains all the data about the request that you want to be able to verify\n        // Here we only sign the timestamp and the pathname, but often you will want to\n        // include more data (for instance, the URL hostname or query parameters)\n        const dataToAuthenticate = `${url.pathname}${timestamp}`;\n\nconst mac = await crypto.subtle.sign(\n          \"HMAC\",\n          key,\n          encoder.encode(dataToAuthenticate),\n        );\n\n// Refer to https://developers.cloudflare.com/workers/runtime-apis/nodejs/\n        // for more details on using Node.js APIs in Workers\n        const base64Mac = Buffer.from(mac).toString(\"base64\");\n\nurl.searchParams.set(\"verify\", `${timestamp}-${base64Mac}`);\n\nreturn new Response(`${url.pathname}${url.search}`);\n        // Verify all non /generate requests\n      } else {\n        // Make sure you have the minimum necessary query parameters.\n        if (!url.searchParams.has(\"verify\")) {\n          return new Response(\"Missing query parameter\", { status: 403 });\n        }\n\nconst [timestamp, hmac] = url.searchParams.get(\"verify\").split(\"-\");\n\nconst assertedTimestamp = Number(timestamp);\n\nconst dataToAuthenticate = `${url.pathname}${assertedTimestamp}`;\n\nconst receivedMac = Buffer.from(hmac, \"base64\");\n\n// Use crypto.subtle.verify() to guard against timing attacks. Since HMACs use\n        // symmetric keys, you could implement this by calling crypto.subtle.sign() and\n        // then doing a string comparison -- this is insecure, as string comparisons\n        // bail out on the first mismatch, which leaks information to potential\n        // attackers.\n        const verified = await crypto.subtle.verify(\n          \"HMAC\",\n          key,\n          receivedMac,\n          encoder.encode(dataToAuthenticate),\n        );\n\nif (!verified) {\n          return new Response(\"Invalid MAC\", { status: 403 });\n        }\n\n// Signed requests expire after one minute. Note that this value should depend on your specific use case\n        if (Date.now() / 1000 > assertedTimestamp + EXPIRY) {\n          return new Response(\n            `URL expired at ${new Date((assertedTimestamp + EXPIRY) * 1000)}`,\n            { status: 403 },\n          );\n        }\n      }\n\nreturn fetch(new URL(url.pathname, \"https://example.com\"), request);\n    },\n  };\n  ts\n  import { Buffer } from \"node:buffer\";\n\nconst encoder = new TextEncoder();\n\n// How long an HMAC token should be valid for, in seconds\n  const EXPIRY = 60;\n\ninterface Env {\n    SECRET_DATA: string;\n  }\n  export default {\n    async fetch(request, env): Promise<Response> {\n      // You will need some secret data to use as a symmetric key. This should be\n      // attached to your Worker as an encrypted secret.\n      // Refer to https://developers.cloudflare.com/workers/configuration/secrets/\n      const secretKeyData = encoder.encode(\n        env.SECRET_DATA ?? \"my secret symmetric key\",\n      );\n\n// Import your secret as a CryptoKey for both 'sign' and 'verify' operations\n      const key = await crypto.subtle.importKey(\n        \"raw\",\n        secretKeyData,\n        { name: \"HMAC\", hash: \"SHA-256\" },\n        false,\n        [\"sign\", \"verify\"],\n      );\n\nconst url = new URL(request.url);\n\n// This is a demonstration Worker that allows unauthenticated access to /generate\n      // In a real application you would want to make sure that\n      // users could only generate signed URLs when authenticated\n      if (url.pathname.startsWith(\"/generate/\")) {\n        url.pathname = url.pathname.replace(\"/generate/\", \"/\");\n\nconst timestamp = Math.floor(Date.now() / 1000);\n\n// This contains all the data about the request that you want to be able to verify\n        // Here we only sign the timestamp and the pathname, but often you will want to\n        // include more data (for instance, the URL hostname or query parameters)\n        const dataToAuthenticate = `${url.pathname}${timestamp}`;\n\nconst mac = await crypto.subtle.sign(\n          \"HMAC\",\n          key,\n          encoder.encode(dataToAuthenticate),\n        );\n\n// Refer to https://developers.cloudflare.com/workers/runtime-apis/nodejs/\n        // for more details on using NodeJS APIs in Workers\n        const base64Mac = Buffer.from(mac).toString(\"base64\");\n\nurl.searchParams.set(\"verify\", `${timestamp}-${base64Mac}`);\n\nreturn new Response(`${url.pathname}${url.search}`);\n        // Verify all non /generate requests\n      } else {\n        // Make sure you have the minimum necessary query parameters.\n        if (!url.searchParams.has(\"verify\")) {\n          return new Response(\"Missing query parameter\", { status: 403 });\n        }\n\nconst [timestamp, hmac] = url.searchParams.get(\"verify\").split(\"-\");\n\nconst assertedTimestamp = Number(timestamp);\n\nconst dataToAuthenticate = `${url.pathname}${assertedTimestamp}`;\n\nconst receivedMac = Buffer.from(hmac, \"base64\");\n\n// Use crypto.subtle.verify() to guard against timing attacks. Since HMACs use\n        // symmetric keys, you could implement this by calling crypto.subtle.sign() and\n        // then doing a string comparison -- this is insecure, as string comparisons\n        // bail out on the first mismatch, which leaks information to potential\n        // attackers.\n        const verified = await crypto.subtle.verify(\n          \"HMAC\",\n          key,\n          receivedMac,\n          encoder.encode(dataToAuthenticate),\n        );\n\nif (!verified) {\n          return new Response(\"Invalid MAC\", { status: 403 });\n        }\n\n// Signed requests expire after one minute. Note that this value should depend on your specific use case\n        if (Date.now() / 1000 > assertedTimestamp + EXPIRY) {\n          return new Response(\n            `URL expired at ${new Date((assertedTimestamp + EXPIRY) * 1000)}`,\n            { status: 403 },\n          );\n        }\n      }\n\nreturn fetch(new URL(url.pathname, \"https://example.com\"), request);\n    },\n  } satisfies ExportedHandler<Env>;\n  ts\n  import { Buffer } from \"node:buffer\";\n  import { Hono } from \"hono\";\n  import { proxy } from \"hono/proxy\";\n\nconst encoder = new TextEncoder();\n\n// How long an HMAC token should be valid for, in seconds\n  const EXPIRY = 60;\n\ninterface Env {\n    SECRET_DATA: string;\n  }\n\nconst app = new Hono();\n\n// Handle URL generation requests\n  app.get(\"/generate/*\", async (c) => {\n    const env = c.env;\n\n// You will need some secret data to use as a symmetric key\n    const secretKeyData = encoder.encode(\n      env.SECRET_DATA ?? \"my secret symmetric key\",\n    );\n\n// Import the secret as a CryptoKey for both 'sign' and 'verify' operations\n    const key = await crypto.subtle.importKey(\n      \"raw\",\n      secretKeyData,\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"sign\", \"verify\"],\n    );\n\n// Replace \"/generate/\" prefix with \"/\"\n    let pathname = c.req.path.replace(\"/generate/\", \"/\");\n\nconst timestamp = Math.floor(Date.now() / 1000);\n\n// Data to authenticate: pathname + timestamp\n    const dataToAuthenticate = `${pathname}${timestamp}`;\n\n// Sign the data\n    const mac = await crypto.subtle.sign(\n      \"HMAC\",\n      key,\n      encoder.encode(dataToAuthenticate),\n    );\n\n// Convert the signature to base64\n    const base64Mac = Buffer.from(mac).toString(\"base64\");\n\n// Add verification parameter to URL\n    url.searchParams.set(\"verify\", `${timestamp}-${base64Mac}`);\n\nreturn c.text(`${pathname}${url.search}`);\n  });\n\n// Handle verification for all other requests\n  app.all(\"*\", async (c) => {\n    const env = c.env;\n    const url = c.req.url;\n\n// You will need some secret data to use as a symmetric key\n    const secretKeyData = encoder.encode(\n      env.SECRET_DATA ?? \"my secret symmetric key\",\n    );\n\n// Import the secret as a CryptoKey for both 'sign' and 'verify' operations\n    const key = await crypto.subtle.importKey(\n      \"raw\",\n      secretKeyData,\n      { name: \"HMAC\", hash: \"SHA-256\" },\n      false,\n      [\"sign\", \"verify\"],\n    );\n\n// Make sure the request has the verification parameter\n    if (!c.req.query(\"verify\")) {\n      return c.text(\"Missing query parameter\", 403);\n    }\n\n// Extract timestamp and signature\n    const [timestamp, hmac] = c.req.query(\"verify\")!.split(\"-\");\n    const assertedTimestamp = Number(timestamp);\n\n// Recreate the data that should have been signed\n    const dataToAuthenticate = `${c.req.path}${assertedTimestamp}`;\n\n// Convert base64 signature back to ArrayBuffer\n    const receivedMac = Buffer.from(hmac, \"base64\");\n\n// Verify the signature\n    const verified = await crypto.subtle.verify(\n      \"HMAC\",\n      key,\n      receivedMac,\n      encoder.encode(dataToAuthenticate),\n    );\n\n// If verification fails, return 403\n    if (!verified) {\n      return c.text(\"Invalid MAC\", 403);\n    }\n\n// Check if the signature has expired\n    if (Date.now() / 1000 > assertedTimestamp + EXPIRY) {\n      return c.text(\n        `URL expired at ${new Date((assertedTimestamp + EXPIRY) * 1000)}`,\n        403,\n      );\n    }\n\n// If verification passes, proxy the request to example.com\n    return proxy(`https://example.com/${c.req.path}`, ...c.req);\n  });\n\nexport default app;\n  py\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import to_js as _to_js\n  from js import Response, URL, TextEncoder, Buffer, fetch, Object, crypto\n\ndef to_js(x):\n      return _to_js(x, dict_converter=Object.fromEntries)\n\nencoder = TextEncoder.new()\n\n# How long an HMAC token should be valid for, in seconds\n  EXPIRY = 60\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          # Get the secret key\n          secret_key_data = encoder.encode(getattr(self.env, \"SECRET_DATA\", None) or \"my secret symmetric key\")\n\n# Import the secret as a CryptoKey for both 'sign' and 'verify' operations\n          key = await crypto.subtle.importKey(\n              \"raw\",\n              secret_key_data,\n              to_js({\"name\": \"HMAC\", \"hash\": \"SHA-256\"}),\n              False,\n              [\"sign\", \"verify\"]\n          )\n\nurl = URL.new(request.url)\n\nif url.pathname.startswith(\"/generate/\"):\n              url.pathname = url.pathname.replace(\"/generate/\", \"/\", 1)\n\ntimestamp = int(Date.now() / 1000)\n\n# Data to authenticate\n              data_to_authenticate = f\"{url.pathname}{timestamp}\"\n\n# Sign the data\n              mac = await crypto.subtle.sign(\n                  \"HMAC\",\n                  key,\n                  encoder.encode(data_to_authenticate)\n              )\n\n# Convert to base64\n              base64_mac = Buffer.from(mac).toString(\"base64\")\n\n# Set the verification parameter\n              url.searchParams.set(\"verify\", f\"{timestamp}-{base64_mac}\")\n\nreturn Response.new(f\"{url.pathname}{url.search}\")\n          else:\n              # Verify the request\n              if not \"verify\" in url.searchParams:\n                  return Response.new(\"Missing query parameter\", status=403)\n\nverify_param = url.searchParams.get(\"verify\")\n              timestamp, hmac = verify_param.split(\"-\")\n\nasserted_timestamp = int(timestamp)\n\ndata_to_authenticate = f\"{url.pathname}{asserted_timestamp}\"\n\nreceived_mac = Buffer.from(hmac, \"base64\")\n\n# Verify the signature\n              verified = await crypto.subtle.verify(\n                  \"HMAC\",\n                  key,\n                  received_mac,\n                  encoder.encode(data_to_authenticate)\n              )\n\nif not verified:\n                  return Response.new(\"Invalid MAC\", status=403)\n\n# Check expiration\n              if Date.now() / 1000 > asserted_timestamp + EXPIRY:\n                  expiry_date = Date.new((asserted_timestamp + EXPIRY) * 1000)\n                  return Response.new(f\"URL expired at {expiry_date}\", status=403)\n\n# Proxy to example.com if verification passes\n          return fetch(URL.new(f\"https://example.com{url.pathname}\"), request)\n  sh\nnpm install @streamparser/json-whatwg\nts\n  import { JSONParser } from \"@streamparser/json-whatwg\";\n\nexport default {\n    async fetch(request): Promise<Response> {\n      const parser = new JSONParser({ paths: [\"$.users.*\"] });\n\nconst users: string[] = [];\n\n// Pipe the request body through the JSON parser\n      const reader = request.body\n        .pipeThrough(parser)\n        .getReader();\n\n// Process matching JSON values as they stream in\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        // Extract only the name field from each user object\n        if (value.value?.name) {\n          users.push(value.value.name);\n        }\n      }\n\nreturn Response.json({ userNames: users });\n    },\n  } satisfies ExportedHandler;\n  js\n  import { JSONParser } from \"@streamparser/json-whatwg\";\n\nexport default {\n    async fetch(request) {\n      const parser = new JSONParser({ paths: [\"$.users.*\"] });\n\n// Pipe the request body through the JSON parser\n      const reader = request.body\n        .pipeThrough(parser)\n        .getReader();\n\n// Process matching JSON values as they stream in\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        // Extract only the name field from each user object\n        if (value.value?.name) {\n          users.push(value.value.name);\n        }\n      }\n\nreturn Response.json({ userNames: users });\n    },\n  };\n  ts\n  import { JSONParser } from \"@streamparser/json-whatwg\";\n\nexport default {\n    async fetch(request): Promise<Response> {\n      const response = await fetch(\"https://api.example.com/large-dataset.json\");\n\nconst parser = new JSONParser({ paths: [\"$.items.*\"] });\n\nconst { readable, writable } = new TransformStream();\n      const writer = writable.getWriter();\n      const encoder = new TextEncoder();\n\n// Process the upstream response in the background\n      (async () => {\n        const reader = response.body\n          .pipeThrough(parser)\n          .getReader();\n\nawait writer.write(encoder.encode('{\"processedItems\":['));\n        let first = true;\n\nwhile (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n\n// Transform each item as it streams through\n          const item = value.value;\n          const transformed = {\n            id: item.id,\n            title: item.title.toUpperCase(),\n            processed: true,\n          };\n\nif (!first) await writer.write(encoder.encode(\",\"));\n          first = false;\n          await writer.write(encoder.encode(JSON.stringify(transformed)));\n        }\n\nawait writer.write(encoder.encode(\"]}\"));\n        await writer.close();\n      })();\n\nreturn new Response(readable, {\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    },\n  } satisfies ExportedHandler;\n  js\n  import { JSONParser } from \"@streamparser/json-whatwg\";\n\nexport default {\n    async fetch(request) {\n      const response = await fetch(\"https://api.example.com/large-dataset.json\");\n\nconst parser = new JSONParser({ paths: [\"$.items.*\"] });\n\nconst { readable, writable } = new TransformStream();\n      const writer = writable.getWriter();\n      const encoder = new TextEncoder();\n\n// Process the upstream response in the background\n      (async () => {\n        const reader = response.body\n          .pipeThrough(parser)\n          .getReader();\n\nawait writer.write(encoder.encode('{\"processedItems\":['));\n        let first = true;\n\nwhile (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n\n// Transform each item as it streams through\n          const item = value.value;\n          const transformed = {\n            id: item.id,\n            title: item.title.toUpperCase(),\n            processed: true,\n          };\n\nif (!first) await writer.write(encoder.encode(\",\"));\n          first = false;\n          await writer.write(encoder.encode(JSON.stringify(transformed)));\n        }\n\nawait writer.write(encoder.encode(\"]}\"));\n        await writer.close();\n      })();\n\nreturn new Response(readable, {\n        headers: { \"Content-Type\": \"application/json\" },\n      });\n    },\n  };\n  js\n  export default {\n    async fetch(request, env) {\n      const SITE_KEY = env.SITE_KEY; // The Turnstile Sitekey of your widget (pass as env or secret)\n      const TURNSTILE_ATTR_NAME = \"your_id_to_replace\"; // The id of the element to put a Turnstile widget in\n      let res = await fetch(request);\n\n// Instantiate the API to run on specific elements, for example, `head`, `div`\n      let newRes = new HTMLRewriter()\n\n// `.on` attaches the element handler and this allows you to match on element/attributes or to use the specific methods per the API\n        .on(\"head\", {\n          element(element) {\n            // In this case, you are using `append` to add a new script to the `head` element\n            element.append(\n              `<script src=\"https://challenges.cloudflare.com/turnstile/v0/api.js\" async defer></script>`,\n              { html: true },\n            );\n          },\n        })\n        .on(\"div\", {\n          element(element) {\n            // Add a turnstile widget element into if an element with the id of TURNSTILE_ATTR_NAME is found\n            if (element.getAttribute(\"id\") === TURNSTILE_ATTR_NAME) {\n              element.append(\n                `<div class=\"cf-turnstile\" data-sitekey=\"${SITE_KEY}\"></div>`,\n                { html: true },\n              );\n            }\n          },\n        })\n        .transform(res);\n      return newRes;\n    },\n  };\n  ts\n  export default {\n    async fetch(request, env): Promise<Response> {\n      const SITE_KEY = env.SITE_KEY; // The Turnstile Sitekey of your widget (pass as env or secret)\n      const TURNSTILE_ATTR_NAME = \"your_id_to_replace\"; // The id of the element to put a Turnstile widget in\n\nlet res = await fetch(request);\n\n// Instantiate the API to run on specific elements, for example, `head`, `div`\n      let newRes = new HTMLRewriter()\n\n// `.on` attaches the element handler and this allows you to match on element/attributes or to use the specific methods per the API\n        .on(\"head\", {\n          element(element) {\n            // In this case, you are using `append` to add a new script to the `head` element\n            element.append(\n              `<script src=\"https://challenges.cloudflare.com/turnstile/v0/api.js\" async defer></script>`,\n              { html: true },\n            );\n          },\n        })\n        .on(\"div\", {\n          element(element) {\n            // Add a turnstile widget element into if an element with the id of TURNSTILE_ATTR_NAME is found\n            if (element.getAttribute(\"id\") === TURNSTILE_ATTR_NAME) {\n              element.append(\n                `<div class=\"cf-turnstile\" data-sitekey=\"${SITE_KEY}\" data-theme=\"light\"></div>`,\n                { html: true },\n              );\n            }\n          },\n        })\n        .transform(res);\n      return newRes;\n    },\n  } satisfies ExportedHandler<Env>;\n  ts\n  import { Hono } from \"hono\";\n\ninterface Env {\n    SITE_KEY: string;\n    SECRET_KEY: string;\n    TURNSTILE_ATTR_NAME?: string;\n  }\n\nconst app = new Hono<{ Bindings: Env }>();\n\n// Middleware to inject Turnstile widget\n  app.use(\"*\", async (c, next) => {\n    const SITE_KEY = c.env.SITE_KEY; // The Turnstile Sitekey from environment\n    const TURNSTILE_ATTR_NAME = c.env.TURNSTILE_ATTR_NAME || \"your_id_to_replace\"; // The target element ID\n\n// Process the request through the original endpoint\n    await next();\n\n// Only process HTML responses\n    const contentType = c.res.headers.get(\"content-type\");\n    if (!contentType || !contentType.includes(\"text/html\")) {\n      return;\n    }\n\n// Clone the response to make it modifiable\n    const originalResponse = c.res;\n    const responseBody = await originalResponse.text();\n\n// Create an HTMLRewriter instance to modify the HTML\n    const rewriter = new HTMLRewriter()\n      // Add the Turnstile script to the head\n      .on(\"head\", {\n        element(element) {\n          element.append(\n            `<script src=\"https://challenges.cloudflare.com/turnstile/v0/api.js\" async defer></script>`,\n            { html: true },\n          );\n        },\n      })\n      // Add the Turnstile widget to the target div\n      .on(\"div\", {\n        element(element) {\n          if (element.getAttribute(\"id\") === TURNSTILE_ATTR_NAME) {\n            element.append(\n              `<div class=\"cf-turnstile\" data-sitekey=\"${SITE_KEY}\" data-theme=\"light\"></div>`,\n              { html: true },\n            );\n          }\n        },\n      });\n\n// Create a new response with the same properties as the original\n    const modifiedResponse = new Response(responseBody, {\n      status: originalResponse.status,\n      statusText: originalResponse.statusText,\n      headers: originalResponse.headers,\n    });\n\n// Transform the response using HTMLRewriter\n    c.res = rewriter.transform(modifiedResponse);\n  });\n\n// Handle POST requests for form submission with Turnstile validation\n  app.post(\"*\", async (c) => {\n    const formData = await c.req.formData();\n    const token = formData.get(\"cf-turnstile-response\");\n    const ip = c.req.header(\"CF-Connecting-IP\");\n\n// If no token, return an error\n    if (!token) {\n      return c.text(\"Missing Turnstile token\", 400);\n    }\n\n// Prepare verification data\n    const verifyFormData = new FormData();\n    verifyFormData.append(\"secret\", c.env.SECRET_KEY || \"\");\n    verifyFormData.append(\"response\", token.toString());\n    if (ip) verifyFormData.append(\"remoteip\", ip);\n\n// Verify the token with Turnstile API\n    const verifyResult = await fetch(\n      \"https://challenges.cloudflare.com/turnstile/v0/siteverify\",\n      {\n        method: \"POST\",\n        body: verifyFormData,\n      },\n    );\n\nconst outcome = await verifyResult.json<{ success: boolean }>;\n\n// If verification fails, return an error\n    if (!outcome.success) {\n      return c.text(\"The provided Turnstile token was not valid!\", 401);\n    }\n\n// If verification succeeds, proceed with the original request\n    // You would typically handle the form submission logic here\n\n// For this example, we'll just send a success response\n    return c.text(\"Form submission successful!\");\n  });\n\n// Default handler for GET requests\n  app.get(\"*\", async (c) => {\n    // Fetch the original content (you'd replace this with your actual content source)\n    return await fetch(c.req.raw);\n  });\n\nexport default app;\n  py\n  from workers import WorkerEntrypoint\n  from pyodide.ffi import create_proxy\n  from js import HTMLRewriter, fetch\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          site_key = self.env.SITE_KEY\n          attr_name = self.env.TURNSTILE_ATTR_NAME\n          res = await fetch(request)\n\nclass Append:\n              def element(self, element):\n                  s = '<script src=\"https://challenges.cloudflare.com/turnstile/v0/api.js\" async defer></script>'\n                  element.append(s, {\"html\": True})\n\nclass AppendOnID:\n              def __init__(self, name):\n                  self.name = name\n              def element(self, element):\n                  # You are using the `getAttribute` method here to retrieve the `id` or `class` of an element\n                  if element.getAttribute(\"id\") == self.name:\n                      div = f'<div class=\"cf-turnstile\" data-sitekey=\"{site_key}\" data-theme=\"light\"></div>'\n                      element.append(div, { \"html\": True })\n\n# Instantiate the API to run on specific elements, for example, `head`, `div`\n          head = create_proxy(Append())\n          div = create_proxy(AppendOnID(attr_name))\n          new_res = HTMLRewriter.new().on(\"head\", head).on(\"div\", div).transform(res)\n\nreturn new_res\n  js\n// In client-side JavaScript, connect to your Workers function using WebSockets:\nconst websocket = new WebSocket(\n  \"wss://example-websocket.signalnerve.workers.dev\",\n);\njs\n  async function handleRequest(request) {\n    const upgradeHeader = request.headers.get('Upgrade');\n    if (!upgradeHeader || upgradeHeader !== 'websocket') {\n      return new Response('Expected Upgrade: websocket', { status: 426 });\n    }\n  }\n  rs\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(req: HttpRequest, _env: Env, _ctx: Context) -> Result<worker::Response> {\n      let upgrade_header = match req.headers().get(\"Upgrade\") {\n          Some(h) => h.to_str().unwrap(),\n          None => \"\",\n      };\n      if upgrade_header != \"websocket\" {\n          return worker::Response::error(\"Expected Upgrade: websocket\", 426);\n      }\n  }\n  js\n  async function handleRequest(request) {\n    const upgradeHeader = request.headers.get('Upgrade');\n    if (!upgradeHeader || upgradeHeader !== 'websocket') {\n      return new Response('Expected Upgrade: websocket', { status: 426 });\n    }\n\nconst webSocketPair = new WebSocketPair();\n    const client = webSocketPair[0],\n      server = webSocketPair[1];\n\nreturn new Response(null, {\n      status: 101,\n      webSocket: client,\n    });\n  }\n  rs\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(req: HttpRequest, _env: Env, _ctx: Context) -> Result<worker::Response> {\n      let upgrade_header = match req.headers().get(\"Upgrade\") {\n          Some(h) => h.to_str().unwrap(),\n          None => \"\",\n      };\n      if upgrade_header != \"websocket\" {\n          return worker::Response::error(\"Expected Upgrade: websocket\", 426);\n      }\n\nlet ws = WebSocketPair::new()?;\n      let client = ws.client;\n      let server = ws.server;\n      server.accept()?;\n\nworker::Response::from_websocket(client)\n\n}\n  js\n  async function handleRequest(request) {\n    const upgradeHeader = request.headers.get('Upgrade');\n    if (!upgradeHeader || upgradeHeader !== 'websocket') {\n      return new Response('Expected Upgrade: websocket', { status: 426 });\n    }\n\nconst webSocketPair = new WebSocketPair();\n    const [client, server] = Object.values(webSocketPair);\n\nreturn new Response(null, {\n      status: 101,\n      webSocket: client,\n    });\n  }\n  rs\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(req: HttpRequest, _env: Env, _ctx: Context) -> Result<worker::Response> {\n      let upgrade_header = match req.headers().get(\"Upgrade\") {\n          Some(h) => h.to_str().unwrap(),\n          None => \"\",\n      };\n      if upgrade_header != \"websocket\" {\n          return worker::Response::error(\"Expected Upgrade: websocket\", 426);\n      }\n\nlet ws = WebSocketPair::new()?;\n      let client = ws.client;\n      let server = ws.server;\n      server.accept()?;\n\nworker::Response::from_websocket(client)\n\n}\n  js\n  async function handleRequest(request) {\n    const upgradeHeader = request.headers.get('Upgrade');\n    if (!upgradeHeader || upgradeHeader !== 'websocket') {\n      return new Response('Expected Upgrade: websocket', { status: 426 });\n    }\n\nconst webSocketPair = new WebSocketPair();\n    const [client, server] = Object.values(webSocketPair);\n\nserver.accept();\n    server.addEventListener('message', event => {\n      console.log(event.data);\n    });\n\nreturn new Response(null, {\n      status: 101,\n      webSocket: client,\n    });\n  }\n  rs\n  use futures::StreamExt;\n  use worker::*;\n\n#[event(fetch)]\n  async fn fetch(req: HttpRequest, _env: Env, _ctx: Context) -> Result<worker::Response> {\n      let upgrade_header = match req.headers().get(\"Upgrade\") {\n          Some(h) => h.to_str().unwrap(),\n          None => \"\",\n      };\n      if upgrade_header != \"websocket\" {\n          return worker::Response::error(\"Expected Upgrade: websocket\", 426);\n      }\n\nlet ws = WebSocketPair::new()?;\n      let client = ws.client;\n      let server = ws.server;\n      server.accept()?;\n\nwasm_bindgen_futures::spawn_local(async move {\n          let mut event_stream = server.events().expect(\"could not open stream\");\n          while let Some(event) = event_stream.next().await {\n              match event.expect(\"received error in websocket\") {\n                  WebsocketEvent::Message(msg) => server.send(&msg.text()).unwrap(),\n                  WebsocketEvent::Close(event) => console_log!(\"{:?}\", event),\n              }\n          }\n      });\n      worker::Response::from_websocket(client)\n\n}\n  ts\n  import { Hono } from 'hono'\n  import { upgradeWebSocket } from 'hono/cloudflare-workers'\n\nconst app = new Hono()\n\napp.get(\n    '*',\n    upgradeWebSocket((c) => {\n      return {\n        onMessage(event, ws) {\n          console.log('Received message from client:', event.data)\n          ws.send(`Echo: ${event.data}`)\n        },\n        onClose: () => {\n          console.log('WebSocket closed:', event)\n        },\n        onError: () => {\n          console.error('WebSocket error:', event)\n        },\n      }\n    })\n  )\n\nexport default app;\n  js\nconst websocket = new WebSocket(\n  \"wss://websocket-example.signalnerve.workers.dev\",\n);\nwebsocket.addEventListener(\"message\", (event) => {\n  console.log(\"Message received from server\");\n  console.log(event.data);\n});\njs\nwebsocket.send(\"MESSAGE\");\njs\nwebsocket.close();\njs\nasync function websocket(url) {\n  // Make a fetch request including `Upgrade: websocket` header.\n  // The Workers Runtime will automatically handle other requirements\n  // of the WebSocket protocol, like the Sec-WebSocket-Key header.\n  let resp = await fetch(url, {\n    headers: {\n      Upgrade: \"websocket\",\n    },\n  });\n\n// If the WebSocket handshake completed successfully, then the\n  // response has a `webSocket` property.\n  let ws = resp.webSocket;\n  if (!ws) {\n    throw new Error(\"server didn't accept WebSocket\");\n  }\n\n// Call accept() to indicate that you'll be handling the socket here\n  // in JavaScript, as opposed to returning it on to a client.\n  ws.accept();\n\n// Now you can send and receive messages like before.\n  ws.send(\"hello\");\n  ws.addEventListener(\"message\", (msg) => {\n    console.log(msg.data);\n  });\n}\npython\nfrom workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n    async def fetch(self, request):\n        return Response(\"Hello World!\")\nplaintext\nuv init\nuv tool install workers-py\nuv run pywrangler init\nbash\nuv run pywrangler dev\nbash\nuv run pywrangler deploy\nbash\nuv run pywrangler init\nbash\ngit clone https://github.com/cloudflare/python-workers-examples\ncd python-workers-examples/01-hello\nsh\nrustup target add wasm32-unknown-unknown\nsh\ncargo install cargo-generate\nsh\ncargo generate cloudflare/workers-rs\nsh\nnpx wrangler dev\nrust\nuse worker::*;\n\n#[event(fetch)]\nasync fn main(req: Request, env: Env, ctx: Context) -> Result<Response> {\n    Response::ok(\"Hello, World!\")\n}\nsh\nnpx wrangler deploy\njs\nimport * as imports from \"./mywasmlib_bg.js\";\n\n// switch between both syntax for node and for workerd\nimport wkmod from \"./mywasmlib_bg.wasm\";\nimport * as nodemod from \"./mywasmlib_bg.wasm\";\nif (typeof process !== \"undefined\" && process.release.name === \"node\") {\n  imports.__wbg_set_wasm(nodemod);\n} else {\n  const instance = new WebAssembly.Instance(wkmod, {\n    \"./mywasmlib_bg.js\": imports,\n  });\n  imports.__wbg_set_wasm(instance.exports);\n}\n\nexport * from \"./mywasmlib_bg.js\";\njs\nimport { myFunction } from \"path/to/mylib.js\";\ntoml\n[profile.release]\nlto = true\nstrip = true\ncodegen-units = 1\nsh\n  npx wrangler types\n  sh\n  yarn wrangler types\n  sh\n  pnpm wrangler types\n  sh\n  npm uninstall @cloudflare/workers-types\n  sh\n  yarn remove @cloudflare/workers-types\n  sh\n  pnpm remove @cloudflare/workers-types\n  sh\n  npx wrangler types\n  sh\n  yarn wrangler types\n  sh\n  pnpm wrangler types\n  json\n{\n  \"compilerOptions\": {\n    \"types\": [\"./worker-configuration.d.ts\"]\n  }\n}\nsh\n  npm i @types/node\n  sh\n  yarn add @types/node\n  sh\n  pnpm add @types/node\n  json\n{\n  \"compilerOptions\": {\n    \"types\": [\"./worker-configuration.d.ts\", \"node\"]\n  }\n}\njson\n{\n  \"scripts\": {\n    \"dev\": \"existing-dev-command\",\n    \"build\": \"existing-build-command\",\n    \"generate-types\": \"wrangler types\",\n    \"type-check\": \"generate-types && tsc\"\n  }\n}\nyaml\n  - run: npm run generate-types\n  - run: npm run build\n  - run: npm test\n  yaml\n  - run: yarn generate-types\n  - run: yarn build\n  - run: yarn test\n  yaml\n  - run: pnpm run generate-types\n  - run: pnpm run build\n  - run: pnpm test\n  js\nexport default {\n  fetch(req) {\n    let response = new Response(\"Example response\");\n    let { promise, resolve } = Promise.withResolvers();\n\n// If the promise is not resolved, the Workers runtime will\n    // recognize this and throw an error.\n\n// setTimeout(resolve, 0)\n\nreturn promise.then(() => response);\n  },\n};\njs\nasync function handleRequest(request) {\n  let webSocketPair = new WebSocketPair();\n  let [client, server] = Object.values(webSocketPair);\n  server.accept();\n\nserver.addEventListener(\"close\", () => {\n    // This missing line would keep a WebSocket connection open indefinitely\n    // and results in \"The script will never generate a response\" errors\n    // server.close();\n  });\n\nreturn new Response(null, {\n    status: 101,\n    webSocket: client,\n  });\n}\njs\nexport default {\n  async fetch(request, env, ctx) {\n    // destructuring ctx makes waitUntil lose its 'this' reference\n    const { waitUntil } = ctx;\n    // waitUntil errors, as it has no 'this'\n    waitUntil(somePromise);\n\nreturn fetch(request);\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    // directly calling the method on ctx avoids the error\n    ctx.waitUntil(somePromise);\n\n// alternatively re-binding to ctx via apply, call, or bind avoids the error\n    const { waitUntil } = ctx;\n    waitUntil.apply(ctx, [somePromise]);\n    waitUntil.call(ctx, somePromise);\n    const reboundWaitUntil = waitUntil.bind(ctx);\n    reboundWaitUntil(somePromise);\n\nreturn fetch(request);\n  },\n};\nplaintext\nUncaught (in promise) Error: Cannot perform I/O on behalf of a different request. I/O objects (such as streams, request/response bodies, and others) created in the context of one request handler cannot be accessed from a different request's handler.\njs\nlet cachedResponse = null;\n\nexport default {\n  async fetch(request, env, ctx) {\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n    cachedResponse = new Response(\"Hello, world!\");\n    await new Promise((resolve) => setTimeout(resolve, 5000)); // Sleep for 5s to demonstrate this particular error case\n    return cachedResponse;\n  },\n};\njs\nlet cachedData = null;\n\nexport default {\n  async fetch(request, env, ctx) {\n    if (cachedData) {\n      return new Response(cachedData);\n    }\n    const response = new Response(\"Hello, world!\");\n    cachedData = await response.text();\n    return new Response(cachedData, response);\n  },\n};\njs\n  export default {\n    async fetch(request, env, ctx) {\n      function postLog(data) {\n        return fetch(\"https://log-service.example.com/\", {\n          method: \"POST\",\n          body: data,\n        });\n      }\n\n// Without ctx.waitUntil(), the `postLog` function may or may not complete.\n      ctx.waitUntil(postLog(stack));\n      return fetch(request);\n    },\n  };\n  js\n  addEventListener(\"fetch\", (event) => {\n    event.respondWith(handleEvent(event));\n  });\n\nasync function handleEvent(event) {\n    // ...\n\n// Without event.waitUntil(), the `postLog` function may or may not complete.\n    event.waitUntil(postLog(stack));\n    return fetch(event.request);\n  }\n\nfunction postLog(data) {\n    return fetch(\"https://log-service.example.com/\", {\n      method: \"POST\",\n      body: data,\n    });\n  }\n  js\n  export default {\n    async fetch(request, env, ctx) {\n      ctx.passThroughOnException();\n      // an error here will return the origin response, as if the Worker wasn't present\n      return fetch(request);\n    },\n  };\n  js\n  addEventListener(\"fetch\", (event) => {\n    event.passThroughOnException();\n    event.respondWith(handleRequest(event.request));\n  });\n\nasync function handleRequest(request) {\n    // An error here will return the origin response, as if the Worker wasnt present.\n    // ...\n    return fetch(request);\n  }\n  jsonc\n  {\n    \"observability\": {\n      \"traces\": {\n        \"enabled\": true,\n        \"destinations\": [\"tracing-destination-name\"],\n\n// traces sample rate of 5%\n        \"head_sampling_rate\": 0.05,\n\n// (optional disable traces in Cloudflare dashboard\n        \"persist\": false\n      },\n      \"logs\": {\n        \"enabled\": true,\n        \"destinations\": [\"logs-destination-name\"],\n        // logs sample rate of 60%\n        \"head_sampling_rate\": 0.6,\n\n// (optional disable logs in Cloudflare dashboard\n        \"persist\": false\n      }\n    }\n  }\n  toml\n  [observability.traces]\n  enabled = true\n  destinations = [ \"tracing-destination-name\" ]\n  head_sampling_rate = 0.05\n  persist = false\n\n[observability.logs]\n  enabled = true\n  destinations = [ \"logs-destination-name\" ]\n  head_sampling_rate = 0.6\n  persist = false\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"observability\": {\n      \"enabled\": true,\n      \"logs\": {\n        \"invocation_logs\": true,\n        \"head_sampling_rate\": 1\n      }\n    }\n  }\n  toml\n  [observability]\n  enabled = true\n\n[observability.logs]\n  invocation_logs = true\n  head_sampling_rate = 1 # optional. default = 1.\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"upload_source_maps\": true\n  }\n  toml\n  upload_source_maps = true\n  jsonc\n  {\n    \"observability\": {\n      \"traces\": {\n        \"enabled\": true,\n        // optional sampling rate (recommended for high-traffic workloads)\n        \"head_sampling_rate\": 0.05\n      }\n    }\n  }\n  toml\n  [observability.traces]\n  enabled = true\n  head_sampling_rate = 0.05\n  jsonc\n  {\n    \"observability\": {\n      \"traces\": {\n        \"enabled\": true,\n        // set tracing sampling rate to 5%\n        \"head_sampling_rate\": 0.05\n      },\n      \"logs\": {\n        \"enabled\": true,\n        // set logging sampling rate to 60%\n        \"head_sampling_rate\": 0.6\n      }\n    }\n  }\n  toml\n  [observability.traces]\n  enabled = true\n  head_sampling_rate = 0.05\n\n[observability.logs]\n  enabled = true\n  head_sampling_rate = 0.6\n  md\n  [![Built with Cloudflare](https://workers.cloudflare.com/built-with-cloudflare.svg)](https://cloudflare.com)\n  html\n  <a href=\"https://cloudflare.com\"><img src=\"https://workers.cloudflare.com/built-with-cloudflare.svg\" alt=\"Built with Cloudflare\"/></a>\n  plaintext\n  https://workers.cloudflare.com/built-with-cloudflare.svg\n  md\n  [![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=<your git repo URL>)\n  html\n  <a href=\"https://deploy.workers.cloudflare.com/?url=<YOUR_REPO_URL>\"><img src=\"https://deploy.workers.cloudflare.com/button\" alt=\"Deploy to Cloudflare\"/></a>\n  plaintext\n  https://deploy.workers.cloudflare.com/?url=<YOUR_REPO_URL>\n  jsonc\n  {\n    \"name\": \"my-worker\",\n    \"main\": \"./src/index.ts\",\n    \"compatibility_date\": \"2025-12-31\",\n    \"vars\": {\n      \"API_HOST\": \"https://example.com\",\n    },\n  }\n  toml\n  name = \"my-worker\"\n  main = \"./src/index.ts\"\n  compatibility_date = \"2025-12-31\"\n\n[vars]\n  API_HOST = \"https://example.com\"\n  ini\nCOOKIE_SIGNING_KEY=my-secret # comment\njsonc\n  {\n    \"name\": \"my-worker\",\n    \"main\": \"./src/index.ts\",\n    \"compatibility_date\": \"2025-12-31\",\n    \"secrets_store_secrets\": [\n      {\n        \"binding\": \"API_KEY\",\n        \"store_id\": \"demo\",\n        \"secret_name\": \"api-key\"\n      }\n    ]\n  }\n  toml\n  name = \"my-worker\"\n  main = \"./src/index.ts\"\n  compatibility_date = \"2025-12-31\"\n\n[[secrets_store_secrets]]\n  binding = \"API_KEY\"\n  store_id = \"demo\"\n  secret_name = \"api-key\"\n  json\n{\n  \"scripts\": {\n    \"build\": \"astro build\",\n    \"deploy\": \"npm run db:migrations:apply && wrangler deploy\",\n    \"db:migrations:apply\": \"wrangler d1 migrations apply DB_BINDING --remote\"\n  }\n}\njson\n{\n  \"name\": \"my-worker\",\n  \"private\": true,\n  \"cloudflare\": {\n    \"bindings\": {\n      \"API_KEY\": {\n        \"description\": \"Select your company's [API key](https://example.com/) for connecting to the example service.\"\n      },\n      \"COOKIE_SIGNING_KEY\": {\n        \"description\": \"Generate a random string using `openssl rand -hex 32`.\"\n      }\n    }\n  }\n}\nbash\nwrangler deploy --dry-run --outdir build\ntf\nvariable \"account_id\" {\n  default = \"replace_me\"\n}\n\nresource \"cloudflare_worker\" \"my_worker\" {\n  account_id = var.account_id\n  name = \"my-worker\"\n  observability = {\n    enabled = true\n  }\n}\n\nresource \"cloudflare_worker_version\" \"my_worker_version\" {\n  account_id = var.account_id\n  worker_id = cloudflare_worker.my_worker.id\n  compatibility_date = \"$today\"\n  main_module = \"my-script.mjs\"\n  modules = [\n    {\n      name = \"my-script.mjs\"\n      content_type = \"application/javascript+module\"\n      # Replacement (version creation) is triggered whenever this file changes\n      content_file = \"my-script.mjs\"\n    }\n  ]\n}\n\nresource \"cloudflare_workers_deployment\" \"my_worker_deployment\" {\n  account_id = var.account_id\n  script_name = cloudflare_worker.my_worker.name\n  strategy = \"percentage\"\n  versions = [{\n    percentage = 100\n    version_id = cloudflare_worker_version.my_worker_version.id\n  }]\n}\ntf\nbindings = [{\n  type = \"kv_namespace\"\n  name = \"MY_KV\"\n  namespace_id = \"your-kv-namespace-id\"\n}]\ntf\nbindings = [{\n  type = \"r2_bucket\"\n  name = \"MY_BUCKET\"\n  bucket_name = \"my-bucket-name\"\n}]\ntf\nbindings = [{\n  type = \"d1\"\n  name = \"DB\"\n  id = \"your-database-id\"\n}]\ntf\nbindings = [{\n  type = \"durable_object_namespace\"\n  name = \"MY_DURABLE_OBJECT\"\n  class_name = \"MyDurableObjectClass\"\n}]\ntf\nbindings = [{\n  type = \"service\"\n  name = \"MY_SERVICE\"\n  service = \"other-worker-name\"\n}]\ntf\nbindings = [{\n  type = \"queue\"\n  name = \"MY_QUEUE\"\n  queue_name = \"my-queue\"\n}]\ntf\nbindings = [{\n  type = \"vectorize\"\n  name = \"VECTORIZE_INDEX\"\n  index_name = \"my-index\"\n}]\ntf\nbindings = [{\n  type = \"ai\"\n  name = \"AI\"\n}]\ntf\nbindings = [{\n  type = \"hyperdrive\"\n  name = \"HYPERDRIVE\"\n  id = \"your-hyperdrive-config-id\"\n}]\ntf\nbindings = [{\n  type = \"analytics_engine\"\n  name = \"ANALYTICS\"\n  dataset = \"my_dataset\"\n}]\ntf\nbindings = [{\n  type = \"plain_text\"\n  name = \"MY_VARIABLE\"\n  text = \"my-value\"\n}]\ntf\nbindings = [{\n  type = \"secret_text\"\n  name = \"API_KEY\"\n  text = var.api_key\n}]\ntf\nresource \"cloudflare_worker_version\" \"my_worker_version\" {\n  account_id = var.account_id\n  worker_id = cloudflare_worker.my_worker.id\n  compatibility_date = \"2025-08-06\"\n  main_module = \"worker.js\"\n\nmodules = [{\n    name = \"worker.js\"\n    content_type = \"application/javascript+module\"\n    content_file = \"worker.js\"\n  }]\n\nbindings = [\n    {\n      type = \"kv_namespace\"\n      name = \"MY_KV\"\n      namespace_id = var.kv_namespace_id\n    },\n    {\n      type = \"r2_bucket\"\n      name = \"MY_BUCKET\"\n      bucket_name = \"my-bucket\"\n    },\n    {\n      type = \"d1\"\n      name = \"DB\"\n      id = var.d1_database_id\n    },\n    {\n      type = \"service\"\n      name = \"AUTH_SERVICE\"\n      service = \"auth-worker\"\n    },\n    {\n      type = \"plain_text\"\n      name = \"ENVIRONMENT\"\n      text = \"production\"\n    },\n    {\n      type = \"secret_text\"\n      name = \"API_KEY\"\n      text = var.api_key\n    }\n  ]\n}\njs\n  #!/usr/bin/env -S npm run tsn -T\n\n/**\n   * Create and deploy a Worker\n   *\n   * Docs:\n   * - https://developers.cloudflare.com/workers/configuration/versions-and-deployments/\n   * - https://developers.cloudflare.com/workers/platform/infrastructure-as-code/\n   *\n   * Prerequisites:\n   * 1. Generate an API token: https://developers.cloudflare.com/fundamentals/api/get-started/create-token/\n   * 2. Find your account ID: https://developers.cloudflare.com/fundamentals/setup/find-account-and-zone-ids/\n   * 3. Find your workers.dev subdomain: https://developers.cloudflare.com/workers/configuration/routing/workers-dev/\n   *\n   * Environment variables:\n   *   - CLOUDFLARE_API_TOKEN (required)\n   *   - CLOUDFLARE_ACCOUNT_ID (required)\n   *   - CLOUDFLARE_SUBDOMAIN (optional)\n   *\n   * Usage:\n   *   Run this script to deploy a simple \"Hello World\" Worker.\n   *   Access it at: my-hello-world-worker.$subdomain.workers.dev\n   */\n\nimport { exit } from \"node:process\";\n\nimport Cloudflare from \"cloudflare\";\n\nconst WORKER_NAME = \"my-hello-world-worker\";\n  const SCRIPT_FILENAME = `${WORKER_NAME}.mjs`;\n\nfunction loadConfig() {\n    const apiToken = process.env[\"CLOUDFLARE_API_TOKEN\"];\n    if (!apiToken) {\n      throw new Error(\n        \"Missing required environment variable: CLOUDFLARE_API_TOKEN\",\n      );\n    }\n\nconst accountId = process.env[\"CLOUDFLARE_ACCOUNT_ID\"];\n    if (!accountId) {\n      throw new Error(\n        \"Missing required environment variable: CLOUDFLARE_ACCOUNT_ID\",\n      );\n    }\n\nconst subdomain = process.env[\"CLOUDFLARE_SUBDOMAIN\"];\n\nreturn {\n      apiToken,\n      accountId,\n      subdomain: subdomain || undefined,\n      workerName: WORKER_NAME,\n    };\n  }\n\nconst config = loadConfig();\n  const client = new Cloudflare({\n    apiToken: config.apiToken,\n  });\n\nasync function main() {\n    try {\n      console.log(\" Starting Worker creation and deployment...\");\n\nconst scriptContent = `\n        export default {\n          async fetch(request, env, ctx) {\n            return new Response(env.MESSAGE, { status: 200 });\n          },\n        }`.trim();\n\nlet worker;\n      try {\n        worker = await client.workers.beta.workers.get(config.workerName, {\n          account_id: config.accountId,\n        });\n        console.log(`  Worker ${config.workerName} already exists. Using it.`);\n      } catch (error) {\n        if (!(error instanceof Cloudflare.NotFoundError)) {\n          throw error;\n        }\n        console.log(`  Creating Worker ${config.workerName}...`);\n        worker = await client.workers.beta.workers.create({\n          account_id: config.accountId,\n          name: config.workerName,\n          subdomain: {\n            enabled: config.subdomain !== undefined,\n          },\n          observability: {\n            enabled: true,\n          },\n        });\n      }\n\nconsole.log(`  Worker id: ${worker.id}`);\n      console.log(\"  Creating Worker version...\");\n\n// Create the first version of the Worker\n      const version = await client.workers.beta.workers.versions.create(\n        worker.id,\n        {\n          account_id: config.accountId,\n          main_module: SCRIPT_FILENAME,\n          compatibility_date: new Date().toISOString().split(\"T\")[0],\n          bindings: [\n            {\n              type: \"plain_text\",\n              name: \"MESSAGE\",\n              text: \"Hello World!\",\n            },\n          ],\n          modules: [\n            {\n              name: SCRIPT_FILENAME,\n              content_type: \"application/javascript+module\",\n              content_base64: Buffer.from(scriptContent).toString(\"base64\"),\n            },\n          ],\n        },\n      );\n\nconsole.log(`  Version id: ${version.id}`);\n      console.log(\" Creating Worker deployment...\");\n\n// Create a deployment and point all traffic to the version we created\n      await client.workers.scripts.deployments.create(config.workerName, {\n        account_id: config.accountId,\n        strategy: \"percentage\",\n        versions: [\n          {\n            percentage: 100,\n            version_id: version.id,\n          },\n        ],\n      });\n\nconsole.log(\" Deployment successful!\");\n\nif (config.subdomain) {\n        console.log(`\n   Your Worker is live!\n   URL: https://${config.workerName}.${config.subdomain}.workers.dev/\n  `);\n      } else {\n        console.log(`\n    Set up a route, custom domain, or workers.dev subdomain to access your Worker.\n  Add CLOUDFLARE_SUBDOMAIN to your environment variables to set one up automatically.\n  `);\n      }\n    } catch (error) {\n      console.error(\" Deployment failed:\", error);\n      exit(1);\n    }\n  }\n\nmain();\n  ts\n  #!/usr/bin/env -S npm run tsn -T\n\n/**\n   * Create and deploy a Worker\n   *\n   * Docs:\n   * - https://developers.cloudflare.com/workers/configuration/versions-and-deployments/\n   * - https://developers.cloudflare.com/workers/platform/infrastructure-as-code/\n   *\n   * Prerequisites:\n   * 1. Generate an API token: https://developers.cloudflare.com/fundamentals/api/get-started/create-token/\n   * 2. Find your account ID: https://developers.cloudflare.com/fundamentals/setup/find-account-and-zone-ids/\n   * 3. Find your workers.dev subdomain: https://developers.cloudflare.com/workers/configuration/routing/workers-dev/\n   *\n   * Environment variables:\n   *   - CLOUDFLARE_API_TOKEN (required)\n   *   - CLOUDFLARE_ACCOUNT_ID (required)\n   *   - CLOUDFLARE_SUBDOMAIN (optional)\n   *\n   * Usage:\n   *   Run this script to deploy a simple \"Hello World\" Worker.\n   *   Access it at: my-hello-world-worker.$subdomain.workers.dev\n   */\n\nimport { exit } from 'node:process';\n\nimport Cloudflare from 'cloudflare';\n\ninterface Config {\n    apiToken: string;\n    accountId: string;\n    subdomain: string | undefined;\n    workerName: string;\n  }\n\nconst WORKER_NAME = 'my-hello-world-worker';\n  const SCRIPT_FILENAME = `${WORKER_NAME}.mjs`;\n\nfunction loadConfig(): Config {\n    const apiToken = process.env['CLOUDFLARE_API_TOKEN'];\n    if (!apiToken) {\n      throw new Error('Missing required environment variable: CLOUDFLARE_API_TOKEN');\n    }\n\nconst accountId = process.env['CLOUDFLARE_ACCOUNT_ID'];\n    if (!accountId) {\n      throw new Error('Missing required environment variable: CLOUDFLARE_ACCOUNT_ID');\n    }\n\nconst subdomain = process.env['CLOUDFLARE_SUBDOMAIN'];\n\nreturn {\n      apiToken,\n      accountId,\n      subdomain: subdomain || undefined,\n      workerName: WORKER_NAME,\n    };\n  }\n\nconst config = loadConfig();\n  const client = new Cloudflare({\n    apiToken: config.apiToken,\n  });\n\nasync function main(): Promise<void> {\n    try {\n      console.log(' Starting Worker creation and deployment...');\n\nconst scriptContent = `\n        export default {\n          async fetch(request, env, ctx) {\n            return new Response(env.MESSAGE, { status: 200 });\n          },\n        }`.trim();\n\nlet worker;\n      try {\n        worker = await client.workers.beta.workers.get(config.workerName, {\n          account_id: config.accountId,\n        });\n        console.log(`  Worker ${config.workerName} already exists. Using it.`);\n      } catch (error) {\n        if (!(error instanceof Cloudflare.NotFoundError)) { throw error; }\n        console.log(`  Creating Worker ${config.workerName}...`);\n        worker = await client.workers.beta.workers.create({\n          account_id: config.accountId,\n          name: config.workerName,\n          subdomain: {\n            enabled: config.subdomain !== undefined,\n          },\n          observability: {\n            enabled: true,\n          },\n        });\n      }\n\nconsole.log(`  Worker id: ${worker.id}`);\n      console.log('  Creating Worker version...');\n\n// Create the first version of the Worker\n      const version = await client.workers.beta.workers.versions.create(worker.id, {\n        account_id: config.accountId,\n        main_module: SCRIPT_FILENAME,\n        compatibility_date: new Date().toISOString().split('T')[0]!,\n        bindings: [\n          {\n            type: 'plain_text',\n            name: 'MESSAGE',\n            text: 'Hello World!',\n          },\n        ],\n        modules: [\n          {\n            name: SCRIPT_FILENAME,\n            content_type: 'application/javascript+module',\n            content_base64: Buffer.from(scriptContent).toString('base64'),\n          },\n        ],\n      });\n\nconsole.log(`  Version id: ${version.id}`);\n      console.log(' Creating Worker deployment...');\n\n// Create a deployment and point all traffic to the version we created\n      await client.workers.scripts.deployments.create(config.workerName, {\n        account_id: config.accountId,\n        strategy: 'percentage',\n        versions: [\n          {\n              percentage: 100,\n              version_id: version.id,\n            },\n          ],\n      });\n\nconsole.log(' Deployment successful!');\n\nif (config.subdomain) {\n        console.log(`\n   Your Worker is live!\n   URL: https://${config.workerName}.${config.subdomain}.workers.dev/\n  `);\n      } else {\n        console.log(`\n    Set up a route, custom domain, or workers.dev subdomain to access your Worker.\n  Add CLOUDFLARE_SUBDOMAIN to your environment variables to set one up automatically.\n  `);\n      }\n    } catch (error) {\n      console.error(' Deployment failed:', error);\n      exit(1);\n    }\n  }\n\nmain();\n  bash\n  account_id=\"replace_me\"\n  api_token=\"replace_me\"\n  worker_name=\"my-hello-world-worker\"\n\nworker_script_base64=$(echo '\n  export default {\n    async fetch(request, env, ctx) {\n      return new Response(env.MESSAGE, { status: 200 });\n    }\n  };\n  ' | base64)\n\n# Note the below will fail if the worker already exists!\n  # Here's how to delete the Worker\n  #\n  # worker_id=\"replace-me\"\n  # curl \"https://api.cloudflare.com/client/v4/accounts/$account_id/workers/workers/$worker_id\" \\\n  #   -X DELETE \\\n  #   -H \"Authorization: Bearer $api_token\"\n\n# Create the Worker\n  worker_id=$(curl \"https://api.cloudflare.com/client/v4/accounts/$account_id/workers/workers\" \\\n    -X POST \\\n    -H \"Authorization: Bearer $api_token\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"name\": \"'$worker_name'\"\n    }' \\\n    | jq -r '.result.id')\n\necho \"\\nWorker ID: $worker_id\\n\"\n\n# Upload the Worker's first version\n  version_id=$(curl \"https://api.cloudflare.com/client/v4/accounts/$account_id/workers/workers/$worker_id/versions\" \\\n    -X POST \\\n    -H \"Authorization: Bearer $api_token\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"compatibility_date\": \"2025-08-06\",\n      \"main_module\": \"'$worker_name'.mjs\",\n      \"modules\": [\n        {\n          \"name\": \"'$worker_name'.mjs\",\n          \"content_type\": \"application/javascript+module\",\n          \"content_base64\": \"'$worker_script_base64'\"\n        }\n      ],\n      \"bindings\": [\n        {\n          \"type\": \"plain_text\",\n          \"name\": \"MESSAGE\",\n          \"text\": \"Hello World!\"\n        }\n      ]\n    }' \\\n    | jq -r '.result.id')\n\necho \"\\nVersion ID: $version_id\\n\"\n\n# Create a deployment for the Worker\n  deployment_id=$(curl \"https://api.cloudflare.com/client/v4/accounts/$account_id/workers/scripts/$worker_name/deployments\" \\\n    -X POST \\\n    -H \"Authorization: Bearer $api_token\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"strategy\": \"percentage\",\n      \"versions\": [\n        {\n          \"percentage\": 100,\n          \"version_id\": \"'$version_id'\"\n        }\n      ]\n    }' \\\n    | jq -r '.result.id')\n\necho \"\\nDeployment ID: $deployment_id\\n\"\n  bash\n  account_id=\"replace_me\"\n  api_token=\"replace_me\"\n  worker_name=\"my-hello-world-worker\"\n\nworker_script_base64=$(echo '\n  from workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n      async def fetch(self, request):\n          return Response(self.env.MESSAGE)\n  ' | base64)\n\n# Note the below will fail if the worker already exists!\n  # Here's how to delete the Worker\n  #\n  # worker_id=\"replace-me\"\n  # curl \"https://api.cloudflare.com/client/v4/accounts/$account_id/workers/workers/$worker_id\" \\\n  #   -X DELETE \\\n  #   -H \"Authorization: Bearer $api_token\"\n\n# Create the Worker\n  worker_id=$(curl \"https://api.cloudflare.com/client/v4/accounts/$account_id/workers/workers\" \\\n    -X POST \\\n    -H \"Authorization: Bearer $api_token\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"name\": \"'$worker_name'\"\n    }' \\\n    | jq -r '.result.id')\n\necho \"\\nWorker ID: $worker_id\\n\"\n\n# Upload the Worker's first version\n  version_id=$(curl \"https://api.cloudflare.com/client/v4/accounts/$account_id/workers/workers/$worker_id/versions\" \\\n    -X POST \\\n    -H \"Authorization: Bearer $api_token\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"compatibility_date\": \"2025-08-06\",\n      \"compatibility_flags\": [\n        \"python_workers\"\n      ],\n      \"main_module\": \"'$worker_name'.py\",\n      \"modules\": [\n        {\n          \"name\": \"'$worker_name'.py\",\n          \"content_type\": \"text/x-python\",\n          \"content_base64\": \"'$worker_script_base64'\"\n        }\n      ],\n      \"bindings\": [\n        {\n          \"type\": \"plain_text\",\n          \"name\": \"MESSAGE\",\n          \"text\": \"Hello World!\"\n        }\n      ]\n    }' \\\n    | jq -r '.result.id')\n\necho \"\\nVersion ID: $version_id\\n\"\n\n# Create a deployment for the Worker\n  deployment_id=$(curl \"https://api.cloudflare.com/client/v4/accounts/$account_id/workers/scripts/$worker_name/deployments\" \\\n    -X POST \\\n    -H \"Authorization: Bearer $api_token\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"strategy\": \"percentage\",\n      \"versions\": [\n        {\n          \"percentage\": 100,\n          \"version_id\": \"'$version_id'\"\n        }\n      ]\n    }' \\\n    | jq -r '.result.id')\n\necho \"\\nDeployment ID: $deployment_id\\n\"\n  bash\n  account_id=\"replace_me\"\n  api_token=\"replace_me\"\n  worker_name=\"my-hello-world-script\"\n\nscript_content='export default {\n    async fetch(request, env, ctx) {\n      return new Response(env.MESSAGE, { status: 200 });\n    }\n  };'\n\n# Upload the Worker\n  curl \"https://api.cloudflare.com/client/v4/accounts/$account_id/workers/scripts/$worker_name\" \\\n    -X PUT \\\n    -H \"Authorization: Bearer $api_token\" \\\n    -F \"metadata={\n      'main_module': '\"$worker_name\".mjs',\n      'bindings': [\n        {\n          'type': 'plain_text',\n          'name': 'MESSAGE',\n          'text': 'Hello World!'\n        }\n      ],\n      'compatibility_date': '$today'\n    };type=application/json\" \\\n    -F \"$worker_name.mjs=@-;filename=$worker_name.mjs;type=application/javascript+module\" <<EOF\n  $script_content\n  EOF\n  bash\n  account_id=\"replace_me\"\n  api_token=\"replace_me\"\n  dispatch_namespace=\"replace_me\"\n  worker_name=\"my-hello-world-script\"\n\nscript_content='export default {\n    async fetch(request, env, ctx) {\n      return new Response(env.MESSAGE, { status: 200 });\n    }\n  };'\n\n# Create a dispatch namespace\n  curl https://api.cloudflare.com/client/v4/accounts/$account_id/workers/dispatch/namespaces \\\n    -X POST \\\n    -H 'Content-Type: application/json' \\\n    -H \"Authorization: Bearer $api_token\" \\\n    -d '{\n      \"name\": \"'$dispatch_namespace'\"\n    }'\n\n# Upload the Worker\n  curl \"https://api.cloudflare.com/client/v4/accounts/$account_id/workers/dispatch/namespaces/$dispatch_namespace/scripts/$worker_name\" \\\n    -X PUT \\\n    -H \"Authorization: Bearer $api_token\" \\\n    -F \"metadata={\n      'main_module': '\"$worker_name\".mjs',\n      'bindings': [\n        {\n          'type': 'plain_text',\n          'name': 'MESSAGE',\n          'text': 'Hello World!'\n        }\n      ],\n      'compatibility_date': '$today'\n    };type=application/json\" \\\n    -F \"$worker_name.mjs=@-;filename=$worker_name.mjs;type=application/javascript+module\" <<EOF\n  $script_content\n  EOF\n  bash\ncurl https://api.cloudflare.com/client/v4/accounts/<account_id>/workers/scripts/my-hello-world-script \\\n  -X PUT \\\n  -H 'Authorization: Bearer <api_token>' \\\n  -F 'metadata={\n        \"main_module\": \"my-hello-world-script.py\",\n        \"bindings\": [\n          {\n            \"type\": \"plain_text\",\n            \"name\": \"MESSAGE\",\n            \"text\": \"Hello World!\"\n          }\n        ],\n        \"compatibility_date\": \"$today\",\n        \"compatibility_flags\": [\n          \"python_workers\"\n        ]\n      };type=application/json' \\\n  -F 'my-hello-world-script.py=@-;filename=my-hello-world-script.py;type=text/x-python' <<EOF\nfrom workers import WorkerEntrypoint, Response\n\nclass Default(WorkerEntrypoint):\n    async def fetch(self, request):\n        return Response(self.env.MESSAGE)\nEOF\ntf\nresource \"cloudflare_worker\" \"my_worker\" {\n  account_id = var.account_id\n  name = \"my-worker\"\n}\n\nresource \"cloudflare_worker_version\" \"my_worker_version\" {\n  account_id = var.account_id\n  worker_id = cloudflare_worker.my_worker.id\n  bindings = [\n    {\n      type = \"durable_object_namespace\"\n      name = \"my_durable_object\"\n      class_name = \"MyDurableObjectClass\"\n    }\n  ]\n  migrations = {\n    new_sqlite_classes = [\n      \"MyDurableObjectClass\"\n    ]\n  }\n  # ...version props ommitted for brevity\n}\n\nresource \"cloudflare_workers_deployment\" \"my_worker_deployment\" {\n  # ...deployment props ommitted for brevity\n}\nbash\nterraform import cloudflare_worker_version.my_worker_version <account_id>/<worker_id>/<version_id>\ntf\nresource \"cloudflare_worker_version\" \"content_file_example\" {\n  account_id  = var.account_id\n  worker_id   = cloudflare_worker.example.id\n  main_module = \"worker.js\"\n  modules = [{\n    name         = \"worker.js\"\n    content_type = \"application/javascript+module\"\n    content_file = \"build/worker.js\"\n  }]\n}\ntf\nresource \"cloudflare_worker_version\" \"content_base64_example\" {\n  account_id  = var.account_id\n  worker_id   = cloudflare_worker.example.id\n  main_module = \"worker.js\"\n  modules = [{\n    name           = \"worker.js\"\n    content_type   = \"application/javascript+module\"\n    content_base64 = base64encode(\"export default { async fetch() { return new Response('Hello world!') } }\")\n  }]\n}\nplaintext\n// (A) example.com/images/*\n// (B) example.com/images*\n\n\"example.com/images\"\n// -> B\n\"example.com/images123\"\n// -> B\n\"example.com/images/hello\"\n// -> B\nplaintext\n// (A) *.example.com/a\n// (B) a.example.com/*\n\n\"a.example.com/a\"\n// -> B\njs\nconst request = new Request(url, incomingRequest);\nrequest.headers.delete('cf-workers-preview-token');\nreturn await fetch(request);\nplaintext\n// Zone in partial setup: example.com\n// DNS records at Authoritative DNS: sub1.example.com, sub2.example.com, ...\n// DNS records at Cloudflare DNS: sub1.example.com\n\n\"sub1.example.com/\"\n// -> Can be resolved by Fetch API\n\"sub2.example.com/\"\n// -> Cannot be resolved by Fetch API, will lead to 530 status code\nplaintext\n// Zone in partial setup: example.com\n// DNS records at Authoritative DNS: sub1.example.com, sub2.example.com, ...\n// DNS records at Cloudflare DNS: sub1.example.com, sub2.example.com\n\n\"sub1.example.com/\"\n// -> Can be resolved by Fetch API\n\"sub2.example.com/\"\n// -> Can be resolved by Fetch API\njs\nawait fetch('http://server.example.com')\njs\nawait fetch('http://192.0.2.1')\njsonc\n  {\n    // ...rest of your configuration...\n    \"limits\": {\n      \"cpu_ms\": 300000, // default is 30000 (30 seconds)\n    },\n    // ...rest of your configuration...\n  }\n  toml\n  [limits]\n  cpu_ms = 300_000\n  ts\nconst response = await fetch(url);\n\n// Only read the response body for successful responses\nif (response.statusCode <= 299) {\n  // Call response.json(), response.text() or otherwise process the body\n} else {\n  // Explicitly cancel it\n  response.body.cancel();\n}\nts\n// Within a for-of loop\nconst response = await fetch(\"https://example.org\");\nfor await (const chunk of response.body) {\n  // While this code block is executing, there are no pending\n  // reads on the response.body. Accordingly, the system may view\n  // the stream as not being active within this block.\n}\n\n// Using body.getReader()\nconst response = await fetch(\"https://example.org\");\nconst reader = response.body.getReader();\nlet chunk = await reader.read();\nawait processChunk(chunk);\nchunk = await reader.read();\nawait processChunk(chunk);\n\nasync function processChunk(chunk) {\n  // The stream is considered inactive as there is no pending reads\n  // on response.body. It may then get cancelled.\n}\nsh\nwrangler deploy --outdir bundled/ --dry-run\nsh",
  "code_samples": [
    {
      "code": "To do more:\n\n* Review our [Examples](https://developers.cloudflare.com/workers/examples/) and [Tutorials](https://developers.cloudflare.com/workers/tutorials/) for inspiration.\n* Set up [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/) to allow your Worker to interact with other resources and unlock new functionality.\n* Learn how to [test and debug](https://developers.cloudflare.com/workers/testing/) your Workers.\n* Read about [Workers limits and pricing](https://developers.cloudflare.com/workers/platform/).\n\n</page>\n\n<page>\n---\ntitle: Get started - CLI  Cloudflare Workers docs\ndescription: Set up and deploy your first Worker with Wrangler, the Cloudflare\n  Developer Platform CLI.\nlastUpdated: 2025-05-26T07:51:19.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/get-started/guide/\n  md: https://developers.cloudflare.com/workers/get-started/guide/index.md\n---\n\nSet up and deploy your first Worker with Wrangler, the Cloudflare Developer Platform CLI.\n\nThis guide will instruct you through setting up and deploying your first Worker.\n\n## Prerequisites\n\n1. Sign up for a [Cloudflare account](https://dash.cloudflare.com/sign-up/workers-and-pages).\n2. Install [`Node.js`](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).\n\nNode.js version manager\n\nUse a Node version manager like [Volta](https://volta.sh/) or [nvm](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node.js versions. [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), discussed later in this guide, requires a Node version of `16.17.0` or later.\n\n## 1. Create a new Worker project\n\nOpen a terminal window and run C3 to create your Worker project. [C3 (`create-cloudflare-cli`)](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare) is a command-line tool designed to help you set up and deploy new applications to Cloudflare.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nNow, you have a new project set up. Move into that project folder.",
      "language": "unknown"
    },
    {
      "code": "What files did C3 create?\n\nIn your project directory, C3 will have generated the following:\n\n* `wrangler.jsonc`: Your [Wrangler](https://developers.cloudflare.com/workers/wrangler/configuration/#sample-wrangler-configuration) configuration file.\n* `index.js` (in `/src`): A minimal `'Hello World!'` Worker written in [ES module](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) syntax.\n* `package.json`: A minimal Node dependencies configuration file.\n* `package-lock.json`: Refer to [`npm` documentation on `package-lock.json`](https://docs.npmjs.com/cli/v9/configuring-npm/package-lock-json).\n* `node_modules`: Refer to [`npm` documentation `node_modules`](https://docs.npmjs.com/cli/v7/configuring-npm/folders#node-modules).\n\nWhat if I already have a project in a git repository?\n\nIn addition to creating new projects from C3 templates, C3 also supports creating new projects from existing Git repositories. To create a new project from an existing Git repository, open your terminal and run:",
      "language": "unknown"
    },
    {
      "code": "`<SOURCE>` may be any of the following:\n\n* `user/repo` (GitHub)\n* `git@github.com:user/repo`\n* `https://github.com/user/repo`\n* `user/repo/some-template` (subdirectories)\n* `user/repo#canary` (branches)\n* `user/repo#1234abcd` (commit hash)\n* `bitbucket:user/repo` (Bitbucket)\n* `gitlab:user/repo` (GitLab)\n\nYour existing template folder must contain the following files, at a minimum, to meet the requirements for Cloudflare Workers:\n\n* `package.json`\n* `wrangler.jsonc` [See sample Wrangler configuration](https://developers.cloudflare.com/workers/wrangler/configuration/#sample-wrangler-configuration)\n* `src/` containing a worker script referenced from `wrangler.jsonc`\n\n## 2. Develop with Wrangler CLI\n\nC3 installs [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), the Workers command-line interface, in Workers projects by default. Wrangler lets you to [create](https://developers.cloudflare.com/workers/wrangler/commands/#init), [test](https://developers.cloudflare.com/workers/wrangler/commands/#dev), and [deploy](https://developers.cloudflare.com/workers/wrangler/commands/#deploy) your Workers projects.\n\nAfter you have created your first Worker, run the [`wrangler dev`](https://developers.cloudflare.com/workers/wrangler/commands/#dev) command in the project directory to start a local server for developing your Worker. This will allow you to preview your Worker locally during development.",
      "language": "unknown"
    },
    {
      "code": "If you have never used Wrangler before, it will open your web browser so you can login to your Cloudflare account.\n\nGo to <http://localhost:8787> to view your Worker.\n\nBrowser issues?\n\nIf you have issues with this step or you do not have access to a browser interface, refer to the [`wrangler login`](https://developers.cloudflare.com/workers/wrangler/commands/#login) documentation.\n\n## 3. Write code\n\nWith your new project generated and running, you can begin to write and edit your code.\n\nFind the `src/index.js` file. `index.js` will be populated with the code below:",
      "language": "unknown"
    },
    {
      "code": "Code explanation\n\nThis code block consists of a few different parts.",
      "language": "unknown"
    },
    {
      "code": "`export default` is JavaScript syntax required for defining [JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules#default_exports_versus_named_exports). Your Worker has to have a default export of an object, with properties corresponding to the events your Worker should handle.",
      "language": "unknown"
    },
    {
      "code": "This [`fetch()` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) will be called when your Worker receives an HTTP request. You can define additional event handlers in the exported object to respond to different types of events. For example, add a [`scheduled()` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/scheduled/) to respond to Worker invocations via a [Cron Trigger](https://developers.cloudflare.com/workers/configuration/cron-triggers/).\n\nAdditionally, the `fetch` handler will always be passed three parameters: [`request`, `env` and `context`](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/).",
      "language": "unknown"
    },
    {
      "code": "The Workers runtime expects `fetch` handlers to return a `Response` object or a Promise which resolves with a `Response` object. In this example, you will return a new `Response` with the string `\"Hello World!\"`.\n\nReplace the content in your current `index.js` file with the content below, which changes the text output.",
      "language": "unknown"
    },
    {
      "code": "Then, save the file and reload the page. Your Worker's output will have changed to the new text.\n\nNo visible changes?\n\nIf the output for your Worker does not change, make sure that:\n\n1. You saved the changes to `index.js`.\n2. You have `wrangler dev` running.\n3. You reloaded your browser.\n\n## 4. Deploy your project\n\nDeploy your Worker via Wrangler to a `*.workers.dev` subdomain or a [Custom Domain](https://developers.cloudflare.com/workers/configuration/routing/custom-domains/).",
      "language": "unknown"
    },
    {
      "code": "If you have not configured any subdomain or domain, Wrangler will prompt you during the publish process to set one up.\n\nPreview your Worker at `<YOUR_WORKER>.<YOUR_SUBDOMAIN>.workers.dev`.\n\nSeeing 523 errors?\n\nIf you see [`523` errors](https://developers.cloudflare.com/support/troubleshooting/http-status-codes/cloudflare-5xx-errors/error-523/) when pushing your `*.workers.dev` subdomain for the first time, wait a minute or so and the errors will resolve themselves.\n\n## Next steps\n\nTo do more:\n\n* Push your project to a GitHub or GitLab repository then [connect to builds](https://developers.cloudflare.com/workers/ci-cd/builds/#get-started) to enable automatic builds and deployments.\n* Visit the [Cloudflare dashboard](https://dash.cloudflare.com/) for simpler editing.\n* Review our [Examples](https://developers.cloudflare.com/workers/examples/) and [Tutorials](https://developers.cloudflare.com/workers/tutorials/) for inspiration.\n* Set up [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/) to allow your Worker to interact with other resources and unlock new functionality.\n* Learn how to [test and debug](https://developers.cloudflare.com/workers/testing/) your Workers.\n* Read about [Workers limits and pricing](https://developers.cloudflare.com/workers/platform/).\n\n</page>\n\n<page>\n---\ntitle: Prompting  Cloudflare Workers docs\ndescription: One of the fastest ways to build an application is by using AI to\n  assist with writing the boiler plate code. When building, iterating on or\n  debugging applications using AI tools and Large Language Models (LLMs), a\n  well-structured and extensive prompt helps provide the model with clearer\n  guidelines & examples that can dramatically improve output.\nlastUpdated: 2025-08-15T20:11:52.000Z\nchatbotDeprioritize: false\ntags: AI,LLM\nsource_url:\n  html: https://developers.cloudflare.com/workers/get-started/prompting/\n  md: https://developers.cloudflare.com/workers/get-started/prompting/index.md\n---\n\nOne of the fastest ways to build an application is by using AI to assist with writing the boiler plate code. When building, iterating on or debugging applications using AI tools and Large Language Models (LLMs), a well-structured and extensive prompt helps provide the model with clearer guidelines & examples that can dramatically improve output.\n\nBelow is an extensive example prompt that can help you build applications using Cloudflare Workers and your preferred AI model.\n\n### Build Workers using a prompt\n\nTo use the prompt:\n\n1. Use the click-to-copy button at the top right of the code block below to copy the full prompt to your clipboard\n2. Paste into your AI tool of choice (for example OpenAI's ChatGPT or Anthropic's Claude)\n3. Make sure to enter your part of the prompt at the end between the `<user_prompt>` and `</user_prompt>` tags.\n\nBase prompt:",
      "language": "unknown"
    },
    {
      "code": "The prompt above adopts several best practices, including:\n\n* Using `<xml>` tags to structure the prompt\n* API and usage examples for products and use-cases\n* Guidance on how to generate configuration (e.g. `wrangler.jsonc`) as part of the models response.\n* Recommendations on Cloudflare products to use for specific storage or state needs\n\n### Additional uses\n\nYou can use the prompt in several ways:\n\n* Within the user context window, with your own user prompt inserted between the `<user_prompt>` tags (**easiest**)\n\n* As the `system` prompt for models that support system prompts\n\n* Adding it to the prompt library and/or file context within your preferred IDE:\n\n  * Cursor: add the prompt to [your Project Rules](https://docs.cursor.com/context/rules-for-ai)\n  * Zed: use [the `/file` command](https://zed.dev/docs/assistant/assistant-panel) to add the prompt to the Assistant context.\n  * Windsurf: use [the `@-mention` command](https://docs.codeium.com/chat/overview) to include a file containing the prompt to your Chat.\n  * Claude Code: add the prompt to your CLAUDE.md configuration after running `/init` to include best practices to a Workers project.\n  * GitHub Copilot: create the [`.github/copilot-instructions.md`](https://docs.github.com/en/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot) file at the root of your project and add the prompt.\n\nNote\n\nThe prompt(s) here are examples and should be adapted to your specific use case. We'll continue to build out the prompts available here, including additional prompts for specific products.\n\nDepending on the model and user prompt, it may generate invalid code, configuration or other errors, and we recommend reviewing and testing the generated code before deploying it.\n\n### Passing a system prompt\n\nIf you are building an AI application that will itself generate code, you can additionally use the prompt above as a \"system prompt\", which will give the LLM additional information on how to structure the output code. For example:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "## Use docs in your editor\n\nAI-enabled editors, including Cursor and Windsurf, can index documentation. Cursor includes the Cloudflare Developer Docs by default: you can use the [`@Docs`](https://docs.cursor.com/context/@-symbols/@-docs) command.\n\nIn other editors, such as Zed or Windsurf, you can paste in URLs to add to your context. Use the *Copy Page* button to paste in Cloudflare docs directly, or fetch docs for each product by appending `llms-full.txt` to the root URL - for example, `https://developers.cloudflare.com/agents/llms-full.txt` or `https://developers.cloudflare.com/workflows/llms-full.txt`.\n\nYou can combine these with the Workers system prompt on this page to improve your editor or agent's understanding of the Workers APIs.\n\n## Additional resources\n\nTo get the most out of AI models and tools, we recommend reading the following guides on prompt engineering and structure:\n\n* OpenAI's [prompt engineering](https://platform.openai.com/docs/guides/prompt-engineering) guide and [best practices](https://platform.openai.com/docs/guides/reasoning-best-practices) for using reasoning models.\n* The [prompt engineering](https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering/overview) guide from Anthropic\n* Google's [quick start guide](https://services.google.com/fh/files/misc/gemini-for-google-workspace-prompting-guide-101.pdf) for writing effective prompts\n* Meta's [prompting documentation](https://www.llama.com/docs/how-to-guides/prompting/) for their Llama model family.\n* GitHub's guide for [prompt engineering](https://docs.github.com/en/copilot/using-github-copilot/copilot-chat/prompt-engineering-for-copilot-chat) when using Copilot Chat.\n\n</page>\n\n<page>\n---\ntitle: Templates  Cloudflare Workers docs\ndescription: GitHub repositories that are designed to be a starting point for\n  building a new Cloudflare Workers project.\nlastUpdated: 2025-11-03T19:32:09.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/get-started/quickstarts/\n  md: https://developers.cloudflare.com/workers/get-started/quickstarts/index.md\n---\n\nTemplates are GitHub repositories that are designed to be a starting point for building a new Cloudflare Workers project. To start any of the projects below, run:\n\n### astro-blog-starter-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/astro-blog-starter-template)\n\nBuild a personal website, blog, or portfolio with Astro.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/astro-blog-starter-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### chanfana-openapi-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/chanfana-openapi-template)\n\nComplete backend API template using Hono + Chanfana + D1 + Vitest.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/chanfana-openapi-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### cli\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/cli)\n\nA handy CLI for developing templates.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/cli)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### containers-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/containers-template)\n\nBuild a Container-enabled Worker\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/containers-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### d1-starter-sessions-api-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/d1-starter-sessions-api-template)\n\nD1 starter template using the Sessions API for read replication.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/d1-starter-sessions-api-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### d1-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/d1-template)\n\nCloudflare's native serverless SQL database.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/d1-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### durable-chat-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/durable-chat-template)\n\nChat with other users in real-time using Durable Objects and PartyKit.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/durable-chat-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### hello-world-do-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/hello-world-do-template)\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/hello-world-do-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### llm-chat-app-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/llm-chat-app-template)\n\nA simple chat application powered by Cloudflare Workers AI\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/llm-chat-app-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### multiplayer-globe-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/multiplayer-globe-template)\n\nDisplay website visitor locations in real-time using Durable Objects and PartyKit.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/multiplayer-globe-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### mysql-hyperdrive-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/mysql-hyperdrive-template)\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/mysql-hyperdrive-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### next-starter-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/next-starter-template)\n\nBuild a full-stack web application with Next.js.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/next-starter-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### nlweb-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/nlweb-template)\n\nBuild Nl Web components with Cloudflare Workers.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/nlweb-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### nodejs-http-server-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/nodejs-http-server-template)\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/nodejs-http-server-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### openauth-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/openauth-template)\n\nDeploy an OpenAuth server on Cloudflare Workers.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/openauth-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### postgres-hyperdrive-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/postgres-hyperdrive-template)\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/postgres-hyperdrive-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### r2-explorer-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/r2-explorer-template)\n\nA Google Drive Interface for your Cloudflare R2 Buckets!\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/r2-explorer-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### react-postgres-fullstack-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/react-postgres-fullstack-template)\n\nDeploy your own library of books using Postgres and Workers.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/react-postgres-fullstack-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### react-router-hono-fullstack-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/react-router-hono-fullstack-template)\n\nA modern full-stack template powered by Cloudflare Workers, using Hono for backend APIs, React Router for frontend routing, and shadcn/ui for beautiful, accessible components styled with Tailwind CSS\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/react-router-hono-fullstack-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### react-router-postgres-ssr-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/react-router-postgres-ssr-template)\n\nDeploy your own library of books using Postgres and Workers.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/react-router-postgres-ssr-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### react-router-starter-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/react-router-starter-template)\n\nBuild a full-stack web application with React Router 7.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/react-router-starter-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### remix-starter-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/remix-starter-template)\n\nBuild a full-stack web application with Remix.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/remix-starter-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### saas-admin-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/saas-admin-template)\n\nAdmin dashboard template built with Astro, shadcn/ui, and Cloudflare's developer stack\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/saas-admin-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### text-to-image-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/text-to-image-template)\n\nGenerate images based on text prompts.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/text-to-image-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### to-do-list-kv-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/to-do-list-kv-template)\n\nA simple to-do list app built with Cloudflare Workers Assets and Remix.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/to-do-list-kv-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### vite-react-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/vite-react-template)\n\nA template for building a React application with Vite, Hono, and Cloudflare Workers\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/vite-react-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### worker-publisher-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/worker-publisher-template)\n\nA Cloudflare Worker template that creates and deploys Workers to a Dispatch Namespace via the Cloudflare SDK.\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/worker-publisher-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### workflows-starter-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/workflows-starter-template)\n\nInteractive starter template demonstrating Cloudflare Workflows with real-time status updates\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/workflows-starter-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n\n### x402-proxy-template\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/x402-proxy-template)\n\nTransparent proxy with payment-gated routes using x402 protocol and stateless JWT authentication\n\nExplore on [GitHub ](https://github.com/cloudflare/templates/tree/main/x402-proxy-template)\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "***\n\n\n</page>\n\n<page>\n---\ntitle: 103 Early Hints  Cloudflare Workers docs\ndescription: Allow a client to request static assets while waiting for the HTML response.\nlastUpdated: 2025-09-17T11:26:09.000Z\nchatbotDeprioritize: false\ntags: Middleware,Headers,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/103-early-hints/\n  md: https://developers.cloudflare.com/workers/examples/103-early-hints/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/103-early-hints)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n`103` Early Hints is an HTTP status code designed to speed up content delivery. When enabled, Cloudflare can cache the `Link` headers marked with preload and/or preconnect from HTML pages and serve them in a `103` Early Hints response before reaching the origin server. Browsers can use these hints to fetch linked assets while waiting for the origins final response, dramatically improving page load speeds.\n\nTo ensure Early Hints are enabled on your zone:\n\n1. In the Cloudflare dashboard, go to the **Speed settings** page.\n\n   [Go to **Settings**](https://dash.cloudflare.com/?to=/:account/:zone/speed/optimization)\n\n2. Go to **Content Optimization**.\n\n3. Enable the **Early Hints** toggle to on.\n\nYou can return `Link` headers from a Worker running on your zone to speed up your page load times.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: A/B testing with same-URL direct access  Cloudflare Workers docs\ndescription: Set up an A/B test by controlling what response is served based on\n  cookies. This version supports passing the request through to test and control\n  on the origin, bypassing random assignment.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/ab-testing/\n  md: https://developers.cloudflare.com/workers/examples/ab-testing/index.md\n---\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Accessing the Cloudflare Object  Cloudflare Workers docs\ndescription: Access custom Cloudflare properties and control how Cloudflare\n  features are applied to every request.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/accessing-the-cloudflare-object/\n  md: https://developers.cloudflare.com/workers/examples/accessing-the-cloudflare-object/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/accessing-the-cloudflare-object)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Aggregate requests  Cloudflare Workers docs\ndescription: Send two GET request to two urls and aggregates the responses into\n  one response.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/aggregate-requests/\n  md: https://developers.cloudflare.com/workers/examples/aggregate-requests/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/aggregate-requests)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Alter headers  Cloudflare Workers docs\ndescription: Example of how to add, change, or delete headers sent in a request\n  or returned in a response.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Headers,Middleware,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/alter-headers/\n  md: https://developers.cloudflare.com/workers/examples/alter-headers/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/alter-headers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "You can also use the [`custom-headers-example` template](https://github.com/kristianfreeman/custom-headers-example) to deploy this code to your custom domain.\n\n</page>\n\n<page>\n---\ntitle: Auth with headers  Cloudflare Workers docs\ndescription: Allow or deny a request based on a known pre-shared key in a\n  header. This is not meant to replace the WebCrypto API.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Authentication,Web Crypto,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/auth-with-headers/\n  md: https://developers.cloudflare.com/workers/examples/auth-with-headers/index.md\n---\n\nCaution when using in production\n\nThe example code contains a generic header key and value of `X-Custom-PSK` and `mypresharedkey`. To best protect your resources, change the header key and value in the Workers editor before saving your code.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: HTTP Basic Authentication  Cloudflare Workers docs\ndescription: Shows how to restrict access using the HTTP Basic schema.\nlastUpdated: 2025-10-23T20:06:36.000Z\nchatbotDeprioritize: false\ntags: Security,Authentication,JavaScript,TypeScript,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/basic-auth/\n  md: https://developers.cloudflare.com/workers/examples/basic-auth/index.md\n---\n\nNote\n\nThis example Worker makes use of the [Node.js Buffer API](https://developers.cloudflare.com/workers/runtime-apis/nodejs/buffer/), which is available as part of the Workers runtime [Node.js compatibility mode](https://developers.cloudflare.com/workers/runtime-apis/nodejs/). To run this Worker, you will need to [enable the `nodejs_compat` compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#nodejs-compatibility-flag).\n\nCaution when using in production\n\nThis code is provided as a sample, and is not suitable for production use. Basic Authentication sends credentials unencrypted, and must be used with an HTTPS connection to be considered secure. For a production-ready authentication system, consider using [Cloudflare Access](https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/self-hosted-public-app/).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Block on TLS  Cloudflare Workers docs\ndescription: Inspects the incoming request's TLS version and blocks if under TLSv1.2.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Security,Middleware,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/block-on-tls/\n  md: https://developers.cloudflare.com/workers/examples/block-on-tls/index.md\n---\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Bulk origin override  Cloudflare Workers docs\ndescription: Resolve requests to your domain to a set of proxy third-party origin URLs.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/bulk-origin-proxy/\n  md: https://developers.cloudflare.com/workers/examples/bulk-origin-proxy/index.md\n---\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Bulk redirects  Cloudflare Workers docs\ndescription: Redirect requests to certain URLs based on a mapped object to the\n  request's URL.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,Redirects,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/bulk-redirects/\n  md: https://developers.cloudflare.com/workers/examples/bulk-redirects/index.md\n---\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Using the Cache API  Cloudflare Workers docs\ndescription: Use the Cache API to store responses in Cloudflare's cache.\nlastUpdated: 2025-12-12T16:06:17.000Z\nchatbotDeprioritize: false\ntags: Middleware,Caching,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cache-api/\n  md: https://developers.cloudflare.com/workers/examples/cache-api/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cache-api)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Cache POST requests  Cloudflare Workers docs\ndescription: Cache POST requests using the Cache API.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,Caching,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cache-post-request/\n  md: https://developers.cloudflare.com/workers/examples/cache-post-request/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cache-post-request)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Cache Tags using Workers  Cloudflare Workers docs\ndescription: Send Additional Cache Tags using Workers\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Caching,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cache-tags/\n  md: https://developers.cloudflare.com/workers/examples/cache-tags/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cache-tags)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Cache using fetch  Cloudflare Workers docs\ndescription: Determine how to cache a resource by setting TTLs, custom cache\n  keys, and cache headers in a fetch request.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Caching,Middleware,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cache-using-fetch/\n  md: https://developers.cloudflare.com/workers/examples/cache-using-fetch/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cache-using-fetch)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "## Caching HTML resources",
      "language": "unknown"
    },
    {
      "code": "Setting the cache level to **Cache Everything** will override the default cacheability of the asset. For time-to-live (TTL), Cloudflare will still rely on headers set by the origin.\n\n## Custom cache keys\n\nNote\n\nThis feature is available only to Enterprise customers.\n\nA request's cache key is what determines if two requests are the same for caching purposes. If a request has the same cache key as some previous request, then Cloudflare can serve the same cached response for both. For more about cache keys, refer to the [Create custom cache keys](https://developers.cloudflare.com/cache/how-to/cache-keys/#create-custom-cache-keys) documentation.",
      "language": "unknown"
    },
    {
      "code": "Normally, Cloudflare computes the cache key for a request based on the request's URL. Sometimes, though, you may like different URLs to be treated as if they were the same for caching purposes. For example, if your website content is hosted from both Amazon S3 and Google Cloud Storage - you have the same content in both places, and you can use a Worker to randomly balance between the two. However, you do not want to end up caching two copies of your content. You could utilize custom cache keys to cache based on the original request URL rather than the subrequest URL:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "Workers operating on behalf of different zones cannot affect each other's cache. You can only override cache keys when making requests within your own zone (in the above example `event.request.url` was the key stored), or requests to hosts that are not on Cloudflare. When making a request to another Cloudflare zone (for example, belonging to a different Cloudflare customer), that zone fully controls how its own content is cached within Cloudflare; you cannot override it.\n\n## Override based on origin response code",
      "language": "unknown"
    },
    {
      "code": "This option is a version of the `cacheTtl` feature which chooses a TTL based on the response's status code and does not automatically set `cacheEverything: true`. If the response to this request has a status code that matches, Cloudflare will cache for the instructed time, and override cache directives sent by the origin. You can review [details on the `cacheTtl` feature on the Request page](https://developers.cloudflare.com/workers/runtime-apis/request/#the-cf-property-requestinitcfproperties).\n\n## Customize cache behavior based on request file type\n\nUsing custom cache keys and overrides based on response code, you can write a Worker that sets the TTL based on the response status code from origin, and request file type.\n\nThe following example demonstrates how you might use this to cache requests for streaming media assets:\n\n* Module Worker",
      "language": "unknown"
    },
    {
      "code": "* Service Worker\n\n  Service Workers are deprecated\n\n  Service Workers are deprecated, but still supported. We recommend using [Module Workers](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) instead. New features may not be supported for Service Workers.",
      "language": "unknown"
    },
    {
      "code": "## Using the HTTP Cache API\n\nThe `cache` mode can be set in `fetch` options. Currently Workers only support the `no-store` and `no-cache` mode for controlling the cache. When `no-store` is supplied the cache is bypassed on the way to the origin and the request is not cacheable. When `no-cache` is supplied the cache is forced to revalidate the currently cached response with the origin.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Conditional response  Cloudflare Workers docs\ndescription: Return a response based on the incoming request's URL, HTTP method,\n  User Agent, IP address, ASN or device type.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/conditional-response/\n  md: https://developers.cloudflare.com/workers/examples/conditional-response/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/conditional-response)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: CORS header proxy  Cloudflare Workers docs\ndescription: Add the necessary CORS headers to a third party API response.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Security,Headers,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cors-header-proxy/\n  md: https://developers.cloudflare.com/workers/examples/cors-header-proxy/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cors-header-proxy)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Country code redirect  Cloudflare Workers docs\ndescription: Redirect a response based on the country code in the header of a visitor.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Redirects,Geolocation,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/country-code-redirect/\n  md: https://developers.cloudflare.com/workers/examples/country-code-redirect/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/country-code-redirect)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Setting Cron Triggers  Cloudflare Workers docs\ndescription: Set a Cron Trigger for your Worker.\nlastUpdated: 2025-11-11T15:40:52.000Z\nchatbotDeprioritize: false\ntags: Middleware,JavaScript,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/cron-trigger/\n  md: https://developers.cloudflare.com/workers/examples/cron-trigger/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/cron-trigger)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "## Set Cron Triggers in Wrangler\n\nRefer to [Cron Triggers](https://developers.cloudflare.com/workers/configuration/cron-triggers/) for more information on how to add a Cron Trigger.\n\nIf you are deploying with Wrangler, set the cron syntax (once per hour as shown below) by adding this to your Wrangler file:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "You also can set a different Cron Trigger for each [environment](https://developers.cloudflare.com/workers/wrangler/environments/) in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). You need to put the `[triggers]` table under your chosen environment. For example:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## Test Cron Triggers using Wrangler\n\nThe recommended way of testing Cron Triggers is using Wrangler.\n\nCron Triggers can be tested using Wrangler by passing in the `--test-scheduled` flag to [`wrangler dev`](https://developers.cloudflare.com/workers/wrangler/commands/#dev). This will expose a `/__scheduled` (or `/cdn-cgi/handler/scheduled` for Python Workers) route which can be used to test using a HTTP request. To simulate different cron patterns, a `cron` query parameter can be passed in.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Data loss prevention  Cloudflare Workers docs\ndescription: Protect sensitive data to prevent data loss, and send alerts to a\n  webhooks server in the event of a data breach.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Security,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/data-loss-prevention/\n  md: https://developers.cloudflare.com/workers/examples/data-loss-prevention/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/data-loss-prevention)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Debugging logs  Cloudflare Workers docs\ndescription: Send debugging information in an errored response to a logging service.\nlastUpdated: 2025-09-01T10:19:51.000Z\nchatbotDeprioritize: false\ntags: Debugging,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/debugging-logs/\n  md: https://developers.cloudflare.com/workers/examples/debugging-logs/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/debugging-logs)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Cookie parsing  Cloudflare Workers docs\ndescription: Given the cookie name, get the value of a cookie. You can also use\n  cookies for A/B testing.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Headers,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/extract-cookie-value/\n  md: https://developers.cloudflare.com/workers/examples/extract-cookie-value/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/extract-cookie-value)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "External dependencies\n\nThis example requires the npm package [`cookie`](https://www.npmjs.com/package/cookie) to be installed in your JavaScript project.\n\nThe Hono example uses the built-in cookie utilities provided by Hono, so no external dependencies are needed for that implementation.\n\n</page>\n\n<page>\n---\ntitle: Fetch HTML  Cloudflare Workers docs\ndescription: Send a request to a remote server, read HTML from the response, and\n  serve that HTML.\nlastUpdated: 2025-08-20T18:47:44.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/fetch-html/\n  md: https://developers.cloudflare.com/workers/examples/fetch-html/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/fetch-html)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "[Run Worker in Playground](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbPYZb6HbW5QDGU2AAwB2ABwBWACwBmAGwAmYQE5JkgFwsWbYBzhcafASIkyFy1QFgAUAGF0VCAFMH2ACJQAzjHQeo0e2ok2ngExCRUcMCODABEUDSOAB4AdABWHjGkqFBgzpHRcQkp6THWdg7OENgAKnQwjoFwMDBgfARQ9sipcABucB68CLAQANTA6LjgjtbWSd5IJLiOqHDgECQA3lYkJP10VLxBjhC8ABYAFAiOAI4gjh4QAJSb2zskyABUH69vHyQASo4WnBeI4SAADK7jJzgkgAdz8pxIEFOYNOPnWdEo8M8SIg6BIHmcuBIV1u9wgHmR6B+Ow+yFpvHsD1JjmhYIYJBipwgEBgHjUyGQSUiLUcySZwEyVlpVwgIAQVF2cLgfiOJwuUPQTgANKzyQ9HkRXgBfHVWE1EayaZjaXT6Hj8IRiKRyRQqSRlexOFzuLw+PwdKiBYK6UgRKKxKKEXSZII5PKRmJkMDoMilWzeyo1OoNXbNVq8dqddL2GZWDYxYCqqgAfXGk1yMTUhSWxQyJutNrtoQdhmdJjd5kkzGsQA)\n\n* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Fetch JSON  Cloudflare Workers docs\ndescription: Send a GET request and read in JSON from the response. Use to fetch\n  external data.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JSON,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/fetch-json/\n  md: https://developers.cloudflare.com/workers/examples/fetch-json/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/fetch-json)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: \"Geolocation: Weather application  Cloudflare Workers docs\"\ndescription: Fetch weather data from an API using the user's geolocation data.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Geolocation,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/geolocation-app-weather/\n  md: https://developers.cloudflare.com/workers/examples/geolocation-app-weather/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/geolocation-app-weather)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: \"Geolocation: Custom Styling  Cloudflare Workers docs\"\ndescription: Personalize website styling based on localized user time.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Geolocation,JavaScript,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/geolocation-custom-styling/\n  md: https://developers.cloudflare.com/workers/examples/geolocation-custom-styling/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/geolocation-custom-styling)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: \"Geolocation: Hello World  Cloudflare Workers docs\"\ndescription: Get all geolocation data fields and display them in HTML.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Geolocation,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/geolocation-hello-world/\n  md: https://developers.cloudflare.com/workers/examples/geolocation-hello-world/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/geolocation-hello-world)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Hot-link protection  Cloudflare Workers docs\ndescription: Block other websites from linking to your content. This is useful\n  for protecting images.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Security,Headers,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/hot-link-protection/\n  md: https://developers.cloudflare.com/workers/examples/hot-link-protection/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/hot-link-protection)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Custom Domain with Images  Cloudflare Workers docs\ndescription: Set up custom domain for Images using a Worker or serve images\n  using a prefix path and Cloudflare registered domain.\nlastUpdated: 2025-09-09T12:12:09.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/images-workers/\n  md: https://developers.cloudflare.com/workers/examples/images-workers/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/images-workers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nTo serve images from a custom domain:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. Select **Create application** > **Workers** > **Create Worker** and create your Worker.\n\n3. In your Worker, select **Quick edit** and paste the following code.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "Another way you can serve images from a custom domain is by using the `cdn-cgi/imagedelivery` prefix path which is used as path to trigger `cdn-cgi` image proxy.\n\nBelow is an example showing the hostname as a Cloudflare proxied domain under the same account as the Image, followed with the prefix path and the image `<ACCOUNT_HASH>`, `<IMAGE_ID>` and `<VARIANT_NAME>` which can be found in the **Images** on the Cloudflare dashboard.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Logging headers to console  Cloudflare Workers docs\ndescription: Examine the contents of a Headers object by logging to console with a Map.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Debugging,Headers,JavaScript,Rust,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/logging-headers/\n  md: https://developers.cloudflare.com/workers/examples/logging-headers/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/logging-headers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "***\n\n## Console-logging headers\n\nUse a `Map` if you need to log a `Headers` object to the console:",
      "language": "unknown"
    },
    {
      "code": "Use the `spread` operator if you need to quickly stringify a `Headers` object:",
      "language": "unknown"
    },
    {
      "code": "Use `Object.fromEntries` to convert the headers to an object:",
      "language": "unknown"
    },
    {
      "code": "### The problem\n\nWhen debugging Workers, examine the headers on a request or response. A common mistake is to try to log headers to the developer console via code like this:",
      "language": "unknown"
    },
    {
      "code": "Or this:",
      "language": "unknown"
    },
    {
      "code": "Both attempts result in what appears to be an empty object  the string `\"{}\"`  even though calling `request.headers.has(\"Your-Header-Name\")` might return true. This is the same behavior that browsers implement.\n\nThe reason this happens is because [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) objects do not store headers in enumerable JavaScript properties, so the developer console and JSON stringifier do not know how to read the names and values of the headers. It is not actually an empty object, but rather an opaque object.\n\n`Headers` objects are iterable, which you can take advantage of to develop a couple of quick one-liners for debug-printing headers.\n\n### Pass headers through a Map\n\nThe first common idiom for making Headers `console.log()`-friendly is to construct a `Map` object from the `Headers` object and log the `Map` object.",
      "language": "unknown"
    },
    {
      "code": "This works because:\n\n* `Map` objects can be constructed from iterables, like `Headers`.\n\n* The `Map` object does store its entries in enumerable JavaScript properties, so the developer console can see into it.\n\n### Spread headers into an array\n\nThe `Map` approach works for calls to `console.log()`. If you need to stringify your headers, you will discover that stringifying a `Map` yields nothing more than `[object Map]`.\n\nEven though a `Map` stores its data in enumerable properties, those properties are [Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)-keyed. Because of this, `JSON.stringify()` will [ignore Symbol-keyed properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#symbols_and_json.stringify) and you will receive an empty `{}`.\n\nInstead, you can take advantage of the iterability of the `Headers` object in a new way by applying the [spread operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) (`...`) to it.",
      "language": "unknown"
    },
    {
      "code": "### Convert headers into an object with Object.fromEntries (ES2019)\n\nES2019 provides [`Object.fromEntries`](https://github.com/tc39/proposal-object-from-entries) which is a call to convert the headers into an object:",
      "language": "unknown"
    },
    {
      "code": "This results in something like:",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Modify request property  Cloudflare Workers docs\ndescription: Create a modified request with edited properties based off of an\n  incoming request.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,Headers,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/modify-request-property/\n  md: https://developers.cloudflare.com/workers/examples/modify-request-property/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/modify-request-property)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Modify response  Cloudflare Workers docs\ndescription: Fetch and modify response properties which are immutable by\n  creating a copy first.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,Headers,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/modify-response/\n  md: https://developers.cloudflare.com/workers/examples/modify-response/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/modify-response)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Multiple Cron Triggers  Cloudflare Workers docs\ndescription: Set multiple Cron Triggers on three different schedules.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Middleware,JavaScript,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/multiple-cron-triggers/\n  md: https://developers.cloudflare.com/workers/examples/multiple-cron-triggers/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/multiple-cron-triggers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "## Test Cron Triggers using Wrangler\n\nThe recommended way of testing Cron Triggers is using Wrangler.\n\nCron Triggers can be tested using Wrangler by passing in the `--test-scheduled` flag to [`wrangler dev`](https://developers.cloudflare.com/workers/wrangler/commands/#dev). This will expose a `/__scheduled` (or `/cdn-cgi/handler/scheduled` for Python Workers) route which can be used to test using a HTTP request. To simulate different cron patterns, a `cron` query parameter can be passed in.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Stream OpenAI API Responses  Cloudflare Workers docs\ndescription: Use the OpenAI v4 SDK to stream responses from OpenAI.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\ntags: AI,JavaScript,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/openai-sdk-streaming/\n  md: https://developers.cloudflare.com/workers/examples/openai-sdk-streaming/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/openai-sdk-streaming)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nIn order to run this code, you must install the OpenAI SDK by running `npm i openai`.\n\nNote\n\nFor analytics, caching, rate limiting, and more, you can also send requests like this through Cloudflare's [AI Gateway](https://developers.cloudflare.com/ai-gateway/usage/providers/openai/).\n\n* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Post JSON  Cloudflare Workers docs\ndescription: Send a POST request with JSON data. Use to share data with external servers.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JSON,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/post-json/\n  md: https://developers.cloudflare.com/workers/examples/post-json/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/post-json)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Using timingSafeEqual  Cloudflare Workers docs\ndescription: Protect against timing attacks by safely comparing values using\n  `timingSafeEqual`.\nlastUpdated: 2025-09-01T10:19:51.000Z\nchatbotDeprioritize: false\ntags: Security,Web Crypto,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/protect-against-timing-attacks/\n  md: https://developers.cloudflare.com/workers/examples/protect-against-timing-attacks/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/protect-against-timing-attacks)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nThe [`crypto.subtle.timingSafeEqual`](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#timingsafeequal) function compares two values using a constant-time algorithm. The time taken is independent of the contents of the values.\n\nWhen strings are compared using the equality operator (`==` or `===`), the comparison will end at the first mismatched character. By using `timingSafeEqual`, an attacker would not be able to use timing to find where at which point in the two strings there is a difference.\n\nThe `timingSafeEqual` function takes two `ArrayBuffer` or `TypedArray` values to compare. These buffers must be of equal length, otherwise an exception is thrown. Note that this function is not constant time with respect to the length of the parameters and also does not guarantee constant time for the surrounding code. Handling of secrets should be taken with care to not introduce timing side channels.\n\nIn order to compare two strings, you must use the [`TextEncoder`](https://developers.cloudflare.com/workers/runtime-apis/encoding/#textencoder) API.\n\n* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Read POST  Cloudflare Workers docs\ndescription: Serve an HTML form, then read POST requests. Use also to read JSON\n  or POST data from an incoming request.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: JSON,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/read-post/\n  md: https://developers.cloudflare.com/workers/examples/read-post/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/read-post)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "Prevent potential errors when accessing request.body\n\nThe body of a [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) can only be accessed once. If you previously used `request.formData()` in the same request, you may encounter a TypeError when attempting to access `request.body`.\n\nTo avoid errors, create a clone of the Request object with `request.clone()` for each subsequent attempt to access a Request's body. Keep in mind that Workers have a [memory limit of 128 MB per Worker](https://developers.cloudflare.com/workers/platform/limits#worker-limits) and loading particularly large files into a Worker's memory multiple times may reach this limit. To ensure memory usage does not reach this limit, consider using [Streams](https://developers.cloudflare.com/workers/runtime-apis/streams/).\n\n</page>\n\n<page>\n---\ntitle: Redirect  Cloudflare Workers docs\ndescription: Redirect requests from one URL to another or from one set of URLs\n  to another set.\nlastUpdated: 2025-08-20T18:47:44.000Z\nchatbotDeprioritize: false\ntags: Middleware,Redirects,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/redirect/\n  md: https://developers.cloudflare.com/workers/examples/redirect/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/redirect)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n## Redirect all requests to one URL\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "[Run Worker in Playground](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbPYZb6HbW5QDGU2AAwBmAKwBGQQCZRANimzx4gFwsWbYBzhcafASInS5CpQFgAUAGF0VCAFNb2ACJQAzjHSuo0G8pIa8AmISKjhgOwYAIigaOwAPADoAK1dI0lQoMAcwiOjYxJTIi2tbBwhsABU6GDs-OBgYMD4CKBtkJLgANzhXXgRYCABqYHRccDsLC3iPJBJcO1Q4cAgSAG9zEhIeuipefzsIXgALAAoEOwBHEDtXCABKNY3Nkl4bW7mb6FCfKgBVACUADIkBgkSJHCAQGCuZTIZDxMKNOwJV7ANJPTavKjvW4EECuazzEEkYSCcREDEkc4QEAIKgkf43DzY5HnHjnXgQE7zW4xFo2AGAgA0JFxNIJozsdwpmwAvkLzLKiBY1MwNFodDx+EIxJIZPJFOJijZ7I4XO5PN5WlQ-AEtKRQuEouFCFo0v5MtknZEyGB0GQilYTWVKtValsGk1ePyqO1XDZJuZVpFgHAYgB9EZjLKRZR5eYFVKylWq9VBTV6HWGfUmcTMCxAA)\n\n* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "## Redirect requests from one domain to another\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Respond with another site  Cloudflare Workers docs\ndescription: Respond to the Worker request with the response from another\n  website (example.com in this example).\nlastUpdated: 2025-10-17T07:10:47.000Z\nchatbotDeprioritize: false\ntags: Middleware,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/respond-with-another-site/\n  md: https://developers.cloudflare.com/workers/examples/respond-with-another-site/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/respond-with-another-site)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "[Run Worker in Playground](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbPYZb6HbW5QDGU2AAyCAbACYAnABZhgiWICMALhYs2wDnC40+A4eOmz5CgLAAoAMLoqEAKY3sAESgBnGOhdRo1pSXV4CYhIqOGBbBgAiKBpbAA8AOgArFwjSVCgwe1DwqJiE5IjzKxt7CGwAFToYW184GBgwPgIoa2REuAA3OBdeBFgIAGpgdFxwW3NzOPckElxbVDhwCBIAbzMSEm66Kl4-WwheAAsACgRbAEcQWxcIAEpV9Y2-al5vKhIAWX3DkYA5dAgAEEwGB0AB3Wy4U4XK43e5rJ5PM4QEAId5UWxgkgAJWu7ioLlsxwABl8ID9cCQACQrM6Xa4QeJhckjAC+wQBmxB4Mh8WJABoHojETcCCAXL4ZABWfmPYUkQ62OBzBASoXyp7A0Fg3wRADiAFFyhFZRqSKzTcLWbciHLzXbkMgSAB5KhgOgkQ3lEh02EQFwkMGYADWga8hxI5NcJBgCHQsTo8TtUFQJGh9JuTO+IxIAEIGAwSPqjRF7sjUe8yRT-kDuRCob6GTa7eW0XsDidiYcIBAYBLHXFQg1bPFeOhgMTmxsLWZWURzKpmOpNNoePwhKJJDJhMYitY7A5nG4PF4WlRfP5NKQQmFIszlYFUn4MllbxEyKCyIVLPvShUqjUmz1I0vDNK0yTWBMZgrBEwBwNEAD6wyjJkERKLkcz5CkrILouy6BKuugbgY25yIozDmEAA)\n\n* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Return small HTML page  Cloudflare Workers docs\ndescription: Deliver an HTML page from an HTML string directly inside the Worker script.\nlastUpdated: 2025-08-20T18:47:44.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/return-html/\n  md: https://developers.cloudflare.com/workers/examples/return-html/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/return-html)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "[Run Worker in Playground](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbPYZb6HbW5QDGU2AAwBmAEwBGACwBOAByyA7AFZZogFwsWbYBzhcafASIkz5y1QFgAUAGF0VCAFMH2ACJQAzjHQeo0e2ok2ngExCRUcMCODABEUDSOAB4AdABWHjGkqFBgzpHRcQkp6THWdg7OENgAKnQwjoFwMDBgfARQ9sipcABucB68CLAQANTA6LjgjtbWSd5IJLiOqHDgECQA3lYkJP10VLxBjhC8ABYAFAiOAI4gjh4QAJSb2zskvPYPJKcQwGAkDBIAAMADwAQlcAHkbNUAJoABQAot9fmAAHyvHYgii4OgYt5vEGncRogASjjAYHQJAA6pgwLgQchifiCSQQTA0dVTp4SMBEABrEAwEgAd36JAA5s5HAgCI5cOQ6LsSDYqSBcKgwIhHLTMALZckmZzMezkDi8UCiFZTVcICAEFRwo5RSQAEr3bxUDyOc4-P4AGhebO+jjgSwQHkCWxDOxiHwqLggdUcMUCMSciRQ-rARDOiB9EAYAFVqgAxbCyGIB007AC+NYJdce1vrNbrRGsmmY2l0+h4-CEYikckUKlEZXsThc7i8Pj8HSogWCulIESisSihF0mSCOTyG5iZCpZFKtinlRqKcazVavHanXS9hmVg2MX58QA+uNJrk04UlmKDI6y7bte1CftDCHExR3MURmGsIA)\n\n* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Return JSON  Cloudflare Workers docs\ndescription: Return JSON directly from a Worker script, useful for building APIs\n  and middleware.\nlastUpdated: 2025-08-20T18:47:44.000Z\nchatbotDeprioritize: false\ntags: JSON,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/return-json/\n  md: https://developers.cloudflare.com/workers/examples/return-json/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/return-json)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "[Run Worker in Playground](https://workers.cloudflare.com/playground#LYVwNgLglgDghgJwgegGYHsHALQBM4RwDcABAEbogB2+CAngLzbPYZb6HbW5QDGU2AAwBmAGwAOAOwBWGeNGjhALhYs2wDnC40+AkRJlyFwgLAAoAMLoqEAKY3sAESgBnGOhdRo1pSXV4CYhIqOGBbBgAiKBpbAA8AOgArFwjSVCgwe1DwqJiE5IjzKxt7CGwAFToYW184GBgwPgIoa2REuAA3OBdeBFgIAGpgdFxwW3NzOPckElxbVDhwCBIAbzMSEm66Kl4-WwheAAsACgRbAEcQWxcIAEpV9Y2SXmsb2cCSBgenp8PbMDA6F8EQA7pgwLgIgAaR4bAC+RDMsJIZwgIAQVBIACVru4qC5bEkXNZjppboj4TCEeZVMx1JptDx+EIxFJZNJ5IoitY7A5nG4PF4WlRfP5NKQQmFImFCJpUn4MlkpREyICyIVLDzShUqjVNvVGrxmq1ktYJmYVhFgHBogB9YajTIRJS5Ob5FJwmm0+mBRm6FkGdmc4TMcxAA)\n\n* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Rewrite links  Cloudflare Workers docs\ndescription: Rewrite URL links in HTML using the HTMLRewriter. This is useful\n  for JAMstack websites.\nlastUpdated: 2025-08-19T19:54:31.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/rewrite-links/\n  md: https://developers.cloudflare.com/workers/examples/rewrite-links/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/rewrite-links)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Set security headers  Cloudflare Workers docs\ndescription: Set common security headers (X-XSS-Protection, X-Frame-Options,\n  X-Content-Type-Options, Permissions-Policy, Referrer-Policy,\n  Strict-Transport-Security, Content-Security-Policy).\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: Security,Middleware,JavaScript,TypeScript,Python,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/security-headers/\n  md: https://developers.cloudflare.com/workers/examples/security-headers/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/security-headers)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Sign requests  Cloudflare Workers docs\ndescription: Verify a signed request using the HMAC and SHA-256 algorithms or return a 403.\nlastUpdated: 2025-09-01T10:19:51.000Z\nchatbotDeprioritize: false\ntags: Security,Web Crypto,JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/signing-requests/\n  md: https://developers.cloudflare.com/workers/examples/signing-requests/index.md\n---\n\nIf you want to get started quickly, click on the button below.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/docs-examples/tree/main/workers/signing-requests)\n\nThis creates a repository in your GitHub account and deploys the application to Cloudflare Workers.\n\nNote\n\nThis example Worker makes use of the [Node.js Buffer API](https://developers.cloudflare.com/workers/runtime-apis/nodejs/buffer/), which is available as part of the Workers runtime [Node.js compatibility mode](https://developers.cloudflare.com/workers/runtime-apis/nodejs/). To run this Worker, you will need to [enable the `nodejs_compat` compatibility flag](https://developers.cloudflare.com/workers/runtime-apis/nodejs/#get-started).\n\nYou can both verify and generate signed requests from within a Worker using the [Web Crypto APIs](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/subtle).\n\nThe following Worker will:\n\n* For request URLs beginning with `/generate/`, replace `/generate/` with `/`, sign the resulting path with its timestamp, and return the full, signed URL in the response body.\n\n* For all other request URLs, verify the signed URL and allow the request through.\n\n- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "- Hono",
      "language": "unknown"
    },
    {
      "code": "- Python",
      "language": "unknown"
    },
    {
      "code": "## Validate signed requests using the WAF\n\nThe provided example code for signing requests is compatible with the [`is_timed_hmac_valid_v0()`](https://developers.cloudflare.com/ruleset-engine/rules-language/functions/#hmac-validation) Rules language function. This means that you can verify requests signed by the Worker script using a [custom rule](https://developers.cloudflare.com/waf/custom-rules/use-cases/configure-token-authentication/#option-2-configure-using-custom-rules).\n\n</page>\n\n<page>\n---\ntitle: Stream large JSON  Cloudflare Workers docs\ndescription: Parse and transform large JSON request and response bodies using streaming.\nlastUpdated: 2025-12-16T04:37:37.000Z\nchatbotDeprioritize: false\ntags: Middleware,JSON,JavaScript,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/streaming-json/\n  md: https://developers.cloudflare.com/workers/examples/streaming-json/index.md\n---\n\nUse the [Streams API](https://developers.cloudflare.com/workers/runtime-apis/streams/) to process JSON payloads that would exceed a Worker's 128 MB memory limit if fully buffered. Streaming allows you to parse and transform JSON data incrementally as it arrives. This is faster than buffering the entire payload into memory, as your Worker can start processing data incrementally, and allows your Worker to handle multi-gigabyte payloads or files within its memory limits.\n\nThe [`@streamparser/json-whatwg`](https://www.npmjs.com/package/@streamparser/json-whatwg) library provides a streaming JSON parser compatible with the Web Streams API.\n\nInstall the dependency:",
      "language": "unknown"
    },
    {
      "code": "## Stream a JSON request body\n\nThis example parses a large JSON request body and extracts specific fields without loading the entire payload into memory.\n\n* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "## Stream and transform a JSON response\n\nThis example fetches a large JSON response from an upstream API, transforms specific fields, and streams the modified response to the client.\n\n* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "## Related resources\n\n* [Streams API](https://developers.cloudflare.com/workers/runtime-apis/streams/) - Learn more about streaming in Workers\n* [TransformStream](https://developers.cloudflare.com/workers/runtime-apis/streams/transformstream/) - Create custom stream transformations\n* [@streamparser/json-whatwg](https://www.npmjs.com/package/@streamparser/json-whatwg) - Streaming JSON parser documentation\n\n</page>\n\n<page>\n---\ntitle: Turnstile with Workers  Cloudflare Workers docs\ndescription: Inject [Turnstile](/turnstile/) implicitly into HTML elements using\n  the HTMLRewriter runtime API.\nlastUpdated: 2025-09-01T10:19:51.000Z\nchatbotDeprioritize: false\ntags: JavaScript,TypeScript,Python\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/turnstile-html-rewriter/\n  md: https://developers.cloudflare.com/workers/examples/turnstile-html-rewriter/index.md\n---\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "Note\n\nThis is only half the implementation for Turnstile. The corresponding token that is a result of a widget being rendered also needs to be verified using the [Siteverify API](https://developers.cloudflare.com/turnstile/get-started/server-side-validation/). Refer to the example below for one such implementation.\n\nPrevent potential errors when accessing request.body\n\nThe body of a [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) can only be accessed once. If you previously used `request.formData()` in the same request, you may encounter a TypeError when attempting to access `request.body`.\n\nTo avoid errors, create a clone of the Request object with `request.clone()` for each subsequent attempt to access a Request's body. Keep in mind that Workers have a [memory limit of 128 MB per Worker](https://developers.cloudflare.com/workers/platform/limits#worker-limits) and loading particularly large files into a Worker's memory multiple times may reach this limit. To ensure memory usage does not reach this limit, consider using [Streams](https://developers.cloudflare.com/workers/runtime-apis/streams/).\n\n</page>\n\n<page>\n---\ntitle: Using the WebSockets API  Cloudflare Workers docs\ndescription: Use the WebSockets API to communicate in real time with your\n  Cloudflare Workers.\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\ntags: WebSockets,JavaScript,Rust\nsource_url:\n  html: https://developers.cloudflare.com/workers/examples/websockets/\n  md: https://developers.cloudflare.com/workers/examples/websockets/index.md\n---\n\nWebSockets allow you to communicate in real time with your Cloudflare Workers serverless functions. In this guide, you will learn the basics of WebSockets on Cloudflare Workers, both from the perspective of writing WebSocket servers in your Workers functions, as well as connecting to and working with those WebSocket servers as a client.\n\nWebSockets are open connections sustained between the client and the origin server. Inside a WebSocket connection, the client and the origin can pass data back and forth without having to reestablish sessions. This makes exchanging data within a WebSocket connection fast. WebSockets are often used for real-time applications such as live chat and gaming.\n\nNote\n\nWebSockets utilize an event-based system for receiving and sending messages, much like the Workers runtime model of responding to events.\n\nNote\n\nIf your application needs to coordinate among multiple WebSocket connections, such as a chat room or game match, you will need clients to send messages to a single-point-of-coordination. Durable Objects provide a single-point-of-coordination for Cloudflare Workers, and are often used in parallel with WebSockets to persist state over multiple clients and connections. In this case, refer to [Durable Objects](https://developers.cloudflare.com/durable-objects/) to get started, and prefer using the Durable Objects' extended [WebSockets API](https://developers.cloudflare.com/durable-objects/best-practices/websockets/).\n\n## Write a WebSocket Server\n\nWebSocket servers in Cloudflare Workers allow you to receive messages from a client in real time. This guide will show you how to set up a WebSocket server in Workers.\n\nA client can make a WebSocket request in the browser by instantiating a new instance of `WebSocket`, passing in the URL for your Workers function:",
      "language": "unknown"
    },
    {
      "code": "Note\n\nFor more details about creating and working with WebSockets in the client, refer to [Writing a WebSocket client](#write-a-websocket-client).\n\nWhen an incoming WebSocket request reaches the Workers function, it will contain an `Upgrade` header, set to the string value `websocket`. Check for this header before continuing to instantiate a WebSocket:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "After you have appropriately checked for the `Upgrade` header, you can create a new instance of `WebSocketPair`, which contains server and client WebSockets. One of these WebSockets should be handled by the Workers function and the other should be returned as part of a `Response` with the [`101` status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/101), indicating the request is switching protocols:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "The `WebSocketPair` constructor returns an Object, with the `0` and `1` keys each holding a `WebSocket` instance as its value. It is common to grab the two WebSockets from this pair using [`Object.values`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Object/values) and [ES6 destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment), as seen in the below example.\n\nIn order to begin communicating with the `client` WebSocket in your Worker, call `accept` on the `server` WebSocket. This will tell the Workers runtime that it should listen for WebSocket data and keep the connection open with your `client` WebSocket:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "WebSockets emit a number of [Events](https://developers.cloudflare.com/workers/runtime-apis/websockets/#events) that can be connected to using `addEventListener`. The below example hooks into the `message` event and emits a `console.log` with the data from it:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* Rust",
      "language": "unknown"
    },
    {
      "code": "* Hono",
      "language": "unknown"
    },
    {
      "code": "### Connect to the WebSocket server from a client\n\nWriting WebSocket clients that communicate with your Workers function is a two-step process: first, create the WebSocket instance, and then attach event listeners to it:",
      "language": "unknown"
    },
    {
      "code": "WebSocket clients can send messages back to the server using the [`send`](https://developers.cloudflare.com/workers/runtime-apis/websockets/#send) function:",
      "language": "unknown"
    },
    {
      "code": "When the WebSocket interaction is complete, the client can close the connection using [`close`](https://developers.cloudflare.com/workers/runtime-apis/websockets/#close):",
      "language": "unknown"
    },
    {
      "code": "For an example of this in practice, refer to the [`websocket-template`](https://github.com/cloudflare/websocket-template) to get started with WebSockets.\n\n## Write a WebSocket client\n\nCloudflare Workers supports the `new WebSocket(url)` constructor. A Worker can establish a WebSocket connection to a remote server in the same manner as the client implementation described above.\n\nAdditionally, Cloudflare supports establishing WebSocket connections by making a fetch request to a URL with the `Upgrade` header set.",
      "language": "unknown"
    },
    {
      "code": "## WebSocket compression\n\nCloudflare Workers supports WebSocket compression. Refer to [WebSocket Compression](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#websocket-compression) for more information.\n\n</page>\n\n<page>\n---\ntitle: JavaScript  Cloudflare Workers docs\ndescription: The Workers platform is designed to be JavaScript standards\n  compliant and web-interoperable, and supports JavaScript standards, as defined\n  by TC39 (ECMAScript). Wherever possible, it uses web platform APIs, so that\n  code can be reused across client and server, as well as across WinterCG\n  JavaScript runtimes.\nlastUpdated: 2025-03-13T11:08:22.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/languages/javascript/\n  md: https://developers.cloudflare.com/workers/languages/javascript/index.md\n---\n\nThe Workers platform is designed to be [JavaScript standards compliant](https://ecma-international.org/publications-and-standards/standards/ecma-262/) and web-interoperable, and supports JavaScript standards, as defined by [TC39](https://tc39.es/) (ECMAScript). Wherever possible, it uses web platform APIs, so that code can be reused across client and server, as well as across [WinterCG](https://wintercg.org/) JavaScript runtimes.\n\nRefer to [Runtime APIs](https://developers.cloudflare.com/workers/runtime-apis/) for more information on specific JavaScript APIs available in Workers.\n\n### Resources\n\n* [Getting Started](https://developers.cloudflare.com/workers/get-started/guide/)\n* [Quickstarts](https://developers.cloudflare.com/workers/get-started/quickstarts/)  More example repos to use as a basis for your projects\n* [TypeScript type definitions](https://github.com/cloudflare/workers-types)\n* [JavaScript and web standard APIs](https://developers.cloudflare.com/workers/runtime-apis/web-standards/)\n* [Tutorials](https://developers.cloudflare.com/workers/tutorials/)\n* [Examples](https://developers.cloudflare.com/workers/examples/?languages=JavaScript)\n\n</page>\n\n<page>\n---\ntitle: Write Cloudflare Workers in Python  Cloudflare Workers docs\ndescription: Write Workers in 100% Python\nlastUpdated: 2025-11-11T15:40:52.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/languages/python/\n  md: https://developers.cloudflare.com/workers/languages/python/index.md\n---\n\nCloudflare Workers provides a first-class Python experience, including support for:\n\n* Easy to install and fast-booting [Packages](https://developers.cloudflare.com/workers/languages/python/packages), including [FastAPI](https://fastapi.tiangolo.com/), [Langchain](https://pypi.org/project/langchain/), [httpx](https://www.python-httpx.org/), [Pydantic](https://docs.pydantic.dev/latest/) and more.\n\n* A robust [foreign function interface (FFI)](https://developers.cloudflare.com/workers/languages/python/ffi) that lets you use JavaScript objects and functions directly from Python including all [Runtime APIs](https://developers.cloudflare.com/workers/runtime-apis/)\n\n* An ecosystem of services on the Workers Platform accessible via [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/), including:\n\n  * State storage and databases like [KV](https://developers.cloudflare.com/kv), [D1](https://developers.cloudflare.com/d1), [Durable Objects](https://developers.cloudflare.com/durable-objects/)\n  * Access to [Environment Variables](https://developers.cloudflare.com/workers/configuration/environment-variables/), [Secrets](https://developers.cloudflare.com/workers/configuration/secrets/), and other Workers using [Service Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/)\n  * AI capabilities with [Workers AI](https://developers.cloudflare.com/workers-ai/), [Vectorize](https://developers.cloudflare.com/vectorize)\n  * File storage with [R2](https://developers.cloudflare.com/r2)\n  * [Durable Workflows](https://developers.cloudflare.com/workflows/), [Queues](https://developers.cloudflare.com/queues/), and [more](https://developers.cloudflare.com/workers/runtime-apis/bindings/)\n\n## Introduction\n\nA Python Worker can be as simple as four lines of code:",
      "language": "unknown"
    },
    {
      "code": "Similar to other Workers, the main entry point for a Python worker is the [`fetch` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch) which handles incoming requests sent to the Worker.\n\nIn a Python Worker, this handler is placed in a `Default` class that extends the `WorkerEntrypoint` class (which you can import from the `workers` SDK module).\n\nPython Workers are in beta.\n\nYou must add the `python_workers` compatibility flag to your Worker, while Python Workers are in open beta. Packages are supported using the [pywrangler](https://developers.cloudflare.com/workers/languages/python/packages) tool.\n\nWe'd love your feedback. Join the #python-workers channel in the [Cloudflare Developers Discord](https://discord.cloudflare.com/) and let us know what you'd like to see next.\n\n### The `pywrangler` CLI tool\n\nTo run a Python Worker locally, install packages, and deploy it to Cloudflare, you use [pywrangler](https://github.com/cloudflare/workers-py), the CLI for Python Workers.\n\nTo set it up, first, ensure [uv](https://docs.astral.sh/uv/#installation) and [Node](https://nodejs.org/en) are installed.\n\nThen set up your development environment:",
      "language": "unknown"
    },
    {
      "code": "This will create a `pyproject.toml` file with `workers-py` as a development dependency. `pywrangler init` will create a wrangler config file. You can then run `pywrangler` with:",
      "language": "unknown"
    },
    {
      "code": "To deploy a Python Worker to Cloudflare, run `pywrangler deploy`:",
      "language": "unknown"
    },
    {
      "code": "### Python Worker Templates\n\nWhen you initialize a new Python Worker project and select from one of many templates:",
      "language": "unknown"
    },
    {
      "code": "Or you can clone the examples repository to explore more options:",
      "language": "unknown"
    },
    {
      "code": "## Next Up\n\n* Learn more about [the basics of Python Workers](https://developers.cloudflare.com/workers/languages/python/basics)\n* Learn details about local development, deployment, and [how to Python Workers work](https://developers.cloudflare.com/workers/languages/python/how-python-workers-work).\n* Explore the [package](https://developers.cloudflare.com/workers/languages/python/packages) docs for instructions on how to use packages with Python Workers.\n* Understand which parts of the [Python Standard Library](https://developers.cloudflare.com/workers/languages/python/stdlib) are supported in Python Workers.\n* Learn about Python Workers' [foreign function interface (FFI)](https://developers.cloudflare.com/workers/languages/python/ffi), and how to use it to work with [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings) and [Runtime APIs](https://developers.cloudflare.com/workers/runtime-apis/).\n\n</page>\n\n<page>\n---\ntitle: Cloudflare Workers  Rust language support  Cloudflare Workers docs\ndescription: Write Workers in 100% Rust using the [`workers-rs`\n  crate](https://github.com/cloudflare/workers-rs)\nlastUpdated: 2025-05-06T10:45:54.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/languages/rust/\n  md: https://developers.cloudflare.com/workers/languages/rust/index.md\n---\n\nCloudflare Workers provides support for Rust via the [`workers-rs` crate](https://github.com/cloudflare/workers-rs), which makes [Runtime APIs](https://developers.cloudflare.com/workers/runtime-apis) and [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/) to developer platform products, such as [Workers KV](https://developers.cloudflare.com/kv/concepts/how-kv-works/), [R2](https://developers.cloudflare.com/r2/), and [Queues](https://developers.cloudflare.com/queues/), available directly from your Rust code.\n\nBy following this guide, you will learn how to build a Worker entirely in the Rust programming language.\n\n## Prerequisites\n\nBefore starting this guide, make sure you have:\n\n* A recent version of [`Rust`](https://rustup.rs/)\n* [`npm`](https://docs.npmjs.com/getting-started)\n* The Rust `wasm32-unknown-unknown` toolchain:",
      "language": "unknown"
    },
    {
      "code": "* And `cargo-generate` sub-command by running:",
      "language": "unknown"
    },
    {
      "code": "## 1. Create a new project with Wrangler\n\nOpen a terminal window, and run the following command to generate a Worker project template in Rust:",
      "language": "unknown"
    },
    {
      "code": "Your project will be created in a new directory that you named, in which you will find the following files and folders:\n\n* `Cargo.toml` - The standard project configuration file for Rust's [`Cargo`](https://doc.rust-lang.org/cargo/) package manager. The template pre-populates some best-practice settings for building for Wasm on Workers.\n* `wrangler.toml` - Wrangler configuration, pre-populated with a custom build command to invoke `worker-build` (Refer to [Wrangler Bundling](https://developers.cloudflare.com/workers/languages/rust/#bundling-worker-build)).\n* `src` - Rust source directory, pre-populated with Hello World Worker.\n\n## 2. Develop locally\n\nAfter you have created your first Worker, run the [`wrangler dev`](https://developers.cloudflare.com/workers/wrangler/commands/#dev) command to start a local server for developing your Worker. This will allow you to test your Worker in development.",
      "language": "unknown"
    },
    {
      "code": "If you have not used Wrangler before, it will try to open your web browser to login with your Cloudflare account.\n\nNote\n\nIf you have issues with this step or you do not have access to a browser interface, refer to the [`wrangler login`](https://developers.cloudflare.com/workers/wrangler/commands/#login) documentation for more information.\n\nGo to <http://localhost:8787> to review your Worker running. Any changes you make to your code will trigger a rebuild, and reloading the page will show you the up-to-date output of your Worker.\n\n## 3. Write your Worker code\n\nWith your new project generated, write your Worker code. Find the entrypoint to your Worker in `src/lib.rs`:",
      "language": "unknown"
    },
    {
      "code": "Note\n\nThere is some counterintuitive behavior going on here:\n\n1. `workers-rs` provides an `event` macro which expects a handler function signature identical to those seen in JavaScript Workers.\n2. `async` is not generally supported by Wasm, but you are able to use `async` in a `workers-rs` project (refer to [`async`](https://developers.cloudflare.com/workers/languages/rust/#async-wasm-bindgen-futures)).\n\n### Related runtime APIs\n\n`workers-rs` provides a runtime API which closely matches Worker's JavaScript API, and enables integration with Worker's platform features. For detailed documentation of the API, refer to [`docs.rs/worker`](https://docs.rs/worker/latest/worker/).\n\n#### `event` macro\n\nThis macro allows you to define entrypoints to your Worker. The `event` macro supports the following events:\n\n* `fetch` - Invoked by an incoming HTTP request.\n* `scheduled` - Invoked by [`Cron Triggers`](https://developers.cloudflare.com/workers/configuration/cron-triggers/).\n* `queue` - Invoked by incoming message batches from [Queues](https://developers.cloudflare.com/queues/) (Requires `queue` feature in `Cargo.toml`, refer to the [`workers-rs` GitHub repository and `queues` feature flag](https://github.com/cloudflare/workers-rs#queues)).\n* `start` - Invoked when the Worker is first launched (such as, to install panic hooks).\n\n#### `fetch` parameters\n\nThe `fetch` handler provides three arguments which match the JavaScript API:\n\n1. **[`Request`](https://docs.rs/worker/latest/worker/struct.Request.html)**\n\nAn object representing the incoming request. This includes methods for accessing headers, method, path, Cloudflare properties, and body (with support for asynchronous streaming and JSON deserialization with [Serde](https://serde.rs/)).\n\n1. **[`Env`](https://docs.rs/worker/latest/worker/struct.Env.html)**\n\nProvides access to Worker [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/).\n\n* [`Secret`](https://github.com/cloudflare/workers-rs/blob/e15f88110d814c2d7759b2368df688433f807694/worker/src/env.rs#L92) - Secret value configured in Cloudflare dashboard or using `wrangler secret put`.\n* [`Var`](https://github.com/cloudflare/workers-rs/blob/e15f88110d814c2d7759b2368df688433f807694/worker/src/env.rs#L92) - Environment variable defined in `wrangler.toml`.\n* [`KvStore`](https://docs.rs/worker-kv/latest/worker_kv/struct.KvStore.html) - Workers [KV](https://developers.cloudflare.com/kv/api/) namespace binding.\n* [`ObjectNamespace`](https://docs.rs/worker/latest/worker/durable/struct.ObjectNamespace.html) - [Durable Object](https://developers.cloudflare.com/durable-objects/) binding.\n* [`Fetcher`](https://docs.rs/worker/latest/worker/struct.Fetcher.html) - [Service binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/) to another Worker.\n* [`Bucket`](https://docs.rs/worker/latest/worker/struct.Bucket.html) - [R2](https://developers.cloudflare.com/r2/) Bucket binding.\n\n1. **[`Context`](https://docs.rs/worker/latest/worker/struct.Context.html)**\n\nProvides access to [`waitUntil`](https://developers.cloudflare.com/workers/runtime-apis/context/#waituntil) (deferred asynchronous tasks) and [`passThroughOnException`](https://developers.cloudflare.com/workers/runtime-apis/context/#passthroughonexception) (fail open) functionality.\n\n#### [`Response`](https://docs.rs/worker/latest/worker/struct.Response.html)\n\nThe `fetch` handler expects a [`Response`](https://docs.rs/worker/latest/worker/struct.Response.html) return type, which includes support for streaming responses to the client asynchronously. This is also the return type of any subrequests made from your Worker. There are methods for accessing status code and headers, as well as streaming the body asynchronously or deserializing from JSON using [Serde](https://serde.rs/).\n\n#### `Router`\n\nImplements convenient [routing API](https://docs.rs/worker/latest/worker/struct.Router.html) to serve multiple paths from one Worker. Refer to the [`Router` example in the `worker-rs` GitHub repository](https://github.com/cloudflare/workers-rs#or-use-the-router).\n\n## 4. Deploy your Worker project\n\nWith your project configured, you can now deploy your Worker, to a `*.workers.dev` subdomain, or a [Custom Domain](https://developers.cloudflare.com/workers/configuration/routing/custom-domains/), if you have one configured. If you have not configured any subdomain or domain, Wrangler will prompt you during the deployment process to set one up.",
      "language": "unknown"
    },
    {
      "code": "Preview your Worker at `<YOUR_WORKER>.<YOUR_SUBDOMAIN>.workers.dev`.\n\nNote\n\nWhen pushing to your `*.workers.dev` subdomain for the first time, you may see [`523` errors](https://developers.cloudflare.com/support/troubleshooting/http-status-codes/cloudflare-5xx-errors/error-523/) while DNS is propagating. These errors should resolve themselves after a minute or so.\n\nAfter completing these steps, you will have a basic Rust-based Worker deployed. From here, you can add crate dependencies and write code in Rust to implement your Worker application. If you would like to know more about the inner workings of how Rust compiled to Wasm is supported by Workers, the next section outlines the libraries and tools involved.\n\n## How this deployment works\n\nWasm Workers are invoked from a JavaScript entrypoint script which is created automatically for you when using `workers-rs`.\n\n### JavaScript Plumbing (`wasm-bindgen`)\n\nTo access platform features such as bindings, Wasm Workers must be able to access methods from the JavaScript runtime API.\n\nThis interoperability is achieved using [`wasm-bindgen`](https://rustwasm.github.io/wasm-bindgen/), which provides the glue code needed to import runtime APIs to, and export event handlers from, the Wasm module. `wasm-bindgen` also provides [`js-sys`](https://docs.rs/js-sys/latest/js_sys/), which implements types for interacting with JavaScript objects. In practice, this is an implementation detail, as `workers-rs`'s API handles conversion to and from JavaScript objects, and interaction with imported JavaScript runtime APIs for you.\n\nNote\n\nIf you are using `wasm-bindgen` without `workers-rs` / `worker-build`, then you will need to patch the JavaScript that it emits. This is because when you import a `wasm` file in Workers, you get a `WebAssembly.Module` instead of a `WebAssembly.Instance` for performance and security reasons.\n\nTo patch the JavaScript that `wasm-bindgen` emits:\n\n1. Run `wasm-pack build --target bundler` as you normally would.\n2. Patch the JavaScript file that it produces (the following code block assumes the file is called `mywasmlib.js`):",
      "language": "unknown"
    },
    {
      "code": "1. In your Worker entrypoint, import the function and use it directly:",
      "language": "unknown"
    },
    {
      "code": "### Async (`wasm-bindgen-futures`)\n\n[`wasm-bindgen-futures`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/) (part of the `wasm-bindgen` project) provides interoperability between Rust Futures and JavaScript Promises. `workers-rs` invokes the entire event handler function using `spawn_local`, meaning that you can program using async Rust, which is turned into a single JavaScript Promise and run on the JavaScript event loop. Calls to imported JavaScript runtime APIs are automatically converted to Rust Futures that can be invoked from async Rust functions.\n\n### Bundling (`worker-build`)\n\nTo run the resulting Wasm binary on Workers, `workers-rs` includes a build tool called [`worker-build`](https://github.com/cloudflare/workers-rs/tree/main/worker-build) which:\n\n1. Creates a JavaScript entrypoint script that properly invokes the module using `wasm-bindgen`'s JavaScript API.\n2. Invokes `web-pack` to minify and bundle the JavaScript code.\n3. Outputs a directory structure that Wrangler can use to bundle and deploy the final Worker.\n\n`worker-build` is invoked by default in the template project using a custom build command specified in the `wrangler.toml` file.\n\n### Binary Size (`wasm-opt`)\n\nUnoptimized Rust Wasm binaries can be large and may exceed Worker bundle size limits or experience long startup times. The template project pre-configures several useful size optimizations in your `Cargo.toml` file:",
      "language": "unknown"
    },
    {
      "code": "Finally, `worker-bundle` automatically invokes [`wasm-opt`](https://github.com/brson/wasm-opt-rs) to further optimize binary size before upload.\n\n## Related resources\n\n* [Rust Wasm Book](https://rustwasm.github.io/docs/book/)\n\n</page>\n\n<page>\n---\ntitle: Write Cloudflare Workers in TypeScript  Cloudflare Workers docs\ndescription: TypeScript is a first-class language on Cloudflare Workers. All\n  APIs provided in Workers are fully typed, and type definitions are generated\n  directly from workerd, the open-source Workers runtime.\nlastUpdated: 2025-07-31T14:58:17.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/languages/typescript/\n  md: https://developers.cloudflare.com/workers/languages/typescript/index.md\n---\n\nTypeScript is a first-class language on Cloudflare Workers. All APIs provided in Workers are fully typed, and type definitions are generated directly from [workerd](https://github.com/cloudflare/workerd), the open-source Workers runtime.\n\nWe recommend you generate types for your Worker by running [`wrangler types`](https://developers.cloudflare.com/workers/wrangler/commands/#types). Cloudflare also publishes type definitions to [GitHub](https://github.com/cloudflare/workers-types) and [npm](https://www.npmjs.com/package/@cloudflare/workers-types) (`npm install -D @cloudflare/workers-types`).\n\n### Generate types that match your Worker's configuration\n\nCloudflare continuously improves [workerd](https://github.com/cloudflare/workerd), the open-source Workers runtime. Changes in workerd can introduce JavaScript API changes, thus changing the respective TypeScript types.\n\nThis means the correct types for your Worker depend on:\n\n1. Your Worker's [compatibility date](https://developers.cloudflare.com/workers/configuration/compatibility-dates/).\n2. Your Worker's [compatibility flags](https://developers.cloudflare.com/workers/configuration/compatibility-flags/).\n3. Your Worker's bindings, which are defined in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration).\n4. Any [module rules](https://developers.cloudflare.com/workers/wrangler/configuration/#bundling) you have specified in your Wrangler configuration file under `rules`.\n\nFor example, the runtime will only allow you to use the [`AsyncLocalStorage`](https://nodejs.org/api/async_context.html#class-asynclocalstorage) class if you have `compatibility_flags = [\"nodejs_als\"]` in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). This should be reflected in the type definitions.\n\nTo ensure that your type definitions always match your Worker's configuration, you can dynamically generate types by running:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "See [the `wrangler types` command docs](https://developers.cloudflare.com/workers/wrangler/commands/#types) for more details.\n\nNote\n\nIf you are running a version of Wrangler that is greater than `3.66.0` but below `4.0.0`, you will need to include the `--experimental-include-runtime` flag. During its experimental release, runtime types were output to a separate file (`.wrangler/types/runtime.d.ts` by default). If you have an older version of Wrangler, you can access runtime types through the `@cloudflare/workers-types` package.\n\nThis will generate a `d.ts` file and (by default) save it to `worker-configuration.d.ts`. This will include `Env` types based on your Worker bindings *and* runtime types based on your Worker's compatibility date and flags.\n\nYou should then add that file to your `tsconfig.json`'s `compilerOptions.types` array. If you have the `nodejs_compat` compatibility flag, you should also install `@types/node`.\n\nYou can commit your types file to git if you wish.\n\nNote\n\nTo ensure that your types are always up-to-date, make sure to run `wrangler types` after any changes to your config file.\n\n### Migrating from `@cloudflare/workers-types` to `wrangler types`\n\nWe recommend you use `wrangler types` to generate runtime types, rather than using the `@cloudflare/workers-types` package, as it generates types based on your Worker's [compatibility date](https://github.com/cloudflare/workerd/tree/main/npm/workers-types#compatibility-dates) and `compatibility flags`, ensuring that types match the exact runtime APIs made available to your Worker.\n\nNote\n\nThere are no plans to stop publishing the `@cloudflare/workers-types` package, which will still be the recommended way to type libraries and shared packages in the workers environment.\n\n#### 1. Uninstall `@cloudflare/workers-types`\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "#### 2. Generate runtime types using Wrangler\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "This will generate a `.d.ts` file, saved to `worker-configuration.d.ts` by default. This will also generate `Env` types. If for some reason you do not want to include those, you can set `--include-env=false`.\n\nYou can now remove any imports from `@cloudflare/workers-types` in your Worker code.\n\nNote\n\nIf you are running a version of Wrangler that is greater than `3.66.0` but below `4.0.0`, you will need to include the `--experimental-include-runtime` flag. During its experimental release, runtime types were output to a separate file (`.wrangler/types/runtime.d.ts` by default). If you have an older version of Wrangler, you can access runtime types through the `@cloudflare/workers-types` package.\n\n#### 3. Make sure your `tsconfig.json` includes the generated types",
      "language": "unknown"
    },
    {
      "code": "Note that if you have specified a custom path for the runtime types file, you should use that in your `compilerOptions.types` array instead of the default path.\n\n#### 4. Add @types/node if you are using [`nodejs_compat`](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) (Optional)\n\nIf you are using the `nodejs_compat` compatibility flag, you should also install `@types/node`.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Then add this to your `tsconfig.json`.",
      "language": "unknown"
    },
    {
      "code": "#### 5. Update your scripts and CI pipelines\n\nRegardless of your specific framework or build tools, you should run the `wrangler types` command before any tasks that rely on TypeScript.\n\nMost projects will have existing build and development scripts, as well as some type-checking. In the example below, we're adding the `wrangler types` before the type-checking script in the project:",
      "language": "unknown"
    },
    {
      "code": "We recommend you commit your generated types file for use in CI. Alternatively, you can run `wrangler types` before other CI commands, as it should not take more than a few seconds. For example:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "### Resources\n\n* [TypeScript template](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare/templates/hello-world/ts)\n* [@cloudflare/workers-types](https://github.com/cloudflare/workers-types)\n* [Runtime APIs](https://developers.cloudflare.com/workers/runtime-apis/)\n* [TypeScript Examples](https://developers.cloudflare.com/workers/examples/?languages=TypeScript)\n\n</page>\n\n<page>\n---\ntitle: DevTools  Cloudflare Workers docs\ndescription: When running your Worker locally using the Wrangler CLI (wrangler\n  dev) or using Vite with the Cloudflare Vite plugin, you automatically have\n  access to Cloudflare's implementation of Chrome DevTools.\nlastUpdated: 2025-07-07T18:08:08.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/observability/dev-tools/\n  md: https://developers.cloudflare.com/workers/observability/dev-tools/index.md\n---\n\n## Using DevTools\n\nWhen running your Worker locally using the [Wrangler CLI](https://developers.cloudflare.com/workers/wrangler/) (`wrangler dev`) or using [Vite](https://vite.dev/) with the [Cloudflare Vite plugin](https://developers.cloudflare.com/workers/vite-plugin/), you automatically have access to [Cloudflare's implementation](https://github.com/cloudflare/workers-sdk/tree/main/packages/chrome-devtools-patches) of [Chrome DevTools](https://developer.chrome.com/docs/devtools/overview).\n\nYou can use Chrome DevTools to:\n\n* View logs directly in the Chrome console\n* [Debug code by setting breakpoints](https://developers.cloudflare.com/workers/observability/dev-tools/breakpoints/)\n* [Profile CPU usage](https://developers.cloudflare.com/workers/observability/dev-tools/cpu-usage/)\n* [Observe memory usage and debug memory leaks in your code that can cause out-of-memory (OOM) errors](https://developers.cloudflare.com/workers/observability/dev-tools/memory-usage/)\n\n## Opening DevTools\n\n### Wrangler\n\n* Run your Worker locally, by running `wrangler dev`\n* Press the `D` key from your terminal to open DevTools in a browser tab\n\n### Vite\n\n* Run your Worker locally by running `vite`\n* In a new Chrome tab, open the debug URL that shows in your console (for example, `http://localhost:5173/__debug`)\n\n### Dashboard editor & playground\n\nBoth the [Cloudflare dashboard](https://dash.cloudflare.com/) and the [Worker's Playground](https://workers.cloudflare.com/playground) include DevTools in the UI.\n\n## Related resources\n\n* [Local development](https://developers.cloudflare.com/workers/development-testing/) - Develop your Workers and connected resources locally via Wrangler and workerd, for a fast, accurate feedback loop.\n\n</page>\n\n<page>\n---\ntitle: Errors and exceptions  Cloudflare Workers docs\ndescription: Review Workers errors and exceptions.\nlastUpdated: 2025-10-20T22:30:37.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/observability/errors/\n  md: https://developers.cloudflare.com/workers/observability/errors/index.md\n---\n\nReview Workers errors and exceptions.\n\n## Error pages generated by Workers\n\nWhen a Worker running in production has an error that prevents it from returning a response, the client will receive an error page with an error code, defined as follows:\n\n| Error code | Meaning |\n| - | - |\n| `1101` | Worker threw a JavaScript exception. |\n| `1102` | Worker exceeded [CPU time limit](https://developers.cloudflare.com/workers/platform/limits/#cpu-time). |\n| `1103` | The owner of this worker needs to contact [Cloudflare Support](https://developers.cloudflare.com/support/contacting-cloudflare-support/) |\n| `1015` | Worker hit the [burst rate limit](https://developers.cloudflare.com/workers/platform/limits/#burst-rate). |\n| `1019` | Worker hit [loop limit](#loop-limit). |\n| `1021` | Worker has requested a host it cannot access. |\n| `1022` | Cloudflare has failed to route the request to the Worker. |\n| `1024` | Worker cannot make a subrequest to a Cloudflare-owned IP address. |\n| `1027` | Worker exceeded free tier [daily request limit](https://developers.cloudflare.com/workers/platform/limits/#daily-request). |\n| `1042` | Worker tried to fetch from another Worker on the same zone, which is only [supported](https://developers.cloudflare.com/workers/runtime-apis/fetch/) when the [`global_fetch_strictly_public` compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#global-fetch-strictly-public) is used. |\n| `10162` | Module has an unsupported Content-Type. |\n\nOther `11xx` errors generally indicate a problem with the Workers runtime itself. Refer to the [status page](https://www.cloudflarestatus.com) if you are experiencing an error.\n\n### Loop limit\n\nA Worker cannot call itself or another Worker more than 16 times. In order to prevent infinite loops between Workers, the [`CF-EW-Via`](https://developers.cloudflare.com/fundamentals/reference/http-headers/#cf-ew-via) header's value is an integer that indicates how many invocations are left. Every time a Worker is invoked, the integer will decrement by 1. If the count reaches zero, a [`1019`](#error-pages-generated-by-workers) error is returned.\n\n### \"The script will never generate a response\" errors\n\nSome requests may return a 1101 error with `The script will never generate a response` in the error message. This occurs when the Workers runtime detects that all the code associated with the request has executed and no events are left in the event loop, but a Response has not been returned.\n\n#### Cause 1: Unresolved Promises\n\nThis is most commonly caused by relying on a Promise that is never resolved or rejected, which is required to return a Response. To debug, look for Promises within your code or dependencies' code that block a Response, and ensure they are resolved or rejected.\n\nIn browsers and other JavaScript runtimes, equivalent code will hang indefinitely, leading to both bugs and memory leaks. The Workers runtime throws an explicit error to help you debug.\n\nIn the example below, the Response relies on a Promise resolution that never happens. Uncommenting the `resolve` callback solves the issue.",
      "language": "unknown"
    },
    {
      "code": "You can prevent this by enforcing the [`no-floating-promises` eslint rule](https://typescript-eslint.io/rules/no-floating-promises/), which reports when a Promise is created and not properly handled.\n\n#### Cause 2: WebSocket connections that are never closed\n\nIf a WebSocket is missing the proper code to close its server-side connection, the Workers runtime will throw a `script will never generate a response` error. In the example below, the `'close'` event from the client is not properly handled by calling `server.close()`, and the error is thrown. In order to avoid this, ensure that the WebSocket's server-side connection is properly closed via an event listener or other server-side logic.",
      "language": "unknown"
    },
    {
      "code": "### \"Illegal invocation\" errors\n\nThe error message `TypeError: Illegal invocation: function called with incorrect this reference` can be a source of confusion.\n\nThis is typically caused by calling a function that calls `this`, but the value of `this` has been lost.\n\nFor example, given an `obj` object with the `obj.foo()` method which logic relies on `this`, executing the method via `obj.foo();` will make sure that `this` properly references the `obj` object. However, assigning the method to a variable, e.g.`const func = obj.foo;` and calling such variable, e.g. `func();` would result in `this` being `undefined`. This is because `this` is lost when the method is called as a standalone function. This is standard behavior in JavaScript.\n\nIn practice, this is often seen when destructuring runtime provided Javascript objects that have functions that rely on the presence of `this`, such as `ctx`.\n\nThe following code will error:",
      "language": "unknown"
    },
    {
      "code": "Avoid destructuring or re-bind the function to the original context to avoid the error.\n\nThe following code will run properly:",
      "language": "unknown"
    },
    {
      "code": "### Cannot perform I/O on behalf of a different request",
      "language": "unknown"
    },
    {
      "code": "This error occurs when you attempt to share input/output (I/O) objects (such as streams, requests, or responses) created by one invocation of your Worker in the context of a different invocation.\n\nIn Cloudflare Workers, each invocation is handled independently and has its own execution context. This design ensures optimal performance and security by isolating requests from one another. When you try to share I/O objects between different invocations, you break this isolation. Since these objects are tied to the specific request they were created in, accessing them from another request's handler is not allowed and leads to the error.\n\nThis error is most commonly caused by attempting to cache an I/O object, like a [Request](https://developers.cloudflare.com/workers/runtime-apis/request/) in global scope, and then access it in a subsequent request. For example, if you create a Worker and run the following code in local development, and make two requests to your Worker in quick succession, you can reproduce this error:",
      "language": "unknown"
    },
    {
      "code": "You can fix this by instead storing only the data in global scope, rather than the I/O object itself:",
      "language": "unknown"
    },
    {
      "code": "If you need to share state across requests, consider using [Durable Objects](https://developers.cloudflare.com/durable-objects/). If you need to cache data across requests, consider using [Workers KV](https://developers.cloudflare.com/kv/).\n\n## Errors on Worker upload\n\nThese errors occur when a Worker is uploaded or modified.\n\n| Error code | Meaning |\n| - | - |\n| `10006` | Could not parse your Worker's code. |\n| `10007` | Worker or [workers.dev subdomain](https://developers.cloudflare.com/workers/configuration/routing/workers-dev/) not found. |\n| `10015` | Account is not entitled to use Workers. |\n| `10016` | Invalid Worker name. |\n| `10021` | Validation Error. Refer to [Validation Errors](https://developers.cloudflare.com/workers/observability/errors/#validation-errors-10021) for details. |\n| `10026` | Could not parse request body. |\n| `10027` | The uploaded Worker exceeded the [Worker size limits](https://developers.cloudflare.com/workers/platform/limits/#worker-size). |\n| `10035` | Multiple attempts to modify a resource at the same time |\n| `10037` | An account has exceeded the number of [Workers allowed](https://developers.cloudflare.com/workers/platform/limits/#number-of-workers). |\n| `10052` | A [binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/) is uploaded without a name. |\n| `10054` | A environment variable or secret exceeds the [size limit](https://developers.cloudflare.com/workers/platform/limits/#environment-variables). |\n| `10055` | The number of environment variables or secrets exceeds the [limit/Worker](https://developers.cloudflare.com/workers/platform/limits/#environment-variables). |\n| `10056` | [Binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/) not found. |\n| `10068` | The uploaded Worker has no registered [event handlers](https://developers.cloudflare.com/workers/runtime-apis/handlers/). |\n| `10069` | The uploaded Worker contains [event handlers](https://developers.cloudflare.com/workers/runtime-apis/handlers/) unsupported by the Workers runtime. |\n\n### Validation Errors (10021)\n\nThe 10021 error code includes all errors that occur when you attempt to deploy a Worker, and Cloudflare then attempts to load and run the top-level scope (everything that happens before your Worker's [handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/) is invoked). For example, if you attempt to deploy a broken Worker with invalid JavaScript that would throw a `SyntaxError`  Cloudflare will not deploy your Worker.\n\nSpecific error cases include but are not limited to:\n\n#### Script startup exceeded CPU time limit\n\nThis means that you are doing work in the top-level scope of your Worker that takes more than the [startup time limit (1s)](https://developers.cloudflare.com/workers/platform/limits/#worker-startup-time) of CPU time.\n\n#### Script startup exceeded memory limit\n\nThis means that you are doing work in the top-level scope of your Worker that allocates more than the [memory limit (128 MB)](https://developers.cloudflare.com/workers/platform/limits/#memory) of memory.\n\n## Runtime errors\n\nRuntime errors will occur within the runtime, do not throw up an error page, and are not visible to the end user. Runtime errors are detected by the user with logs.\n\n| Error message | Meaning |\n| - | - |\n| `Network connection lost` | Connection failure. Catch a `fetch` or binding invocation and retry it. |\n| `Memory limit` `would be exceeded` `before EOF` | Trying to read a stream or buffer that would take you over the [memory limit](https://developers.cloudflare.com/workers/platform/limits/#memory). |\n| `daemonDown` | A temporary problem invoking the Worker. |\n\n## Identify errors: Workers Metrics\n\nTo review whether your application is experiencing any downtime or returning any errors:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. In **Overview**, select your Worker and review your Worker's metrics.\n\n### Worker Errors\n\nThe **Errors by invocation status** chart shows the number of errors broken down into the following categories:\n\n| Error | Meaning |\n| - | - |\n| `Uncaught Exception` | Your Worker code threw a JavaScript exception during execution. |\n| `Exceeded CPU Time Limits` | Worker exceeded CPU time limit or other resource constraints. |\n| `Exceeded Memory` | Worker exceeded the memory limit during execution. |\n| `Internal` | An internal error occurred in the Workers runtime. |\n\nThe **Client disconnected by type** chart shows the number of client disconnect errors broken down into the following categories:\n\n| Client Disconnects | Meaning |\n| - | - |\n| `Response Stream Disconnected` | Connection was terminated during the deferred proxying stage of a Worker request flow. It commonly appears for longer lived connections such as [WebSockets](https://developers.cloudflare.com/workers/runtime-apis/websockets/). |\n| `Cancelled` | The Client disconnected before the Worker completed its response. |\n\n## Debug exceptions with Workers Logs\n\n[Workers Logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs) is a powerful tool for debugging your Workers. It shows all the historic logs generated by your Worker, including any uncaught exceptions that occur during execution.\n\nTo find all your errors in Workers Logs, you can use the following filter: `$metadata.error EXISTS`. This will show all the logs that have an error associated with them. You can also filter by `$workers.outcome` to find the requests that resulted in an error. For example, you can filter by `$workers.outcome = \"exception\"` to find all the requests that resulted in an uncaught exception.\n\nAll the possible outcome values can be found in the [Workers Trace Event](https://developers.cloudflare.com/logs/logpush/logpush-job/datasets/account/workers_trace_events/#outcome) reference.\n\n## Debug exceptions from `Wrangler`\n\nTo debug your worker via wrangler use `wrangler tail` to inspect and fix the exceptions.\n\nExceptions will show up under the `exceptions` field in the JSON returned by `wrangler tail`. After you have identified the exception that is causing errors, redeploy your code with a fix, and continue tailing the logs to confirm that it is fixed.\n\n## Set up a 3rd party logging service\n\nA Worker can make HTTP requests to any HTTP service on the public Internet. You can use a service like [Sentry](https://sentry.io) to collect error logs from your Worker, by making an HTTP request to the service to report the error. Refer to your services API documentation for details on what kind of request to make.\n\nWhen using an external logging strategy, remember that outstanding asynchronous tasks are canceled as soon as a Worker finishes sending its main response body to the client. To ensure that a logging subrequest completes, pass the request promise to [`event.waitUntil()`](https://developer.mozilla.org/en-US/docs/Web/API/ExtendableEvent/waitUntil). For example:\n\n* Module Worker",
      "language": "unknown"
    },
    {
      "code": "* Service Worker\n\n  Service Workers are deprecated\n\n  Service Workers are deprecated, but still supported. We recommend using [Module Workers](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) instead. New features may not be supported for Service Workers.",
      "language": "unknown"
    },
    {
      "code": "## Collect and persist Wasm core dumps\n\nConfigure the [Wasm Coredump Service](https://github.com/cloudflare/wasm-coredump) to collect coredumps from your Rust Workers applications and persist them to logs, Sentry, or R2 for analysis with [wasmgdb](https://github.com/xtuc/wasm-coredump/tree/main/bin/wasmgdb). Read the [blog post](https://blog.cloudflare.com/wasm-coredumps/) for more details.\n\n## Go to origin on error\n\nBy using [`event.passThroughOnException`](https://developers.cloudflare.com/workers/runtime-apis/context/#passthroughonexception), a Workers application will forward requests to your origin if an exception is thrown during the Worker's execution. This allows you to add logging, tracking, or other features with Workers, without degrading your application's functionality.\n\n* Module Worker",
      "language": "unknown"
    },
    {
      "code": "* Service Worker\n\n  Service Workers are deprecated\n\n  Service Workers are deprecated, but still supported. We recommend using [Module Workers](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/) instead. New features may not be supported for Service Workers.",
      "language": "unknown"
    },
    {
      "code": "## Related resources\n\n* [Log from Workers](https://developers.cloudflare.com/workers/observability/logs/) - Learn how to log your Workers.\n* [Logpush](https://developers.cloudflare.com/workers/observability/logs/logpush/) - Learn how to push Workers Trace Event Logs to supported destinations.\n* [RPC error handling](https://developers.cloudflare.com/workers/runtime-apis/rpc/error-handling/) - Learn how to handle errors from remote-procedure calls.\n\n</page>\n\n<page>\n---\ntitle: Exporting OpenTelemetry Data  Cloudflare Workers docs\ndescription: Cloudflare Workers supports exporting OpenTelemetry\n  (OTel)-compliant telemetry data to any destination with an available OTel\n  endpoint, allowing you to integrate with your existing monitoring and\n  observability stack.\nlastUpdated: 2025-11-10T09:55:27.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/observability/exporting-opentelemetry-data/\n  md: https://developers.cloudflare.com/workers/observability/exporting-opentelemetry-data/index.md\n---\n\nCloudflare Workers supports exporting OpenTelemetry (OTel)-compliant telemetry data to any destination with an available OTel endpoint, allowing you to integrate with your existing monitoring and observability stack.\n\n### Supported telemetry types\n\nYou can export the following types of telemetry data:\n\n* **Traces** - Traces showing request flows through your Worker and connected services\n* **Logs** - Application logs including `console.log()` output and system-generated logs\n\n**Note**: exporting Worker metrics and custom metrics is not yet supported.\n\n### Available OpenTelemetry destinations\n\nBelow are common OTLP endpoint formats for popular observability providers. Refer to your provider's documentation for specific details and authentication requirements.\n\n| Provider | Traces Endpoint | Logs Endpoint |\n| - | - | - |\n| [**Honeycomb**](https://developers.cloudflare.com/workers/observability/exporting-opentelemetry-data/honeycomb/) | `https://api.honeycomb.io/v1/traces` | `https://api.honeycomb.io/v1/logs` |\n| [**Grafana Cloud**](https://developers.cloudflare.com/workers/observability/exporting-opentelemetry-data/grafana-cloud/) | `https://otlp-gateway-{region}.grafana.net/otlp/v1/traces` | `https://otlp-gateway-{region}.grafana.net/otlp/v1/logs`\\[^1] |\n| [**Axiom**](https://developers.cloudflare.com/workers/observability/exporting-opentelemetry-data/axiom/) | `https://api.axiom.co/v1/traces` | `https://api.axiom.co/v1/logs` |\n| [**Sentry**](https://developers.cloudflare.com/workers/observability/exporting-opentelemetry-data/sentry/) | `https://{HOST}/api/{PROJECT_ID}/integration/otlp/v1/traces` | `https://{HOST}/api/{PROJECT_ID}/integration/otlp/v1/logs` |\n| [**Datadog**](https://docs.datadoghq.com/opentelemetry/setup/otlp_ingest/) | Coming soon, pending release from Datadog | `https://otlp.{SITE}.datadoghq.com/v1/logs` |\n\nAuthentication\n\nMost providers require authentication headers. Refer to your provider's documentation for specific authentication requirements.\n\n## Setting up OpenTelemetry-compatible destinations\n\nTo start sending data to your destination, you'll need to create a destination in the Cloudflare dashboard.\n\n### Creating a destination\n\n![Observability Destinations dashboard showing configured destinations for Grafana and Honeycomb with their respective endpoints and status](https://developers.cloudflare.com/_astro/destinations.B-CW_OSI_1OgD00.webp)\n\n1. Head to your account's [Workers Observability](https://dash.cloudflare.com/?to=/:account/workers-and-pages/observability/pipelines) section of the dashboard\n\n2. Click add destination.\n\n3. Configure your destination:\n\n   * **Destination Name** - A descriptive name (e.g., \"Grafana-tracing\", \"Honeycomb-Logs\")\n   * **Destination Type** - Choose between \"Traces\" or \"Logs\"\n   * **OTLP Endpoint** - The URL where your observability platform accepts OTLP data.\n   * **Custom Headers** (Optional) - Any authentication headers or other provider-required headers\n\n4. Save your destination\n\n![Edit Destination dialog showing configuration for Honeycomb tracing with destination name, type selection, OTLP endpoint, and custom headers](https://developers.cloudflare.com/_astro/destination-setup.B8cxx8yd_ZLFqNV.webp)\n\n## Enabling OpenTelemetry export for your Worker\n\nAfter setting up destinations in the dashboard, configure your Worker to export telemetry data by updating your Wrangler configuration. Your destination name configured in your configuration file should be the same as the destination configured in the dashboard.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Once you've configured your Wrangler configuration file, redeploy your Worker for new configurations to take effect. Note that it may take a few minutes for events to reach your destination.\n\n## Destination status\n\nAfter creating a destination, you can monitor its health and delivery status in the Cloudflare dashboard. Each destination displays a status indicator that shows how recently data was successfully delivered.\n\n### Status indicators\n\n| Status | Description | Troubleshooting |\n| - | - | - |\n| **Last: n minutes ago** | Data was recently delivered successfully. | |\n| **Never run** | No data has been delivered to this destination. | Check if your Worker is receving traffic  Review sampling rates (low rates generate less data)  |\n| **Error** | An error occurred while attempting to deliver data to this destination. |  Verify OTLP endpoint URL is correct  Check authentication headers are valid  |\n\n## Limits and pricing\n\nExporting OTel data is currently **free** to those currently on a Workers Paid subscription or higher during the early beta period. However, starting on **`January 15, 2026`**, tracing will be billed as part of your usage on the Workers Paid plan or contract.\n\nThis includes the following limits and pricing:\n\n| Plan | Traces | Logs | Pricing |\n| - | - | - | - |\n| **Workers Free** | Not available | Not available | - |\n| **Workers Paid** | 10 million events per month included | 10 million events per month included | $0.05 per million additional events |\n\n## Known limitations\n\nOpenTelemetry data export is currently in beta. Please be aware of the following limitations:\n\n* **Metrics export not yet supported**: Exporting Worker infrastructure metrics and custom metrics via OpenTelemetry is not currently available. We are actively working to add metrics support in the future.\n* **Limited OTLP support from some providers**: Some observability providers are still rolling out OTLP endpoint support. Check the [Available OpenTelemetry destinations](#available-opentelemetry-destinations) table above for current availability.\n\n</page>\n\n<page>\n---\ntitle: Logs  Cloudflare Workers docs\ndescription: Logs are an important component of a developer's toolkit to\n  troubleshoot and diagnose application issues and maintaining system health.\n  The Cloudflare Developer Platform offers many tools to help developers manage\n  their application's logs.\nlastUpdated: 2025-08-15T16:51:05.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/observability/logs/\n  md: https://developers.cloudflare.com/workers/observability/logs/index.md\n---\n\nLogs are an important component of a developer's toolkit to troubleshoot and diagnose application issues and maintaining system health. The Cloudflare Developer Platform offers many tools to help developers manage their application's logs.\n\n## [Workers Logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs)\n\nAutomatically ingest, filter, and analyze logs emitted from Cloudflare Workers in the Cloudflare dashboard.\n\n## [Real-time logs](https://developers.cloudflare.com/workers/observability/logs/real-time-logs)\n\nAccess log events in near real-time. Real-time logs provide immediate feedback and visibility into the health of your Cloudflare Worker.\n\n## [Tail Workers](https://developers.cloudflare.com/workers/observability/logs/tail-workers) Beta\n\nTail Workers allow developers to apply custom filtering, sampling, and transformation logic to telemetry data.\n\n## [Workers Logpush](https://developers.cloudflare.com/workers/observability/logs/logpush)\n\nSend Workers Trace Event Logs to a supported destination. Workers Logpush includes metadata about requests and responses, unstructured `console.log()` messages and any uncaught exceptions.\n\n## Video Tutorial\n\n</page>\n\n<page>\n---\ntitle: MCP server  Cloudflare Workers docs\nlastUpdated: 2025-10-09T17:32:08.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/observability/mcp-server/\n  md: https://developers.cloudflare.com/workers/observability/mcp-server/index.md\n---\n\n\n</page>\n\n<page>\n---\ntitle: Metrics and analytics  Cloudflare Workers docs\ndescription: Diagnose issues with Workers metrics, and review request data for a\n  zone with Workers analytics.\nlastUpdated: 2025-11-17T14:08:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/observability/metrics-and-analytics/\n  md: https://developers.cloudflare.com/workers/observability/metrics-and-analytics/index.md\n---\n\nThere are two graphical sources of information about your Workers traffic at a given time: Workers metrics and zone-based Workers analytics.\n\nWorkers metrics can help you diagnose issues and understand your Workers' workloads by showing performance and usage of your Workers. If your Worker runs on a route on a zone, or on a few zones, Workers metrics will show how much traffic your Worker is handling on a per-zone basis, and how many requests your site is getting.\n\nZone analytics show how much traffic all Workers assigned to a zone are handling.\n\n## Workers metrics\n\nWorkers metrics aggregate request data for an individual Worker (if your Worker is running across multiple domains, and on `*.workers.dev`, metrics will aggregate requests across them). To view your Worker's metrics:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. In **Overview**, select your Worker to view its metrics.\n\nThere are two metrics that can help you understand the health of your Worker in a given moment: requests success and error metrics, and invocation statuses.\n\n### Requests\n\nThe first graph shows historical request counts from the Workers runtime broken down into successful requests, errored requests, and subrequests.\n\n* **Total**: All incoming requests registered by a Worker. Requests blocked by [WAF](https://www.cloudflare.com/waf/) or other security features will not count.\n* **Success**: Requests that returned a Success or Client Disconnected invocation status.\n* **Errors**: Requests that returned a Script Threw Exception, Exceeded Resources, or Internal Error invocation status  refer to [Invocation Statuses](https://developers.cloudflare.com/workers/observability/metrics-and-analytics/#invocation-statuses) for a breakdown of where your errors are coming from.\n\nRequest traffic data may display a drop off near the last few minutes displayed in the graph for time ranges less than six hours. This does not reflect a drop in traffic, but a slight delay in aggregation and metrics delivery.\n\n### Subrequests\n\nSubrequests are requests triggered by calling `fetch` from within a Worker. A subrequest that throws an uncaught error will not be counted.\n\n* **Total**: All subrequests triggered by calling `fetch` from within a Worker.\n* **Cached**: The number of cached responses returned.\n* **Uncached**: The number of uncached responses returned.\n\n### Wall time per execution\n\nWall time represents the elapsed time in milliseconds between the start of a Worker invocation, and when the Workers runtime determines that no more JavaScript needs to run. Specifically, wall time per execution chart measures the wall time that the JavaScript context remained open  including time spent waiting on I/O, and time spent executing in your Worker's [`waitUntil()`](https://developers.cloudflare.com/workers/runtime-apis/context/#waituntil) handler. Wall time is not the same as the time it takes your Worker to send the final byte of a response back to the client - wall time can be higher, if tasks within `waitUntil()` are still running after the response has been sent, or it can be lower. For example, when returning a response with a large body, the Workers runtime can, in some cases, determine that no more JavaScript needs to run, and closes the JavaScript context before all the bytes have passed through and been sent.\n\nThe Wall Time per execution chart shows historical wall time data broken down into relevant quantiles using [reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling). Learn more about [interpreting quantiles](https://www.statisticshowto.com/quantile-definition-find-easy-steps/).\n\n### CPU Time per execution\n\nThe CPU Time per execution chart shows historical CPU time data broken down into relevant quantiles using [reservoir sampling](https://en.wikipedia.org/wiki/Reservoir_sampling). Learn more about [interpreting quantiles](https://www.statisticshowto.com/quantile-definition-find-easy-steps/). In some cases, higher quantiles may appear to exceed [CPU time limits](https://developers.cloudflare.com/workers/platform/limits/#cpu-time) without generating invocation errors because of a mechanism in the Workers runtime that allows rollover CPU time for requests below the CPU limit.\n\n### Execution duration (GB-seconds)\n\nThe Duration per request chart shows historical [duration](https://developers.cloudflare.com/workers/platform/limits/#duration) per Worker invocation. The data is broken down into relevant quantiles, similar to the CPU time chart. Learn more about [interpreting quantiles](https://www.statisticshowto.com/quantile-definition-find-easy-steps/). Understanding duration on your Worker is especially useful when you are intending to do a significant amount of computation on the Worker itself.\n\n### Invocation statuses\n\nTo review invocation statuses:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. Select your Worker.\n\n3. Find the **Summary** graph in **Metrics**.\n\n4. Select **Errors**.\n\nWorker invocation statuses indicate whether a Worker executed successfully or failed to generate a response in the Workers runtime. Invocation statuses differ from HTTP status codes. In some cases, a Worker invocation succeeds but does not generate a successful HTTP status because of another error encountered outside of the Workers runtime. Some invocation statuses result in a [Workers error code](https://developers.cloudflare.com/workers/observability/errors/#error-pages-generated-by-workers) being returned to the client.\n\n| Invocation status | Definition | Workers error code | GraphQL field |\n| - | - | - | - |\n| Success | Worker executed successfully | | `success` |\n| Client disconnected | HTTP client (that is, the browser) disconnected before the request completed | | `clientDisconnected` |\n| Worker threw exception | Worker threw an unhandled JavaScript exception | 1101 | `scriptThrewException` |\n| Exceeded resources | Worker exceeded runtime limits | 1102, 1027 | `exceededResources` |\n| Internal error | Workers runtime encountered an error | | `internalError` |\n\n The Exceeded Resources status may appear when the Worker exceeds a [runtime limit](https://developers.cloudflare.com/workers/platform/limits/#request-limits). The most common cause is excessive CPU time, but is also caused by a Worker exceeding startup time or free tier limits.\n\n The Internal Error status may appear when the Workers runtime fails to process a request due to an internal failure in our system. These errors are not caused by any issue with the Worker code nor any resource limit. While requests with Internal Error status are rare, some may appear during normal operation. These requests are not counted towards usage for billing purposes. If you notice an elevated rate of requests with Internal Error status, review [www.cloudflarestatus.com](https://www.cloudflarestatus.com/).\n\nTo further investigate exceptions, use [`wrangler tail`](https://developers.cloudflare.com/workers/wrangler/commands/#tail).\n\n### Request duration\n\nThe request duration chart shows how long it took your Worker to respond to requests, including code execution and time spent waiting on I/O. The request duration chart is currently only available when your Worker has [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement) enabled.\n\nIn contrast to [execution duration](https://developers.cloudflare.com/workers/observability/metrics-and-analytics/#execution-duration-gb-seconds), which measures only the time a Worker is active, request duration measures from the time a request comes into a data center until a response is delivered.\n\nThe data shows the duration for requests with Smart Placement enabled compared to those with Smart Placement disabled (by default, 1% of requests are routed with Smart Placement disabled). The chart shows a histogram with duration across the x-axis and the percentage of requests that fall into the corresponding duration on the y-axis.\n\n### Metrics retention\n\nWorker metrics can be inspected for up to three months in the past in maximum increments of one week.\n\n## Zone analytics\n\nZone analytics aggregate request data for all Workers assigned to any [routes](https://developers.cloudflare.com/workers/configuration/routing/routes/) defined for a zone.\n\nTo review zone metrics:\n\nIn the Cloudflare dashboard, go to the **Workers Analytics** page for your zone.\n\n[Go to **Workers**](https://dash.cloudflare.com/?to=/:account/:zone/analytics/workers)\n\nZone data can be scoped by time range within the last 30 days. The dashboard includes charts and information described below.\n\n### Subrequests\n\nThis chart shows subrequests  requests triggered by calling `fetch` from within a Worker  broken down by cache status.\n\n* **Uncached**: Requests answered directly by your origin server or other servers responding to subrequests.\n* **Cached**: Requests answered by Cloudflares [cache](https://www.cloudflare.com/learning/cdn/what-is-caching/). As Cloudflare caches more of your content, it accelerates content delivery and reduces load on your origin.\n\n### Bandwidth\n\nThis chart shows historical bandwidth usage for all Workers on a zone broken down by cache status.\n\n### Status codes\n\nThis chart shows historical requests for all Workers on a zone broken down by HTTP status code.\n\n### Total requests\n\nThis chart shows historical data for all Workers on a zone broken down by successful requests, failed requests, and subrequests. These request types are categorized by HTTP status code where `200`-level requests are successful and `400` to `500`-level requests are failed.\n\n## GraphQL\n\nWorker metrics are powered by GraphQL. Learn more about querying our data sets in the [Querying Workers Metrics with GraphQL tutorial](https://developers.cloudflare.com/analytics/graphql-api/tutorials/querying-workers-metrics/).\n\n</page>\n\n<page>\n---\ntitle: Query Builder  Cloudflare Workers docs\ndescription: Write structured queries to investigate and visualize your telemetry data.\nlastUpdated: 2025-10-28T12:06:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/observability/query-builder/\n  md: https://developers.cloudflare.com/workers/observability/query-builder/index.md\n---\n\nThe Query Builder helps you write structured queries to investigate and visualize your telemetry data. The Query Builder searches the Workers Observability dataset, which currently includes all logs stored by [Workers Logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/).\n\nThe Query Builder can be found in the **Observability** page of the Cloudflare dashboard:\n\n[Go to **Observability**](https://dash.cloudflare.com/?to=/:account/workers-and-pages/observability)\n\n## Enable Query Builder\n\nThe Query Builder is available to all developers and requires no enablement. Queries search all Workers Logs stored by Cloudflare. If you have not yet enabled Workers Logs, you can do so by adding the following setting to your [Worker's Wrangler file](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#enable-workers-logs) and redeploying your Worker.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## Write a query in the Cloudflare dashboard\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. Select your Worker.\n\n3. Select **Observability** in the left-hand navigation panel, and then the **Investigate** tab.\n\n4. Select a **Visualization**.\n\n5. Optional: Add fields to Filter, Group By, Order By, and Limit. For more information, see what [composes a query](https://developers.cloudflare.com/workers/observability/query-builder/#query-composition).\n\n6. Optional: Select the appropriate time range.\n\n7. Select **Run**. The query will automatically run whenever changes are made.\n\n## Query composition\n\n### Visualization\n\nThe Query Builder supports many visualization operators, including:\n\n| Function | Arguments | Description |\n| - | - | - |\n| **Count** | n/a | The total number of rows matching the query conditions |\n| **Count Distinct** | any field | The number of occurrences of the unique values in the dataset |\n| **Min** | numeric field | The smallest value for the field in the dataset |\n| **Max** | numeric field | The largest value for the field in the dataset |\n| **Sum** | numeric field | The total of all of the values for the field in the dataset |\n| **Average** | numeric field | The average of the field in the dataset |\n| **Standard Deviation** | numeric field | The standard deviation of the field in the dataset |\n| **Variance** | numeric field | The variance of the field in the dataset |\n| **P001** | numeric field | The value of the field below which 0.1% of the data falls |\n| **P01** | numeric field | The value of the field below with 1% of the data falls |\n| **P05** | numeric field | The value of the field below with 5% of the data falls |\n| **P10** | numeric field | The value of the field below with 10% of the data falls |\n| **P25** | numeric field | The value of the field below with 25% of the data falls |\n| **Median (P50)** | numeric field | The value of the field below with 50% of the data falls |\n| **P75** | numeric field | The value of the field below with 75% of the data falls |\n| **P90** | numeric field | The value of the field below with 90% of the data falls |\n| **P95** | numeric field | The value of the field below with 95% of the data falls |\n| **P99** | numeric field | The value of the field below with 99% of the data falls |\n| **P999** | numeric field | The value of the field below with 99.9% of the data falls |\n\nYou can add multiple visualizations in a single query. Each visualization renders a graph. A single summary table is also returned, which shows the raw query results.\n\n![Example of showing the Query Builder with multiple visualization](https://developers.cloudflare.com/_astro/query-builder-visualization.CBcVDFe0_25kyAz.webp)\n\nAll methods are aggregate functions. Most methods operate on a specific field in the log event. `Count` is an exception, and is an aggregate function that returns the number of log events matching the filter conditions.\n\n### Filter\n\nFilters help return the columns that match the specified conditions. Filters have three components: a key, an operator, and a value.\n\nThe key is any field in a log event. For example, you may choose `$workers.cpuTimeMs` or `$metadata.message`.\n\nThe operator is a logical condition that evaluates to true or false. See the table below for supported conditions:\n\n| Data Type | Valid Conditions (Operators) |\n| - | - |\n| Numeric | Equals, Does not equal, Greater, Greater or equals, Less, Less or equals, Exists, Does not exist |\n| String | Equals, Does not equal, Includes, Does not include, Regex, Exists, Does not exist, Starts with |\n\nThe value for a numeric field is an integer. The value for a string field is any string.\n\nTo add a filter:\n\n1. Select **+** in the **Filter** section.\n2. Select **Select key...** and input a key name. For example, `$workers.cpuTimeMs`.\n3. Select the operator and change it to the operator best suited. For example, `Greater than`.\n4. Select **Select value...** and input a value. For example, `100`.\n\nWhen you run the query with the filter specified above, only log events where `$workers.cpuTimeMs > 100` will be returned.\n\nAdding multiple filters combines them with an AND operator, meaning that only events matching all the filters will be returned.\n\n### Search\n\nSearch is a text filter that returns only events containing the specified text. Search can be helpful as a quick filtering mechanism, or to search for unique identifiable values in your logs.\n\n### Group By\n\nGroup By combines rows that have the same value into summary rows. For example, if a query adds `$workers.event.request.cf.country` as a Group By field, then the summary table will group by country.\n\n### Order By\n\nOrder By affects how the results are sorted in the summary table. If `asc` is selected, the results are sorted in ascending order - from least to greatest. If `desc` is selected, the results are sorted in descending order - from greatest to least.\n\n### Limit\n\nLimit restricts the number of results returned. When paired with [Order By](https://developers.cloudflare.com/workers/observability/query-builder/#order-by), it can be used to return the \"top\" or \"first\" N results.\n\n### Select time range\n\nWhen you select a time range, you specify the time interval where you want to look for matching events. The retention period is dependent on your [plan type](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#pricing).\n\n## Viewing query results\n\nThere are three views for queries: Visualizations, Invocations, and Events.\n\n### Visualizations tab\n\nThe **Visualizations** tab shows graphs and a summary table for the query.\n\n![Visualization Overview](https://developers.cloudflare.com/_astro/query-builder-visualization.CBcVDFe0_25kyAz.webp)\n\n### Invocations tab\n\nThe **Invocations** tab shows all logs, grouped by by the invocation, and ordered by timestamp. Only invocations matching the query criteria are returned.\n\n![Invocations Overview](https://developers.cloudflare.com/_astro/query-builder-invocations-overview.C02m4pPf_5zMXx.webp)\n\n### Events tab\n\nThe **Events** tab shows all logs, ordered by timestamp. Only events matching the query criteria are returned. The Events tab can be customized to add additional fields in the view.\n\n![Overview](https://developers.cloudflare.com/_astro/query-builder-events-overview.Cvj8cxX3_Z17BcJ5.webp)\n\n## Save queries\n\nIt is recommended to save queries that may be reused for future investigations. You can save a query with a name, description, and custom tags by selecting **Save Query**. Queries are saved at the account-level and are accessible to all users in the account.\n\nSaved queries can be re-run by selecting the relevant query from the **Queries** tab. You can edit the query and save edits.\n\nQueries can be starred by users. Starred queries are unique to the user, and not to the account.\n\n## Delete queries\n\nSaved queries can be deleted from the **Queries** tab. If you delete a query, the query is deleted for all users in the account.\n\n1. In the Cloudflare dashboard, go to the **Observability** page.\n\n   [Go to **Observability**](https://dash.cloudflare.com/?to=/:account/workers-and-pages/observability)\n\n2. Select the **Queries** tab.\n\n3. On the right-hand side, select the three dots for additional actions.\n\n4. Select **Delete Query** and follow the instructions.\n\n## Share queries\n\nSaved queries are assigned a unique URL and can be shared with any user in the account.\n\n## Example: Composing a query\n\nIn this example, we will construct a query to find and debug all paths that respond with 5xx errors. First, we create a base query. In this base query, we want to visualize by the raw event count. We can add a filter for `$workers.event.response.status` that is greater than 500. Then, we group by `$workers.event.request.path` and `$workers.event.response.status` to identify the number of requests that were affected by this behavior.\n\n![Constructing a query](https://developers.cloudflare.com/_astro/query-builder-ex1-query.CDbj8N5d_Z1yElmc.webp)\n\nThe results show that the `/actuator/env` path has been experiencing 500s. Now, we can apply a filter for this path and investigate.\n\n![Adding an additional field to the query](https://developers.cloudflare.com/_astro/query-builder-ex1-query-with-filter.DUqcI8AK_1aMEHy.webp)\n\nNow, we can investigate by selecting the **Invocations** tab. We can see that there were two logged invocations of this error.\n\n![Examining the Invocations tab in the Query Builder](https://developers.cloudflare.com/_astro/query-builder-ex1-invocations.C4Qt7ulL_eBX3s.webp)\n\nWe can expand a single invocation to view the relevant logs, and continue to debug.\n\n![Viewing the logs for a single Invocation](https://developers.cloudflare.com/_astro/query-builder-ex1-invocation-logs.FJWtya7H_2tU9NB.webp)\n\n</page>\n\n<page>\n---\ntitle: Source maps and stack traces  Cloudflare Workers docs\ndescription: Adding source maps and generating stack traces for Workers.\nlastUpdated: 2025-10-22T21:56:17.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/observability/source-maps/\n  md: https://developers.cloudflare.com/workers/observability/source-maps/index.md\n---\n\n[Stack traces](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/stack) help with debugging your code when your application encounters an unhandled exception. Stack traces show you the specific functions that were called, in what order, from which line and file, and with what arguments.\n\nMost JavaScript code is first bundled, often transpiled, and then minified before being deployed to production. This process creates smaller bundles to optimize performance and converts code from TypeScript to Javascript if needed.\n\nSource maps translate compiled and minified code back to the original code that you wrote. Source maps are combined with the stack trace returned by the JavaScript runtime to present you with a stack trace.\n\n## Source Maps\n\nTo enable source maps, add the following to your Worker's [Wrangler configuration](https://developers.cloudflare.com/workers/wrangler/configuration/):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "When `upload_source_maps` is set to `true`, Wrangler will automatically generate and upload source map files when you run [`wrangler deploy`](https://developers.cloudflare.com/workers/wrangler/commands/#deploy) or [`wrangler versions deploy`](https://developers.cloudflare.com/workers/wrangler/commands/#versions-deploy). \n\nNote\n\nMiniflare can also [output source maps](https://miniflare.dev/developing/source-maps) for use in local development or [testing](https://developers.cloudflare.com/workers/testing/miniflare/writing-tests).\n\n## Stack traces\n\n When your Worker throws an uncaught exception, we fetch the source map and use it to map the stack trace of the exception back to lines of your Workers original source code.\n\nYou can then view the stack trace when streaming [real-time logs](https://developers.cloudflare.com/workers/observability/logs/real-time-logs/) or in [Tail Workers](https://developers.cloudflare.com/workers/observability/logs/tail-workers/).\n\nNote\n\nThe source map is retrieved after your Worker invocation completes  it's an asynchronous process that does not impact your Worker's CPU utilization or performance. Source maps are not accessible inside the Worker at runtime, if you `console.log()` the [stack property](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/stack) within a Worker, you will not get a deobfuscated stack trace.\n\nWhen Cloudflare attempts to remap a stack trace to the Worker's source map, it does so line-by-line, remapping as much as possible. If a line of the stack trace cannot be remapped for any reason, Cloudflare will leave that line of the stack trace unchanged, and continue to the next line of the stack trace.\n\n## Limits\n\nWrangler version\n\nMinimum required Wrangler version for source maps: 3.46.0. Check your version by running `wrangler --version`.\n\n| Description | Limit |\n| - | - |\n| Maximum Source Map Size | 15 MB gzipped |\n\n## Example\n\nConsider a simple project. `src/index.ts` serves as the entrypoint of the application and `src/calculator.ts` defines a ComplexCalculator class that supports basic arithmetic.\n\nLet's see how source maps can simplify debugging an error in the ComplexCalculator class.\n\n![Stack Trace without Source Map remapping](https://developers.cloudflare.com/_astro/without-source-map.ByYR83oU_1kmSml.webp)\n\nWith **no source maps uploaded**: notice how all the Javascript has been minified to one file, so the stack trace is missing information on file name, shows incorrect line numbers, and incorrectly references `js` instead of `ts`.\n\n![Stack Trace with Source Map remapping](https://developers.cloudflare.com/_astro/with-source-map.PipytmVe_Z17DcFD.webp)\n\nWith **source maps uploaded**: all methods reference the correct files and line numbers.\n\n## Related resources\n\n* [Tail Workers](https://developers.cloudflare.com/workers/observability/logs/logpush/) - Learn how to attach Tail Workers to transform your logs and send them to HTTP endpoints.\n* [Real-time logs](https://developers.cloudflare.com/workers/observability/logs/real-time-logs/) - Learn how to capture Workers logs in real-time.\n* [RPC error handling](https://developers.cloudflare.com/workers/runtime-apis/rpc/error-handling/) - Learn how exceptions are handled over RPC (Remote Procedure Call).\n\n</page>\n\n<page>\n---\ntitle: Integrations  Cloudflare Workers docs\nlastUpdated: 2025-10-28T12:06:21.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/workers/observability/third-party-integrations/\n  md: https://developers.cloudflare.com/workers/observability/third-party-integrations/index.md\n---\n\n* [Sentry](https://docs.sentry.io/platforms/javascript/guides/cloudflare/)\n\n</page>\n\n<page>\n---\ntitle: Traces  Cloudflare Workers docs\ndescription: \"Tracing gives you end-to-end visibility into the life of a request\n  as it travels through your Workers application and connected services. This\n  helps you identify performance bottlenecks, debug issues, and understand\n  complex request flows. With tracing you can answer questions such as:\"\nlastUpdated: 2025-11-07T21:07:00.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/observability/traces/\n  md: https://developers.cloudflare.com/workers/observability/traces/index.md\n---\n\n### What is Workers tracing?\n\nTracing gives you end-to-end visibility into the life of a request as it travels through your Workers application and connected services. This helps you identify performance bottlenecks, debug issues, and understand complex request flows. With tracing you can answer questions such as:\n\n* What is the cause of a long-running request?\n* How long do subrequests from my Worker take?\n* How long are my calls to my KV Namespace or R2 bucket taking?\n\n![Example trace showing a POST request to a cake shop with multiple spans including fetch requests and durable object operations](https://developers.cloudflare.com/_astro/trace-waterfall-example.DvcEMnVZ_1yAi65.webp)\n\n### Automatic instrumentation\n\nCloudflare Workers provides tracing instrumentation **out of the box** - no code changes or SDK are required. Simply enable tracing on your Worker and Cloudflare automatically captures telemetry data for:\n\n* **Fetch calls** - All outbound HTTP requests, capturing timing, status codes, and request metadata. This enables you to quickly identify how external dependencies affect your application's performance.\n* **Binding calls** - Interactions with various Worker bindings such as KV reads and writes, R2 object storage operations and Durable Object invocations.\n* **Handler calls** - The complete lifecycle of each Worker invocation, including triggers such as [fetch handlers](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/), [scheduled handlers](https://developers.cloudflare.com/workers/runtime-apis/handlers/scheduled/), and [queue handlers](https://developers.cloudflare.com/queues/configuration/javascript-apis/#consumer).\n\nFor a full list of instrumented operations , see the [spans and attributes documentation](https://developers.cloudflare.com/workers/observability/traces/spans-and-attributes).\n\n### How to enable tracing\n\nYou can configure tracing by setting `observability.traces.enabled = true` in your [wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/#observability).\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Note\n\nIn the future, Cloudflare plans to enable automatic tracing in addition to logs when you set `observability.enabled = true` in your Wrangler configuration.\n\nWhile automatic tracing is in early beta, this setting will not enable tracing by default, and will only enable logs.\n\nAn updated [`compatibility_date`](https://developers.cloudflare.com/workers/configuration/compatibility-dates/) will be required for this change to take effect.\n\n### Exporting OpenTelemetry traces to a 3rd party destination\n\nWorkers tracing follows [OpenTelemetry (OTel) standards](https://opentelemetry.io/). This makes it compatible with popular observability platforms, such as [Honeycomb](https://developers.cloudflare.com/workers/observability/exporting-opentelemetry-data/honeycomb/), [Grafana Cloud](https://developers.cloudflare.com/workers/observability/exporting-opentelemetry-data/grafana-cloud/), and [Axiom](https://developers.cloudflare.com/workers/observability/exporting-opentelemetry-data/axiom/), while requiring zero development effort from you. If your observability provider has an available OpenTelemetry endpoint, you can export traces (and logs)!\n\nLearn more about exporting OpenTelemetry data from Workers [here](https://developers.cloudflare.com/workers/observability/exporting-opentelemetry-data/).\n\n### Sampling\n\nDefault Sampling Rate\n\nThe default sampling rate is `1`, meaning 100% of requests will be traced if tracing is enabled. Set `head_sampling_rate` if you want to trace fewer requests.\n\nWith sampling, you can trace a percentage of incoming requests in your Cloudflare Worker. This allows you to manage volume and costs, while still providing meaningful insights into your application.\n\nThe valid sampling range is from `0` to `1`, where `0` indicates zero out of one hundred invocations will be traced, and `1` indicates every requests will be traced, and a number such a `0.05` indicates five out of one hundred requests will be traced.\n\nIf you have not specified a sampling rate, it defaults to `1`, meaning 100% of requests will be traced.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "If you have `head_sampling_rate` configured for logs, you can also create a separate rate for traces.\n\nSampling is [head-based](https://opentelemetry.io/docs/concepts/sampling/#head-sampling), meaning that non-traced requests do not incur any tracing overhead.\n\n### Limits & Pricing\n\nWorkers tracing is currently **free** during the initial beta period. This includes all tracing functionality such as collecting traces, storing them, and viewing them in the Cloudflare dashboard.\n\nStarting on January 15, 2026, tracing will be billed as part of your usage on the Workers Free Paid and Enterprise plans. Each span in a trace represents one observability event, sharing the same monthly quota and pricing as [Workers logs](https://developers.cloudflare.com/workers/platform/pricing/#workers-logs):\n\n| | Events (trace spans or log events) | Retention |\n| - | - | - |\n| **Workers Free** | 200,000 per day | 3 Days |\n| **Workers Paid** | 10 million included per month +$0.60 per additional million events | 7 Days |\n\n</page>\n\n<page>\n---\ntitle: Betas  Cloudflare Workers docs\ndescription: Cloudflare developer platform and Workers features beta status.\nlastUpdated: 2025-12-17T00:24:18.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/platform/betas/\n  md: https://developers.cloudflare.com/workers/platform/betas/index.md\n---\n\nThese are the current alphas and betas relevant to the Cloudflare Workers platform.\n\n* **Public alphas and betas are openly available**, but may have limitations and caveats due to their early stage of development.\n* Private alphas and betas require explicit access to be granted. Refer to the documentation to join the relevant product waitlist.\n\n| Product | Private Beta | Public Beta | More Info |\n| - | - | - | - |\n| Email Workers | |  | [Docs](https://developers.cloudflare.com/email-routing/email-workers/) |\n| Green Compute | |  | [Blog](https://blog.cloudflare.com/earth-day-2022-green-compute-open-beta/) |\n| [TCP Sockets](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/) | |  | [Docs](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets) |\n\n</page>\n\n<page>\n---\ntitle: Built with Cloudflare button  Cloudflare Workers docs\ndescription: Set up a Built with Cloudflare button\nlastUpdated: 2025-09-11T16:45:07.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/platform/built-with-cloudflare/\n  md: https://developers.cloudflare.com/workers/platform/built-with-cloudflare/index.md\n---\n\nIf you're building an application or website on Cloudflare, you can embed a Built with Cloudflare button in your README, blog post, or documentation.\n\n![Built with Cloudflare](https://workers.cloudflare.com/built-with-cloudflare.svg)\n\nDisambiguation\n\nThe \"Built with Cloudflare\" button can be used to share that you're using Cloudflare products on your website or application. If you want people to be able to deploy your application on their own account, refer to [Deploy to Cloudflare buttons](https://developers.cloudflare.com/workers/platform/deploy-buttons).\n\n## How to Set Up Built with Cloudflare button\n\nThe Built with Cloudflare button is an SVG and can be embedded anywhere. Use the following snippet to paste the button into your README, blog post, or documentation.\n\n* Markdown",
      "language": "unknown"
    },
    {
      "code": "* HTML",
      "language": "unknown"
    },
    {
      "code": "* URL",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Workers Changelog  Cloudflare Workers docs\ndescription: Review recent changes to Cloudflare Workers.\nlastUpdated: 2025-02-13T19:35:19.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/platform/changelog/\n  md: https://developers.cloudflare.com/workers/platform/changelog/index.md\n---\n\nThis changelog details meaningful changes made to Workers across the Cloudflare dashboard, Wrangler, the API, and the workerd runtime. These changes are not configurable.\n\nThis is *different* from [compatibility dates](https://developers.cloudflare.com/workers/configuration/compatibility-dates/) and [compatibility flags](https://developers.cloudflare.com/workers/configuration/compatibility-flags/), which let you explicitly opt-in to or opt-out of specific changes to the Workers Runtime.\n\n[Subscribe to RSS](https://developers.cloudflare.com/workers/platform/changelog/index.xml)\n\n## 2025-11-25\n\n* Updated v8 to version 14.3.\n\n## 2025-10-25\n\n* The maximum WebSocket message size limit has been increased from 1 MiB to 32 MiB.\n\n## 2025-10-22\n\n* Warnings which were previously only visible via the devtools console in preview sessions are now also sent to the tail Worker, if one is attached.\n\n## 2025-10-17\n\n* Updated v8 to version 14.2.\n* Backported an optimization to `JSON.parse()`. More details are [available in this blog post](https://blog.cloudflare.com/unpacking-cloudflare-workers-cpu-performance-benchmarks/#json-parsing) and [the upstream patch](https://chromium-review.googlesource.com/c/v8/v8/+/7027411).\n\n## 2025-09-18\n\n* Updated v8 to version 14.1.\n\n## 2025-09-11\n\n* The node:fs and Web File System APIs are now available within Workers.\n\n## 2025-08-21\n\n* Updated v8 to version 14.0.\n* `Uint8Array` type in JavaScript now supports base64 and hex operations.\n\n## 2025-08-14\n\n* Enable V8 Sandbox for improved isolation and security.\n\n## 2025-08-11\n\n* The MessageChannel and MessagePort APIs are now available in Workers.\n\n## 2025-06-27\n\n* Updated v8 to version 13.9.\n\n## 2025-06-23\n\n* Enable FinalizationRegistry API. See [We shipped FinalizationRegistry in Workers: why you should never use it](https://blog.cloudflare.com/we-shipped-finalizationregistry-in-workers-why-you-should-never-use-it/) for details.\n\n## 2025-06-04\n\n* Updated v8 to version 13.8.\n\n## 2025-05-27\n\n* Historically, in some cases, the same instance of `ctx` would be passed to multiple invocations of the event handler. We now always pass a new object for each event. We made this change retroactive to all compatibility dates because we suspect it fixes security bugs in some workers and does not break any worker. However, the old behavior can be restored using the compat flag `nonclass_entrypoint_reuses_ctx_across_invocations`.\n\n## 2025-05-22\n\n* Enabled explicit resource context management and support for Float16Array\n\n## 2025-05-20\n\n* Updated v8 to version 13.7.\n\n## 2025-04-16\n\n* Updated v8 to version 13.6.\n\n## 2025-04-14\n\n* JSRPC message size limit has been increased to 32MiB.\n\n## 2025-04-03\n\n* Websocket client exceptions are now JS exceptions rather than internal errors.\n\n## 2025-03-27\n\n* Updated v8 to version 13.5.\n\n## 2025-02-28\n\n* Updated v8 to version 13.4.\n* When using `nodejs_compat`, the new `nodejs_compat_populate_process_env` compatibility flag will cause `process.env` to be automatically populated with text bindings configured for the worker.\n\n## 2025-02-26\n\n* [Workers Builds](https://developers.cloudflare.com/workers/ci-cd/builds/) now supports building projects that use **pnpm 10** as the package manager. If your build previously failed due to this unsupported version, retry your build. No config changes needed.\n\n## 2025-02-13\n\n* [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement/) no longer runs Workers in the same location as D1 databases they are bound to. The same [placement logic](https://developers.cloudflare.com/workers/configuration/smart-placement/#understand-how-smart-placement-works) now applies to all Workers that use Smart Placement, regardless of whether they use D1 bindings.\n\n## 2025-02-11\n\n* When Workers generate an \"internal error\" exception in response to certain failures, the exception message may provide a reference ID that customers can include in support communication for easier error identification. For example, an exception with the new message might look like: `internal error; reference = 0123456789abcdefghijklmn`.\n\n## 2025-01-31\n\n* Updated v8 to version 13.3.\n\n## 2025-01-15\n\n* The runtime will no longer reuse isolates across worker versions even if the code happens to be identical. This \"optimization\" was deemed more confusing than it is worth.\n\n## 2025-01-14\n\n* Updated v8 to version 13.2.\n\n## 2024-12-19\n\n* **Cloudflare GitHub App Permissions Update**\n\n  * Cloudflare is requesting updated permissions for the [Cloudflare GitHub App](https://github.com/apps/cloudflare-workers-and-pages) to enable features like automatically creating a repository on your GitHub account and deploying the new repository for you when getting started with a template. This feature is coming out soon to support a better onboarding experience.\n\n  * **Requested permissions:**\n\n    * [Repository Administration](https://docs.github.com/en/rest/authentication/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-administration) (read/write) to create repositories.\n    * [Contents](https://docs.github.com/en/rest/authentication/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-contents) (read/write) to push code to the created repositories.\n\n  * **Who is impacted:**\n\n    * Existing users will be prompted to update permissions when GitHub sends an email with subject \"\\[GitHub] Cloudflare Workers & Pages is requesting updated permission\" on December 19th, 2024.\n    * New users installing the app will see the updated permissions during the connecting repository process.\n\n  * **Action:** Review and accept the permissions update to use upcoming features. *If you decline or take no action, you can continue connecting repositories and deploying changes via the Cloudflare GitHub App as you do today, but new features requiring these permissions will not be available.*\n\n  * **Questions?** Visit [#github-permissions-update](https://discord.com/channels/595317990191398933/1313895851520688163) in the Cloudflare Developers Discord.\n\n## 2024-11-18\n\n* Updated v8 to version 13.1.\n\n## 2024-11-12\n\n* Fixes exception seen when trying to call deleteAll() during a SQLite-backed Durable Object's alarm handler.\n\n## 2024-11-08\n\n* Update SQLite to version 3.47.\n\n## 2024-10-21\n\n* Fixed encoding of WebSocket pong messages when talking to remote servers. Previously, when a Worker made a WebSocket connection to an external server, the server may have prematurely closed the WebSocket for failure to respond correctly to pings. Client-side connections were not affected.\n\n## 2024-10-14\n\n* Updated v8 to version 13.0.\n\n## 2024-09-26\n\n* You can now connect your GitHub or GitLab repository to an existing Worker to automatically build and deploy your changes when you make a git push with [Workers Builds](https://developers.cloudflare.com/workers/ci-cd/builds/).\n\n## 2024-09-20\n\n* Workers now support the \\[`handle_cross_request_promise_resolution`] compatibility flag which addresses certain edge cases around awaiting and resolving promises across multiple requests.\n\n## 2024-09-19\n\n* Revamped Workers and Pages UI settings to simplify the creation and management of project configurations. For bugs and general feedback, please submit this [form](https://forms.gle/XXqhRGbZmuzninuN9).\n\n## 2024-09-16\n\n* Updated v8 to version 12.9.\n\n## 2024-08-19\n\n* Workers now support the [`allow_custom_ports` compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#allow-specifying-a-custom-port-when-making-a-subrequest-with-the-fetch-api) which enables using the `fetch()` calls to custom ports.\n\n## 2024-08-15\n\n* Updated v8 to version 12.8.\n* You can now use [`Promise.try()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/try) in Cloudflare Workers. Refer to [`tc39/proposal-promise-try`](https://github.com/tc39/proposal-promise-try) for more context on this API that has recently been added to the JavaScript language.\n\n## 2024-08-14\n\n* When using the `nodejs_compat_v2` compatibility flag, the `setImmediate(fn)` API from Node.js is now available at the global scope.\n* The `internal_writable_stream_abort_clears_queue` compatibility flag will ensure that certain `WritableStream` `abort()` operations are handled immediately rather than lazily, ensuring that the stream is appropriately aborted when the consumer of the stream is no longer active.\n\n## 2024-07-19\n\n* Workers with the [mTLS](https://developers.cloudflare.com/workers/runtime-apis/bindings/mtls/) binding now support [Gradual Deployments](https://developers.cloudflare.com/workers/configuration/versions-and-deployments/gradual-deployments/).\n\n## 2024-07-18\n\n* Added a new `truncated` flag to [Tail Worker](https://developers.cloudflare.com/workers/observability/logs/tail-workers/) events to indicate when the event buffer is full and events are being dropped.\n\n## 2024-07-17\n\n* Updated v8 to version 12.7.\n\n## 2024-07-03\n\n* The [`node:crypto`](https://developers.cloudflare.com/workers/runtime-apis/nodejs/crypto/) implementation now includes the scrypt(...) and scryptSync(...) APIs.\n* Workers now support the standard [EventSource](https://developers.cloudflare.com/workers/runtime-apis/eventsource/) API.\n* Fixed a bug where when writing to an HTTP Response body would sometimes hang when the client disconnected (and sometimes throw an exception). It will now always throw an exception.\n\n## 2024-07-01\n\n* When using [Gradual Deployments](https://developers.cloudflare.com/workers/configuration/versions-and-deployments/gradual-deployments/), you can now use [version overrides](https://developers.cloudflare.com/workers/configuration/versions-and-deployments/gradual-deployments/#version-overrides) to send a request to a specific version of your Worker.\n\n## 2024-06-28\n\n* Fixed a bug which caused `Date.now()` to return skewed results if called before the first I/O of the first request after a Worker first started up. The value returned would be offset backwards by the amount of CPU time spent starting the Worker (compiling and running global scope), making it seem like the first I/O (e.g. first fetch()) was slower than it really was. This skew had nothing to do with Spectre mitigations; it was simply a longstanding bug.\n\n## 2024-06-24\n\n* [Exceptions](https://developers.cloudflare.com/durable-objects/best-practices/error-handling) thrown from Durable Object internal operations and tunneled to the caller may now be populated with a `.retryable: true` property if the exception was likely due to a transient failure, or populated with an `.overloaded: true` property if the exception was due to [overload](https://developers.cloudflare.com/durable-objects/observability/troubleshooting/#durable-object-is-overloaded).\n\n## 2024-06-20\n\n* We now prompt for extra confirmation if attempting to rollback to a version of a Worker using the [Deployments API](https://developers.cloudflare.com/api/resources/workers/subresources/scripts/subresources/deployments/methods/create/) where the value of a secret is different than the currently deployed version. A `?force=true` query parameter can be specified to proceed with the rollback.\n\n## 2024-06-19\n\n* When using [`nodejs_compat` compatibility flag](https://developers.cloudflare.com/workers/runtime-apis/nodejs/), the `buffer` module now has an implementation of `isAscii()` and `isUtf8()` methods.\n* Fixed a bug where exceptions propagated from [JS RPC](https://developers.cloudflare.com/workers/runtime-apis/rpc) calls to Durable Objects would lack the `.remote` property that exceptions from `fetch()` calls to Durable Objects have.\n\n## 2024-06-12\n\n* Blob and Body objects now include a new `bytes()` method, reflecting [recent](https://w3c.github.io/FileAPI/#bytes-method-algo) [additions](https://fetch.spec.whatwg.org/#dom-body-bytes) to web standards.\n\n## 2024-06-03\n\n* Workers with [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement/) enabled now support [Gradual Deployments](https://developers.cloudflare.com/workers/configuration/versions-and-deployments/gradual-deployments/).\n\n## 2024-05-17\n\n* Updated v8 to version 12.6.\n\n## 2024-05-15\n\n* The new [`fetch_standard_url` compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#use-standard-url-parsing-in-fetch) will become active by default on June 3rd, 2024 and ensures that URLs passed into the `fetch(...)` API, the `new Request(...)` constructor, and redirected requests will be parsed using the standard WHATWG URL parser.\n* DigestStream is now more efficient and exposes a new `bytesWritten` property that indicates that number of bytes written to the digest.\n\n## 2024-05-13\n\n* Updated v8 to version 12.5.\n* A bug in the fetch API implementation would cause the content type of a Blob to be incorrectly set. The fix is being released behind a new [`blob_standard_mime_type` compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#properly-extract-blob-mime-type-from-content-type-headers).\n\n## 2024-05-03\n\n* Fixed RPC to/from Durable Objects not honoring the output gate.\n* The `internal_stream_byob_return_view` compatibility flag can be used to improve the standards compliance of the `ReadableStreamBYOBReader` implementation when working with BYOB streams provided by the runtime (like in `response.body` or `request.body`). The flag ensures that the final read result will always include a `value` field whose value is set to an empty `Uint8Array` whose underlying `ArrayBuffer` is the same memory allocation as the one passed in on the call to `read()`.\n* The Web platform standard `reportError(err)` global API is now available in workers. The reported error will first be emitted as an 'error' event on the global scope then reported in both the console output and tail worker exceptions by default.\n\n## 2024-04-26\n\n* Updated v8 to version 12.4.\n\n## 2024-04-11\n\n* Improve Streams API spec compliance by exposing `desiredSize` and other properties on stream class prototypes\n* The new `URL.parse(...)` method is implemented. This provides an alternative to the URL constructor that does not throw exceptions on invalid URLs.\n* R2 bindings objects now have a `storageClass` option. This can be set on object upload to specify the R2 storage class - Standard or Infrequent Access. The property is also returned with object metadata.\n\n## 2024-04-05\n\n* A new [JavaScript-native remote procedure call (RPC) API](https://developers.cloudflare.com/workers/runtime-apis/rpc) is now available, allowing you to communicate more easily across Workers and between Workers and Durable Objects.\n\n## 2024-04-04\n\n* There is no longer an explicit limit on the total amount of data which may be uploaded with Cache API [`put()`](https://developers.cloudflare.com/workers/runtime-apis/cache/#put) per request. Other [Cache API Limits](https://developers.cloudflare.com/workers/platform/limits/#cache-api-limits) continue to apply.\n* The Web standard `ReadableStream.from()` API is now implemented. The API enables creating a `ReadableStream` from a either a sync or async iterable.\n\n## 2024-04-03\n\n* When the [`brotli_content_encoding`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#brotli-content-encoding-support) compatibility flag is enabled, the Workers runtime now supports compressing and decompressing request bodies encoded using the [Brotli](https://developer.mozilla.org/en-US/docs/Glossary/Brotli_compression) compression algorithm. Refer to [this docs section](https://developers.cloudflare.com/workers/runtime-apis/fetch/#how-the-accept-encoding-header-is-handled) for more detail.\n\n## 2024-04-02\n\n* You can now [write Workers in Python](https://developers.cloudflare.com/workers/languages/python)\n\n## 2024-04-01\n\n* The new [`unwrap_custom_thenables` compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#handling-custom-thenables) enables workers to accept custom thenables in internal APIs that expect a promise (for instance, the `ctx.waitUntil(...)` method).\n* TransformStreams created with the TransformStream constructor now have a cancel algorithm that is called when the stream is canceled or aborted. This change is part of the implementation of the WHATWG Streams standard.\n* The [`nodejs_compat` compatibility flag](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) now includes an implementation of the [`MockTracker` API from `node:test`](https://nodejs.org/api/test.html#class-mocktracker). This is not an implementation of the full `node:test` module, and mock timers are currently not included.\n* Exceptions reported to [Tail Workers](https://developers.cloudflare.com/workers/observability/logs/tail-workers/) now include a \"stack\" property containing the exception's stack trace, if available.\n\n## 2024-03-11\n\n* Built-in APIs that return Promises will now produce stack traces when the Promise rejects. Previously, the rejection error lacked a stack trace.\n* A new compat flag `fetcher_no_get_put_delete` removes the `get()`, `put()`, and `delete()` methods on service bindings and Durable Object stubs. This will become the default as of compatibility date 2024-03-26. These methods were designed as simple convenience wrappers around `fetch()`, but were never documented.\n* Updated v8 to version 12.3.\n\n## 2024-02-24\n\n* v8 updated to version 12.2.\n* You can now use [Iterator helpers](https://v8.dev/features/iterator-helpers) in Workers.\n* You can now use [new methods on `Set`](https://github.com/tc39/proposal-set-methods), such as `Set.intersection` and `Set.union`, in Workers.\n\n## 2024-02-23\n\n* Sockets now support an [`opened`](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/#socket) attribute.\n* [Durable Object alarm handlers](https://developers.cloudflare.com/durable-objects/api/alarms/#alarm) now impose a maximum wall time of 15 minutes.\n\n## 2023-12-04\n\n* The Web Platform standard [`navigator.sendBeacon(...)` API](https://developers.cloudflare.com/workers/runtime-apis/web-standards#navigatorsendbeaconurl-data) is now provided by the Workers runtime.\n* V8 updated to 12.0.\n\n## 2023-10-30\n\n* A new usage model called [Workers Standard](https://developers.cloudflare.com/workers/platform/pricing/#workers) is available for Workers and Pages Functions pricing. This is now the default usage model for accounts that are first upgraded to the Workers Paid plan. Read the [blog post](https://blog.cloudflare.com/workers-pricing-scale-to-zero/) for more information.\n* The usage model set in a script's wrangler.toml will be ignored after an account has opted-in to [Workers Standard](https://developers.cloudflare.com/workers/platform/pricing/#workers) pricing. It must be configured through the dashboard (Workers & Pages > Select your Worker > Settings > Usage Model).\n* Workers and Pages Functions on the Standard usage model can set custom [CPU limits](https://developers.cloudflare.com/workers/wrangler/configuration/#limits) for their Workers\n\n## 2023-10-20\n\n* Added the [`crypto_preserve_public_exponent`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#webcrypto-preserve-publicexponent-field) compatibility flag to correct a wrong type being used in the algorithm field of RSA keys in the WebCrypto API.\n\n## 2023-10-18\n\n* The limit of 3 Cron Triggers per Worker has been removed. Account-level limits on the total number of Cron Triggers across all Workers still apply.\n\n## 2023-10-12\n\n* A [TCP Socket](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/)'s WritableStream now ensures the connection has opened before resolving the promise returned by `close`.\n\n## 2023-10-09\n\n* The Web Platform standard [`CustomEvent` class](https://dom.spec.whatwg.org/#interface-customevent) is now available in Workers.\n* Fixed a bug in the WebCrypto API where the `publicExponent` field of the algorithm of RSA keys would have the wrong type. Use the [`crypto_preserve_public_exponent` compatibility flag](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#webcrypto-preserve-publicexponent-field) to enable the new behavior.\n\n## 2023-09-14\n\n* An implementation of the [`node:crypto`](https://developers.cloudflare.com/workers/runtime-apis/nodejs/crypto/) API from Node.js is now available when the [`nodejs_compat` compatibility flag](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) is enabled.\n\n## 2023-07-14\n\n* An implementation of the [`util.MIMEType`](https://nodejs.org/api/util.html#class-utilmimetype) API from Node.js is now available when the [`nodejs_compat` compatibility flag](https://developers.cloudflare.com/workers/runtime-apis/nodejs/) is enabled.\n\n## 2023-07-07\n\n* An implementation of the [`process.env`](https://developers.cloudflare.com/workers/runtime-apis/nodejs/process) API from Node.js is now available when using the `nodejs_compat` compatibility flag.\n* An implementation of the [`diagnostics_channel`](https://developers.cloudflare.com/workers/runtime-apis/nodejs/diagnostics-channel) API from Node.js is now available when using the `nodejs_compat` compatibility flag.\n\n## 2023-06-22\n\n* Added the [`strict_crypto_checks`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#strict-crypto-error-checking) compatibility flag to enable additional [Web Crypto API](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/) error and security checking.\n* Fixes regression in the [TCP Sockets API](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/) where `connect(\"google.com:443\")` would fail with a `TypeError`.\n\n## 2023-06-19\n\n* The [TCP Sockets API](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/) now reports clearer errors when a connection cannot be established.\n* Updated V8 to 11.5.\n\n## 2023-06-09\n\n* `AbortSignal.any()` is now available.\n* Updated V8 to 11.4.\n* Following an update to the [WHATWG URL spec](https://url.spec.whatwg.org/#interface-urlsearchparams), the `delete()` and `has()` methods of the `URLSearchParams` class now accept an optional second argument to specify the search parameters value. This is potentially a breaking change, so it is gated behind the new `urlsearchparams_delete_has_value_arg` and [`url_standard`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#new-url-parser-implementation) compatibility flags.\n* Added the [`strict_compression_checks`](https://developers.cloudflare.com/workers/configuration/compatibility-flags/#strict-compression-error-checking) compatibility flag for additional [`DecompressionStream`](https://developers.cloudflare.com/workers/runtime-apis/web-standards/#compression-streams) error checking.\n\n## 2023-05-26\n\n* A new [Hibernatable WebSockets API](https://developers.cloudflare.com/durable-objects/best-practices/websockets/) (beta) has been added to [Durable Objects](https://developers.cloudflare.com/durable-objects/). The Hibernatable WebSockets API allows a Durable Object that is not currently running an event handler (for example, processing a WebSocket message or alarm) to be removed from memory while keeping its WebSockets connected (hibernation). A Durable Object that hibernates will not incur billable Duration (GB-sec) charges.\n\n## 2023-05-16\n\n* The [new `connect()` method](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/) allows you to connect to any TCP-speaking services directly from your Workers. To learn more about other protocols supported on the Workers platform, visit the [new Protocols documentation](https://developers.cloudflare.com/workers/reference/protocols/).\n* We have added new [native database integrations](https://developers.cloudflare.com/workers/databases/native-integrations/) for popular serverless database providers, including Neon, PlanetScale, and Supabase. Native integrations automatically handle the process of creating a connection string and adding it as a Secret to your Worker.\n* You can now also connect directly to databases over TCP from a Worker, starting with [PostgreSQL](https://developers.cloudflare.com/hyperdrive/examples/connect-to-postgres/). Support for PostgreSQL is based on the popular `pg` driver, and allows you to connect to any PostgreSQL instance over TLS from a Worker directly.\n* The [R2 Migrator](https://developers.cloudflare.com/r2/data-migration/) (Super Slurper), which automates the process of migrating from existing object storage providers to R2, is now Generally Available.\n\n## 2023-05-15\n\n* [Cursor](https://developers.cloudflare.com/workers/ai/), an experimental AI assistant, trained to answer questions about Cloudflare's Developer Platform, is now available to preview! Cursor can answer questions about Workers and the Cloudflare Developer Platform, and is itself built on Workers. You can read more about Cursor in the [announcement blog](https://blog.cloudflare.com/introducing-cursor-the-ai-assistant-for-docs/).\n\n## 2023-05-12\n\n* The [`performance.now()`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now) and [`performance.timeOrigin`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/timeOrigin) APIs can now be used in Cloudflare Workers. Just like `Date.now()`, for [security reasons](https://developers.cloudflare.com/workers/reference/security-model/) time only advances after I/O.\n\n## 2023-05-05\n\n* The new `nodeJsCompatModule` type can be used with a Worker bundle to emulate a Node.js environment. Common Node.js globals such as `process` and `Buffer` will be present, and `require('...')` can be used to load Node.js built-ins without the `node:` specifier prefix.\n* Fixed an issue where websocket connections would be disconnected when updating workers. Now, only WebSockets connected to Durable Objects are disconnected by updates to that Durable Objects code.\n\n## 2023-04-28\n\n* The Web Crypto API now supports curves Ed25519 and X25519 defined in the Secure Curves specification.\n* The global `connect` method has been moved to a `cloudflare:sockets` module.\n\n## 2023-04-14\n\n* No externally-visible changes this week.\n\n## 2023-04-10\n\n* `URL.canParse(...)` is a new standard API for testing that an input string can be parsed successfully as a URL without the additional cost of creating and throwing an error.\n* The Workers-specific `IdentityTransformStream` and `FixedLengthStream` classes now support specifying a `highWaterMark` for the writable-side that is used for backpressure signaling using the standard `writer.desiredSize`/`writer.ready` mechanisms.\n\n## 2023-03-24\n\n* Fixed a bug in Wrangler tail and live logs on the dashboard that prevented the Administrator Read-Only and Workers Tail Read roles from successfully tailing Workers.\n\n## 2023-03-09\n\n* No externally-visible changes.\n\n## 2023-03-06\n\n* [Workers Logpush](https://developers.cloudflare.com/workers/observability/logs/logpush/#limits) now supports 300 characters per log line. This is an increase from the previous limit of 150 characters per line.\n\n## 2023-02-06\n\n* Fixed a bug where transferring large request bodies to a Durable Object was unexpectedly slow.\n* Previously, an error would be thrown when trying to access unimplemented standard `Request` and `Response` properties. Now those will be left as `undefined`.\n\n## 2023-01-31\n\n* The [`request.cf`](https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties) object now includes two additional properties, `tlsClientHelloLength` and `tlsClientRandom`.\n\n## 2023-01-13\n\n* Durable Objects can now use jurisdictions with `idFromName` via a new subnamespace API.\n* V8 updated to 10.9.\n\n</page>\n\n<page>\n---\ntitle: Deploy to Cloudflare buttons  Cloudflare Workers docs\ndescription: Set up a Deploy to Cloudflare button\nlastUpdated: 2025-07-29T15:39:18.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/platform/deploy-buttons/\n  md: https://developers.cloudflare.com/workers/platform/deploy-buttons/index.md\n---\n\nIf you're building a Workers application and would like to share it with other developers, you can embed a Deploy to Cloudflare button in your README, blog post, or documentation to enable others to quickly deploy your application on their own Cloudflare account. Deploy to Cloudflare buttons eliminate the need for complex setup, allowing developers to get started with your public GitHub or GitLab repository in just a few clicks.\n\n[![Deploy to Cloudflare](https://deploy.workers.cloudflare.com/button)](https://deploy.workers.cloudflare.com/?url=https://github.com/cloudflare/templates/tree/main/saas-admin-template)\n\n## What are Deploy to Cloudflare buttons?\n\nDeploy to Cloudflare buttons simplify the deployment of a Workers application by enabling Cloudflare to:\n\n* **Clone a Git repository**: Cloudflare clones your source repository into the user's GitHub/GitLab account where they can continue development after deploying.\n* **Configure a project**: Your users can customize key details such as repository name, Worker name, and required resource names in a single setup page with customizations reflected in the newly created Git repository.\n* **Build & deploy**: Cloudflare builds the application using [Workers Builds](https://developers.cloudflare.com/workers/ci-cd/builds) and deploys it to the Cloudflare network. Any required resources are automatically provisioned and bound to the Worker without additional setup.\n\n![Deploy to Cloudflare Flow](https://developers.cloudflare.com/_astro/dtw-user-flow.zgS3Y8iK_hqlHb.webp)\n\n## How to Set Up Deploy to Cloudflare buttons\n\nDeploy to Cloudflare buttons can be embedded anywhere developers might want to launch your project. To add a Deploy to Cloudflare button, copy the following snippet and replace the Git repository URL with your project's URL. You can also optionally specify a subdirectory.\n\n* Markdown",
      "language": "unknown"
    },
    {
      "code": "* HTML",
      "language": "unknown"
    },
    {
      "code": "* URL",
      "language": "unknown"
    },
    {
      "code": "If you have already deployed your application using Workers Builds, you can generate a Deploy to Cloudflare button directly from the Cloudflare dashboard by selecting the share button (located within your Worker details) and copying the provided snippet.\n\n![Share an application](https://developers.cloudflare.com/_astro/dtw-share-project.CTDMrwQu_Z1yXLMx.webp)\n\nOnce you have your snippet, you can paste this wherever you would like your button to be displayed.\n\n## Automatic resource provisioning\n\nIf your Worker application requires Cloudflare resources, they will be automatically provisioned as part of the deployment. Currently, supported resources include:\n\n* **Storage**: [KV namespaces](https://developers.cloudflare.com/kv/), [D1 databases](https://developers.cloudflare.com/d1/), [R2 buckets](https://developers.cloudflare.com/r2/), [Hyperdrive](https://developers.cloudflare.com/hyperdrive/), [Vectorize databases](https://developers.cloudflare.com/vectorize/), and [Secrets Store Secrets](https://developers.cloudflare.com/secrets-store/)\n* **Compute**: [Durable Objects](https://developers.cloudflare.com/durable-objects/), [Workers AI](https://developers.cloudflare.com/workers-ai/), and [Queues](https://developers.cloudflare.com/queues/)\n\nCloudflare will read the Wrangler configuration file of your source repo to determine resource requirements for your application. During deployment, Cloudflare will provision any necessary resources and update the Wrangler configuration where applicable for newly created resources (e.g. database IDs and namespace IDs). To ensure successful deployment, please make sure your source repository includes default values for resource names, resource IDs and any other properties for each binding.\n\n### Worker environment variables and secrets\n\n[Worker environment variables](https://developers.cloudflare.com/workers/configuration/environment-variables/) can be defined in your Wrangler configuration file as normal:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "[Worker secrets](https://developers.cloudflare.com/workers/configuration/secrets/) can be defined in a `.dev.vars.example` or `.env.example` file with a [dotenv](https://www.npmjs.com/package/dotenv) format:",
      "language": "unknown"
    },
    {
      "code": "[Secrets Store](https://developers.cloudflare.com/secrets-store/) secrets can be configured in the Wrangler configuration file as normal:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## Best practices\n\n**Configuring Build/Deploy commands**: If you are using custom `build` and `deploy` scripts in your `package.json` (for example, if using a full stack framework or running D1 migrations), Cloudflare will automatically detect and pre-populate the build and deploy fields. Users can choose to modify or accept the custom commands during deployment configuration.\n\nIf no `deploy` script is specified, Cloudflare will preconfigure `npx wrangler deploy` by default. If no `build` script is specified, Cloudflare will leave this field blank.\n\n**Running D1 Migrations**: If you would like to run migrations as part of your setup, you can specify this in your `package.json` by running your migrations as part of your `deploy` script. The migration command should reference the binding name rather than the database name to ensure migrations are successful when users specify a database name that is different from that of your source repository. The following is an example of how you can set up the scripts section of your `package.json`:",
      "language": "unknown"
    },
    {
      "code": "**Provide a description for bindings**: If you wish to provide additional information about bindings, such as why they are required in this template, or suggestions for how to configure a value, you can provide a description in your `package.json`. This can be particularly useful for environment variables and secrets where users might need to find a value outside of Cloudflare.\n\nInline markdown `` `code` ``, `**bold**`, `__italics__` and `[links](https://example.com)` are supported.",
      "language": "unknown"
    },
    {
      "code": "## Limitations\n\n* **Monorepos**: Cloudflare does not fully support monorepos\n\n  * If your repository URL contains a subdirectory, your application must be fully isolated within that subdirectory, including any dependencies. Otherwise, the build will fail. Cloudflare treats this subdirectory as the root of the new repository created as part of the deploy process.\n  * Additionally, if you have a monorepo that contains multiple Workers applications, they will not be deployed together. You must configure a separate Deploy to Cloudflare button for each application. The user will manually create a distinct Workers application for each subdirectory.\n\n* **Pages applications**: Deploy to Cloudflare buttons only support Workers applications.\n\n* **Non-GitHub/GitLab repositories**: Source repositories from anything other than github.com and gitlab.com are not supported. Self-hosted versions of GitHub and GitLab are also not supported.\n\n* **Private repositories**: Repositories must be public in order for others to successfully use your Deploy to Cloudflare button.\n\n</page>\n\n<page>\n---\ntitle: Infrastructure as Code (IaC)  Cloudflare Workers docs\ndescription: While Wrangler makes it easy to upload and manage Workers, there\n  are times when you need a more programmatic approach. This could involve using\n  Infrastructure as Code (IaC) tools or interacting directly with the Workers\n  API. Examples include build and deploy scripts, CI/CD pipelines, custom\n  developer tools, and automated testing.\nlastUpdated: 2025-12-29T17:29:32.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/platform/infrastructure-as-code/\n  md: https://developers.cloudflare.com/workers/platform/infrastructure-as-code/index.md\n---\n\nWhile [Wrangler](https://developers.cloudflare.com/workers/wrangler/configuration) makes it easy to upload and manage Workers, there are times when you need a more programmatic approach. This could involve using Infrastructure as Code (IaC) tools or interacting directly with the [Workers API](https://developers.cloudflare.com/api/resources/workers/). Examples include build and deploy scripts, CI/CD pipelines, custom developer tools, and automated testing.\n\nTo make this easier, Cloudflare provides SDK libraries for popular languages such as [cloudflare-typescript](https://github.com/cloudflare/cloudflare-typescript) and [cloudflare-python](https://github.com/cloudflare/cloudflare-python). For IaC, you can use tools like HashiCorp's Terraform and the [Cloudflare Terraform Provider](https://developers.cloudflare.com/terraform) to manage Workers resources.\n\nBelow are examples of deploying a Worker using different tools and languages, along with important considerations for managing Workers with IaC.\n\nAll of these examples need an [account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids) and [API token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token) (not Global API key) to work.\n\n## Workers Bundling\n\nNone of the examples below do [Workers Bundling](https://developers.cloudflare.com/workers/wrangler/bundling). This is usually done with Wrangler or a tool like [esbuild](https://esbuild.github.io).\n\nGenerally, you'd run this bundling step before applying your Terraform plan or using the API for script upload:",
      "language": "unknown"
    },
    {
      "code": "When using Wrangler for building and a different method for uploading, make sure to copy all of your config from `wrangler.json` into your Terraform config or API request. This is especially important with `compatibility_date` or flags your script relies on.\n\n## Terraform\n\nIn this example, you need a local file named `my-script.mjs` with script content similar to the below examples. Learn more about the Cloudflare Terraform Provider [here](https://developers.cloudflare.com/terraform), and see an example with all the Workers script resource settings [here](https://github.com/cloudflare/terraform-provider-cloudflare/blob/main/examples/resources/cloudflare_workers_script/resource.tf).",
      "language": "unknown"
    },
    {
      "code": "Notice how you don't have to manage all of these resources in Terraform. For example, you could just the `cloudflare_worker` resource and seamlessly use Wrangler or your own deployment tools for Versions or Deployments.\n\n## Bindings in Terraform\n\n[Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/) allow your Worker to interact with resources on the Cloudflare Developer Platform. In Terraform, bindings are configured differently than in Wrangler. Instead of separate top-level properties for each binding type (like `kv_namespaces`, `r2_buckets`, etc.), Terraform uses a single `bindings` array where each binding has a `type` property along with type-specific properties.\n\nBelow are examples of each binding type and their required properties:\n\n### KV Namespace Binding\n\nBind to a [KV namespace](https://developers.cloudflare.com/kv/api/) for key-value storage:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"kv_namespace\"`\n* `name`: The variable name for the binding, accessible via `env.MY_KV`\n* `namespace_id`: The ID of your KV namespace\n\n### R2 Bucket Binding\n\nBind to an [R2 bucket](https://developers.cloudflare.com/r2/api/workers/workers-api-reference/) for object storage:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"r2_bucket\"`\n* `name`: The binding name to access via `env.MY_BUCKET`\n* `bucket_name`: The name of your R2 bucket\n\n### D1 Database Binding\n\nBind to a [D1 database](https://developers.cloudflare.com/d1/worker-api/) for SQL storage:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"d1\"`\n* `name`: The binding name to access via `env.DB`\n* `id`: The ID of your D1 database\n\n### Durable Object Binding\n\nBind to a [Durable Object](https://developers.cloudflare.com/durable-objects/api/) class:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"durable_object_namespace\"`\n* `name`: The binding name to access via `env.MY_DURABLE_OBJECT`\n* `class_name`: The exported class name of the Durable Object\n* `script_name`: (Optional) The Worker script that exports this Durable Object class. Omit if the class is defined in the same Worker.\n\n### Service Binding\n\nBind to another [Worker](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/) for Worker-to-Worker communication:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"service\"`\n* `name`: The binding name to access via `env.MY_SERVICE`\n* `service`: The name of the target Worker\n* `entrypoint`: (Optional) The named [entrypoint](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/rpc/#named-entrypoints) to bind to\n\n### Queue Binding\n\nBind to a [Queue](https://developers.cloudflare.com/queues/configuration/javascript-apis/) for message passing:\n\nFor producing messages:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"queue\"`\n* `name`: The binding name to access via `env.MY_QUEUE`\n* `queue_name`: The name of your Queue\n\nFor consuming messages, configure your Worker as a consumer in the queue resource itself, not via bindings.\n\n### Vectorize Binding\n\nBind to a [Vectorize index](https://developers.cloudflare.com/vectorize/) for vector search:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"vectorize\"`\n* `name`: The binding name to access via `env.VECTORIZE_INDEX`\n* `index_name`: The name of your Vectorize index\n\n### Workers AI Binding\n\nBind to [Workers AI](https://developers.cloudflare.com/workers-ai/) for AI inference:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"ai\"`\n* `name`: The binding name to access via `env.AI`\n\n### Hyperdrive Binding\n\nBind to a [Hyperdrive](https://developers.cloudflare.com/hyperdrive/) configuration for database connection pooling:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"hyperdrive\"`\n* `name`: The binding name to access via `env.HYPERDRIVE`\n* `id`: The ID of your Hyperdrive configuration\n\n### Analytics Engine Binding\n\nBind to an [Analytics Engine](https://developers.cloudflare.com/analytics/analytics-engine/) dataset:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"analytics_engine\"`\n* `name`: The binding name to access via `env.ANALYTICS`\n* `dataset`: The name of your Analytics Engine dataset\n\n### Environment Variables\n\nFor plain text environment variables, use the `plain_text` binding type:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"plain_text\"`\n* `name`: The binding name to access via `env.MY_VARIABLE`\n* `text`: The value of the environment variable\n\n### Secret Text Binding\n\nFor encrypted secrets, use the `secret_text` binding type:",
      "language": "unknown"
    },
    {
      "code": "**Properties:**\n\n* `type`: `\"secret_text\"`\n* `name`: The binding name to access via `env.API_KEY`\n* `text`: The secret value (will be encrypted)\n\n### Complete Example\n\nHere's an example combining multiple binding types:",
      "language": "unknown"
    },
    {
      "code": "## Cloudflare API Libraries\n\nThis example uses the [cloudflare-typescript](https://github.com/cloudflare/cloudflare-typescript) SDK which provides convenient access to the Cloudflare REST API from server-side JavaScript or TypeScript.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "## Cloudflare REST API\n\nOpen a terminal or create a shell script to upload a Worker and manage versions and deployments with curl. Workers scripts are JavaScript [ES Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), but we also support [Python Workers](https://developers.cloudflare.com/workers/languages/python/) (open beta) and [Rust Workers](https://developers.cloudflare.com/workers/languages/rust/).\n\nWarning\n\nThis API is in beta. See the multipart/form-data API below for the stable API.\n\n* ES Module",
      "language": "unknown"
    },
    {
      "code": "* Python\n\n  [Python Workers](https://developers.cloudflare.com/workers/languages/python/) have their own special `text/x-python` content type and `python_workers` compatibility flag.",
      "language": "unknown"
    },
    {
      "code": "### multipart/form-data upload API\n\nThis API uses [multipart/form-data](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods/POST) to upload a Worker and will implicitly create a version and deployment. The above API is recommended for direct management of versions and deployments.\n\n* Workers",
      "language": "unknown"
    },
    {
      "code": "* Workers for Platforms\n\n  For [Workers for Platforms](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms), you can upload a [User Worker](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/how-workers-for-platforms-works/#user-workers) to a [dispatch namespace](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/how-workers-for-platforms-works/#dispatch-namespace). Note the [API endpoint](https://developers.cloudflare.com/api/resources/workers_for_platforms/subresources/dispatch/subresources/namespaces/subresources/scripts/methods/update/) is on `/workers/dispatch/namespaces/$DISPATCH_NAMESPACE/scripts/$SCRIPT_NAME`.",
      "language": "unknown"
    },
    {
      "code": "### Python Workers\n\n[Python Workers](https://developers.cloudflare.com/workers/languages/python/) (open beta) have their own special `text/x-python` content type and `python_workers` compatibility flag for uploading using the multipart/form-data API.",
      "language": "unknown"
    },
    {
      "code": "## Considerations with Durable Objects\n\n[Durable Object](https://developers.cloudflare.com/durable-objects/) migrations are applied with deployments. This means you can't bind to a Durable Object in a Version if a deployment doesn't exist i.e. migrations haven't been applied. For example, running this in Terraform will fail the first time the plan is applied:",
      "language": "unknown"
    },
    {
      "code": "To make this succeed, you first have to comment out the `durable_object` binding block, apply the plan, uncomment it, comment out the `migrations` block, then apply again. This time the plan will succeed. This also applies to the API or SDKs. This is an example where it makes sense to just manage the `cloudflare_worker` and/or `cloudflare_workers_deployment` resources while using Wrangler for build and Version management.\n\n## Considerations with Worker Versions\n\n### Resource immutability\n\nWorker versions are immutable at the API level, meaning they cannot be updated after creation, only re-created with any desired changes. This means that meaningful changes to the `cloudflare_worker_version` Terraform resource will always trigger replacement. When the `cloudflare_worker_version` resource is replaced, a new version with the desired changes is created, but the previous version is not deleted. This ensures the Worker has a complete version history when managed via Terraform. In other words, versions are both immutable and append-only. When the parent `cloudflare_worker` resource is deleted, all existing versions associated with the Worker are also deleted.\n\n### Module Content\n\nWorker version modules support two mutually exclusive ways to provide content:\n\n* **`content_file`** - Points to a local file\n* **`content_base64`** - Inline base64-encoded content\n\nIn both cases, changes to the underlying content are tracked using the computed `content_sha256` attribute. Specifying content using the `content_file` attribute is preferred in almost all cases, as it avoids storing the content itself in state. Module content may be quite large (up to tens of megabytes), and storing it in state will bloat the state file and negatively affect the performance of Terraform operations. The main use case for the `content_base64` attribute is importing the `cloudflare_worker_version` Terraform resource from the API, discussed below.\n\n### Import Behavior\n\n**During import, Terraform always populates the `content_base64` attribute in state**, regardless of the attribute used in your config.",
      "language": "unknown"
    },
    {
      "code": "If your config uses `content_file`, there will be a mismatch after import (state uses `content_base64`, config uses `content_file`). This is expected.\n\nAssuming the content of the local file referenced by `content_file` matches the imported content and their `content_sha256` values are the same, this will result in an in-place update of the `cloudflare_worker_version` Terraform resource. This should be an in-place update instead of a replacement because the underlying content is not changing (the `content_sha256` attribute is the same in both cases), and the resource does not need to be updated at the API level. The only thing that needs to be updated is Terraform state, which will switch from using `content_base64` to `content_file` after the update.\n\nIf Terraform instead wants to replace the resource, citing a difference in computed `content_sha256` values, then the content of the local file referenced by `content_file` does not match the imported content and the resource can't be cleanly imported without updating the local file to match the expected API value.\n\n### Examples\n\n**Using `content_file`:**",
      "language": "unknown"
    },
    {
      "code": "**Using `content_base64`:**",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Known issues  Cloudflare Workers docs\ndescription: Known issues and bugs to be aware of when using Workers.\nlastUpdated: 2025-05-15T14:14:09.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/platform/known-issues/\n  md: https://developers.cloudflare.com/workers/platform/known-issues/index.md\n---\n\nBelow are some known bugs and issues to be aware of when using Cloudflare Workers.\n\n## Route specificity\n\n* When defining route specificity, a trailing `/*` in your pattern may not act as expected.\n\nConsider two different Workers, each deployed to the same zone. Worker A is assigned the `example.com/images/*` route and Worker B is given the `example.com/images*` route pattern. With these in place, here are how the following URLs will be resolved:",
      "language": "unknown"
    },
    {
      "code": "You will notice that all examples trigger Worker B. This includes the final example, which exemplifies the unexpected behavior.\n\nWhen adding a wildcard on a subdomain, here are how the following URLs will be resolved:",
      "language": "unknown"
    },
    {
      "code": "## wrangler dev\n\n* When running `wrangler dev --remote`, all outgoing requests are given the `cf-workers-preview-token` header, which Cloudflare recognizes as a preview request. This applies to the entire Cloudflare network, so making HTTP requests to other Cloudflare zones is currently discarded for security reasons. To enable a workaround, insert the following code into your Worker script:",
      "language": "unknown"
    },
    {
      "code": "## Fetch API in CNAME setup\n\nWhen you make a subrequest using [`fetch()`](https://developers.cloudflare.com/workers/runtime-apis/fetch/) from a Worker, the Cloudflare DNS resolver is used. When a zone has a [Partial (CNAME) setup](https://developers.cloudflare.com/dns/zone-setups/partial-setup/), all hostnames that the Worker needs to be able to resolve require a dedicated DNS entry in Cloudflare's DNS setup. Otherwise the Fetch API call will fail with status code [530 (1016)](https://developers.cloudflare.com/support/troubleshooting/http-status-codes/cloudflare-1xxx-errors/error-1016/).\n\nSetup with missing DNS records in Cloudflare DNS",
      "language": "unknown"
    },
    {
      "code": "After adding `sub2.example.com` to Cloudflare DNS",
      "language": "unknown"
    },
    {
      "code": "## Fetch to IP addresses\n\nFor Workers subrequests, requests can only be made to URLs, not to IP addresses directly. To overcome this limitation [add a A or AAAA name record to your zone](https://developers.cloudflare.com/dns/manage-dns-records/how-to/create-dns-records/) and then fetch that resource.\n\nFor example, in the zone `example.com` create a record of type `A` with the name `server` and value `192.0.2.1`, and then use:",
      "language": "unknown"
    },
    {
      "code": "Do not use:",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Limits  Cloudflare Workers docs\ndescription: Cloudflare Workers plan and platform limits.\nlastUpdated: 2025-11-05T22:40:03.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/platform/limits/\n  md: https://developers.cloudflare.com/workers/platform/limits/index.md\n---\n\n## Account plan limits\n\n| Feature | Workers Free | Workers Paid |\n| - | - | - |\n| [Subrequests](#subrequests) | 50/request | 1000/request |\n| [Simultaneous outgoing connections/request](#simultaneous-open-connections) | 6 | 6 |\n| [Environment variables](#environment-variables) | 64/Worker | 128/Worker |\n| [Environment variable size](#environment-variables) | 5 KB | 5 KB |\n| [Worker size](#worker-size) | 3 MB | 10 MB |\n| [Worker startup time](#worker-startup-time) | 1 second | 1 second |\n| [Number of Workers](#number-of-workers)1 | 100 | 500 |\n| Number of [Cron Triggers](https://developers.cloudflare.com/workers/configuration/cron-triggers/) per account | 5 | 250 |\n| Number of [Static Asset](#static-assets) files per Worker version | 20,000 | 100,000 |\n| Individual [Static Asset](#static-assets) file size | 25 MiB | 25 MiB |\n\n1 If you are running into limits, your project may be a good fit for [Workers for Platforms](https://developers.cloudflare.com/cloudflare-for-platforms/workers-for-platforms/).\n\nNeed a higher limit?\n\nTo request an adjustment to a limit, complete the [Limit Increase Request Form](https://forms.gle/ukpeZVLWLnKeixDu7). If the limit can be increased, Cloudflare will contact you with next steps.\n\n***\n\n## Request limits\n\nURLs have a limit of 16 KB.\n\nRequest headers observe a total limit of 128 KB.\n\nCloudflare has network-wide limits on the request body size. This limit is tied to your Cloudflare account's plan, which is separate from your Workers plan. When the request body size of your `POST`/`PUT`/`PATCH` requests exceed your plan's limit, the request is rejected with a `(413) Request entity too large` error.\n\nCloudflare Enterprise customers may contact their account team or [Cloudflare Support](https://developers.cloudflare.com/support/contacting-cloudflare-support/) to have a request body limit beyond 500 MB.\n\n| Cloudflare Plan | Maximum body size |\n| - | - |\n| Free | 100 MB |\n| Pro | 100 MB |\n| Business | 200 MB |\n| Enterprise | 500 MB (by default) |\n\n***\n\n## Response limits\n\nResponse headers observe a total limit of 128 KB.\n\nCloudflare does not enforce response limits on response body sizes, but cache limits for [our CDN are observed](https://developers.cloudflare.com/cache/concepts/default-cache-behavior/). Maximum file size is 512 MB for Free, Pro, and Business customers and 5 GB for Enterprise customers.\n\n***\n\n## Worker limits\n\n| Feature | Workers Free | Workers Paid |\n| - | - | - |\n| [Request](#request) | 100,000requests/day 1000requests/min | No limit |\n| [Worker memory](#memory) | 128 MB | 128 MB |\n| [CPU time](#cpu-time) | 10 ms | 5 min HTTP request 15 min [Cron Trigger](https://developers.cloudflare.com/workers/configuration/cron-triggers/) |\n| [Duration](#duration) | No limit | No limit for Workers. 15 min duration limit for [Cron Triggers](https://developers.cloudflare.com/workers/configuration/cron-triggers/), [Durable Object Alarms](https://developers.cloudflare.com/durable-objects/api/alarms/) and [Queue Consumers](https://developers.cloudflare.com/queues/configuration/javascript-apis/#consumer) |\n\n### Duration\n\nDuration is a measurement of wall-clock time the total amount of time from the start to end of an invocation of a Worker. There is no hard limit on the duration of a Worker. As long as the client that sent the request remains connected, the Worker can continue processing, making subrequests, and setting timeouts on behalf of that request. When the client disconnects, all tasks associated with that client request are canceled. Use [`event.waitUntil()`](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) to delay cancellation for another 30 seconds or until the promise passed to `waitUntil()` completes.\n\nNote\n\nCloudflare updates the Workers runtime a few times per week. When this happens, any in-flight requests are given a grace period of 30 seconds to finish. If a request does not finish within this time, it is terminated. While your application should follow the best practice of handling disconnects by retrying requests, this scenario is extremely improbable. To encounter it, you would need to have a request that takes longer than 30 seconds that also happens to intersect with the exact time an update to the runtime is happening.\n\n### CPU time\n\nCPU time is the amount of time the CPU actually spends doing work during a given request. If a Worker's request makes a sub-request and waits for that request to come back before doing additional work, this time spent waiting **is not** counted towards CPU time.\n\n**Most Workers requests consume less than 1-2 milliseconds of CPU time**, but you can increase the maximum CPU time from the default 30 seconds to 5 minutes (300,000 milliseconds) if you have CPU-bound tasks, such as large JSON payloads that need to be serialized, cryptographic key generation, or other data processing tasks.\n\nEach [isolate](https://developers.cloudflare.com/workers/reference/how-workers-works/#isolates) has some built-in flexibility to allow for cases where your Worker infrequently runs over the configured limit. If your Worker starts hitting the limit consistently, its execution will be terminated according to the limit configured.\n\nTo understand your CPU usage:\n\n* CPU time and Wall time are surfaced in the [invocation log](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) within Workers Logs.\n* For Tail Workers, CPU time and Wall time are surfaced at the top level of the [Workers Trace Events object](https://developers.cloudflare.com/logs/logpush/logpush-job/datasets/account/workers_trace_events/).\n* DevTools locally can help identify CPU intensive portions of your code. See the [CPU profiling with DevTools documentation](https://developers.cloudflare.com/workers/observability/dev-tools/cpu-usage/).\n\nYou can also set a [custom limit](https://developers.cloudflare.com/workers/wrangler/configuration/#limits) on the amount of CPU time that can be used during each invocation of your Worker.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "You can also customize this in the [Workers dashboard](https://dash.cloudflare.com/?to=/:account/workers). Select the specific Worker you wish to modify -> click on the \"Settings\" tab -> adjust the CPU time limit.\n\nNote\n\nScheduled Workers ([Cron Triggers](https://developers.cloudflare.com/workers/configuration/cron-triggers/)) have different limits on CPU time based on the schedule interval. When the schedule interval is less than 1 hour, a Scheduled Worker may run for up to 30 seconds. When the schedule interval is 1 hour or more, a scheduled Worker may run for up to 15 minutes.\n\n***\n\n## Cache API limits\n\n| Feature | Workers Free | Workers Paid |\n| - | - | - |\n| [Maximum object size](#cache-api-limits) | 512 MB | 512 MB |\n| [Calls/request](#cache-api-limits) | 50 | 1,000 |\n\nCalls/request means the number of calls to `put()`, `match()`, or `delete()` Cache API method per-request, using the same quota as subrequests (`fetch()`).\n\nNote\n\nThe size of chunked response bodies (`Transfer-Encoding: chunked`) is not known in advance. Then, `.put()`ing such responses will block subsequent `.put()`s from starting until the current `.put()` completes.\n\n***\n\n## Request\n\nWorkers automatically scale onto thousands of Cloudflare global network servers around the world. There is no general limit to the number of requests per second Workers can handle.\n\n### Daily request\n\nAccounts using the Workers Free plan are subject to a daily request limit of 100,000 requests. Free plan daily requests counts reset at midnight UTC. A Worker that fails as a result of daily request limit errors can be configured by toggling its corresponding [route](https://developers.cloudflare.com/workers/configuration/routing/routes/) in two modes: 1) Fail open and 2) Fail closed.\n\n#### Fail open\n\nRoutes in fail open mode will bypass the failing Worker and prevent it from operating on incoming traffic. Incoming requests will behave as if there was no Worker.\n\n#### Fail closed\n\nRoutes in fail closed mode will display a Cloudflare `1027` error page to visitors, signifying the Worker has been temporarily disabled. Cloudflare recommends this option if your Worker is performing security related tasks.\n\n***\n\n## Memory\n\nEach [isolate](https://developers.cloudflare.com/workers/reference/how-workers-works/#isolates) of your Worker's code runs in can consume up to 128 MB of memory. This includes both memory used by the JavaScript heap, and memory explicitly allocated in [WebAssembly](https://developers.cloudflare.com/workers/runtime-apis/webassembly/). Note that this limit is per-isolate, not per-invocation of your Worker. A single isolate can handle many concurrent requests.\n\nWhen an isolate running your Worker exceeds 128 MB of memory, the Workers runtime handles this gracefully instead of failing immediately. It allows in-flight requests to complete while simultaneously creating a new isolate for your Worker for new requests. While this approach typically allows in-flight requests to complete, during periods of extremely high load, some incoming requests may be cancelled to maintain system stability.\n\nTo view out-of-memory errors (OOM), as well as CPU limit overages:\n\n1. In the Cloudflare dashboard, go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. Select the Worker you would like to investigate.\n\n3. Under **Metrics**, select **Errors** > **Invocation Statuses** and examine **Exceeded Memory**.\n\nTo avoid exceeding memory limits, where possible you should avoid buffering large objects or responses in memory, and instead use streaming APIs such as [`TransformStream`](https://developers.cloudflare.com/workers/runtime-apis/streams/transformstream/) or [`node:stream`](https://developers.cloudflare.com/workers/runtime-apis/nodejs/streams/) to stream responses. Manipulating streams allows you to avoid buffering entire responses in memory.\n\nYou can also use Chrome DevTools in local development to identify memory leaks in your code. See the [memory profiling with DevTools documentation](https://developers.cloudflare.com/workers/observability/dev-tools/memory-usage/) to learn more.\n\n***\n\n## Subrequests\n\nA subrequest is any request that a Worker makes to either Internet resources using the [Fetch API](https://developers.cloudflare.com/workers/runtime-apis/fetch/) or requests to other Cloudflare services like [R2](https://developers.cloudflare.com/r2/), [KV](https://developers.cloudflare.com/kv/), or [D1](https://developers.cloudflare.com/d1/).\n\n### Worker-to-Worker subrequests\n\nTo make subrequests from your Worker to another Worker on your account, use [Service Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/). Service bindings allow you to send HTTP requests to another Worker without those requests going over the Internet.\n\nIf you attempt to use global [`fetch()`](https://developers.cloudflare.com/workers/runtime-apis/fetch/) to make a subrequest to another Worker on your account that runs on the same [zone](https://developers.cloudflare.com/fundamentals/concepts/accounts-and-zones/#zones), without service bindings, the request will fail.\n\nIf you make a subrequest from your Worker to a target Worker that runs on a [Custom Domain](https://developers.cloudflare.com/workers/configuration/routing/custom-domains/#worker-to-worker-communication) rather than a route, the request will be allowed.\n\n### How many subrequests can I make?\n\nYou can make 50 subrequests per request on Workers Free, and 1,000 subrequests per request on Workers Paid. Each subrequest in a redirect chain counts against this limit. This means that the number of subrequests a Worker makes could be greater than the number of `fetch(request)` calls in the Worker.\n\nFor subrequests to internal services like Workers KV and Durable Objects, the subrequest limit is 1,000 per request, regardless of the [usage model](https://developers.cloudflare.com/workers/platform/pricing/#workers) configured for the Worker.\n\n### How long can a subrequest take?\n\nThere is no set limit on the amount of real time a Worker may use. As long as the client which sent a request remains connected, the Worker may continue processing, making subrequests, and setting timeouts on behalf of that request.\n\nWhen the client disconnects, all tasks associated with that clients request are proactively canceled. If the Worker passed a promise to [`event.waitUntil()`](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/), cancellation will be delayed until the promise has completed or until an additional 30 seconds have elapsed, whichever happens first.\n\n***\n\n## Simultaneous open connections\n\nYou can open up to six connections simultaneously for each invocation of your Worker. The connections opened by the following API calls all count toward this limit:\n\n* the `fetch()` method of the [Fetch API](https://developers.cloudflare.com/workers/runtime-apis/fetch/).\n* `get()`, `put()`, `list()`, and `delete()` methods of [Workers KV namespace objects](https://developers.cloudflare.com/kv/api/).\n* `put()`, `match()`, and `delete()` methods of [Cache objects](https://developers.cloudflare.com/workers/runtime-apis/cache/).\n* `list()`, `get()`, `put()`, `delete()`, and `head()` methods of [R2](https://developers.cloudflare.com/r2/).\n* `send()` and `sendBatch()`, methods of [Queues](https://developers.cloudflare.com/queues/).\n* Opening a TCP socket using the [`connect()`](https://developers.cloudflare.com/workers/runtime-apis/tcp-sockets/) API.\n\nOutbound WebSocket connections are just HTTP connections and thus also contribute to the maximum concurrent connections limit.\n\nOnce an invocation has six connections open, it can still attempt to open additional connections.\n\n* These attempts are put in a pending queue  the connections will not be initiated until one of the currently open connections has closed.\n* Earlier connections can delay later ones, if a Worker tries to make many simultaneous subrequests, its later subrequests may appear to take longer to start.\n* Earlier connections that are stalled1 might get closed with a `Response closed due to connection limit` exception.\n\nIf you have cases in your application that use `fetch()` but that do not require consuming the response body, you can avoid the unread response body from consuming a concurrent connection by using `response.body.cancel()`.\n\nFor example, if you want to check whether the HTTP response code is successful (2xx) before consuming the body, you should explicitly cancel the pending response body:",
      "language": "unknown"
    },
    {
      "code": "This will free up an open connection.\n\nIf the system detects that a Worker is deadlocked on stalled connections1  for example, if the Worker has pending connection attempts but has no in-progress reads or writes on the connections that it already has open  then the least-recently-used open connection will be canceled to unblock the Worker.\n\nIf the Worker later attempts to use a canceled connection, a `Response closed due to connection limit` exception will be thrown. These exceptions should rarely occur in practice, though, since it is uncommon for a Worker to open a connection that it does not have an immediate use for.\n\n1A connections is considered stalled when it is not not being actively read from or written to, for example:",
      "language": "unknown"
    },
    {
      "code": "Note\n\nSimultaneous Open Connections are measured from the top-level request, meaning any connections open from Workers sharing resources (for example, Workers triggered via [Service bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/service-bindings/)) will share the simultaneous open connection limit.\n\n***\n\n## Environment variables\n\nThe maximum number of environment variables (secret and text combined) for a Worker is 128 variables on the Workers Paid plan, and 64 variables on the Workers Free plan. There is no limit to the number of environment variables per account.\n\nEach environment variable has a size limitation of 5 KB.\n\n***\n\n## Worker size\n\nA Worker can be up to 10 MB in size *after compression* on the Workers Paid plan, and up to 3 MB on the Workers Free plan. On either plan, a Worker can be up to 64 MB *before compression*.\n\nYou can assess the size of your Worker bundle after compression by performing a dry-run with `wrangler` and reviewing the final compressed (`gzip`) size output by `wrangler`:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Create a new Worker project",
      "id": "1.-create-a-new-worker-project"
    },
    {
      "level": "h2",
      "text": "2. Develop with Wrangler CLI",
      "id": "2.-develop-with-wrangler-cli"
    },
    {
      "level": "h2",
      "text": "3. Write code",
      "id": "3.-write-code"
    },
    {
      "level": "h2",
      "text": "4. Deploy your project",
      "id": "4.-deploy-your-project"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h3",
      "text": "Build Workers using a prompt",
      "id": "build-workers-using-a-prompt"
    },
    {
      "level": "h3",
      "text": "Additional uses",
      "id": "additional-uses"
    },
    {
      "level": "h3",
      "text": "Passing a system prompt",
      "id": "passing-a-system-prompt"
    },
    {
      "level": "h2",
      "text": "Use docs in your editor",
      "id": "use-docs-in-your-editor"
    },
    {
      "level": "h2",
      "text": "Additional resources",
      "id": "additional-resources"
    },
    {
      "level": "h3",
      "text": "astro-blog-starter-template",
      "id": "astro-blog-starter-template"
    },
    {
      "level": "h3",
      "text": "chanfana-openapi-template",
      "id": "chanfana-openapi-template"
    },
    {
      "level": "h3",
      "text": "cli",
      "id": "cli"
    },
    {
      "level": "h3",
      "text": "containers-template",
      "id": "containers-template"
    },
    {
      "level": "h3",
      "text": "d1-starter-sessions-api-template",
      "id": "d1-starter-sessions-api-template"
    },
    {
      "level": "h3",
      "text": "d1-template",
      "id": "d1-template"
    },
    {
      "level": "h3",
      "text": "durable-chat-template",
      "id": "durable-chat-template"
    },
    {
      "level": "h3",
      "text": "hello-world-do-template",
      "id": "hello-world-do-template"
    },
    {
      "level": "h3",
      "text": "llm-chat-app-template",
      "id": "llm-chat-app-template"
    },
    {
      "level": "h3",
      "text": "multiplayer-globe-template",
      "id": "multiplayer-globe-template"
    },
    {
      "level": "h3",
      "text": "mysql-hyperdrive-template",
      "id": "mysql-hyperdrive-template"
    },
    {
      "level": "h3",
      "text": "next-starter-template",
      "id": "next-starter-template"
    },
    {
      "level": "h3",
      "text": "nlweb-template",
      "id": "nlweb-template"
    },
    {
      "level": "h3",
      "text": "nodejs-http-server-template",
      "id": "nodejs-http-server-template"
    },
    {
      "level": "h3",
      "text": "openauth-template",
      "id": "openauth-template"
    },
    {
      "level": "h3",
      "text": "postgres-hyperdrive-template",
      "id": "postgres-hyperdrive-template"
    },
    {
      "level": "h3",
      "text": "r2-explorer-template",
      "id": "r2-explorer-template"
    },
    {
      "level": "h3",
      "text": "react-postgres-fullstack-template",
      "id": "react-postgres-fullstack-template"
    },
    {
      "level": "h3",
      "text": "react-router-hono-fullstack-template",
      "id": "react-router-hono-fullstack-template"
    },
    {
      "level": "h3",
      "text": "react-router-postgres-ssr-template",
      "id": "react-router-postgres-ssr-template"
    },
    {
      "level": "h3",
      "text": "react-router-starter-template",
      "id": "react-router-starter-template"
    },
    {
      "level": "h3",
      "text": "remix-starter-template",
      "id": "remix-starter-template"
    },
    {
      "level": "h3",
      "text": "saas-admin-template",
      "id": "saas-admin-template"
    },
    {
      "level": "h3",
      "text": "text-to-image-template",
      "id": "text-to-image-template"
    },
    {
      "level": "h3",
      "text": "to-do-list-kv-template",
      "id": "to-do-list-kv-template"
    },
    {
      "level": "h3",
      "text": "vite-react-template",
      "id": "vite-react-template"
    },
    {
      "level": "h3",
      "text": "worker-publisher-template",
      "id": "worker-publisher-template"
    },
    {
      "level": "h3",
      "text": "workflows-starter-template",
      "id": "workflows-starter-template"
    },
    {
      "level": "h3",
      "text": "x402-proxy-template",
      "id": "x402-proxy-template"
    },
    {
      "level": "h2",
      "text": "Caching HTML resources",
      "id": "caching-html-resources"
    },
    {
      "level": "h2",
      "text": "Custom cache keys",
      "id": "custom-cache-keys"
    },
    {
      "level": "h2",
      "text": "Override based on origin response code",
      "id": "override-based-on-origin-response-code"
    },
    {
      "level": "h2",
      "text": "Customize cache behavior based on request file type",
      "id": "customize-cache-behavior-based-on-request-file-type"
    },
    {
      "level": "h2",
      "text": "Using the HTTP Cache API",
      "id": "using-the-http-cache-api"
    },
    {
      "level": "h2",
      "text": "Set Cron Triggers in Wrangler",
      "id": "set-cron-triggers-in-wrangler"
    },
    {
      "level": "h2",
      "text": "Test Cron Triggers using Wrangler",
      "id": "test-cron-triggers-using-wrangler"
    },
    {
      "level": "h2",
      "text": "Console-logging headers",
      "id": "console-logging-headers"
    },
    {
      "level": "h3",
      "text": "The problem",
      "id": "the-problem"
    },
    {
      "level": "h3",
      "text": "Pass headers through a Map",
      "id": "pass-headers-through-a-map"
    },
    {
      "level": "h3",
      "text": "Spread headers into an array",
      "id": "spread-headers-into-an-array"
    },
    {
      "level": "h3",
      "text": "Convert headers into an object with Object.fromEntries (ES2019)",
      "id": "convert-headers-into-an-object-with-object.fromentries-(es2019)"
    },
    {
      "level": "h2",
      "text": "Test Cron Triggers using Wrangler",
      "id": "test-cron-triggers-using-wrangler"
    },
    {
      "level": "h2",
      "text": "Redirect all requests to one URL",
      "id": "redirect-all-requests-to-one-url"
    },
    {
      "level": "h2",
      "text": "Redirect requests from one domain to another",
      "id": "redirect-requests-from-one-domain-to-another"
    },
    {
      "level": "h2",
      "text": "Validate signed requests using the WAF",
      "id": "validate-signed-requests-using-the-waf"
    },
    {
      "level": "h2",
      "text": "Stream a JSON request body",
      "id": "stream-a-json-request-body"
    },
    {
      "level": "h2",
      "text": "Stream and transform a JSON response",
      "id": "stream-and-transform-a-json-response"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Write a WebSocket Server",
      "id": "write-a-websocket-server"
    },
    {
      "level": "h3",
      "text": "Connect to the WebSocket server from a client",
      "id": "connect-to-the-websocket-server-from-a-client"
    },
    {
      "level": "h2",
      "text": "Write a WebSocket client",
      "id": "write-a-websocket-client"
    },
    {
      "level": "h2",
      "text": "WebSocket compression",
      "id": "websocket-compression"
    },
    {
      "level": "h3",
      "text": "Resources",
      "id": "resources"
    },
    {
      "level": "h2",
      "text": "Introduction",
      "id": "introduction"
    },
    {
      "level": "h3",
      "text": "The `pywrangler` CLI tool",
      "id": "the-`pywrangler`-cli-tool"
    },
    {
      "level": "h3",
      "text": "Python Worker Templates",
      "id": "python-worker-templates"
    },
    {
      "level": "h2",
      "text": "Next Up",
      "id": "next-up"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Create a new project with Wrangler",
      "id": "1.-create-a-new-project-with-wrangler"
    },
    {
      "level": "h2",
      "text": "2. Develop locally",
      "id": "2.-develop-locally"
    },
    {
      "level": "h2",
      "text": "3. Write your Worker code",
      "id": "3.-write-your-worker-code"
    },
    {
      "level": "h3",
      "text": "Related runtime APIs",
      "id": "related-runtime-apis"
    },
    {
      "level": "h2",
      "text": "4. Deploy your Worker project",
      "id": "4.-deploy-your-worker-project"
    },
    {
      "level": "h2",
      "text": "How this deployment works",
      "id": "how-this-deployment-works"
    },
    {
      "level": "h3",
      "text": "JavaScript Plumbing (`wasm-bindgen`)",
      "id": "javascript-plumbing-(`wasm-bindgen`)"
    },
    {
      "level": "h3",
      "text": "Async (`wasm-bindgen-futures`)",
      "id": "async-(`wasm-bindgen-futures`)"
    },
    {
      "level": "h3",
      "text": "Bundling (`worker-build`)",
      "id": "bundling-(`worker-build`)"
    },
    {
      "level": "h3",
      "text": "Binary Size (`wasm-opt`)",
      "id": "binary-size-(`wasm-opt`)"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h3",
      "text": "Generate types that match your Worker's configuration",
      "id": "generate-types-that-match-your-worker's-configuration"
    },
    {
      "level": "h3",
      "text": "Migrating from `@cloudflare/workers-types` to `wrangler types`",
      "id": "migrating-from-`@cloudflare/workers-types`-to-`wrangler-types`"
    },
    {
      "level": "h3",
      "text": "Resources",
      "id": "resources"
    },
    {
      "level": "h2",
      "text": "Using DevTools",
      "id": "using-devtools"
    },
    {
      "level": "h2",
      "text": "Opening DevTools",
      "id": "opening-devtools"
    },
    {
      "level": "h3",
      "text": "Wrangler",
      "id": "wrangler"
    },
    {
      "level": "h3",
      "text": "Vite",
      "id": "vite"
    },
    {
      "level": "h3",
      "text": "Dashboard editor & playground",
      "id": "dashboard-editor-&-playground"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Error pages generated by Workers",
      "id": "error-pages-generated-by-workers"
    },
    {
      "level": "h3",
      "text": "Loop limit",
      "id": "loop-limit"
    },
    {
      "level": "h3",
      "text": "\"The script will never generate a response\" errors",
      "id": "\"the-script-will-never-generate-a-response\"-errors"
    },
    {
      "level": "h3",
      "text": "\"Illegal invocation\" errors",
      "id": "\"illegal-invocation\"-errors"
    },
    {
      "level": "h3",
      "text": "Cannot perform I/O on behalf of a different request",
      "id": "cannot-perform-i/o-on-behalf-of-a-different-request"
    },
    {
      "level": "h2",
      "text": "Errors on Worker upload",
      "id": "errors-on-worker-upload"
    },
    {
      "level": "h3",
      "text": "Validation Errors (10021)",
      "id": "validation-errors-(10021)"
    },
    {
      "level": "h2",
      "text": "Runtime errors",
      "id": "runtime-errors"
    },
    {
      "level": "h2",
      "text": "Identify errors: Workers Metrics",
      "id": "identify-errors:-workers-metrics"
    },
    {
      "level": "h3",
      "text": "Worker Errors",
      "id": "worker-errors"
    },
    {
      "level": "h2",
      "text": "Debug exceptions with Workers Logs",
      "id": "debug-exceptions-with-workers-logs"
    },
    {
      "level": "h2",
      "text": "Debug exceptions from `Wrangler`",
      "id": "debug-exceptions-from-`wrangler`"
    },
    {
      "level": "h2",
      "text": "Set up a 3rd party logging service",
      "id": "set-up-a-3rd-party-logging-service"
    },
    {
      "level": "h2",
      "text": "Collect and persist Wasm core dumps",
      "id": "collect-and-persist-wasm-core-dumps"
    },
    {
      "level": "h2",
      "text": "Go to origin on error",
      "id": "go-to-origin-on-error"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h3",
      "text": "Supported telemetry types",
      "id": "supported-telemetry-types"
    },
    {
      "level": "h3",
      "text": "Available OpenTelemetry destinations",
      "id": "available-opentelemetry-destinations"
    },
    {
      "level": "h2",
      "text": "Setting up OpenTelemetry-compatible destinations",
      "id": "setting-up-opentelemetry-compatible-destinations"
    },
    {
      "level": "h3",
      "text": "Creating a destination",
      "id": "creating-a-destination"
    },
    {
      "level": "h2",
      "text": "Enabling OpenTelemetry export for your Worker",
      "id": "enabling-opentelemetry-export-for-your-worker"
    },
    {
      "level": "h2",
      "text": "Destination status",
      "id": "destination-status"
    },
    {
      "level": "h3",
      "text": "Status indicators",
      "id": "status-indicators"
    },
    {
      "level": "h2",
      "text": "Limits and pricing",
      "id": "limits-and-pricing"
    },
    {
      "level": "h2",
      "text": "Known limitations",
      "id": "known-limitations"
    },
    {
      "level": "h2",
      "text": "[Workers Logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs)",
      "id": "[workers-logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs)"
    },
    {
      "level": "h2",
      "text": "[Real-time logs](https://developers.cloudflare.com/workers/observability/logs/real-time-logs)",
      "id": "[real-time-logs](https://developers.cloudflare.com/workers/observability/logs/real-time-logs)"
    },
    {
      "level": "h2",
      "text": "[Tail Workers](https://developers.cloudflare.com/workers/observability/logs/tail-workers) Beta",
      "id": "[tail-workers](https://developers.cloudflare.com/workers/observability/logs/tail-workers)-beta"
    },
    {
      "level": "h2",
      "text": "[Workers Logpush](https://developers.cloudflare.com/workers/observability/logs/logpush)",
      "id": "[workers-logpush](https://developers.cloudflare.com/workers/observability/logs/logpush)"
    },
    {
      "level": "h2",
      "text": "Video Tutorial",
      "id": "video-tutorial"
    },
    {
      "level": "h2",
      "text": "Workers metrics",
      "id": "workers-metrics"
    },
    {
      "level": "h3",
      "text": "Requests",
      "id": "requests"
    },
    {
      "level": "h3",
      "text": "Subrequests",
      "id": "subrequests"
    },
    {
      "level": "h3",
      "text": "Wall time per execution",
      "id": "wall-time-per-execution"
    },
    {
      "level": "h3",
      "text": "CPU Time per execution",
      "id": "cpu-time-per-execution"
    },
    {
      "level": "h3",
      "text": "Execution duration (GB-seconds)",
      "id": "execution-duration-(gb-seconds)"
    },
    {
      "level": "h3",
      "text": "Invocation statuses",
      "id": "invocation-statuses"
    },
    {
      "level": "h3",
      "text": "Request duration",
      "id": "request-duration"
    },
    {
      "level": "h3",
      "text": "Metrics retention",
      "id": "metrics-retention"
    },
    {
      "level": "h2",
      "text": "Zone analytics",
      "id": "zone-analytics"
    },
    {
      "level": "h3",
      "text": "Subrequests",
      "id": "subrequests"
    },
    {
      "level": "h3",
      "text": "Bandwidth",
      "id": "bandwidth"
    },
    {
      "level": "h3",
      "text": "Status codes",
      "id": "status-codes"
    },
    {
      "level": "h3",
      "text": "Total requests",
      "id": "total-requests"
    },
    {
      "level": "h2",
      "text": "GraphQL",
      "id": "graphql"
    },
    {
      "level": "h2",
      "text": "Enable Query Builder",
      "id": "enable-query-builder"
    },
    {
      "level": "h2",
      "text": "Write a query in the Cloudflare dashboard",
      "id": "write-a-query-in-the-cloudflare-dashboard"
    },
    {
      "level": "h2",
      "text": "Query composition",
      "id": "query-composition"
    },
    {
      "level": "h3",
      "text": "Visualization",
      "id": "visualization"
    },
    {
      "level": "h3",
      "text": "Filter",
      "id": "filter"
    },
    {
      "level": "h3",
      "text": "Search",
      "id": "search"
    },
    {
      "level": "h3",
      "text": "Group By",
      "id": "group-by"
    },
    {
      "level": "h3",
      "text": "Order By",
      "id": "order-by"
    },
    {
      "level": "h3",
      "text": "Limit",
      "id": "limit"
    },
    {
      "level": "h3",
      "text": "Select time range",
      "id": "select-time-range"
    },
    {
      "level": "h2",
      "text": "Viewing query results",
      "id": "viewing-query-results"
    },
    {
      "level": "h3",
      "text": "Visualizations tab",
      "id": "visualizations-tab"
    },
    {
      "level": "h3",
      "text": "Invocations tab",
      "id": "invocations-tab"
    },
    {
      "level": "h3",
      "text": "Events tab",
      "id": "events-tab"
    },
    {
      "level": "h2",
      "text": "Save queries",
      "id": "save-queries"
    },
    {
      "level": "h2",
      "text": "Delete queries",
      "id": "delete-queries"
    },
    {
      "level": "h2",
      "text": "Share queries",
      "id": "share-queries"
    },
    {
      "level": "h2",
      "text": "Example: Composing a query",
      "id": "example:-composing-a-query"
    },
    {
      "level": "h2",
      "text": "Source Maps",
      "id": "source-maps"
    },
    {
      "level": "h2",
      "text": "Stack traces",
      "id": "stack-traces"
    },
    {
      "level": "h2",
      "text": "Limits",
      "id": "limits"
    },
    {
      "level": "h2",
      "text": "Example",
      "id": "example"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h3",
      "text": "What is Workers tracing?",
      "id": "what-is-workers-tracing?"
    },
    {
      "level": "h3",
      "text": "Automatic instrumentation",
      "id": "automatic-instrumentation"
    },
    {
      "level": "h3",
      "text": "How to enable tracing",
      "id": "how-to-enable-tracing"
    },
    {
      "level": "h3",
      "text": "Exporting OpenTelemetry traces to a 3rd party destination",
      "id": "exporting-opentelemetry-traces-to-a-3rd-party-destination"
    },
    {
      "level": "h3",
      "text": "Sampling",
      "id": "sampling"
    },
    {
      "level": "h3",
      "text": "Limits & Pricing",
      "id": "limits-&-pricing"
    },
    {
      "level": "h2",
      "text": "How to Set Up Built with Cloudflare button",
      "id": "how-to-set-up-built-with-cloudflare-button"
    },
    {
      "level": "h2",
      "text": "2025-11-25",
      "id": "2025-11-25"
    },
    {
      "level": "h2",
      "text": "2025-10-25",
      "id": "2025-10-25"
    },
    {
      "level": "h2",
      "text": "2025-10-22",
      "id": "2025-10-22"
    },
    {
      "level": "h2",
      "text": "2025-10-17",
      "id": "2025-10-17"
    },
    {
      "level": "h2",
      "text": "2025-09-18",
      "id": "2025-09-18"
    },
    {
      "level": "h2",
      "text": "2025-09-11",
      "id": "2025-09-11"
    },
    {
      "level": "h2",
      "text": "2025-08-21",
      "id": "2025-08-21"
    },
    {
      "level": "h2",
      "text": "2025-08-14",
      "id": "2025-08-14"
    },
    {
      "level": "h2",
      "text": "2025-08-11",
      "id": "2025-08-11"
    },
    {
      "level": "h2",
      "text": "2025-06-27",
      "id": "2025-06-27"
    },
    {
      "level": "h2",
      "text": "2025-06-23",
      "id": "2025-06-23"
    },
    {
      "level": "h2",
      "text": "2025-06-04",
      "id": "2025-06-04"
    },
    {
      "level": "h2",
      "text": "2025-05-27",
      "id": "2025-05-27"
    },
    {
      "level": "h2",
      "text": "2025-05-22",
      "id": "2025-05-22"
    },
    {
      "level": "h2",
      "text": "2025-05-20",
      "id": "2025-05-20"
    },
    {
      "level": "h2",
      "text": "2025-04-16",
      "id": "2025-04-16"
    },
    {
      "level": "h2",
      "text": "2025-04-14",
      "id": "2025-04-14"
    },
    {
      "level": "h2",
      "text": "2025-04-03",
      "id": "2025-04-03"
    },
    {
      "level": "h2",
      "text": "2025-03-27",
      "id": "2025-03-27"
    },
    {
      "level": "h2",
      "text": "2025-02-28",
      "id": "2025-02-28"
    },
    {
      "level": "h2",
      "text": "2025-02-26",
      "id": "2025-02-26"
    },
    {
      "level": "h2",
      "text": "2025-02-13",
      "id": "2025-02-13"
    },
    {
      "level": "h2",
      "text": "2025-02-11",
      "id": "2025-02-11"
    },
    {
      "level": "h2",
      "text": "2025-01-31",
      "id": "2025-01-31"
    },
    {
      "level": "h2",
      "text": "2025-01-15",
      "id": "2025-01-15"
    },
    {
      "level": "h2",
      "text": "2025-01-14",
      "id": "2025-01-14"
    },
    {
      "level": "h2",
      "text": "2024-12-19",
      "id": "2024-12-19"
    },
    {
      "level": "h2",
      "text": "2024-11-18",
      "id": "2024-11-18"
    },
    {
      "level": "h2",
      "text": "2024-11-12",
      "id": "2024-11-12"
    },
    {
      "level": "h2",
      "text": "2024-11-08",
      "id": "2024-11-08"
    },
    {
      "level": "h2",
      "text": "2024-10-21",
      "id": "2024-10-21"
    },
    {
      "level": "h2",
      "text": "2024-10-14",
      "id": "2024-10-14"
    },
    {
      "level": "h2",
      "text": "2024-09-26",
      "id": "2024-09-26"
    },
    {
      "level": "h2",
      "text": "2024-09-20",
      "id": "2024-09-20"
    },
    {
      "level": "h2",
      "text": "2024-09-19",
      "id": "2024-09-19"
    },
    {
      "level": "h2",
      "text": "2024-09-16",
      "id": "2024-09-16"
    },
    {
      "level": "h2",
      "text": "2024-08-19",
      "id": "2024-08-19"
    },
    {
      "level": "h2",
      "text": "2024-08-15",
      "id": "2024-08-15"
    },
    {
      "level": "h2",
      "text": "2024-08-14",
      "id": "2024-08-14"
    },
    {
      "level": "h2",
      "text": "2024-07-19",
      "id": "2024-07-19"
    },
    {
      "level": "h2",
      "text": "2024-07-18",
      "id": "2024-07-18"
    },
    {
      "level": "h2",
      "text": "2024-07-17",
      "id": "2024-07-17"
    },
    {
      "level": "h2",
      "text": "2024-07-03",
      "id": "2024-07-03"
    },
    {
      "level": "h2",
      "text": "2024-07-01",
      "id": "2024-07-01"
    },
    {
      "level": "h2",
      "text": "2024-06-28",
      "id": "2024-06-28"
    },
    {
      "level": "h2",
      "text": "2024-06-24",
      "id": "2024-06-24"
    },
    {
      "level": "h2",
      "text": "2024-06-20",
      "id": "2024-06-20"
    },
    {
      "level": "h2",
      "text": "2024-06-19",
      "id": "2024-06-19"
    },
    {
      "level": "h2",
      "text": "2024-06-12",
      "id": "2024-06-12"
    },
    {
      "level": "h2",
      "text": "2024-06-03",
      "id": "2024-06-03"
    },
    {
      "level": "h2",
      "text": "2024-05-17",
      "id": "2024-05-17"
    },
    {
      "level": "h2",
      "text": "2024-05-15",
      "id": "2024-05-15"
    },
    {
      "level": "h2",
      "text": "2024-05-13",
      "id": "2024-05-13"
    },
    {
      "level": "h2",
      "text": "2024-05-03",
      "id": "2024-05-03"
    },
    {
      "level": "h2",
      "text": "2024-04-26",
      "id": "2024-04-26"
    },
    {
      "level": "h2",
      "text": "2024-04-11",
      "id": "2024-04-11"
    },
    {
      "level": "h2",
      "text": "2024-04-05",
      "id": "2024-04-05"
    },
    {
      "level": "h2",
      "text": "2024-04-04",
      "id": "2024-04-04"
    },
    {
      "level": "h2",
      "text": "2024-04-03",
      "id": "2024-04-03"
    },
    {
      "level": "h2",
      "text": "2024-04-02",
      "id": "2024-04-02"
    },
    {
      "level": "h2",
      "text": "2024-04-01",
      "id": "2024-04-01"
    },
    {
      "level": "h2",
      "text": "2024-03-11",
      "id": "2024-03-11"
    },
    {
      "level": "h2",
      "text": "2024-02-24",
      "id": "2024-02-24"
    },
    {
      "level": "h2",
      "text": "2024-02-23",
      "id": "2024-02-23"
    },
    {
      "level": "h2",
      "text": "2023-12-04",
      "id": "2023-12-04"
    },
    {
      "level": "h2",
      "text": "2023-10-30",
      "id": "2023-10-30"
    },
    {
      "level": "h2",
      "text": "2023-10-20",
      "id": "2023-10-20"
    },
    {
      "level": "h2",
      "text": "2023-10-18",
      "id": "2023-10-18"
    },
    {
      "level": "h2",
      "text": "2023-10-12",
      "id": "2023-10-12"
    },
    {
      "level": "h2",
      "text": "2023-10-09",
      "id": "2023-10-09"
    },
    {
      "level": "h2",
      "text": "2023-09-14",
      "id": "2023-09-14"
    },
    {
      "level": "h2",
      "text": "2023-07-14",
      "id": "2023-07-14"
    },
    {
      "level": "h2",
      "text": "2023-07-07",
      "id": "2023-07-07"
    },
    {
      "level": "h2",
      "text": "2023-06-22",
      "id": "2023-06-22"
    },
    {
      "level": "h2",
      "text": "2023-06-19",
      "id": "2023-06-19"
    },
    {
      "level": "h2",
      "text": "2023-06-09",
      "id": "2023-06-09"
    },
    {
      "level": "h2",
      "text": "2023-05-26",
      "id": "2023-05-26"
    },
    {
      "level": "h2",
      "text": "2023-05-16",
      "id": "2023-05-16"
    },
    {
      "level": "h2",
      "text": "2023-05-15",
      "id": "2023-05-15"
    },
    {
      "level": "h2",
      "text": "2023-05-12",
      "id": "2023-05-12"
    },
    {
      "level": "h2",
      "text": "2023-05-05",
      "id": "2023-05-05"
    },
    {
      "level": "h2",
      "text": "2023-04-28",
      "id": "2023-04-28"
    },
    {
      "level": "h2",
      "text": "2023-04-14",
      "id": "2023-04-14"
    },
    {
      "level": "h2",
      "text": "2023-04-10",
      "id": "2023-04-10"
    },
    {
      "level": "h2",
      "text": "2023-03-24",
      "id": "2023-03-24"
    },
    {
      "level": "h2",
      "text": "2023-03-09",
      "id": "2023-03-09"
    },
    {
      "level": "h2",
      "text": "2023-03-06",
      "id": "2023-03-06"
    },
    {
      "level": "h2",
      "text": "2023-02-06",
      "id": "2023-02-06"
    },
    {
      "level": "h2",
      "text": "2023-01-31",
      "id": "2023-01-31"
    },
    {
      "level": "h2",
      "text": "2023-01-13",
      "id": "2023-01-13"
    },
    {
      "level": "h2",
      "text": "What are Deploy to Cloudflare buttons?",
      "id": "what-are-deploy-to-cloudflare-buttons?"
    },
    {
      "level": "h2",
      "text": "How to Set Up Deploy to Cloudflare buttons",
      "id": "how-to-set-up-deploy-to-cloudflare-buttons"
    },
    {
      "level": "h2",
      "text": "Automatic resource provisioning",
      "id": "automatic-resource-provisioning"
    },
    {
      "level": "h3",
      "text": "Worker environment variables and secrets",
      "id": "worker-environment-variables-and-secrets"
    },
    {
      "level": "h2",
      "text": "Best practices",
      "id": "best-practices"
    },
    {
      "level": "h2",
      "text": "Limitations",
      "id": "limitations"
    },
    {
      "level": "h2",
      "text": "Workers Bundling",
      "id": "workers-bundling"
    },
    {
      "level": "h2",
      "text": "Terraform",
      "id": "terraform"
    },
    {
      "level": "h2",
      "text": "Bindings in Terraform",
      "id": "bindings-in-terraform"
    },
    {
      "level": "h3",
      "text": "KV Namespace Binding",
      "id": "kv-namespace-binding"
    },
    {
      "level": "h3",
      "text": "R2 Bucket Binding",
      "id": "r2-bucket-binding"
    },
    {
      "level": "h3",
      "text": "D1 Database Binding",
      "id": "d1-database-binding"
    },
    {
      "level": "h3",
      "text": "Durable Object Binding",
      "id": "durable-object-binding"
    },
    {
      "level": "h3",
      "text": "Service Binding",
      "id": "service-binding"
    },
    {
      "level": "h3",
      "text": "Queue Binding",
      "id": "queue-binding"
    },
    {
      "level": "h3",
      "text": "Vectorize Binding",
      "id": "vectorize-binding"
    },
    {
      "level": "h3",
      "text": "Workers AI Binding",
      "id": "workers-ai-binding"
    },
    {
      "level": "h3",
      "text": "Hyperdrive Binding",
      "id": "hyperdrive-binding"
    },
    {
      "level": "h3",
      "text": "Analytics Engine Binding",
      "id": "analytics-engine-binding"
    },
    {
      "level": "h3",
      "text": "Environment Variables",
      "id": "environment-variables"
    },
    {
      "level": "h3",
      "text": "Secret Text Binding",
      "id": "secret-text-binding"
    },
    {
      "level": "h3",
      "text": "Complete Example",
      "id": "complete-example"
    },
    {
      "level": "h2",
      "text": "Cloudflare API Libraries",
      "id": "cloudflare-api-libraries"
    },
    {
      "level": "h2",
      "text": "Cloudflare REST API",
      "id": "cloudflare-rest-api"
    },
    {
      "level": "h3",
      "text": "multipart/form-data upload API",
      "id": "multipart/form-data-upload-api"
    },
    {
      "level": "h3",
      "text": "Python Workers",
      "id": "python-workers"
    },
    {
      "level": "h2",
      "text": "Considerations with Durable Objects",
      "id": "considerations-with-durable-objects"
    },
    {
      "level": "h2",
      "text": "Considerations with Worker Versions",
      "id": "considerations-with-worker-versions"
    },
    {
      "level": "h3",
      "text": "Resource immutability",
      "id": "resource-immutability"
    },
    {
      "level": "h3",
      "text": "Module Content",
      "id": "module-content"
    },
    {
      "level": "h3",
      "text": "Import Behavior",
      "id": "import-behavior"
    },
    {
      "level": "h3",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h2",
      "text": "Route specificity",
      "id": "route-specificity"
    },
    {
      "level": "h2",
      "text": "wrangler dev",
      "id": "wrangler-dev"
    },
    {
      "level": "h2",
      "text": "Fetch API in CNAME setup",
      "id": "fetch-api-in-cname-setup"
    },
    {
      "level": "h2",
      "text": "Fetch to IP addresses",
      "id": "fetch-to-ip-addresses"
    },
    {
      "level": "h2",
      "text": "Account plan limits",
      "id": "account-plan-limits"
    },
    {
      "level": "h2",
      "text": "Request limits",
      "id": "request-limits"
    },
    {
      "level": "h2",
      "text": "Response limits",
      "id": "response-limits"
    },
    {
      "level": "h2",
      "text": "Worker limits",
      "id": "worker-limits"
    },
    {
      "level": "h3",
      "text": "Duration",
      "id": "duration"
    },
    {
      "level": "h3",
      "text": "CPU time",
      "id": "cpu-time"
    },
    {
      "level": "h2",
      "text": "Cache API limits",
      "id": "cache-api-limits"
    },
    {
      "level": "h2",
      "text": "Request",
      "id": "request"
    },
    {
      "level": "h3",
      "text": "Daily request",
      "id": "daily-request"
    },
    {
      "level": "h2",
      "text": "Memory",
      "id": "memory"
    },
    {
      "level": "h2",
      "text": "Subrequests",
      "id": "subrequests"
    },
    {
      "level": "h3",
      "text": "Worker-to-Worker subrequests",
      "id": "worker-to-worker-subrequests"
    },
    {
      "level": "h3",
      "text": "How many subrequests can I make?",
      "id": "how-many-subrequests-can-i-make?"
    },
    {
      "level": "h3",
      "text": "How long can a subrequest take?",
      "id": "how-long-can-a-subrequest-take?"
    },
    {
      "level": "h2",
      "text": "Simultaneous open connections",
      "id": "simultaneous-open-connections"
    },
    {
      "level": "h2",
      "text": "Environment variables",
      "id": "environment-variables"
    },
    {
      "level": "h2",
      "text": "Worker size",
      "id": "worker-size"
    }
  ],
  "url": "llms-txt#push-the-changes-to-your-git-provider",
  "links": []
}