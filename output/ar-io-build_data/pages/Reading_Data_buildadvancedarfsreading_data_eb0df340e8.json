{
  "title": "Reading Data (/build/advanced/arfs/reading-data)",
  "content": "Clients can perform read operations to create a timeline of entity write transactions which can then be replayed to construct the Drive state. This is done by querying an Arweave GraphQL index for the user's respective transactions. [Arweave GraphQL Guide](https://gql-guide.vercel.app/) can provide more information on how to use Arweave GraphQL. If no GraphQL index is available, drive state can only be generated by downloading and inspecting all transactions made by the user's wallet.\n\nThis timeline of transactions should be grouped by the block number of each transaction. At every step of the timeline, the client can check if the entity was written by an authorized user. This also conveniently enables the client to surface a trusted entity version history to the user.\n\nTo determine the owner of a Drive, clients must check for who created the first Drive Entity transaction using that `Drive-Id`. Until a trusted permissions or ACL system is put in place, any transaction in a drive created by any wallet other than the one who created the first Drive Entity transaction could be considered spam.\n\nThe `Unix-Time` defined on each transaction should be reserved for tie-breaking same entity updates in the same block and should not be trusted as the source of truth for entity write ordering. This is unimportant for single owner drives but is crucial for multi-owner drives with updateable permissions (currently undefined in this spec) as a malicious user could fake the `Unix-Time` to modify the drive timeline for other users.\n\n- Drives that have been updated many times can have a long entity timeline which can be a performance bottleneck. To avoid this, clients can cache the drive state locally and sync updates to the file system by only querying for entities in blocks higher than the last time they checked.\n- Not checking for Drive Ownership could result in seeing incorrect drive state and GraphQL queries.\n\nArweaveFS does not store folder or file paths along with entities as these paths will need to be updated whenever the parent folder name changes which can require many updates for deeply nested file systems. Instead, folder/file paths are left for the client to generate from the folder/file names.\n\n## Folder View Queries\n\nClients that want to provide users with a quick view of a single folder can simply query for an entity timeline for a particular folder by its id. Clients with multi-owner permissions will additionally have to query for the folder's parent drive entity for permission based filtering of the timeline.\n\n## Basic Query Patterns\n\n### Query All Drive Entities\n\n### Query Folder Contents\n\n### Query File Entities\n\n## Building Drive State\n\nThe process of building drive state involves several steps:\n\n### Step-by-Step Process\n\n1. **Query for all entities** associated with a specific `Drive-Id`\n2. **Sort by block height** to establish chronological order\n3. **Process entities bottom-up** starting with files and folders\n4. **Build the hierarchy** by following parent-child relationships\n5. **Handle conflicts** by using the most recent entity version\n\n### Example Implementation\n\nFor large drives, snapshots can significantly improve performance:\n\n## Performance Optimization\n\n### Caching Strategies\n\n- **Local caching** - Store frequently accessed data locally\n- **Incremental updates** - Only fetch new transactions since last sync\n- **Snapshot usage** - Use snapshots for large drives\n- **Batch queries** - Combine multiple queries when possible\n\n### Query Optimization\n\n- **Use specific tags** - Narrow down queries with relevant tags\n- **Limit results** - Use pagination for large result sets\n- **Filter by date** - Query specific time ranges\n- **Index utilization** - Leverage GraphQL indexes effectively\n\n- **Network timeouts** - Implement retry logic\n- **Invalid data** - Validate entity structure\n- **Missing entities** - Handle incomplete data gracefully\n- **Decryption errors** - Proper error handling for private data\n\n- **Validate ownership** - Check drive ownership before processing\n- **Handle conflicts** - Resolve entity version conflicts\n- **Graceful degradation** - Provide fallbacks for missing data\n- **User feedback** - Inform users of sync status\n\n## Security Considerations\n\n- **Verify signatures** - Check transaction signatures\n- **Validate ownership** - Ensure drive ownership\n- **Check timestamps** - Validate entity timestamps\n- **Sanitize data** - Clean user-provided data\n\n### Privacy Protection\n\n- **Decrypt carefully** - Handle private data securely\n- **Key management** - Protect encryption keys\n- **Access control** - Implement proper permissions\n- **Audit logging** - Track data access\n\nNow that you understand how to read ArFS data, explore these related topics:\n\n- [Privacy & Encryption](/build/advanced/arfs/privacy) - Secure your data with private drives\n- [Upgrading Private Drives](/build/advanced/arfs/upgrading-drives) - Update legacy drives to v0.15\n- [Creating Drives](/build/advanced/arfs/creating-drives) - Start building with ArFS",
  "code_samples": [
    {
      "code": "query {\n  transactions(\n    tags: [\n      { name: \"ArFS\", values: [\"0.15\"] }\n      { name: \"Entity-Type\", values: [\"drive\"] }\n      { name: \"Drive-Id\", values: [\"your-drive-id\"] }\n    ]\n  ) {\n    edges {\n      node {\n        id\n        block {\n          height\n          timestamp\n        }\n        tags {\n          name\n          value\n        }\n      }\n    }\n  }\n}",
      "language": "graphql"
    },
    {
      "code": "query ($parentFolderId: String!) {\n  transactions(\n    tags: [\n      { name: \"ArFS\", values: [\"0.15\"] }\n      { name: \"Parent-Folder-Id\", values: [$parentFolderId] }\n    ]\n  ) {\n    edges {\n      node {\n        id\n        block {\n          height\n          timestamp\n        }\n        tags {\n          name\n          value\n        }\n      }\n    }\n  }\n}",
      "language": "graphql"
    },
    {
      "code": "query ($fileId: String!) {\n  transactions(\n    tags: [\n      { name: \"ArFS\", values: [\"0.15\"] }\n      { name: \"Entity-Type\", values: [\"file\"] }\n      { name: \"File-Id\", values: [$fileId] }\n    ]\n  ) {\n    edges {\n      node {\n        id\n        block {\n          height\n          timestamp\n        }\n        tags {\n          name\n          value\n        }\n      }\n    }\n  }\n}",
      "language": "graphql"
    },
    {
      "code": "graph TD\n    A[Query Drive Entities] --> B[Sort by Block Height]\n    B --> C[Process Files First]\n    C --> D[Process Folders]\n    D --> E[Process Drive Metadata]\n    E --> F[Build Hierarchy Tree]\n    F --> G[Resolve Conflicts]\n    G --> H[Return Complete State]\n\n    style A fill:#e3f2fd\n    style H fill:#c8e6c9",
      "language": "mermaid"
    },
    {
      "code": "async function buildDriveState(driveId) {\n  // Query all entities for the drive\n  const entities = await queryDriveEntities(driveId);\n\n  // Sort by block height\n  entities.sort((a, b) => a.block.height - b.block.height);\n\n  // Process entities\n  const driveState = {\n    drive: null,\n    folders: new Map(),\n    files: new Map(),\n  };\n\n  for (const entity of entities) {\n    const entityType = getTagValue(entity.tags, \"Entity-Type\");\n\n    switch (entityType) {\n      case \"drive\":\n        driveState.drive = processDriveEntity(entity);\n        break;\n      case \"folder\":\n        driveState.folders.set(\n          getTagValue(entity.tags, \"Folder-Id\"),\n          processFolderEntity(entity)\n        );\n        break;\n      case \"file\":\n        driveState.files.set(\n          getTagValue(entity.tags, \"File-Id\"),\n          processFileEntity(entity)\n        );\n        break;\n    }\n  }\n\n  return driveState;\n}",
      "language": "javascript"
    },
    {
      "code": "sequenceDiagram\n    participant Client\n    participant Gateway\n    participant Arweave\n\n    Client->>Gateway: Query for latest snapshot\n    Gateway->>Client: Return snapshot data\n    Client->>Client: Process snapshot data\n    Client->>Gateway: Query for newer transactions\n    Gateway->>Client: Return newer entities\n    Client->>Client: Merge with snapshot data\n    Client->>Client: Return complete drive state",
      "language": "mermaid"
    },
    {
      "code": "query ($driveId: String!) {\n  transactions(\n    tags: [\n      { name: \"ArFS\", values: [\"0.15\"] }\n      { name: \"Entity-Type\", values: [\"snapshot\"] }\n      { name: \"Drive-Id\", values: [$driveId] }\n    ]\n    sort: HEIGHT_DESC\n    first: 1\n  ) {\n    edges {\n      node {\n        id\n        block {\n          height\n          timestamp\n        }\n        tags {\n          name\n          value\n        }\n      }\n    }\n  }\n}",
      "language": "graphql"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Folder/File Paths",
      "id": "folder/file-paths"
    },
    {
      "level": "h2",
      "text": "Folder View Queries",
      "id": "folder-view-queries"
    },
    {
      "level": "h2",
      "text": "Basic Query Patterns",
      "id": "basic-query-patterns"
    },
    {
      "level": "h3",
      "text": "Query All Drive Entities",
      "id": "query-all-drive-entities"
    },
    {
      "level": "h3",
      "text": "Query Folder Contents",
      "id": "query-folder-contents"
    },
    {
      "level": "h3",
      "text": "Query File Entities",
      "id": "query-file-entities"
    },
    {
      "level": "h2",
      "text": "Building Drive State",
      "id": "building-drive-state"
    },
    {
      "level": "h3",
      "text": "Step-by-Step Process",
      "id": "step-by-step-process"
    },
    {
      "level": "h3",
      "text": "Example Implementation",
      "id": "example-implementation"
    },
    {
      "level": "h2",
      "text": "Using Snapshots",
      "id": "using-snapshots"
    },
    {
      "level": "h3",
      "text": "Snapshot Query",
      "id": "snapshot-query"
    },
    {
      "level": "h2",
      "text": "Performance Optimization",
      "id": "performance-optimization"
    },
    {
      "level": "h3",
      "text": "Caching Strategies",
      "id": "caching-strategies"
    },
    {
      "level": "h3",
      "text": "Query Optimization",
      "id": "query-optimization"
    },
    {
      "level": "h2",
      "text": "Error Handling",
      "id": "error-handling"
    },
    {
      "level": "h3",
      "text": "Common Issues",
      "id": "common-issues"
    },
    {
      "level": "h3",
      "text": "Best Practices",
      "id": "best-practices"
    },
    {
      "level": "h2",
      "text": "Security Considerations",
      "id": "security-considerations"
    },
    {
      "level": "h3",
      "text": "Data Validation",
      "id": "data-validation"
    },
    {
      "level": "h3",
      "text": "Privacy Protection",
      "id": "privacy-protection"
    },
    {
      "level": "h2",
      "text": "Next Steps",
      "id": "next-steps"
    }
  ],
  "url": "llms-txt#reading-data-(/build/advanced/arfs/reading-data)",
  "links": []
}