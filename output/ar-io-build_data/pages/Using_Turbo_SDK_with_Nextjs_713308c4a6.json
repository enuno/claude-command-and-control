{
  "title": "Using Turbo SDK with Next.js",
  "content": "**Firefox Compatibility**: Some compatibility issues have been reported with\n  the Turbo SDK in Firefox browsers. At this time the below framework examples\n  may not behave as expected in Firefox.\n\nThis guide demonstrates how to configure the `@ardrive/turbo-sdk` in a Next.js application with proper polyfills for client-side usage. Next.js uses webpack under the hood, which requires specific configuration to handle Node.js modules that the Turbo SDK depends on.\n\n**Polyfills**: Polyfills are required when using the Turbo SDK in Next.js\n  applications. The SDK relies on Node.js modules like `crypto`, `buffer`,\n  `process`, and `stream` that are not available in the browser by default.\n\n- Next.js 13+ (with App Router or Pages Router)\n- Node.js 18+\n- Basic familiarity with Next.js configuration\n\nInstall the main Turbo SDK package:\n\nAdd required polyfill packages for browser compatibility:\n\n**Wallet Integration Dependencies**: The Turbo SDK includes\n      `@dha-team/arbundles` as a peer dependency, which provides the necessary\n      signers for browser wallet integration (like `InjectedEthereumSigner` and\n      `ArconnectSigner`). You can import these directly without additional\n      installation.\n\nCreate or update your `next.config.js` file to include the necessary polyfills:\n\nIf you're using TypeScript, update your `tsconfig.json` to include proper module resolution:\n\n**TypeScript Wallet Types**\n\nCreate a `types/wallet.d.ts` file to properly type wallet objects:\n\nSelect between MetaMask or Wander wallet integration:\n\n**Never expose private keys in browser applications!** Always use browser\n      wallet integrations for security.\n\nCreate a React component for MetaMask wallet integration:\n\nFor MetaMask integration, you'll need to use `InjectedEthereumSigner` from\n      `@dha-team/arbundles`, which is available as a peer dependency through the\n      Turbo SDK.\n\nCreate a React component for Wander wallet integration:\n\n## Common Issues and Solutions\n\nIf you encounter build errors related to missing modules:\n\n1. **\"Module not found: Can't resolve 'fs'\"**\n   - Ensure `fs: false` is set in your webpack fallback configuration\n\n2. **\"process is not defined\"**\n   - Make sure you have the `ProvidePlugin` configuration for process\n\n3. **\"Buffer is not defined\"**\n   - Verify the Buffer polyfill is properly configured in `ProvidePlugin`\n\n1. **\"crypto.getRandomValues is not a function\"**\n   - This usually indicates the crypto polyfill isn't working. Double-check your webpack configuration.\n\n2. **\"TypeError: e.startsWith is not a function\"**\n   - This indicates incorrect signer usage. For MetaMask integration, use `InjectedEthereumSigner` from `@dha-team/arbundles`, not `EthereumSigner`.\n   - `EthereumSigner` expects a private key string, while `InjectedEthereumSigner` expects a provider wrapper.\n\n3. **\"No accounts available\" during wallet operations**\n   - Ensure the wallet is properly connected before attempting operations\n   - Add validation to check account availability after connection\n\n4. **Message signing failures with wallets**\n   - For `InjectedEthereumSigner`, ensure your provider wrapper correctly implements the `getSigner()` method\n   - Handle both string and Uint8Array message types in your `signMessage` implementation\n   - Use MetaMask's `personal_sign` method with proper parameter formatting\n\n5. **Server-side rendering issues**\n   - Always use `'use client'` directive for components that use the Turbo SDK\n   - Consider dynamic imports with `ssr: false` for complex cases:\n\n### Wallet Integration Issues\n\n1. **Incorrect Signer Import**\n\n2. **Provider Interface Mismatch**\n\n3. **Missing Dependencies**\n\nIf you encounter import errors for `@dha-team/arbundles`, note that it's available as a peer dependency through `@ardrive/turbo-sdk`. You may need to ensure it's properly resolved in your build process.\n\n1. **Use Client Components**: Always mark components using the Turbo SDK with `'use client'`\n\n2. **Error Handling**: Implement proper error handling for network requests and wallet interactions\n\n3. **Environment Variables**: Store sensitive configuration in environment variables:\n\n4. **Bundle Size**: Consider code splitting for large applications to reduce bundle size\n\n5. **Wallet Security**:\n   - **Never expose private keys** in client-side code\n   - Always use browser wallet integrations (MetaMask, Wander, etc.)\n   - Request only necessary permissions from wallets\n   - Validate wallet connections before use\n   - Handle wallet disconnection gracefully\n\n## Production Deployment Checklist\n\nFor production deployments:\n\n1. **Verify polyfills work correctly** in your build environment\n2. **Test wallet connections** with various providers (Wander, MetaMask, etc.)\n3. **Monitor bundle sizes** to ensure polyfills don't significantly increase your app size\n4. **Use environment-specific configurations** for different Turbo endpoints\n5. **Implement proper error boundaries** for wallet connection failures\n6. **Add loading states** for wallet operations to improve UX\n7. **Test across different browsers** to ensure wallet compatibility\n\n## Implementation Verification\n\nTo verify your MetaMask integration is working correctly:\n\n1. **Check Console Logs**: After connecting to MetaMask, you should see:\n\n2. **Test Balance Retrieval**: Add this to verify your authenticated client works:\n\n3. **Verify Signer Setup**: Your implementation should:\n   - Use `InjectedEthereumSigner` from `@dha-team/arbundles`\n   - Include a proper provider wrapper with `getSigner()` method\n   - Handle both string and Uint8Array message types\n   - Use MetaMask's `personal_sign` method\n\n4. **Common Success Indicators**:\n   - No `TypeError: e.startsWith is not a function` errors\n   - Successful wallet connection and address display\n   - Ability to fetch balance without errors\n   - Upload operations work with proper MetaMask transaction prompts\n\n## Additional Resources\n\n- [Turbo SDK Documentation](https://docs.ardrive.io)\n- [Web Usage Examples](https://docs.ardrive.io)\n- [Next.js Webpack Configuration](https://nextjs.org/docs/pages/api-reference/next-config-js/webpack)\n- [ArDrive Examples Repository](https://github.com/ardriveio/turbo-sdk)\n\nFor more examples and advanced usage patterns, refer to the [Turbo SDK examples directory](https://github.com/ardriveio/turbo-sdk) or the main [SDK documentation](https://docs.ardrive.io).",
  "code_samples": [
    {
      "code": "npm install @ardrive/turbo-sdk",
      "language": "bash"
    },
    {
      "code": "npm install --save-dev crypto-browserify stream-browserify process buffer",
      "language": "bash"
    },
    {
      "code": "/** @type {import('next').NextConfig} */\n    const nextConfig = {\n      webpack: (config, { isServer }) => {\n        // Only configure polyfills for client-side bundles\n        if (!isServer) {\n          config.resolve.fallback = {\n            ...config.resolve.fallback,\n            crypto: require.resolve(\"crypto-browserify\"),\n            stream: require.resolve(\"stream-browserify\"),\n            buffer: require.resolve(\"buffer\"),\n            process: require.resolve(\"process/browser\"),\n            fs: false,\n            net: false,\n            tls: false,\n          };\n\n          // Provide global process and Buffer\n          config.plugins.push(\n            new config.webpack.ProvidePlugin({\n              process: \"process/browser\",\n              Buffer: [\"buffer\", \"Buffer\"],\n            })\n          );\n        }\n\n        return config;\n      },\n    };\n\n    module.exports = nextConfig;",
      "language": "javascript"
    },
    {
      "code": "{\n      \"compilerOptions\": {\n        \"moduleResolution\": \"bundler\",\n        \"lib\": [\"es2015\", \"dom\", \"dom.iterable\"]\n        // ... other options\n      }\n    }",
      "language": "json"
    },
    {
      "code": "// types/wallet.d.ts\n    interface Window {\n      ethereum?: {\n        request: (args: { method: string; params?: any[] }) => Promise;\n        on?: (event: string, handler: (...args: any[]) => void) => void;\n        removeListener?: (event: string, handler: (...args: any[]) => void) => void;\n        isMetaMask?: boolean;\n      };\n      arweaveWallet?: {\n        connect: (permissions: string[]) => Promise;\n        disconnect: () => Promise;\n        getActiveAddress: () => Promise;\n        getPermissions: () => Promise;\n        sign: (transaction: any) => Promise;\n        getPublicKey: () => Promise;\n      };\n    }",
      "language": "typescript"
    },
    {
      "code": "\"use client\";\n\n          const [connected, setConnected] = useState(false);\n      const [address, setAddress] = useState(\"\");\n      const [uploading, setUploading] = useState(false);\n      const [uploadResult, setUploadResult] = useState(null);\n\n      const connectMetaMask = useCallback(async () => {\n        try {\n          if (!window.ethereum) {\n            alert(\"MetaMask is not installed!\");\n            return;\n          }\n\n          // Request account access\n          await window.ethereum.request({\n            method: \"eth_requestAccounts\",\n          });\n\n          // Get the current account\n          const accounts = await window.ethereum.request({\n            method: \"eth_accounts\",\n          });\n\n          if (accounts.length > 0) {\n            setAddress(accounts[0]);\n            setConnected(true);\n\n            // Log current chain for debugging\n            const chainId = await window.ethereum.request({\n              method: \"eth_chainId\",\n            });\n            console.log(\"Connected to chain:\", chainId);\n          }\n        } catch (error) {\n          console.error(\"Failed to connect to MetaMask:\", error);\n        }\n      }, []);\n\n      const uploadWithMetaMask = async (event) => {\n        const file = event.target.files?.[0];\n        if (!file || !connected) return;\n\n        setUploading(true);\n\n        try {\n          // Create a provider wrapper for InjectedEthereumSigner\n          const providerWrapper = {\n            getSigner: () => ({\n              signMessage: async (message: string | Uint8Array) => {\n                const accounts = await window.ethereum!.request({\n                  method: \"eth_accounts\",\n                });\n                if (accounts.length === 0) {\n                  throw new Error(\"No accounts available\");\n                }\n\n                // Convert message to hex if it's Uint8Array\n                const messageToSign =\n                  typeof message === \"string\"\n                    ? message\n                    : \"0x\" +\n                      Array.from(message)\n                        .map((b) => b.toString(16).padStart(2, \"0\"))\n                        .join(\"\");\n\n                return await window.ethereum!.request({\n                  method: \"personal_sign\",\n                  params: [messageToSign, accounts[0]],\n                });\n              },\n            }),\n          };\n\n          // Create the signer using InjectedEthereumSigner\n          const signer = new InjectedEthereumSigner(providerWrapper);\n          const turbo = TurboFactory.authenticated({\n            signer,\n            token: \"ethereum\", // Important: specify token type for Ethereum\n          });\n\n          // Upload file with progress tracking\n          const result = await turbo.uploadFile({\n            fileStreamFactory: () => file.stream(),\n            fileSizeFactory: () => file.size,\n            dataItemOpts: {\n              tags: [\n                { name: \"Content-Type\", value: file.type },\n                { name: \"App-Name\", value: \"My-Next-App\" },\n                { name: \"Funded-By\", value: \"Ethereum\" },\n              ],\n            },\n            events: {\n              onProgress: ({ totalBytes, processedBytes, step }) => {\n                console.log(\n                  `${step}: ${Math.round((processedBytes / totalBytes) * 100)}%`\n                );\n              },\n              onError: ({ error, step }) => {\n                console.error(`Error during ${step}:`, error);\n                console.error(\"Error details:\", JSON.stringify(error, null, 2));\n              },\n            },\n          });\n\n          setUploadResult(result);\n        } catch (error) {\n          console.error(\"Upload failed:\", error);\n          console.error(\"Error details:\", JSON.stringify(error, null, 2));\n          alert(`Upload failed: ${error.message}`);\n        } finally {\n          setUploading(false);\n        }\n      };\n\n      return (\n        \n          MetaMask Upload\n\n          {!connected ? (\n            \n              Connect MetaMask\n            \n          ) : (\n\n                âœ… Connected: {address.slice(0, 6)}...{address.slice(-4)}\n\n                  Select File to Upload:\n\n              {uploading && (\n                \n                  ðŸ”„ Uploading... Please confirm transaction in MetaMask\n                \n              )}\n\n              {uploadResult && (\n\n                    âœ… Upload Successful!\n\n                    Transaction ID: {uploadResult.id}\n\n                    Data Size: {uploadResult.totalBytes} bytes\n\n              )}\n            \n          )}\n        \n      );\n    }",
      "language": "tsx"
    },
    {
      "code": "\"use client\";\n\n          const [connected, setConnected] = useState(false);\n      const [address, setAddress] = useState(\"\");\n      const [uploading, setUploading] = useState(false);\n      const [uploadResult, setUploadResult] = useState(null);\n\n      const connectWanderWallet = useCallback(async () => {\n        try {\n          if (!window.arweaveWallet) {\n            alert(\"Wander wallet is not installed!\");\n            return;\n          }\n\n          // Required permissions for Turbo SDK\n          const permissions = [\n            \"ACCESS_ADDRESS\",\n            \"ACCESS_PUBLIC_KEY\",\n            \"SIGN_TRANSACTION\",\n            \"SIGNATURE\",\n          ];\n\n          // Connect to wallet\n          await window.arweaveWallet.connect(permissions);\n\n          // Get wallet address\n          const walletAddress = await window.arweaveWallet.getActiveAddress();\n          setAddress(walletAddress);\n          setConnected(true);\n        } catch (error) {\n          console.error(\"Failed to connect to Wander wallet:\", error);\n        }\n      }, []);\n\n      const uploadWithWanderWallet = async (event) => {\n        const file = event.target.files?.[0];\n        if (!file || !connected) return;\n\n        setUploading(true);\n\n        try {\n          // Create ArConnect signer using Wander wallet\n          const signer = new ArconnectSigner(window.arweaveWallet);\n          const turbo = TurboFactory.authenticated({ signer });\n          // Note: No need to specify token for Arweave as it's the default\n\n          // Upload file with progress tracking\n          const result = await turbo.uploadFile({\n            fileStreamFactory: () => file.stream(),\n            fileSizeFactory: () => file.size,\n            dataItemOpts: {\n              tags: [\n                { name: \"Content-Type\", value: file.type },\n                { name: \"App-Name\", value: \"My-Next-App\" },\n                { name: \"Funded-By\", value: \"Arweave\" },\n              ],\n            },\n            events: {\n              onProgress: ({ totalBytes, processedBytes, step }) => {\n                console.log(\n                  `${step}: ${Math.round((processedBytes / totalBytes) * 100)}%`\n                );\n              },\n              onError: ({ error, step }) => {\n                console.error(`Error during ${step}:`, error);\n              },\n            },\n          });\n\n          setUploadResult(result);\n        } catch (error) {\n          console.error(\"Upload failed:\", error);\n          alert(`Upload failed: ${error.message}`);\n        } finally {\n          setUploading(false);\n        }\n      };\n\n      return (\n        \n          Wander Wallet Upload\n\n          {!connected ? (\n            \n              Connect Wander Wallet\n            \n          ) : (\n\n                âœ… Connected: {address.slice(0, 6)}...{address.slice(-4)}\n\n                  Select File to Upload:\n\n              {uploading && (\n                \n                  ðŸ”„ Uploading... Please confirm transaction in Wander wallet\n                \n              )}\n\n              {uploadResult && (\n\n                    âœ… Upload Successful!\n\n                    Transaction ID: {uploadResult.id}\n\n                    Data Size: {uploadResult.totalBytes} bytes\n\n              )}\n            \n          )}\n        \n      );\n    }",
      "language": "tsx"
    },
    {
      "code": "const TurboUploader = dynamic(() => import(\"./TurboUploader\"), {\n  ssr: false,\n});",
      "language": "tsx"
    },
    {
      "code": "// âŒ INCORRECT - For Node environments\n   \n   // âœ… CORRECT - For browser wallets",
      "language": "tsx"
    },
    {
      "code": "// âŒ INCORRECT - window.ethereum doesn't have getSigner()\n   const signer = new InjectedEthereumSigner(window.ethereum);\n\n   // âœ… CORRECT - Use a provider wrapper\n   const providerWrapper = {\n     getSigner: () => ({\n       signMessage: async (message: string | Uint8Array) => {\n         // Implementation here\n       },\n     }),\n   };\n   const signer = new InjectedEthereumSigner(providerWrapper);",
      "language": "tsx"
    },
    {
      "code": "// next.config.js\nconst nextConfig = {\n  env: {\n    TURBO_UPLOAD_URL: process.env.TURBO_UPLOAD_URL,\n    TURBO_PAYMENT_URL: process.env.TURBO_PAYMENT_URL,\n  },\n  // ... webpack config\n};",
      "language": "javascript"
    },
    {
      "code": "Connected to chain: 0x1 (or appropriate chain ID)",
      "language": "unknown"
    },
    {
      "code": "// After creating authenticated turbo client\n   const balance = await turbo.getBalance();\n   console.log(\"Current balance:\", balance);",
      "language": "tsx"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Overview",
      "id": "overview"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "Common Issues and Solutions",
      "id": "common-issues-and-solutions"
    },
    {
      "level": "h3",
      "text": "Build Errors",
      "id": "build-errors"
    },
    {
      "level": "h3",
      "text": "Runtime Errors",
      "id": "runtime-errors"
    },
    {
      "level": "h3",
      "text": "Wallet Integration Issues",
      "id": "wallet-integration-issues"
    },
    {
      "level": "h2",
      "text": "Best Practices",
      "id": "best-practices"
    },
    {
      "level": "h2",
      "text": "Production Deployment Checklist",
      "id": "production-deployment-checklist"
    },
    {
      "level": "h2",
      "text": "Implementation Verification",
      "id": "implementation-verification"
    },
    {
      "level": "h2",
      "text": "Additional Resources",
      "id": "additional-resources"
    }
  ],
  "url": "llms-txt#using-turbo-sdk-with-next.js",
  "links": []
}