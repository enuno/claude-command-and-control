{
  "title": "Data Model (/build/advanced/arfs/data-model)",
  "content": "Because of Arweave's permanent and immutable nature, traditional file structure operations such as renaming and moving files or folders cannot be accomplished by simply updating on-chain data. ArFS works around this by defining an append-only transaction data model based on the metadata tags found in the Arweave [Transaction Headers.](https://docs.arweave.org/developers/server/http-api#transaction-format)\n\nThis model uses a bottom-up reference method, which avoids race conditions in file system updates. Each file contains metadata that refers to the parent folder, and each folder contains metadata that refers to its parent drive. A top-down data model would require the parent model (i.e. a folder) to store references to its children.\n\nThese defined entities allow the state of the drive to be constructed by a client to look and feel like a file system:\n\n- Drive Entities contain folders and files\n- Folder Entities contain other folders or files\n- File Entities contain both the file data and metadata\n- Snapshot entities contain a state rollups of all entities' (such as drive, folder, file and snapshot) metadata within a drive\n\n## Entity Relationships\n\nThe following diagram shows the high level relationships between drive, folder, and file entities, and their associated data. More detailed information about each Entity Type can be found in the ArFS specification documentation.\n\nAs you can see, each file and folder contains metadata which points to both the parent folder and the parent drive. The drive entity contains metadata about itself, but not the child contents. So clients must build drive states from the lowest level and work their way up.\n\nMetadata stored in any Arweave transaction tag will be defined in the following manner:\n\nMetadata stored in the Transaction Data Payload will follow JSON formatting like below:\n\nFields with a `?` suffix are optional.\n\nEnumerated field values (those which must adhere to certain values) are defined in the format \"value 1 | value 2\".\n\nAll UUIDs used for Entity-Ids are based on the [Universally Unique Identifier](https://en.wikipedia.org/wiki/Universally_unique_identifier) standard.\n\nThere are no requirements to list ArFS tags in any specific order.\n\n## Building Drive State\n\nTo construct the current state of a drive, clients must:\n\n1. **Query for all entities** associated with a specific `Drive-Id`\n2. **Sort by block height** to establish chronological order\n3. **Process entities bottom-up** starting with files and folders\n4. **Build the hierarchy** by following parent-child relationships\n5. **Handle conflicts** by using the most recent entity version\n\n### Example Drive State Construction\n\nEach ArFS entity follows a specific lifecycle pattern:\n\n1. Generate unique UUID for entity\n2. Create metadata transaction with required tags\n3. For files: create separate data transaction\n4. Upload to Arweave network\n\n1. Create new entity with same ID\n2. Update metadata as needed\n3. Upload new transaction\n4. Client processes both versions and uses latest\n\n1. Mark entity as hidden (`isHidden: true`)\n2. Upload new transaction\n3. Entity remains in history but hidden from UI\n\nArFS ensures data integrity through:\n\n- **Immutable transactions** - Once uploaded, data cannot be modified\n- **Cryptographic signatures** - All transactions are signed by the owner\n- **Version tracking** - Multiple versions of entities can exist\n- **Conflict resolution** - Clients use block height and timestamps to resolve conflicts\n\n## Performance Considerations\n\nFor large drives, consider these optimization strategies:\n\n- **Use snapshots** for quick state reconstruction\n- **Implement caching** for frequently accessed data\n- **Batch operations** when possible\n- **Query by date ranges** to limit data transfer\n\nNow that you understand the ArFS data model, learn how to work with it:\n\n- [Privacy & Encryption](/build/advanced/arfs/privacy) - Secure your data with private drives\n- [Creating Drives](/build/advanced/arfs/creating-drives) - Start building with ArFS\n- [Reading Data](/build/advanced/arfs/reading-data) - Query and retrieve your data",
  "code_samples": [
    {
      "code": "graph TD\n    A[Drive Entity] --> B[Root Folder]\n    B --> C[Subfolder 1]\n    B --> D[Subfolder 2]\n    B --> E[File 1]\n    C --> F[File 2]\n    C --> G[File 3]\n    D --> H[File 4]\n    D --> I[Subfolder 3]\n    I --> J[File 5]\n\n    A --> K[Drive Metadata]\n    B --> L[Folder Metadata]\n    C --> M[Folder Metadata]\n    D --> N[Folder Metadata]\n    I --> O[Folder Metadata]\n    E --> P[File Metadata + Data]\n    F --> Q[File Metadata + Data]\n    G --> R[File Metadata + Data]\n    H --> S[File Metadata + Data]\n    J --> T[File Metadata + Data]\n\n    U[Snapshot Entity] --> V[Complete Drive State]\n    V --> A\n    V --> B\n    V --> C\n    V --> D\n    V --> I\n    V --> E\n    V --> F\n    V --> G\n    V --> H\n    V --> J",
      "language": "mermaid"
    },
    {
      "code": "{ \"name\": \"Example-Tag\", \"value\": \"example-data\" }",
      "language": "json"
    },
    {
      "code": "{\n  \"exampleField\": \"exampleData\"\n}",
      "language": "json"
    },
    {
      "code": "{\n  \"name\": \"My Project\",\n  \"description\": \"This is a sample project.\",\n  \"version?\": \"1.0.0\",\n  \"author?\": \"John Doe\"\n}",
      "language": "json"
    },
    {
      "code": "sequenceDiagram\n    participant Client\n    participant Gateway\n    participant Arweave\n\n    Client->>Gateway: Query Drive-Id: abc123\n    Gateway->>Client: Return all entities\n\n    Client->>Client: Sort by block height\n    Client->>Client: Process files first\n    Client->>Client: Process folders\n    Client->>Client: Process drive metadata\n    Client->>Client: Build hierarchy tree\n    Client->>Client: Resolve conflicts\n    Client->>Client: Return complete drive state",
      "language": "mermaid"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Entity Relationships",
      "id": "entity-relationships"
    },
    {
      "level": "h2",
      "text": "Metadata Format",
      "id": "metadata-format"
    },
    {
      "level": "h2",
      "text": "Building Drive State",
      "id": "building-drive-state"
    },
    {
      "level": "h3",
      "text": "Example Drive State Construction",
      "id": "example-drive-state-construction"
    },
    {
      "level": "h2",
      "text": "Entity Lifecycle",
      "id": "entity-lifecycle"
    },
    {
      "level": "h3",
      "text": "Creation",
      "id": "creation"
    },
    {
      "level": "h3",
      "text": "Updates",
      "id": "updates"
    },
    {
      "level": "h3",
      "text": "Deletion",
      "id": "deletion"
    },
    {
      "level": "h2",
      "text": "Data Integrity",
      "id": "data-integrity"
    },
    {
      "level": "h2",
      "text": "Performance Considerations",
      "id": "performance-considerations"
    },
    {
      "level": "h2",
      "text": "Next Steps",
      "id": "next-steps"
    }
  ],
  "url": "llms-txt#data-model-(/build/advanced/arfs/data-model)",
  "links": []
}