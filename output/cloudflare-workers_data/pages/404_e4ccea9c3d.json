{
  "title": "404",
  "content": "Check the URL, try using our [search](https://developers.cloudflare.com/search/) or try our LLM-friendly [llms.txt directory](https://developers.cloudflare.com/llms.txt).\n\n<page>\n---\ntitle: Advanced options · Cloudflare Zaraz docs\nlastUpdated: 2024-09-24T17:04:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/advanced/\n  md: https://developers.cloudflare.com/zaraz/advanced/index.md\n---\n\n* [Load Zaraz selectively](https://developers.cloudflare.com/zaraz/advanced/load-selectively/)\n* [Blocking Triggers](https://developers.cloudflare.com/zaraz/advanced/blocking-triggers/)\n* [Data layer compatibility mode](https://developers.cloudflare.com/zaraz/advanced/datalayer-compatibility/)\n* [Domains not proxied by Cloudflare](https://developers.cloudflare.com/zaraz/advanced/domains-not-proxied/)\n* [Google Consent Mode](https://developers.cloudflare.com/zaraz/advanced/google-consent-mode/)\n* [Load Zaraz manually](https://developers.cloudflare.com/zaraz/advanced/load-zaraz-manually/)\n* [Configuration Import & Export](https://developers.cloudflare.com/zaraz/advanced/import-export/)\n* [Context Enricher](https://developers.cloudflare.com/zaraz/advanced/context-enricher/)\n* [Using JSONata](https://developers.cloudflare.com/zaraz/advanced/using-jsonata/)\n* [Send Zaraz logs to Logpush](https://developers.cloudflare.com/zaraz/advanced/logpush/)\n* [Custom Managed Components](https://developers.cloudflare.com/zaraz/advanced/load-custom-managed-component/)\n\n<page>\n---\ntitle: Changelog · Cloudflare Zaraz docs\ndescription: Subscribe to RSS\nlastUpdated: 2025-02-13T19:35:19.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/changelog/\n  md: https://developers.cloudflare.com/zaraz/changelog/index.md\n---\n\n[Subscribe to RSS](https://developers.cloudflare.com/zaraz/changelog/index.xml)\n\n* **Logpush**: Add Logpush support for Zaraz\n\n* **Consent Management**: Allow forcing the consent modal language\n\n- **Zaraz Debugger**: Log the response status and body for server-side requests\n\n* **Monitoring**: Introduce \"Advanced Monitoring\" with new reports such as geography, user timeline, funnel, retention and more\n* **Monitoring**: Show information about server-side requests success rate\n\n- **Zaraz Types**: Update the `zaraz-types` package\n- **Custom HTML Managed Component**: Apply syntax highlighting for inlined JavaScript code\n\n* **Facebook Component**: Update to version 21 of the API, and fail gracefully when e-commerce payload doesn't match schema\n\n- **Zaraz Monitoring**: Show all response status codes from the Zaraz server-side requests in the dashboard\n- **Zaraz Debugger**: Fix a bug that broke the display when Custom HTML included backticks\n- **Context Enricher**: It's now possible to programatically edit the Zaraz `config` itself, in addition to the `system` and `client` objects\n- **Rocker Loader**: Issues with using Zaraz next to Rocket Loader were fixed\n- **Automatic Actions**: The tools setup flow now fully supports configuring Automatic Actions\n- **Bing Managed Component**: Issues with setting the currency field were fixed\n- **Improvement**: The allowed size for a Zaraz config was increased by 250x\n- **Improvement**: The Zaraz runtime should run faster due to multiple code optimizations\n- **Bugfix**: Fixed an issue that caused the dashboard to sometimes show \"E-commerce\" option for tools that do not support it\n\n* **Automatic Actions**: E-commerce support is now integrated with Automatic Actions\n* **Consent Management**: Support styling the Consent Modal when CSP is enabled\n* **Consent Management**: Fix an issue that could cause tools to load before consent was granted when TCF is enabled\n* **Zaraz Debugger**: Remove redundant messages related to empty values\n* **Amplitude Managed Component**: Respect the EU endpoint setting\n\n* **Automatic Actions**: Automatic Event Tracking is now fully available\n* **Consent Management**: Fixed issues with rendering the Consent modal on iOS\n* **Zaraz Debugger**: Remove redundant messages related to `__zarazEcommerce`\n* **Zaraz Debugger**: Fixed bug that prevented the debugger to load when certain Custom HTML tools were used\n\n* **Automatic Actions**: Automatic Pageview tracking is now fully available\n* **Google Analytics 4**: Support Google Consent signals when using e-commerce tracking\n* **HTTP Events API**: Ignore bot score detection on the HTTP Events API endpoint\n* **Zaraz Debugger**: Show client-side network requests initiated by Managed Components\n\n* **Automatic Actions**: New tools now support Automatic Pageview tracking\n* **HTTP Events API**: Respect Google consent signals\n\n* **Embeds**: Add support for server-side rendering of X (Twitter) and Instagram embeds\n* **CSP Compliance**: Remove `eval` dependency\n* **Google Analytics 4 Managed Component**: Allow customizing the document title and client ID fields\n* **Custom HTML Managed Component**: Scripts included in a Custom HTML will preserve their running order\n* **Google Ads Managed Component**: Allow linking data with Google Analytics 4 instances\n* **TikTok Managed Component**: Use the new TikTok Events API v2\n* **Reddit Managed Component**: Support custom events\n* **Twitter Managed Component**: Support setting the `event_id`, using custom fields, and improve conversion tracking\n* **Bugfix**: Cookie life-time cannot exceed one year anymore\n* **Bugfix**: Zaraz Debugger UI does not break when presenting really long lines of information\n\n* **Dashboard**: Add an option to disable the automatic `Pageview` event\n\n* **Amplitude Managed Component**: Allow users to choose data center\n* **Bing Managed Component**: Fix e-commerce events handling\n* **Google Analytics 4 Managed Component**: Mark e-commerce events as conversions\n* **Consent Management**: Fix IAB Consent Mode tools not showing with purposes\n\n* **Dashboard**: Add setting for Google Consent mode default\n* **Bugfix**: Cookie values are now decoded\n* **Bugfix**: Ensure context enricher worker can access the `context.system.consent` object\n* **Google Ads Managed Component**: Add conversion linker on pageviews without sending a pageview event\n* **Pinterest Conversion API Managed Component**: Bugfix handling of partial e-commerce event payloads\n\n* **Instagram Managed Component**: Improve performance of Instagram embeds\n* **Mixpanel Managed Component**: Include `gclid` and `fbclid` values in Mixpanel requests if available\n* **Consent Management**: Ensure consent platform is enabled when using IAB TCF compliant mode when there's at least one TCF-approved vendor configured\n* **Bugfix**: Ensure track data payload keys take priority over preset-keys when using enrich-payload feature for custom actions\n\n* **Consent Management**: Add `consent` object to `context.system` for finer control over consent preferences\n* **Consent Management**: Add support for IAB-compliant consent mode\n* **Consent Management**: Add \"zarazConsentChoicesUpdated\" event\n* **Consent Management**: Modal now respects system dark mode prefs when present\n* **Google Analytics 4 Managed Component**: Add support for Google Consent Mode v2\n* **Google Ads Managed Component**: Add support for Google Consent Mode v2\n* **Twitter Managed Component**: Enable tweet embeds\n* **Bing Managed Component**: Support running without setting cookies\n* **Bugfix**: `client.get` for Custom Managed Components fixed\n* **Bugfix**: Prevent duplicate pageviews in monitoring after consent granting\n* **Bugfix**: Prevent Managed Component routes from blocking origin routes unintentionally\n\n* **Single Page Applications**: Introduce `zaraz.spaPageview()` for manually triggering SPA pageviews\n* **Pinterest Managed Component**: Add ecommerce support\n* **Google Ads Managed Component**: Append url and rnd params to pagead/landing endpoint\n* **Bugfix**: Add noindex robots headers for Zaraz GET endpoint responses\n* **Bugfix**: Gracefully handle responses from custom Managed Components without mapped endpoints\n\n* **Dashboard**: rename \"tracks\" to \"events\" for consistency\n* **Pinterest Conversion API Managed Component**: update parameters sent to api\n* **HTTP Managed Component**: update \\_settings prefix usage handling\n* **Bugfix**: better minification of client-side js\n* **Bugfix**: fix bug where anchor link click events were not bubbling when using click listener triggers\n* **API update**: begin migration support from deprecated `tool.neoEvents` array to `tool.actions` object config schema migration\n\n* **Google Analytics 4 Managed Component**: Fix Google Analytics 4 average engagement time metric.\n\n* **HTTP Request Managed Component**: Re-added `__zarazTrack` property.\n\n* **Google Analytics 4 Managed Component**: Remove `debug_mode` key if falsy or `false`.\n\n* **Custom HTML**: Added support for non-JavaScript script tags.\n\n* **Bing Managed Component**: Fixed an issue where some events were not being sent to Bing even after being triggered.\n* **Dashboard**: Improved welcome screen for new Zaraz users.\n\n* **Bugfix**: Fixed an issue that prevented some server-side requests from arriving to their destination\n* **Google Analytics 4 Managed Component**: Add support for `dbg` and `ir` fields.\n\n* **Consent Management**: Add support for custom button translations.\n* **Consent Management**: Modal stays fixed when scrolling.\n* **Google Analytics 4 Managed Component**: `hideOriginalIP` and `ga-audiences` can be set from tool event.\n\n* **Reddit Managed Component**: Support new \"Account ID\" formats (e.g. \"ax\\_xxxxx\").\n\n* **Consent Management**: Consent cookie name can now be customized.\n\n* **Segment Managed Component**: API Endpoint can be customized.\n\n* **TikTok Managed Component**: Support setting `ttp` and `event_id`.\n* **Consent Management**: Accessibility improvements.\n* **Facebook Managed Component**: Support for using \"Limited Data Use\" features.\n\n<page>\n---\ntitle: Zaraz Consent Management platform · Cloudflare Zaraz docs\ndescription: Zaraz provides a Consent Management platform (CMP) to help you\n  address and manage required consents under the European General Data\n  Protection Regulation (GDPR) and the Directive on privacy and electronic\n  communications. This consent platform lets you easily create a consent modal\n  for your website based on the tools you have configured. With Zaraz CMP, you\n  can make sure Zaraz only loads tools under the umbrella of the specific\n  purposes your users have agreed to.\nlastUpdated: 2025-09-23T20:48:09.000Z\nchatbotDeprioritize: false\ntags: Privacy\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/consent-management/\n  md: https://developers.cloudflare.com/zaraz/consent-management/index.md\n---\n\nZaraz provides a Consent Management platform (CMP) to help you address and manage required consents under the European [General Data Protection Regulation (GDPR)](https://gdpr-info.eu/) and the [Directive on privacy and electronic communications](https://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:02002L0058-20091219\\&from=EN#tocId7). This consent platform lets you easily create a consent modal for your website based on the tools you have configured. With Zaraz CMP, you can make sure Zaraz only loads tools under the umbrella of the specific purposes your users have agreed to.\n\nThe consent modal added to your website is concise and gives your users an easy way to opt-in to any purposes of data processing your tools need.\n\n## Crucial vocabulary\n\nThe Zaraz Consent Management platform (CMP) has a **Purposes** section. This is where you will have to create purposes for the third-party tools your website uses. To better understand the terms involved in dealing with personal data, refer to these definitions:\n\n* **Purpose**: The reason you are loading a given tool on your website, such as to track conversions or improve your website’s layout based on behavior tracking. One purpose can be assigned to many tools, but one tool can be assigned only to one purpose.\n* **Consent**: An affirmative action that the user makes, required to store and access cookies (or other persistent data, like `LocalStorage`) on the users’ computer/browser.\n\nAll tools use consent as a legal basis. This is due to the fact that they all use cookies that are not strictly necessary for the website’s correct operation. Due to this, all purposes are opt-in.\n\n## Purposes and tools\n\nWhen you add a new tool to your website, Zaraz does not assign any purpose to it. This means that this tool will skip consent by default. Remember to check the [Consent Management settings](https://developers.cloudflare.com/zaraz/consent-management/enable-consent-management/) every time you set up a new tool. This helps ensure you avoid a situation where your tool is triggered before the user gives consent.\n\nThe user’s consent preferences are stored within a first-party cookie. This cookie is a JSON file that maps the purposes’ ID to a `true`/`false`/missing value:\n\n* `true` value: The user gave consent.\n* `false`value: The user refused consent.\n* Missing value: The user has not made a choice yet.\n\nCloudflare cannot recommend nor assign by default any specific purpose for your tools. It is your responsibility to properly assign tools to purposes if you need to comply with GDPR.\n\n## Important things to note\n\n* Purposes that have no tools assigned will not show up in the CMP modal.\n* If a tool is assigned to a purpose, it will not run unless the user gives consent for the purpose the tool is assigned for.\n* Once your website loads for a given user for the first time, all the triggers you have configured for tools that are waiting for consent are cached in the browser. Then, they will be fired when/if the user gives consent, so they are not lost.\n* If the user visits your website for the first time, the consent modal will automatically show up. This also happens if the user has previously visited your website, but in the meantime you have enabled CMP.\n* On subsequent visits, the modal will not show up. You can make the modal show up by calling the function `zaraz.showConsentModal()` — for example, by binding it to a button.\n\n<page>\n---\ntitle: Embeds · Cloudflare Zaraz docs\ndescription: Embeds are tools for incorporating external content, like social\n  media posts, directly onto webpages, enhancing user engagement without\n  compromising site performance and security.\nlastUpdated: 2025-09-05T07:54:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/embeds/\n  md: https://developers.cloudflare.com/zaraz/embeds/index.md\n---\n\nEmbeds are tools for incorporating external content, like social media posts, directly onto webpages, enhancing user engagement without compromising site performance and security.\n\nCloudflare Zaraz introduces server-side rendering for embeds, avoiding third-party JavaScript to improve security, privacy, and page speed. This method processes content on the server side, removing the need for direct communication between the user's browser and third-party servers.\n\nTo add an Embed to Your Website:\n\n1. In the Cloudflare dashboard, go to the **Tag Setup** page.\n\n[Go to **Tag setup**](https://dash.cloudflare.com/?to=/:account/tag-management/zaraz)\n\n2. Go to **Tools Configuration**.\n\n3. Click \"add new tool\" and activate the desired tools on your Cloudflare Zaraz dashboard.\n\n4. Add a placeholder in your HTML, specifying the necessary attributes. For a generic embed, the snippet looks like this:\n\nReplace `componentName`, `embedName` and `attribute=\"value\"` with the specific Managed Component requirements. Zaraz automatically detects placeholders and replaces them with the content in a secure and efficient way.\n\n### X (Twitter) embed\n\nReplace `tweet-id` with the actual tweet ID for the content you wish to embed.\n\nReplace `post-url` with the actual URL for the content you wish to embed. To include posts captions set captions attribute to `true`.\n\n<page>\n---\ntitle: Create a third-party tool action · Cloudflare Zaraz docs\ndescription: Tools on Zaraz must have actions configured in order to do\n  something. Often, using Automatic Actions is enough for configuring a tool.\n  But you might want to use Custom Actions to create a more customized setup, or\n  perhaps you are using a tool that does not support Automatic Actions. In these\n  cases, you will need to configure Custom Actions manually.\nlastUpdated: 2024-09-24T17:04:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/custom-actions/\n  md: https://developers.cloudflare.com/zaraz/custom-actions/index.md\n---\n\nTools on Zaraz must have actions configured in order to do something. Often, using Automatic Actions is enough for configuring a tool. But you might want to use Custom Actions to create a more customized setup, or perhaps you are using a tool that does not support Automatic Actions. In these cases, you will need to configure Custom Actions manually.\n\nEvery action has firing triggers assigned to it. When the conditions of the firing triggers are met, the action will start. An action can be anything the tool can do - sending analytics information, showing a widget, adding a script and much more.\n\nTo start using actions, first [create a trigger](https://developers.cloudflare.com/zaraz/custom-actions/create-trigger/) to determine when this action will start. If you have already set up a trigger, or if you are using one of the built-in triggers, follow these steps to [create an action](https://developers.cloudflare.com/zaraz/custom-actions/create-action/).\n\n<page>\n---\ntitle: FAQ · Cloudflare Zaraz docs\ndescription: Below you will find answers to our most commonly asked questions.\n  If you cannot find the answer you are looking for, refer to the community page\n  or Discord channel to explore additional resources.\nlastUpdated: 2025-09-05T07:54:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/faq/\n  md: https://developers.cloudflare.com/zaraz/faq/index.md\n---\n\nBelow you will find answers to our most commonly asked questions. If you cannot find the answer you are looking for, refer to the [community page](https://community.cloudflare.com/) or [Discord channel](https://discord.cloudflare.com) to explore additional resources.\n\n* [General](#general)\n* [Tools](#tools)\n* [Consent](#consent)\n\nIf you're looking for information regarding Zaraz Pricing, see the [Zaraz Pricing](https://developers.cloudflare.com/zaraz/pricing-info/) page.\n\n#### Why is Zaraz not working?\n\nIf you are experiencing issues with Zaraz, there could be multiple reasons behind it. First, it's important to verify that the Zaraz script is loading properly on your website.\n\nTo check if the script is loading correctly, follow these steps:\n\n1. Open your website in a web browser.\n2. Open your browser's Developer Tools.\n3. In the Console, type `zaraz`.\n4. If you see an error message saying `zaraz is not defined`, it means that Zaraz failed to load.\n\nIf Zaraz is not loading, please verify the following:\n\n* The domain running Zaraz [is proxied by Cloudflare](https://developers.cloudflare.com/dns/proxy-status/).\n* Auto Injection is enabled in your [Zaraz Settings](https://developers.cloudflare.com/zaraz/reference/settings/#auto-inject-script).\n* Your website's HTML is valid and includes `<head>` and `</head>` tags.\n* You have at least [one enabled tool](https://developers.cloudflare.com/zaraz/get-started/) configured in Zaraz.\n\n#### The browser extension I'm using cannot find the tool I have added. Why?\n\nZaraz is loading tools server-side, which means code running in the browser will not be able to see it. Running tools server-side is better for your website performance and privacy, but it also means you cannot use normal browser extensions to debug your Zaraz tools.\n\n#### I'm seeing some data discrepancies. Is there a way to check what data reaches Zaraz?\n\nYes. You can use the metrics in [Zaraz Monitoring](https://developers.cloudflare.com/zaraz/monitoring/) and [Debug Mode](https://developers.cloudflare.com/zaraz/web-api/debug-mode/) to help you find where in the workflow the problem occurred.\n\n#### Can I use Zaraz with Rocket Loader?\n\nWe recommend disabling [Rocket Loader](https://developers.cloudflare.com/speed/optimization/content/rocket-loader/) when using Zaraz. While Zaraz can be used together with Rocket Loader, there's usually no need to use both. Rocket Loader can sometimes delay data from reaching Zaraz, causing issues.\n\n#### Is Zaraz compatible with Content Security Policies (CSP)?\n\nYes. To learn more about how Zaraz compatibility with [CSP](https://developers.cloudflare.com/fundamentals/reference/policies-compliances/content-security-policies/) configurations works, refer to the [Cloudflare Zaraz supports CSP](https://blog.cloudflare.com/cloudflare-zaraz-supports-csp/) blog post.\n\n#### Does Cloudflare process my HTML, removing existing scripts and then injecting Zaraz?\n\nCloudflare Zaraz does not remove other third-party scripts from the page. Zaraz [can be auto-injected or not](https://developers.cloudflare.com/zaraz/reference/settings/#auto-inject-script), depending on your configuration, but if you have existing scripts that you intend to load with Zaraz, you should remove them.\n\n#### Does Zaraz work with Cloudflare Page Shield?\n\nYes. Refer to [Page Shield](https://developers.cloudflare.com/page-shield/) for more information related to this product.\n\n#### Is there a way to prevent Zaraz from loading on specific pages, like under `/wp-admin`?\n\nTo prevent Zaraz from loading on specific pages, refer to [Load Zaraz selectively](https://developers.cloudflare.com/zaraz/advanced/load-selectively/).\n\n#### How can I remove my Zaraz configuration?\n\nResetting your Zaraz configuration will erase all of your configuration settings, including any tools, triggers, and variables you've set up. This action will disable Zaraz immediately. If you want to start over with a clean slate, you can always reset your configuration.\n\n1. In the Cloudflare dashboard, go to the **Settings** page.\n\n[Go to **Settings**](https://dash.cloudflare.com/?to=/:account/tag-management/settings)\n\n2. Go to **Advanced**.\n\n3. Click \"Reset\" and follow the instructions.\n\n#### Why would the `zaraz.ecommerce()` method returns an undefined error?\n\nE-commerce tracking needs to be enabled in [the Zaraz Settings page](https://developers.cloudflare.com/zaraz/reference/settings/#e-commerce-tracking) before you can start using the E-commerce Web API.\n\n#### How would I trigger pageviews manually on a Single Page Application (SPA)?\n\nZaraz comes with built-in [Single Page Application (SPA) support](https://developers.cloudflare.com/zaraz/reference/settings/#single-page-application-support) that automatically sends pageview events when navigating through the pages of your SPA. However, if you have advanced use cases, you might want to build your own system to trigger pageviews. In such cases, you can use the internal SPA pageview event by calling `zaraz.spaPageview()`.\n\n#### After moving from Google Analytics 4 to Zaraz, I can no longer see demographics data. Why?\n\nYou probably have enabled **Hide Originating IP Address** in the [Settings option](https://developers.cloudflare.com/zaraz/custom-actions/edit-tools-and-actions/) for Google Analytics 4. This tells Zaraz to not send the IP address to Google. To have access to demographics data and anonymize your visitor's IP, you should use [**Anonymize Originating IP Address**](#i-see-two-ways-of-anonymizing-ip-address-information-on-the-third-party-tool-google-analytics-one-in-privacy-and-one-in-additional-fields-which-is-the-correct-one) instead.\n\n#### I see two ways of anonymizing IP address information on the third-party tool Google Analytics: one in Privacy, and one in Additional fields. Which is the correct one?\n\nThere is not a correct option, as the two options available in Google Analytics (GA) do different things.\n\nThe \"Hide Originating IP Address\" option in [Tool Settings](https://developers.cloudflare.com/zaraz/custom-actions/edit-tools-and-actions/) prevents Zaraz from sending the IP address from a visitor to Google. This means that GA treats Zaraz's Worker's IP address as the visitor's IP address. This is often close in terms of location, but it might not be.\n\nWith the **Anonymize Originating IP Address** available in the [Add field](https://developers.cloudflare.com/zaraz/custom-actions/additional-fields/) option, Cloudflare sends the visitor's IP address to Google as is, and passes the 'aip' parameter to GA. This asks GA to anonymize the data.\n\n#### If I set up Event Reporting (enhanced measurements) for Google Analytics, why does Zaraz only report Page View, Session Start, and First Visit?\n\nThis is not a bug. Zaraz does not offer all the automatic events the normal GA4 JavaScript snippets offer out of the box. You will need to build [triggers](https://developers.cloudflare.com/zaraz/custom-actions/create-trigger/) and [actions](https://developers.cloudflare.com/zaraz/custom-actions/) to capture those events. Refer to [Get started](https://developers.cloudflare.com/zaraz/get-started/) to learn more about how Zaraz works.\n\n#### Can I set up custom dimensions for Google Analytics with Zaraz?\n\nYes. Refer to [Additional fields](https://developers.cloudflare.com/zaraz/custom-actions/additional-fields/) to learn how to send additional data to tools.\n\n#### How do I attach a User Property to my events?\n\nIn your Google Analytics 4 action, select **Add field** > **Add custom field...** and enter a field name that starts with `up.` — for example, `up.name`. This will make Zaraz send the field as a User Property and not as an Event Property.\n\n#### How can I enable Google Consent Mode signals?\n\nZaraz has built-in support for Google Consent Mode v2. Learn more on how to use it in [Google Consent Mode page](https://developers.cloudflare.com/zaraz/advanced/google-consent-mode/).\n\n#### If I set up Facebook Pixel on my Zaraz account, why am I not seeing data coming through?\n\nIt can take between 15 minutes to several hours for data to appear on Facebook's interface, due the way Facebook Pixel works. You can also use [debug mode](https://developers.cloudflare.com/zaraz/web-api/debug-mode/) to confirm that data is being properly sent from your Zaraz account.\n\n#### What is the expected format for Conversion ID and Conversion Label\n\nConversion ID and Conversion Label are usually provided by Google Ads as a \"gtag script\". Here's an example for a $1 USD conversion:\n\nThe Conversion ID is the first part of `send_to` parameter, without the `AW-`. In the above example it would be `123456789`. The Conversion Label is the second part of the `send_to` parameter, therefore `AbC-D_efG-h12_34-567` in the above example. When setting up your Google Ads conversions through Zaraz, take the information from the original scripts you were asked to implement.\n\n#### Can I use Google Tag Manager together with Zaraz?\n\nYou can load Google Tag Manager using Zaraz, but it is not recommended. Tools configured inside Google Tag Manager cannot be optimized by Zaraz, and cannot be restricted by the Zaraz privacy controls. In addition, Google Tag Manager could slow down your website because it requires additional JavaScript, and its rules are evaluated client-side. If you are currently using Google Tag Manager, we recommend replacing it with Zaraz by configuring your tags directly as Zaraz tools.\n\n#### Why should I prefer a native tool integration instead of an HTML snippet?\n\nAdding a tool to your website via a native Zaraz integration is always better than using an HTML snippet. HTML snippets usually depends on additional client-side requests, and require client-side code execution, which can slow down your website. They are often a security risk, as they can be hacked. Moreover, it can be very difficult to control their affect on the privacy of your visitors. Tools included in the Zaraz library are not suffering from these issues - they are fast, executed at the edge, and be controlled and restricted because they are sandboxed.\n\n#### How can I set my Custom HTML to be injected just once in my Single Page App (SPA) website?\n\nIf you have enabled \"Single Page Application support\" in Zaraz Settings, your Custom HTML code may be unnecessarily injected every time a new SPA page is loaded. This can result in duplicates. To avoid this, go to your Custom HTML action and select the \"Add Field\" option. Then, add the \"Ignore SPA\" field and enable the toggle switch. Doing so will prevent your code from firing on every SPA pageview and ensure that it is injected only once.\n\n#### What if I want to use a tool that is not supported by Zaraz?\n\nThe Zaraz engineering team is adding support to new tools all the time. You can also refer to the [community space](https://community.cloudflare.com/c/developers/integrationrequest/68) to ask for new integrations.\n\n#### I cannot get a tool to load when the website is loaded. Do I have to add code to my website?\n\nIf you proxy your domain through Cloudflare, you do not need to add any code to your website. By default, Zaraz includes an automated `Pageview` trigger. Some tools, like Google Analytics, automatically add a `Pageview` action that uses this trigger. With other tools, you will need to add it manually. Refer to [Get started](https://developers.cloudflare.com/zaraz/get-started/) for more information.\n\n#### I am a vendor. How can I integrate my tool with Zaraz?\n\nThe Zaraz team is working with third-party vendors to build their own Zaraz integrations using the Zaraz SDK. To request a new tool integration, or to collaborate on our SDK, contact us at <zaraz@cloudflare.com>.\n\n### How do I show the consent modal again to all users?\n\nIn such a case, you can change the cookie name in the *Consent cookie name* field in the Zaraz Consent configuration. This will cause the consent modal to reappear for all users. Make sure to use a cookie name that has not been used for Zaraz on your site.\n\n<page>\n---\ntitle: Get started · Cloudflare Zaraz docs\ndescription: Before being able to use Zaraz, it is recommended that you proxy\n  your website through Cloudflare. Refer to Set up Cloudflare for more\n  information. If you do not want to proxy your website through Cloudflare,\n  refer to Use Zaraz on domains not proxied by Cloudflare.\nlastUpdated: 2025-09-05T07:54:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/get-started/\n  md: https://developers.cloudflare.com/zaraz/get-started/index.md\n---\n\nBefore being able to use Zaraz, it is recommended that you proxy your website through Cloudflare. Refer to [Set up Cloudflare](https://developers.cloudflare.com/fundamentals/account/) for more information. If you do not want to proxy your website through Cloudflare, refer to [Use Zaraz on domains not proxied by Cloudflare](https://developers.cloudflare.com/zaraz/advanced/domains-not-proxied/).\n\n## Add a third-party tool to your website\n\nYou can add new third-party tools and load them into your website through the Cloudflare dashboard.\n\n1. In the Cloudflare dashboard, go to the **Tag Setup** page.\n\n[Go to **Tag setup**](https://dash.cloudflare.com/?to=/:account/tag-management/zaraz)\n\n2. If you have already added a tool before, select **Third-party tools** and click on **Add new tool**.\n\n3. Choose a tool from the tools catalog. Select **Continue** to confirm your selection.\n\n4. In **Set up**, configure the settings for your new tool. The information you need to enter will depend on the tool you choose. If you want to use any dynamic properties or variables, select the `+` sign in the drop-down menu next to the relevant field.\n\n5. In **Actions** setup the actions for your new tool. You should be able to select Pageviews, Events or E-Commerce [1](#user-content-fn-1).\n\n## Events, triggers and actions\n\nZaraz relies on events, triggers and actions to determine when to load the tools you need in your website, and what action they need to perform. The way you configure Zaraz and where you start largely depend on the tool you wish to use. When using a tool that supports Automatic Actions, this process is largely done for you. If the tool you are adding doesn't support Automatic Actions, read more about configuring [Custom Actions](https://developers.cloudflare.com/zaraz/custom-actions).\n\nWhen using Automatic Actions, the available actions are as follows:\n\n* **Pageviews** - for tracking every pageview on your website\n* **Events** - For tracking calls using the [`zaraz.track` Web API](https://developers.cloudflare.com/zaraz/web-api/track)\n* **E-commerce** - For tracking calls to [`zaraz.ecommerce` Web API](https://developers.cloudflare.com/zaraz/web-api/ecommerce)\n\nIf you need to programmatically start actions in your tools, Cloudflare Zaraz provides a unified Web API to send events to Zaraz, and from there, to third-party tools. This Web API includes the `zaraz.track()`, `zaraz.set()` and `zaraz.ecommerce()` methods.\n\n[The Track method](https://developers.cloudflare.com/zaraz/web-api/track/) allows you to track custom events and actions on your website that might happen in real time. [The Set method](https://developers.cloudflare.com/zaraz/web-api/set/) is an easy shortcut to define a variable once and have it sent with every future Track call. [E-commerce](https://developers.cloudflare.com/zaraz/web-api/ecommerce/) is a unified method for sending e-commerce related data to multiple tools without needing to configure triggers and events. Refer to [Web API](https://developers.cloudflare.com/zaraz/web-api/) for more information.\n\nIf you suspect that something is not working the way it should, or if you want to verify the operation of tools on your website, read more about [Debug Mode](https://developers.cloudflare.com/zaraz/web-api/debug-mode/) and [Zaraz Monitoring](https://developers.cloudflare.com/zaraz/monitoring/). Also, check the [FAQ](https://developers.cloudflare.com/zaraz/faq/) page to see if your question was already answered there.\n\nUsers and companies have developed plugins that make using Zaraz easier on specific platforms. We recommend checking out these plugins if you are using one of these platforms.\n\n* [Beetle Tracking](https://beetle-tracking.com/) - Integrate Zaraz with your WordPress WooCommerce website to track e-commerce events with zero configuration. Beetle Tracking also supports consent management and other advanced features.\n\n1. Some tools do not supported Automatic Actions, see the section about [Custom Actions](https://developers.cloudflare.com/zaraz/custom-actions) if the tool you are adding doesn't present Automatic Actions. [↩](#user-content-fnref-1)\n\n<page>\n---\ntitle: Versions & History · Cloudflare Zaraz docs\ndescription: Zaraz can work in real-time. In this mode, every change you make is\n  instantly published. You can also enable Preview & Publish mode, which allows\n  you to test your changes before you commit to them.\nlastUpdated: 2024-09-24T17:04:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/history/\n  md: https://developers.cloudflare.com/zaraz/history/index.md\n---\n\nZaraz can work in real-time. In this mode, every change you make is instantly published. You can also enable [Preview & Publish mode](https://developers.cloudflare.com/zaraz/history/preview-mode/), which allows you to test your changes before you commit to them.\n\nWhen enabling Preview & Publish mode, you will also have access to [Zaraz History](https://developers.cloudflare.com/zaraz/history/versions/). Zaraz History shows you a list of all the changes made to your settings, and allows you to revert to any previous settings.\n\n* [Preview mode](https://developers.cloudflare.com/zaraz/history/preview-mode/)\n* [Versions](https://developers.cloudflare.com/zaraz/history/versions/)\n\n<page>\n---\ntitle: HTTP Events API · Cloudflare Zaraz docs\ndescription: The Zaraz HTTP Events API allows you to send information to Zaraz\n  from places that cannot run the Web API, such as your server or your mobile\n  app. It is useful for tracking events that are happening outside the browser,\n  like successful transactions, sign-ups and more. The API also allows sending\n  multiple events in batches.\nlastUpdated: 2025-09-05T07:54:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/http-events-api/\n  md: https://developers.cloudflare.com/zaraz/http-events-api/index.md\n---\n\nThe Zaraz HTTP Events API allows you to send information to Zaraz from places that cannot run the [Web API](https://developers.cloudflare.com/zaraz/web-api/), such as your server or your mobile app. It is useful for tracking events that are happening outside the browser, like successful transactions, sign-ups and more. The API also allows sending multiple events in batches.\n\n## Configure the API endpoint\n\nThe API is disabled unless you configure an endpoint for it. The endpoint determines under what URL the API will be accessible. For example, if you set the endpoint to be `/zaraz/api`, and your domain is `example.com`, requests to the API will go to `https://example.com/zaraz/api`.\n\nTo enable the API endpoint:\n\n1. In the Cloudflare dashboard, go to the **Settings** page.\n\n[Go to **Settings**](https://dash.cloudflare.com/?to=/:account/tag-management/settings)\n\n2. Under **Endpoints** > **HTTP Events API**, set your desired path. Remember the path is relative to your domain, and it must start with a `/`.\n\nTo avoid getting the API used by unwanted actors, Cloudflare recommends choosing a unique path.\n\nThe endpoint you have configured for the API will receive `POST` requests with a JSON payload. Below, there is an example payload:\n\nThe payload must contain an `events` array. Each Event Object in this array corresponds to one event you want Zaraz to process. The above example is similar to calling `zaraz.track('transaction successful', { value: \"200\" })` using the Web API.\n\nThe Event Object holds the `client` object, in which you can pass information about the event itself. Every key you include in the Event Object will be available as a *Track Property* in the Zaraz dashboard.\n\nThere are two reserved keys:\n\n* `__zarazTrack`: The value of this key will be available as *Event Name*. This is what you will usually build your triggers around. In the above example, setting this to `transaction successful` is the same as [using the Web API](https://developers.cloudflare.com/zaraz/web-api/track/) and calling `zaraz.track(\"transaction successful\")`.\n* `__zarazEcommerce`: This key needs to be set to `true` if you want Zaraz to process the event as an e-commerce event.\n\nIn addition to the `client` key, you can use the `system` key to include information about the device from which the event originated. For example, you can submit the `User-Agent` string, the cookies and the screen resolution. Zaraz will use this information when connecting to different third-party tools. Since some tools depend on certain fields, it is often useful to include all the information you can.\n\nThe same payload from before will resemble the following example, when we add the `system` information:\n\nFor all available system keys, refer to the table below:\n\n| Property | Type | Description |\n| - | - | - |\n| `system.cookies` | Object | A key-value object holding cookies from the device associated with the event. |\n| `system.device.ip` | String | The IP address of the device associated with the event. |\n| `system.device.resolution` | String | The screen resolution of the device associated with the event, in a `WIDTHxHEIGHT` format. |\n| `system.device.viewport` | String | The viewport of the device associated with the event, in a `WIDTHxHEIGHT` format. |\n| `system.device.language` | String | The language code used by the device associated with the event. |\n| `system.device.user-agent` | String | The `User-Agent` string of the device associated with the event. |\n| `system.page.title` | String | The title of the page associated with the event. |\n| `system.page.url` | String | The URL of the page associated with the event. |\n| `system.page.referrer` | String | The URL of the referrer page in the time the event took place. |\n| `system.page.encoding` | String | The encoding of the page associated with the event. |\n\nIt is currently not possible to override location related properties, such as City, Country, and Continent.\n\n## Process API responses\n\nFor each Event Object in your payload, Zaraz will respond with a Result Object. The Result Objects order matches the order of your Event Objects.\n\nDepending on what tools you are loading using Zaraz, the body of the response coming from the API might include information you will want to process. This is because some tools do not have a complete server-side implementation and still depend on cookies, client-side JavaScript or similar mechanisms. Each Result Object can include the following information:\n\n| Result key | Description |\n| - | - |\n| `fetch` | Fetch requests that tools want to send from the user browser. |\n| `execute` | JavaScript code that tools want to execute in the user browser. |\n| `return` | Information that tools return. |\n| `cookies` | Cookies that tools want to set for the user. |\n\nYou do not have to process the information above, but some tools might depend on this to work properly. You can start using the HTTP Events API without processing the information in the table above, and adjust accordingly later.\n\n<page>\n---\ntitle: Monitoring · Cloudflare Zaraz docs\ndescription: Zaraz Monitoring shows you different metrics regarding Zaraz. This\n  helps you to detect issues when they occur. For example, if a third-party\n  analytics provider stops collecting data, you can use the information\n  presented by Zaraz Monitoring to find where in the workflow the problem\n  occurred.\nlastUpdated: 2025-09-05T07:54:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/monitoring/\n  md: https://developers.cloudflare.com/zaraz/monitoring/index.md\n---\n\nZaraz Monitoring shows you different metrics regarding Zaraz. This helps you to detect issues when they occur. For example, if a third-party analytics provider stops collecting data, you can use the information presented by Zaraz Monitoring to find where in the workflow the problem occurred.\n\nYou can also check activity data in the **Activity last 24hr** section, when you access [tools](https://developers.cloudflare.com/zaraz/get-started/), [actions](https://developers.cloudflare.com/zaraz/custom-actions/) and [triggers](https://developers.cloudflare.com/zaraz/custom-actions/create-trigger/) in the dashboard.\n\nTo use Zaraz Monitoring:\n\n1. In the Cloudflare dashboard, go to the **Monitoring** page.\n\n[Go to **Monitoring**](https://dash.cloudflare.com/?to=/:account/tag-management/monitoring)\n\n2. Select one of the options (Loads, Events, Triggers, Actions). Zaraz Monitoring will show you how the traffic for that section evolved for the time period selected.\n\n## Zaraz Monitoring options\n\n* **Loads**: Counts how many times Zaraz was loaded on pages of your website. When [Single Page Application support](https://developers.cloudflare.com/zaraz/reference/settings/#single-page-application-support) is enabled, Loads will count every change of navigation as well.\n* **Events**: Counts how many times a specific event was tracked by Zaraz. It includes the [Pageview event](https://developers.cloudflare.com/zaraz/get-started/), [Track events](https://developers.cloudflare.com/zaraz/web-api/track/), and [E-commerce events](https://developers.cloudflare.com/zaraz/web-api/ecommerce/).\n* **Triggers**: Counts how many times a specific trigger was activated. It includes the built-in [Pageview trigger](https://developers.cloudflare.com/zaraz/custom-actions/create-trigger/) and any other trigger you set in Zaraz.\n* **Actions**: Counts how many times a [specific action](https://developers.cloudflare.com/zaraz/custom-actions/) was activated. It includes the pre-configured Pageview action, and any other actions you set in Zaraz.\n* **Server-side requests**: tracks the status codes returned from server-side requests that Zaraz makes to your third-party tools.\n\n<page>\n---\ntitle: Pricing · Cloudflare Zaraz docs\ndescription: Zaraz is available to all Cloudflare users, across all tiers. Each\n  month, every Cloudflare account gets 1,000,000 free Zaraz Events. For\n  additional usage, the Zaraz Paid plan costs $5 per month for each additional\n  1,000,000 Zaraz Events.\nlastUpdated: 2025-09-23T13:15:19.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/pricing-info/\n  md: https://developers.cloudflare.com/zaraz/pricing-info/index.md\n---\n\nZaraz is available to all Cloudflare users, across all tiers. Each month, every Cloudflare account gets 1,000,000 free Zaraz Events. For additional usage, the Zaraz Paid plan costs $5 per month for each additional 1,000,000 Zaraz Events.\n\nAll Zaraz features and tools are always available on all accounts. Learn more about our pricing in [the following pricing announcement](https://blog.cloudflare.com/zaraz-announces-new-pricing)\n\n## The Zaraz Event unit\n\nOne Zaraz Event is an event you are sending to Zaraz, whether that is a page view, a `zaraz.track` event, or similar. You can easily see the total number of Zaraz Events you are currently using on the **Monitoring** page of the Cloudflare dashboard:\n\n[Go to **Monitoring**](https://dash.cloudflare.com/?to=/:account/tag-management/monitoring)\n\n## Enabling Zaraz Paid\n\n1. In the Cloudflare dashboard, go to the **Zaraz plans** page.\n\n[Go to **Zaraz plans**](https://dash.cloudflare.com/?to=/:account/tag-management/plans)\n\n2. Click the **Enable Zaraz usage billing** button and follow the instructions.\n\nIf you don't enable Zaraz Paid, you'll receive email notifications when you reach 50%, 80%, and 90% of your free allocation. Zaraz will be disabled until the next billing cycle if you exceed 1,000,000 events without enabling Zaraz Paid.\n\n<page>\n---\ntitle: Reference · Cloudflare Zaraz docs\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/reference/\n  md: https://developers.cloudflare.com/zaraz/reference/index.md\n---\n\n* [Zaraz Context](https://developers.cloudflare.com/zaraz/reference/context/)\n* [Properties reference](https://developers.cloudflare.com/zaraz/reference/properties-reference/)\n* [Settings](https://developers.cloudflare.com/zaraz/reference/settings/)\n* [Third-party tools](https://developers.cloudflare.com/zaraz/reference/supported-tools/)\n* [Triggers and rules](https://developers.cloudflare.com/zaraz/reference/triggers/)\n\n<page>\n---\ntitle: Variables · Cloudflare Zaraz docs\nlastUpdated: 2024-09-24T17:04:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/variables/\n  md: https://developers.cloudflare.com/zaraz/variables/index.md\n---\n\n* [Create a variable](https://developers.cloudflare.com/zaraz/variables/create-variables/)\n* [Edit variables](https://developers.cloudflare.com/zaraz/variables/edit-variables/)\n* [Worker Variables](https://developers.cloudflare.com/zaraz/variables/worker-variables/)\n\n<page>\n---\ntitle: DNS in Google Sheets · Cloudflare 1.1.1.1 docs\ndescription: Cloudflare 1.1.1 works directly inside Google Sheets. To get\n  started, create a Google Function with the following code.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-in-google-sheets/\n  md: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-in-google-sheets/index.md\n---\n\n1.1.1.1 works directly inside Google Sheets. To get started, create a [Google Function](https://developers.google.com/apps-script/guides/sheets/functions) with the following code:\n\nWhen you feed the function `NSLookup` a record type and a domain, you will get a DNS record value in the cell you called `NSLookup`.\n\nTo limit the number of DNS lookups and speed up the results (especially in larger Google Sheets), you can cache the returned DNS record value. Both the cache usage and the cache TTL can be controlled in arguments 3 and 4, respectively.\n\nSupported DNS record types\n\n* `A`\n* `AAAA`\n* `CAA`\n* `CNAME`\n* `DS`\n* `DNSKEY`\n* `MX`\n* `NS`\n* `NSEC`\n* `NSEC3`\n* `RRSIG`\n* `SOA`\n* `TXT`\n\nOr - depending on your regional settings - you may have to use this formula:\n\n![Google sheets function](https://developers.cloudflare.com/_astro/google-sheet-function.B_K9dB4i_B0eSL.webp)\n\n![Google sheets function](https://developers.cloudflare.com/_astro/google-sheet-result.qjsyQyZU_ZuvlJi.webp)\n\n<page>\n---\ntitle: Web API · Cloudflare Zaraz docs\ndescription: Zaraz provides a client-side web API that you can use anywhere\n  inside the <body> tag of a page.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/zaraz/web-api/\n  md: https://developers.cloudflare.com/zaraz/web-api/index.md\n---\n\nZaraz provides a client-side web API that you can use anywhere inside the `<body>` tag of a page.\n\nThis API allows you to send events and data to Zaraz, that you can later use when creating your triggers. Using the API lets you tailor the behavior of Zaraz to your needs: You can launch tools only when you need them, or send information you care about that is not otherwise automatically collected from your site.\n\n* [Track](https://developers.cloudflare.com/zaraz/web-api/track/)\n* [Set](https://developers.cloudflare.com/zaraz/web-api/set/)\n* [E-commerce](https://developers.cloudflare.com/zaraz/web-api/ecommerce/)\n* [Debug mode](https://developers.cloudflare.com/zaraz/web-api/debug-mode/)\n\n<page>\n---\ntitle: DNS over Discord · Cloudflare 1.1.1.1 docs\ndescription: 1.1. 1.1 works from a Discord server. Invite the bot to your\n  Discord server to start using DNS over Discord. Or, add it to your account to\n  use it anywhere in Discord.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-over-discord/\n  md: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-over-discord/index.md\n---\n\n1.1.1.1 works from a Discord server, thanks to the 1.1.1.1 bot. [Invite the bot to your Discord server](https://cfl.re/3nM6VfQ) to start using DNS over Discord. Or, [add the bot to your Discord account](https://dns-over-discord.v4.wtf/invite/user) to use it anywhere in Discord.\n\n## Perform DNS lookups\n\nOnce the bot is in your server, type `/dig` to start performing DNS lookups. This will provide a native interface within Discord that allows you to specify the domain to lookup, an optional DNS record type and an optional flag for a short result.\n\nIf only a domain is given for the command, the bot will default to looking for `A` DNS records, and will return the full format result, not the short form.\n\n### Supported record types\n\nDiscord has a limit of 25 options in slash commands, so DNS over Discord offers the 25 most common DNS record types to choose from.\n\nSupported DNS record types\n\n* `A`\n* `AAAA`\n* `CAA`\n* `CDNSKEY`\n* `CDS`\n* `CERT`\n* `CNAME`\n* `DNSKEY`\n* `DS`\n* `HINFO`\n* `HTTPS`\n* `LOC`\n* `MX`\n* `NAPTR`\n* `NS`\n* `PTR`\n* `SMIMEA`\n* `SOA`\n* `SPF`\n* `SRV`\n* `SSHFP`\n* `SVCB`\n* `TLSA`\n* `TXT`\n* `URI`\n\nTo query other DNS record types, or multiple record types at once, use the `/multi-dig` command.\n\n### Short form response\n\nDNS over Discord has an optional flag in the `/dig` command that allows the user to request a response in the short form.\n\nWhen you request a response in the short form, the name and TTL columns will be excluded. The command only returns the data column without formatting, similar to the equivalent `dig` command-line interface response.\n\n### Disable DNSSEC checking\n\nYou can disable DNSSEC checking in the `dig` command by passing `cdflag` as true. This will return the DNS records even if the DNSSEC validation fails.\n\n### Refreshing existing results\n\nYou can refresh the DNS lookup results by clicking the Refresh button. Clicking it will trigger the bot to re-request the DNS query in the message, and update the results in the message. Any user can click this button.\n\nThe refresh button is available on all responses to the `/dig` command, including those that resulted in an error, such as an unknown domain or no records found.\n\n### Changing DNS provider\n\nBy default, the DNS over Discord bot uses Cloudflare's 1.1.1.1 DNS service. You can run the DNS lookup with alternate DNS providers by selecting the dropdown below the result. This shows you a list of available providers. Selecting a new provider updates the results in the message. Any user can change the DNS provider.\n\n## `multi-dig` command\n\nIf you want to look up multiple DNS record types at once, use the `/multi-dig` command. This allows you to specify any supported DNS record type, and multiple types separated by a space.\n\n### Supported record types\n\nWhen providing DNS record types for the `/multi-dig` command, Discord will not prompt you with options. You have to provide a space-separated list of valid DNS record types to lookup, as any invalid options will be silently dropped. `A` records will be used as the default if no valid types are given.\n\nDNS record types supported and considered valid by the bot\n\nUse a `*` (asterisk) in place of a record type to get DNS results for all supported types.\n\n* `A`\n* `AAAA`\n* `AFSDB`\n* `APL`\n* `CAA`\n* `CDNSKEY`\n* `CDS`\n* `CERT`\n* `CNAME`\n* `CSYNC`\n* `DHCID`\n* `DLV`\n* `DNAME`\n* `DNSKEY`\n* `DS`\n* `EUI48`\n* `EUI64`\n* `HINFO`\n* `HIP`\n* `HTTPS`\n* `IPSECKEY`\n* `KEY`\n* `KX`\n* `LOC`\n* `MX`\n* `NAPTR`\n* `NS`\n* `NSEC`\n* `NSEC3`\n* `NSEC3PARAM`\n* `OPENPGPKEY`\n* `PTR`\n* `RP`\n* `SMIMEA`\n* `SOA`\n* `SPF`\n* `SRV`\n* `SSHFP`\n* `SVCB`\n* `TA`\n* `TKEY`\n* `TLSA`\n* `TXT`\n* `URI`\n* `ZONEMD`\n\n### Short form response\n\nLike the main `/dig` command, the `/multi-dig` command also supports the optional short flag after the types have been specified in the slash command.\n\n### Disable DNSSEC checking\n\nAs with the `dig` command, you can disable DNSSEC checking by passing `cdflag` as true. This will return the DNS records even if the DNSSEC validation fails.\n\n### Refreshing existing results\n\nThe `/multi-dig` command also provides a refresh button below each set of DNS results requested (or after each block of 10 DNS record types, if you requested more than 10).\n\nAs with the `/dig` command, any user can press the refresh button to refresh the displayed DNS results, including for DNS queries that had previously failed.\n\n### Changing DNS provider\n\nLike the `/dig` command, you can change the DNS provider when using the `/multi-dig` command. The menu appears after each set of DNS results (or after each block of results if more than 10 record types are requested).\n\nThis menu can be used by any user to change the DNS provider used for the lookup.\n\nThe `/whois` command allows you to perform a RDAP/WHOIS lookup right in Discord for a given domain, IP or ASN.\n\nThe bot also has a set of helper commands available to get more information about the bot and quick links.\n\nThe `/help` command provides in-Discord documentation about all the commands available in the 1.1.1.1 DNS over Discord bot.\n\n### `privacy` command\n\nThe `/privacy` command displays the Privacy Policy notice for using the 1.1.1.1 DNS over Discord bot. You can also [refer to the Privacy Policy page](https://dns-over-discord.v4.wtf/privacy) to access it.\n\nThe `/terms` command displays the Terms of Service notice for using the 1.1.1.1 DNS over Discord bot. You can also [refer to the Terms of Service page](https://dns-over-discord.v4.wtf/terms) to access it.\n\nThe DNS over Discord bot is open-source, and the `/github` command provides a quick link to access the GitHub repository. The GitHub repository can be accessed at <https://github.com/MattIPv4/DNS-over-Discord/>.\n\nThe `/invite` command provides the user with a quick link to invite the 1.1.1.1 DNS over Discord bot to another Discord server, or to add it to a Discord account. The bot can be invited at any time with <https://cfl.re/3nM6VfQ>. The bot can also be added to accounts with <https://dns-over-discord.v4.wtf/invite/user>.\n\nThe DNS over Discord bot is deployed on [Cloudflare Workers](https://workers.cloudflare.com/).\n\nYou can find the source code for the bot on GitHub, as well as information on getting started with contributing to the project, at <https://github.com/MattIPv4/DNS-over-Discord/>.\n\n<page>\n---\ntitle: DNS over Tor · Cloudflare 1.1.1.1 docs\ndescription: If you do not want to disclose your IP address to the resolver, you\n  can use our Tor onion service. Resolving DNS queries through the Tor network\n  guarantees a significantly higher level of anonymity than making the requests\n  directly.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-over-tor/\n  md: https://developers.cloudflare.com/1.1.1.1/additional-options/dns-over-tor/index.md\n---\n\nThe hidden resolver is still an experimental service and should not be used in production or for other critical uses.\n\nIf you do not want to disclose your IP address to the resolver, you can use our Tor onion service. Resolving DNS queries through the Tor network guarantees a significantly higher level of anonymity than making the requests directly. Not only does doing so prevent the resolver from ever seeing your IP address, but it also prevents your ISP from knowing that you attempted to resolve a domain name.\n\nRead more about this service in [this blog post](https://blog.cloudflare.com/welcome-hidden-resolver/).\n\n## Setting up a Tor client\n\nThe important difference between using all other modes of DNS and this one is that packet routing no longer uses IP addresses, and therefore all connections must be routed through a Tor client.\n\nBefore you start, head to the [Tor Project website](https://www.torproject.org/download/download.html.en) to download and install a Tor client. If you use the Tor Browser, it will automatically start a [SOCKS proxy](https://en.wikipedia.org/wiki/SOCKS) at `127.0.0.1:9150`.\n\nIf you use Tor from the command line, create the following configuration file:\n\nThen you can run tor with:\n\nAlso, if you use the Tor Browser, you can head to the resolver's address to see the usual 1.1.1.1 page:\n\nThe HTTPS certificate indicator should say \"Cloudflare, Inc. (US).\"\n\nIf you ever forget 1.1.1.1's address, use cURL to retrieve it:\n\n## Setting up a local DNS proxy using socat\n\nOf course, not all DNS clients support connecting to the Tor client, so the easiest way to connect any DNS-speaking software to the hidden resolver is by forwarding ports locally, for instance [using `socat`](http://www.dest-unreach.org/socat/).\n\n### DNS over TCP, TLS, and HTTPS\n\nThe hidden resolver is set up to listen on TCP ports 53 and 853 for DNS over TCP and TLS. After setting up a Tor proxy, run the following `socat` command as a privileged user, replacing the port number appropriately:\n\nFrom here, you can follow the regular guide for [setting up 1.1.1.1](https://developers.cloudflare.com/1.1.1.1/setup/), except you should always use `127.0.0.1` instead of `1.1.1.1`. If you need to access the proxy from another device, simply replace `127.0.0.1` in `socat` commands with your local IP address.\n\n[As explained in the blog post](https://blog.cloudflare.com/welcome-hidden-resolver/), our favorite way of using the hidden resolver is using DNS over HTTPS (DoH). To set it up:\n\n1. Download `cloudflared` by following the guide for [connecting to 1.1.1.1 using DNS over HTTPS clients](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/dns-over-https-client/).\n\n2. Start a Tor SOCKS proxy and use `socat` to forward port TCP:443 to localhost:\n\n1. Instruct your machine to treat the `.onion` address as localhost:\n\n1. Finally, start a local DNS over UDP daemon:\n\n<page>\n---\ntitle: DNS over HTTPS · Cloudflare 1.1.1.1 docs\ndescription: With DNS over HTTPS (DoH), DNS queries and responses are encrypted\n  and sent via the HTTP, HTTP/2 and HTTP/3 protocols. DoH ensures that attackers\n  cannot forge or alter DNS traffic. DoH uses port 443, which is the standard\n  HTTPS traffic port, to wrap the DNS query in an HTTPS request. DNS queries and\n  responses are camouflaged within other HTTPS traffic, since it all comes and\n  goes from the same port.\nlastUpdated: 2025-10-09T12:44:04.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/\n  md: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/index.md\n---\n\nWith DNS over HTTPS (DoH), DNS queries and responses are encrypted and sent via the HTTP, HTTP/2 and HTTP/3 protocols. DoH ensures that attackers cannot forge or alter DNS traffic. DoH uses port 443, which is the standard HTTPS traffic port, to wrap the DNS query in an HTTPS request. DNS queries and responses are camouflaged within other HTTPS traffic, since it all comes and goes from the same port.\n\n* [Configure DoH on your browser](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/encrypted-dns-browsers/)\n* [Connect to 1.1.1.1 using DoH clients](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/dns-over-https-client/)\n* [Make API requests to 1.1.1.1](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/make-api-requests/)\n\n<page>\n---\ntitle: Supported DNSKEY signature algorithms · Cloudflare 1.1.1.1 docs\ndescription: \"DNSSEC is a protocol that adds a layer of security to the domain\n  name system (DNS). DNSSEC does this by providing authentication through public\n  signing keys using two DNS records: DNSKEY and DS. They can be used to verify\n  DNSSEC signatures in RRSIG records.\"\nlastUpdated: 2024-11-19T17:02:12.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/encryption/dnskey/\n  md: https://developers.cloudflare.com/1.1.1.1/encryption/dnskey/index.md\n---\n\n[DNSSEC is a protocol](https://www.cloudflare.com/learning/dns/dns-records/dnskey-ds-records/) that adds a layer of security to the domain name system (DNS). DNSSEC does this by providing authentication through public signing keys using two DNS records: DNSKEY and DS. They can be used to verify DNSSEC signatures in [RRSIG records](https://www.cloudflare.com/dns/dnssec/how-dnssec-works/).\n\n1.1.1.1 supports the following signature algorithms:\n\n* RSA/SHA-1\n* RSA/SHA-256\n* RSA/SHA-512\n* RSASHA1-NSEC3-SHA1\n* ECDSA Curve P-256 with SHA-256 (ECDSAP256SHA256)\n* ECDSA Curve P-384 with SHA-384 (ECDSAP384SHA384)\n* ED25519\n\n<page>\n---\ntitle: DNS over TLS · Cloudflare 1.1.1.1 docs\ndescription: By default, DNS is sent over a plaintext connection. DNS over TLS\n  (DoT) is one way to send DNS queries over an encrypted connection. Cloudflare\n  supports DNS over TLS on standard port 853 and is compliant with RFC 7858.\n  With DoT, the encryption happens at the transport layer, where it adds TLS\n  encryption on top of a TCP connection.\nlastUpdated: 2024-11-19T17:02:12.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-tls/\n  md: https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-tls/index.md\n---\n\nBy default, DNS is sent over a plaintext connection. DNS over TLS (DoT) is one way to send DNS queries over an encrypted connection. Cloudflare supports DNS over TLS on standard port 853 and is compliant with [RFC 7858](https://tools.ietf.org/html/rfc7858). With DoT, the encryption happens at the transport layer, where it adds TLS encryption on top of a TCP connection.\n\nCloudflare supports DNS over TLS (DoT) on `1.1.1.1`, `1.0.0.1`, and the corresponding IPv6 addresses (`2606:4700:4700::1111` and `2606:4700:4700::1001`) on port `853`. If your DoT client does not support IP addresses, Cloudflare's DoT endpoint can also be reached by hostname on `one.one.one.one`. A stub resolver (the DNS client on a device that talks to the DNS resolver) connects to the resolver over a TLS connection:\n\n1. Before the connection, the DNS stub resolver has stored a base64 encoded SHA256 hash of the TLS certificate from 1.1.1.1 (called SPKI).\n2. DNS stub resolver establishes a TCP connection with `1.1.1.1:853`.\n3. DNS stub resolver initiates a TLS handshake.\n4. In the TLS handshake, 1.1.1.1 presents its TLS certificate.\n5. Once the TLS connection is established, the DNS stub resolver can send DNS over an encrypted connection, preventing eavesdropping and tampering.\n6. All DNS queries sent over the TLS connection must comply with specifications of [sending DNS over TCP](https://tools.ietf.org/html/rfc1035#section-4.2.2).\n\n## Supported TLS versions\n\nCloudflare's DNS over TLS supports TLS 1.3 and TLS 1.2.\n\n<page>\n---\ntitle: Oblivious DNS over HTTPS · Cloudflare 1.1.1.1 docs\ndescription: Learn how Cloudflare 1.1.1.1 supports Oblivious DNS over HTTPS\n  (ODoH) to enhance privacy by separating HTTP request contents from requester\n  IP addresses.\nlastUpdated: 2025-03-03T17:17:36.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/encryption/oblivious-dns-over-https/\n  md: https://developers.cloudflare.com/1.1.1.1/encryption/oblivious-dns-over-https/index.md\n---\n\nAs announced on [our blog](https://blog.cloudflare.com/oblivious-dns/), since late 2020, Cloudflare 1.1.1.1 supports Oblivious DNS over HTTPS (ODoH).\n\nODoH is defined in [RFC 9230](https://www.rfc-editor.org/rfc/rfc9230.html). This RFC is experimental and is not endorsed by the IETF.\n\nODoH improves privacy by separating the contents of an HTTP request (and response) from its requester IP address. To achieve this, a proxy and a target are introduced between the client and the upstream DNS resolver:\n\n* The proxy has no visibility into the DNS messages, with no ability to identify, read, or modify either the query being sent by the client or the answer being returned by the target.\n\n* The target only has access to the encrypted query and the proxy's IP address, while not having visibility over the client's IP address.\n\n* Only the intended target can read the content of the query and produce a response, which is also encrypted.\n\nThis means that, as long as the proxy and the target do not collude, no single entity can have access to both the DNS messages and the client IP address at the same time. Also, clients are in complete control of proxy and target selection.\n\nAdditionally, clients encrypt their query for the target using Hybrid Public Key Encryption (HPKE). A target's public key is obtained via DNS, where it is bundled into an HTTPS resource record and protected by DNSSEC.\n\n## Cloudflare and third-party products\n\nCloudflare 1.1.1.1 supports ODoH by acting as a target that can be reached at `odoh.cloudflare-dns.com`.\n\nTo make ODoH queries you can use open source clients such as [dnscrypt-proxy](https://github.com/DNSCrypt/dnscrypt-proxy).\n\nAlso, [iCloud Private Relay](https://support.apple.com/102602) is based on ODoH and uses [Cloudflare as one of their partners](https://blog.cloudflare.com/icloud-private-relay/).\n\n* [HPKE: Standardizing public-key encryption](https://blog.cloudflare.com/hybrid-public-key-encryption/) blog post\n* [Privacy Gateway](https://developers.cloudflare.com/privacy-gateway/)\n\n<page>\n---\ntitle: Extended DNS error codes · Cloudflare 1.1.1.1 docs\ndescription: Extended DNS Error Codes is a method to return additional\n  information about the cause of DNS errors. As there are many reasons why a DNS\n  query might fail, it became necessary to provide additional information on the\n  exact cause of an error.\nlastUpdated: 2024-12-05T10:44:03.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/infrastructure/extended-dns-error-codes/\n  md: https://developers.cloudflare.com/1.1.1.1/infrastructure/extended-dns-error-codes/index.md\n---\n\n[Extended DNS Error Codes](https://www.rfc-editor.org/rfc/rfc8914.html) is a method to return additional information about the cause of DNS errors. As there are many reasons why a DNS query might fail, it became necessary to provide additional information on the exact cause of an error.\n\n1.1.1.1 supports Extended DNS Error Codes. Below is a list of error codes 1.1.1.1 returns, what they mean, and steps you may want to take to resolve the issue.\n\n| Code number | Code name | Example output | Next steps |\n| - | - | - | - |\n| 1 | Unsupported DNSKEY Algorithm | `EDE: 1 (Unsupported DNSKEY Algorithm): (failed to verify example.com. A: unsupported key size, DNSKEY example.com., id = 12345)` | The domain did not pass DNSSEC validation. Check which [signature key algorithm](https://developers.cloudflare.com/1.1.1.1/encryption/dnskey/) your website uses and confirm it is supported by 1.1.1.1. |\n| 2 | Unsupported DS Digest Type | `EDE: 2 (Unsupported DS Digest Type): (no supported DS digest type for example.com.)` | The domain did not pass DNSSEC validation due to an unsupported digest type on the DS record. If none of the provided DS records are supported, the domain will fail to resolve. Make sure to [add a supported DS record](https://developers.cloudflare.com/dns/dnssec/) with your registrar. |\n| 3 | Stale Answer | `EDE: 3 (Stale Answer)` | This is a silent error. It notifies that the DNS resolver could only return stale data. If the issue persists reach out on the 1.1.1.1 [community forum](https://community.cloudflare.com/c/reliability/dns-1111/47). |\n| 6 | DNSSEC Bogus | `EDE: 6 (DNSSEC Bogus): (proof of non-existence of example.com. A)` `EDE: 6 (DNSSEC Bogus): (found duplicate CNAME records for example.com. (1 duplicate RRs))` | This domain did not pass DNSSEC validation. The signatures for the target record, or the proof of non-existence of the target records, are invalid. Check your [DNS configuration](https://developers.cloudflare.com/dns/). |\n| 7 | Signature Expired | `EDE: 7 (Signature Expired): (for DNSKEY example.com., id = 12345: RRSIG example.com., expiration = 123456)` | This domain did not pass DNSSEC validation due to an expired signature. Make sure your zone is signed with valid [DNSSEC signatures](https://developers.cloudflare.com/dns/dnssec/troubleshooting/). |\n| 8 | Signature Not Yet Valid | `EDE: 8 (Signature Not Yet Valid): (for DNSKEY example.com., id = 12345: RRSIG example.com., inception = 12345)` | This domain did not pass DNSSEC validation. Make sure your zone is signed with valid [DNSSEC signatures](https://developers.cloudflare.com/dns/dnssec/troubleshooting/). |\n| 9 | DNSKEY Missing | `EDE: 9 (DNSKEY Missing): (no SEP matching the DS found for example.com.)` | This domain did not pass DNSSEC validation. It does not have a SEP DNSKEY that matches the set of DS records at the registry. Make sure to either sign the zone using keys that match the current DS set, or [add the missing DS records](https://developers.cloudflare.com/dns/dnssec/) with your registrar. |\n| 10 | RRSIGs Missing | `EDE: 10 (RRSIGs Missing): (for DNSKEY example.com., id = 12345)` | 1.1.1.1 was unable to retrieve Resource Record Signatures (RRSigs) to verify the authenticity of the records. Check your [DNS configuration](https://developers.cloudflare.com/dns/) and the response code. If the response code is not `SERVFAIL`, this error indicates that there is a non-operational key issue somewhere along the path, but the resolver found at least one successful path for validation. Examples of non-operational key issues include but are not limited to key rollover in-progress, stand-by key, and attacker stripping signatures made by a certain key. |\n| 11 | No Zone Key Bit Set | `EDE: 11 (No Zone Key Bit Set): (for DNSKEY example.com., id = 12345)` | This domain did not pass DNSSEC validation. The zone's SEP DNSKEY must [set a Zone Key flag](https://datatracker.ietf.org/doc/html/rfc4035#section-5.3.1). Check your [DNSSEC configuration](https://developers.cloudflare.com/dns/dnssec/) or DNSSEC's [troubleshooting guide](https://developers.cloudflare.com/dns/dnssec/troubleshooting/). |\n| 12 | NSEC Missing | `EDE: 12 (NSEC Missing): failed to verify an insecure referral proof for example.com` | This domain did not pass DNSSEC validation. The upstream nameserver did not include a valid proof of non-existence for the target name. Make sure the zone is [signed with DNSSEC](https://developers.cloudflare.com/dns/dnssec/troubleshooting/) and has valid [NSEC/NSEC3 records](https://www.cloudflare.com/dns/dnssec/dnssec-complexities-and-considerations/). |\n| 13 | Cached Error | `EDE: 13 (Cached Error)` | 1.1.1.1 returned a cached error. If this issue persists, reach out to the [community forum](https://community.cloudflare.com/c/reliability/dns-1111/47). |\n| 22 | No Reachable Authority | `EDE: 22 (No Reachable Authority): (at delegation example.com.)` | 1.1.1.1 could not reach some or all of the authoritative nameservers (or they potentially refused to resolve). This can occur if the authoritative nameservers are overloaded or temporarily unavailable. If this issue persists, reach out to the [community forum](https://community.cloudflare.com/c/reliability/dns-1111/47). |\n| 23 | Network Error | `EDE: 23 (Network Error): (1.1.1.1:53 rcode=SERVFAIL for example.com. A)` | 1.1.1.1 could not determine a network path to the upstream nameservers, or the nameserver did not respond. If this issue persists, reach out to the [community forum](https://community.cloudflare.com/c/reliability/dns-1111/47). |\n| 30 | Invalid Query Type | `EDE: 30 (Invalid Query Type): Invalid Query Type` | The record type in the request cannot give a valid answer. If this is returned for standard query types, such as A or AAAA records, please reach out to the [community forum](https://community.cloudflare.com/c/reliability/dns-1111/47). |\n\n<page>\n---\ntitle: Support for IPv6-only networks · Cloudflare 1.1.1.1 docs\ndescription: While network infrastructure is shifting towards IPv6-only\n  networks, providers still need to support IPv4 addresses. Dual-stack networks\n  are networks in which all nodes have both IPv4 and IPv6 connectivity\n  capabilities, and can therefore understand both IPv4 and IPv6 packets.\nlastUpdated: 2025-08-15T20:11:52.000Z\nchatbotDeprioritize: false\ntags: IPv6\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/infrastructure/ipv6-networks/\n  md: https://developers.cloudflare.com/1.1.1.1/infrastructure/ipv6-networks/index.md\n---\n\nWhile network infrastructure is shifting towards IPv6-only networks, providers still need to support IPv4 addresses. Dual-stack networks are networks in which all nodes have both IPv4 and IPv6 connectivity capabilities, and can therefore understand both IPv4 and IPv6 packets.\n\n1.1.1.1 supports DNS64, a mechanism that synthesizes AAAA records from A records when no AAAA records exist. DNS64 allows configuring a DNS resolver to synthesize IPv6 addresses from IPv4 answers.\n\nYou should only enable DNS64 if you are managing or using an IPv6-only network. While the resolver can synthesize IPv6 addresses, it cannot synthesize their record signatures for domains using DNSSEC, so a DNS client that is able to revalidate signatures would reject these extra records without signatures.\n\nA good tradeoff is to use a secure protocol such as DNS over TLS, or DNS over HTTPS between the client and the resolver to prevent tampering.\n\nDNS64 is specifically for networks that already have NAT64 support. If you are a network operator who has NAT64, you can test our DNS64 support by updating it to the following IP addresses:\n\nSome devices use separate fields for all eight parts of IPv6 addresses and cannot accept the `::` IPv6 abbreviation syntax. For such fields enter:\n\nAfter your configuration, visit an IPv4 only address to check if you can reach it. For example, you can visit <https://ipv4.google.com>.\n\nVisit <http://test-ipv6.com/> to test if it can detect your IPv6 address. If you receive a `10/10`, your IPv6 is configured correctly.\n\n<page>\n---\ntitle: Network operators · Cloudflare 1.1.1.1 docs\ndescription: Network operators, including Internet Service Providers (ISPs),\n  device manufacturers, public Wi-Fi networks, municipal broadband providers,\n  and security scanning services can use 1.1.1.1 in place of operating their own\n  recursive DNS infrastructure.\nlastUpdated: 2025-12-18T10:25:22.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/infrastructure/network-operators/\n  md: https://developers.cloudflare.com/1.1.1.1/infrastructure/network-operators/index.md\n---\n\nNetwork operators, including Internet Service Providers (ISPs), device manufacturers, public Wi-Fi networks, municipal broadband providers, and security scanning services can use [1.1.1.1](https://developers.cloudflare.com/1.1.1.1/setup/) in place of operating their own recursive DNS infrastructure.\n\nCloudflare also partners with ISPs and network equipment providers to make [1.1.1.1 for Families](https://developers.cloudflare.com/1.1.1.1/setup/#1111-for-families) available within their offerings. Refer to our [blog post](https://blog.cloudflare.com/safer-resolver/) for details.\n\nUsing 1.1.1.1 can improve performance for end-users due to Cloudflare's extensive [global network](https://www.cloudflare.com/network/), as well as provide higher overall cache hit rates due to our regional caches.\n\nThe 1.1.1.1 resolver was designed with a privacy-first approach. Refer to our [data and privacy policies](https://developers.cloudflare.com/1.1.1.1/privacy/public-dns-resolver/) for what is logged and retained by 1.1.1.1.\n\n## Configuring 1.1.1.1\n\nThere are multiple ways to use 1.1.1.1 as an operator:\n\n* Including a [DNS over HTTPS](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-https/) or [DNS over TLS](https://developers.cloudflare.com/1.1.1.1/encryption/dns-over-tls/) proxy on end-user routers or devices (best for privacy).\n* Pushing 1.1.1.1 to devices via DHCP/PPP within an operator network (recommended; most practical).\n* Having a DNS proxy on a edge router make requests to 1.1.1.1 on behalf of all connected devices.\n\nWhere possible, we recommend using encrypted transports (DNS over HTTPS or TLS) for queries, as this provides the highest degree of privacy for users over last-mile networks.\n\n## Available Endpoints\n\n[Cloudflare Zero Trust](https://www.cloudflare.com/products/zero-trust/) supports customizable [DNS policies](https://developers.cloudflare.com/cloudflare-one/traffic-policies/dns-policies/), analytics, additional built-in filtering categories, and custom rate limiting capabilities.\n\nIf you require additional controls over our public 1.1.1.1 resolver, [contact us](https://www.cloudflare.com/products/zero-trust/).\n\nThe publicly available endpoints for 1.1.1.1 are detailed in the following table:\n\n| Resolver | IPv4 address | IPv6 address | DNS over HTTPS endpoint | DNS over TLS endpoint |\n| - | - | - | - | - |\n| 1.1.1.1 (unfiltered) | `1.1.1.1` `1.0.0.1` | `2606:4700:4700::1111` `2606:4700:4700::1001` | `https://cloudflare-dns.com/dns-query` | `one.one.one.one` |\n| Families (Malware) | `1.1.1.2` `1.0.0.2` | `2606:4700:4700::1112` `2606:4700:4700::1002` | `https://security.cloudflare-dns.com/dns-query` | `security.cloudflare-dns.com` |\n| Families (Adult Content + Malware) | `1.1.1.3` `1.0.0.3` | `2606:4700:4700::1113` `2606:4700:4700::1003` | `https://family.cloudflare-dns.com/dns-query` | `family.cloudflare-dns.com` |\n\nYou may wish to provide end users with options to change from the default 1.1.1.1 resolver to one of the [1.1.1.1 for Families](https://developers.cloudflare.com/1.1.1.1/setup/#1111-for-families) endpoints.\n\nOperators using 1.1.1.1 for typical Internet-facing applications and/or users should not encounter any rate limiting for their users. In some rare cases, security scanning use-cases or proxied traffic may be rate limited to protect our infrastructure as well as upstream DNS infrastructure from potential abuse.\n\nBest practices include:\n\n* Avoiding tunneling or proxying all queries from a single IP address at high rates. Distributing queries across multiple public IPs will improve this without impacting cache hit rates (caches are regional).\n* A high rate of \"uncacheable\" responses (such as `SERVFAIL`) against the same domain may be rate limited to protect upstream, authoritative nameservers. Many authoritative nameservers enforce their own rate limits, and we strive to avoid overloading third party infrastructure where possible.\n\nIf you are a network operator and still have outstanding questions, contact `resolver@cloudflare.com` with your use case, so it can be discussed further. Make sure to visit [1.1.1.1/help](https://one.one.one.one/help) from within your network and share the resulting report when contacting Cloudflare.\n\n<page>\n---\ntitle: SLA and technical support · Cloudflare 1.1.1.1 docs\ndescription: As you use 1.1.1.1 in your infrastructure or service, note that\n  dedicated technical support is limited.\nlastUpdated: 2025-10-22T21:11:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/infrastructure/sla-and-support/\n  md: https://developers.cloudflare.com/1.1.1.1/infrastructure/sla-and-support/index.md\n---\n\nAs you use 1.1.1.1 in your infrastructure or service, note that dedicated technical support is limited.\n\nYou are subject to the [Cloudflare Website and Online Services Terms of Use](https://www.cloudflare.com/website-terms/) and no service level agreements (SLAs) are provided.\n\nIf you need SLAs and dedicated support, consider using [Cloudflare Gateway](https://developers.cloudflare.com/cloudflare-one/traffic-policies/) instead.\n\nGateway includes other advanced options such as domain categories, customized filtering, and scheduling capabilities. For example, if you are a device manufacturer or network operator, you can use a multi-tenant environment to allow your customers to configure their own individual filters.\n\n<page>\n---\ntitle: Cloudflare Resolver for Firefox · Cloudflare 1.1.1.1 docs\ndescription: Every time you type a web address, such as www.mozilla.org or\n  www.firefox.com, into a web browser, the web browser sends a query to a DNS\n  resolver. If DNS is like the card catalog of the Internet, then a DNS resolver\n  is like a helpful librarian that knows how to use the information from that\n  catalog to track down the exact location of a website. Whenever a resolver\n  receives your query it looks up the IP address associated with the web address\n  that you entered and relays that information to your web browser. “DNS\n  resolution” as this process is referred to, is a crucial component of your\n  Internet experience because without it your web browser would be unable to\n  communicate with the servers that host your favorite websites, since\n  communication requires knowing the IP addresses of those websites.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/privacy/cloudflare-resolver-firefox/\n  md: https://developers.cloudflare.com/1.1.1.1/privacy/cloudflare-resolver-firefox/index.md\n---\n\n## Frequently asked questions about the Cloudflare resolver for Firefox\n\n### What is the Cloudflare resolver for Firefox?\n\nEvery time you type a web address, such as [www.mozilla.org](http://www.mozilla.org) or [www.firefox.com](http://www.firefox.com), into a web browser, the web browser sends a query to a DNS resolver. If DNS is like the card catalog of the Internet, then a DNS resolver is like a helpful librarian that knows how to use the information from that catalog to track down the exact location of a website. Whenever a resolver receives your query it looks up the IP address associated with the web address that you entered and relays that information to your web browser. “DNS resolution” as this process is referred to, is a crucial component of your Internet experience because without it your web browser would be unable to communicate with the servers that host your favorite websites, since communication requires knowing the IP addresses of those websites.\n\nFor most Internet users, the DNS resolver that they use is either the one that comes with the operating system running on their machines or the one that is set by their network provider. In some cases, these resolvers leave a lot to be desired because of their susceptibility to unwanted spying and other security threats.\n\nTo counter such threats, Mozilla has partnered with Cloudflare to provide direct DNS resolution from within the Firefox browser using the Cloudflare Resolver for Firefox. What this means is that whenever you select or type a web address in the Firefox browser your DNS lookup request will be sent over a secure channel to the Cloudflare Resolver for Firefox rather than to an unknown DNS resolver, significantly decreasing the odds of any unwanted spying or man in the middle attacks.\n\n### What information does the Cloudflare resolver for Firefox collect?\n\nAny data Cloudflare handles as a result of its resolver for Firefox is as a data processor acting pursuant to Firefox’s data processing instructions. Therefore, the data Cloudflare collects and processes pursuant to its agreement with Firefox is not covered by the [Cloudflare Privacy Policy](https://www.cloudflare.com/privacypolicy/). As part of its agreement with Firefox, Cloudflare has agreed to collect only a limited amount of data about the DNS requests that are sent to the Cloudflare Resolver for Firefox via the Firefox browser. Cloudflare will collect only the following information from Firefox users:\n\n* date\n* dateTime\n* srcAsNum\n* srcIPVersion\n* dstIPVersion\n* dstIPv6\n* dstIPv4\n* dstPort\n* protocol\n* queryName\n* queryType\n* queryClass\n* queryRd\n* queryDo\n* querySize\n* queryEdns\n* ednsVersion\n* ednsPayload\n* ednsNsid\n* responseType\n* responseCode\n* responseSize\n* responseCount\n* responseTimeMs\n* responseCached\n* responseMinTTL\n* answerData type\n* answerData\n* validationState\n* coloID (unique Cloudflare data center ID)\n* metalId (unique Cloudflare data center ID)\n\nAll of the above information will be stored briefly as part of Cloudflare’s temporary logs, and then permanently deleted within 24 hours of Cloudflare’s receipt of such information. In addition to the above information, Cloudflare will also collect and store the following information as part of its permanent logs.\n\n* Total number of requests processed by each Cloudflare co-location facility.\n* Aggregate list of all domain names requested.\n* Samples of domain names queried along with the times of such queries.\n\nInformation stored in Cloudflare’s permanent logs will be anonymized and may be held indefinitely by Cloudflare for its own internal research and development purposes.\n\n### What is the Cloudflare promise?\n\nCloudflare understands how important your data is to you, which is why we promise to use the information that we collect from the Cloudflare Resolver for Firefox solely to improve the performance of Cloudflare Resolver for Firefox and to assist us in debugging efforts if an issue arises. In addition to limiting our collection and use of your data, Cloudflare also promises:\n\n* Cloudflare will not retain or sell or transfer to any third party (except as may be required by law) any personal information, IP addresses or other user identifiers from the DNS queries sent from the Firefox browser to the Cloudflare Resolver for Firefox;\n\n* Cloudflare will not combine the data that it collects from such queries, with any other Cloudflare or third party data in any way that can be used to identify individual end users;\n\n* Cloudflare will not sell, license, sublicense, or grant any rights to your data to any other person or entity without Mozilla’s explicit written permission.\n\n### What about government requests for content blocking?\n\nCloudflare does not block or filter content through the Cloudflare Resolver for Firefox. As part of its agreement with Mozilla, Cloudflare is providing only direct DNS resolution. If Cloudflare were to receive written requests from law enforcement and government agencies to block access to domains or content through the Cloudflare resolver for Firefox, Cloudflare would, in consultation with Mozilla, exhaust our legal remedies before complying with such a request. We also commit to documenting any government request to block access in our semi-annual transparency report, unless legally prohibited from doing so.\n\n<page>\n---\ntitle: 1.1.1.1 Public DNS Resolver · Cloudflare 1.1.1.1 docs\ndescription: Learn more about Cloudflare's commitment to privacy with the\n  1.1.1.1 Public DNS Resolver.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/privacy/public-dns-resolver/\n  md: https://developers.cloudflare.com/1.1.1.1/privacy/public-dns-resolver/index.md\n---\n\n*Last updated March 27, 2024*\n\n## Cloudflare’s commitment to privacy: 1.1.1.1 Public DNS Resolver\n\nThe 1.1.1.1 public DNS resolver is governed by our [Privacy Policy](https://www.cloudflare.com/privacypolicy/). This document provides additional details on our collection, use, and disclosure of the information collected from the 1.1.1.1 public DNS resolver.\n\nNearly everything on the Internet starts with a DNS request. DNS is the Internet’s directory. Select a link, open an app, send an email, and the first thing your phone or computer does is ask its directory: where can I find this?\n\nUnfortunately, by default, DNS is usually slow and insecure. Your ISP, and anyone else listening in on the Internet, can see every site you visit and every app you use — even if their content is encrypted. Creepily, some DNS providers sell data about your Internet activity or use it to target you with ads.\n\nGiven the current state of affairs, Cloudflare created a DNS resolver with your privacy and security in mind. Cloudflare, in partnership with APNIC, runs the 1.1.1.1 public resolver, a recursive DNS service that values user privacy and security. DNS requests sent to our public resolver can be sent over a secure channel, significantly decreasing the odds of any unwanted spying or man in the middle attacks.\n\nThe 1.1.1.1 public DNS resolver was designed for privacy first, and Cloudflare commits to the following:\n\n1. Cloudflare will not sell or share Public Resolver users’ personal data with third parties or use personal data from the Public Resolver to target any user with advertisements.\n2. Cloudflare will only retain or use what is being asked, not information that will identify who is asking it. Except for randomly sampled network packets captured from at most 0.05% of all traffic sent to Cloudflare’s network infrastructure, Cloudflare will not retain the source IP from DNS queries to the Public Resolver in non-volatile storage. These randomly sampled packets are solely used for network troubleshooting and DoS mitigation purposes.\n3. A Public Resolver user’s IP address (referred to as the client or source IP address) will not be stored in non-volatile storage. Cloudflare will anonymize source IP addresses via IP truncation methods (last octet for IPv4 and last 80 bits for IPv6). Cloudflare will delete the truncated IP address within 25 hours.\n4. Cloudflare will retain only the limited transaction and debug log data (“Public Resolver Logs”) set forth below, for the legitimate operation of our Public Resolver and research purposes, and Cloudflare will delete the Public Resolver Logs within 25 hours.\n5. Cloudflare will not share the Public Resolver Logs with any third parties except for APNIC pursuant to a Research Cooperative Agreement. APNIC will only have limited access to query the anonymized data in the Public Resolver Logs and conduct research related to the operation of the DNS system.\n\nCloudflare has taken technical steps to ensure that we cannot retain our user’s information.\n\nWe have also retained one of the top four accounting firms to audit our practices and publish a public report confirming we are doing what we said we would. The report is available in the [Certifications and compliance resources](https://www.cloudflare.com/trust-hub/compliance-resources/) page.\n\n## Limited data sharing with APNIC\n\nCloudflare has partnered with [APNIC Labs](https://labs.apnic.net/?p=1127), the regional Internet registry for the Asia-Pacific region to make the 1.1.1.1 IP address the home of the Cloudflare Public DNS Resolver. As part of its mission to ensure a global, open and secure Internet, APNIC conducts research about the functioning and governance of the Internet, which it makes available on its website, located at [www.apnic.net](http://www.apnic.net).\n\nCloudflare has agreed to provide APNIC with access to some of the anonymized data that Cloudflare collects through the Cloudflare Public DNS Resolver. Specifically, APNIC will be permitted to access query names, query types, resolver location and other metadata via a Cloudflare API that will allow APNIC to study topics like the volume of DDoS attacks launched on the Internet and adoption of IPv6.\n\nAPNIC Labs will use such data for non-profit operational research. As part of Cloudflare’s commitment to privacy, Cloudflare will not provide APNIC with any access to the IP address associated with a client.\n\nAside from APNIC, Cloudflare will not share the Public Resolver Logs with any third party.\n\n## Data in public resolver logs\n\nThe Public Resolver Logs we store consist entirely of the following fields:\n\n* answerData type\n* answerData\n* coloID (unique Cloudflare data center ID)\n* date\n* dateTime\n* dstIPVersion\n* dstIPv6\n* dstIPv4\n* dstPort\n* ede\n* ednsVersion\n* ednsPayload\n* ednsNsid\n* feature.uid\n* feature.value\n* metalId (unique Cloudflare data center ID)\n* ns ip\n* ns name\n* protocol\n* queryName\n* queryType\n* queryClass\n* queryRd\n* queryDo\n* querySize\n* queryEdns\n* queryCd\n* responseType\n* responseCode\n* responseSize\n* responseCount\n* responseTimeMs\n* responseCached\n* responseMinTTL\n* reused\n* srcAsNum\n* srcCountry\n* srcIPVersion\n* validationState\n\nAdditionally, recursive resolvers perform outgoing queries to various authoritative nameservers in the DNS hierarchy that are logged in subrequest fields. These logs are used for the operation and debugging of our public DNS resolver service.\n\nThe following subrequest data is included in the Public Resolver Logs:\n\n* subrequest.ipv6 (authoritative nameserver)\n* subrequest.ipv4 (authoritative nameserver)\n* subrequest.protocol\n* subrequest.durationMs\n* subrequest.queryName\n* subrequest.queryType\n* subrequest.responseCode\n* subrequest.responseCount\n* subrequest.recordType\n* subrequest.recordData\n* subrequest.error\n\nExcept for the limited sampled data from the Public Resolver Logs (which do not include truncated IP addresses) used to generate the aggregated data described below, all of the Public Resolver Logs are deleted within 25 hours of Cloudflare’s receipt of such information.\n\nCloudflare may make the following aggregations:\n\n* Total number of queries with different protocol settings (for example, tcp/udp/dnssec) by Cloudflare data centers.\n* Response code/time quantiles with different protocol settings by Cloudflare data centers.\n* Total Number of Requests Processed by Cloudflare data centers.\n* Aggregate List of All Domain Names Requested and aggregate number of requests and timestamp of first time requested by region.\n* Number of unique clients, queries over IPv4, queries over IPv6, queries with the RD bit set, queries asking for DNSSEC, number of bogus, valid, and invalid DNSSEC answers, queries by type, number of answers with each response code, response time quantiles (e.g. 50 percentile), response TTL, and number of cached answers per minute, per day, per protocol (HTTPS/UDP/TCP/TLS), per region, per Cloudflare data center, and per Autonomous System Number.\n* Number of queries, number of queries with EDNS, number of bytes and time in answers quantiles (e.g. 50 percentile) by day, month, Cloudflare data center, and by IPv4 vs IPv6.\n* Number of queries, response codes and response code quantiles (e.g. 50 percentile) by day, region, name and type.\n\nCloudflare may store the data described above indefinitely in order to power Cloudflare Radar and assist Cloudflare in improving Cloudflare services, such as, enhancing the overall performance of the Cloudflare Resolver and identifying security threats.\n\n## What about requests for content blocking?\n\nCloudflare does not block or filter any content through the 1.1.1.1 Public DNS Resolver, which is designed for direct, fast DNS resolution, not for blocking or filtering content. Cloudflare does block and filter malware and adult content through 1.1.1.1 for Families, which is designed to help individuals protect their home networks.\n\nIn general, Cloudflare views government or civil requests to block content at the DNS level as ineffective, inefficient, and overboard. Because such a block would apply globally to all users of the resolver, regardless of where they are located, it would affect end users outside of the blocking government’s jurisdiction. A government request to block content through a globally available public recursive resolver like the 1.1.1.1 Public DNS Resolver and 1.1.1.1 for Families should therefore be evaluated as a request to block content globally.\n\nGiven the broad extraterritorial effect, if Cloudflare were to receive written requests from law enforcement and government agencies to block access to domains or content through the 1.1.1.1 Public DNS Resolver or to block access to domains or content through 1.1.1.1 for Families that is outside the scope of the filtering in that product, Cloudflare would pursue its legal remedies before complying with such a request. We also commit to documenting any government request to block access in our semi-annual transparency report, unless legally prohibited from doing so.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on Android · Cloudflare 1.1.1.1 docs\ndescription: Learn how to set up Cloudflare's 1.1.1.1 DNS resolver on Android\n  devices. Encrypt DNS queries with DoT or DoH, and enable 1.1.1.1 for Families.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/android/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/android/index.md\n---\n\n[1.1.1.1: Faster Internet](https://play.google.com/store/apps/details?id=com.cloudflare.onedotonedotonedotone) is the preferred method of setting up 1.1.1.1 DNS resolver and 1.1.1.1 for Families. It allows you to automatically configure your phone to use 1.1.1.1 on any network you connect to.\n\nThe app also allows you to enable encryption for DNS queries or enable [WARP mode](https://developers.cloudflare.com/warp-client/), which keeps all your HTTP traffic private and secure, including your DNS queries to 1.1.1.1.\n\nYou can select between the options available in the app settings. By default, 1.1.1.1: Faster Internet is configured to WARP mode.\n\n## Set up 1.1.1.1: Faster Internet\n\n1. Download [1.1.1.1: Faster Internet from Google Play](https://play.google.com/store/apps/details?id=com.cloudflare.onedotonedotonedotone) for free.\n2. Launch 1.1.1.1: Faster Internet and accept the Terms of Service.\n3. Toggle the **WARP** button to **Connected**.\n4. Install the VPN profile that allows your phone to connect securely to 1.1.1.1.\n\nYour connection to the Internet and your DNS queries are now protected.\n\n### Enable 1.1.1.1 for Families\n\n1. Open 1.1.1.1: Faster Internet.\n2. Tap the **menu button**.\n3. Select **Advanced** > **Connection options**.\n4. In **DNS settings** > **1.1.1.1 for Families**, select the option you want to use.\n\n## Configure 1.1.1.1 manually\n\n### Android 11 or later\n\nAndroid 11 or later versions support both DNS over TLS (DoT) and DNS over HTTPS (DoH).\n\n1. Go to **Settings** > **Network & internet**.\n2. Select **Advanced** > **Private DNS**.\n3. Select the **Private DNS provider hostname** option.\n4. Depending on what you want to configure, use one of the following DNS hostnames or [IP addresses](https://developers.cloudflare.com/1.1.1.1/ip-addresses/) and select **Save**.\n\nOr the corresponding IP address if your device requires it:\n\n* **IPv4**: `1.1.1.1` or `1.0.0.1`\n* **IPv6**: `2606:4700:4700::1111` or `2606:4700:4700::1001`\n\nBlock malware with 1.1.1.1 for Families\n\n* `security.cloudflare-dns.com`\n\nOr the corresponding IP address if your device requires it:\n\n* **IPv4**: `1.1.1.2` or `1.0.0.2`\n* **IPv6**: `2606:4700:4700::1112` or `2606:4700:4700::1002`\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n* `family.cloudflare-dns.com`\n\nOr the corresponding IP address if your device requires it:\n\n* **IPv4**: `1.1.1.3` or `1.0.0.3`\n* **IPv6**: `2606:4700:4700::1113` or `2606:4700:4700::1003`\n\nAndroid 9 and Android 10 support DNS over TLS to secure your queries through encryption. In Android, this option is called Private DNS. It prevents your queries from being tracked, modified or surveilled by third-parties. Unlike previous versions of Android, this method also ensures 1.1.1.1 does not need to be configured for each new Wi-Fi network your smartphone joins.\n\n1. Go to **Settings** > **Network & internet**.\n2. Select **Advanced** > **Private DNS**.\n3. Select the **Private DNS provider hostname** option.\n4. Enter `one.one.one.one` and select **Save**. Or consider the following options if you want to use 1.1.1.1 for Families.\n\nBlock malware with 1.1.1.1 for Families\n\n* `security.cloudflare-dns.com`\n\nOr the corresponding IP address if your device requires it:\n\n* **IPv4**: `1.1.1.2` or `1.0.0.2`\n* **IPv6**: `2606:4700:4700::1112` or `2606:4700:4700::1002`\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n* `family.cloudflare-dns.com`\n\nOr the corresponding IP address if your device requires it:\n\n* **IPv4**: `1.1.1.3` or `1.0.0.3`\n* **IPv6**: `2606:4700:4700::1113` or `2606:4700:4700::1003`\n\n### Previous Android versions\n\nBefore making changes, take note of any DNS addresses you might have and save them in a safe place in case you need to use them later.\n\n1. Open **Settings** > **Wi-Fi**.\n\n2. Press down and hold the name of the network you are currently connected to.\n\n3. Select **Modify Network**.\n\n4. Select the checkbox **Show Advanced Options**.\n\n5. Change the IP Settings to **Static**.\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n7. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n8. Select **Save**. You may need to disconnect from the Wi-Fi and reconnect for the changes to take place.\n\nSetting up a static IP address to configure a DNS server may prevent you from connecting to some public Wi-Fi networks that use captive portals — these are the web pages some wireless networks employ to let users log in and use their services.\n\nIf you are experiencing connectivity issues related to captive portals:\n\n1. Remove the static IP addresses from the device or disable the 1.1.1.1 app.\n2. Connect to the Wi-Fi network.\n3. Once the connection has been established, re-add the static IP addresses or enable the 1.1.1.1 app.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on Azure · Cloudflare 1.1.1.1 docs\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/azure/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/azure/index.md\n---\n\n1. Log in to your Azure portal.\n\n2. From the Azure portal side menu, select **Virtual Networks**.\n\n3. Navigate to the virtual network associated with your virtual machine (VM).\n\n4. Select **DNS Servers** > **Custom**, and add two entries:\n\n<page>\n---\ntitle: Set up 1.1.1.1 on gaming consoles · Cloudflare 1.1.1.1 docs\ndescription: The following instructions work on New Nintendo 3DS, New Nintendo\n  3DS XL, New Nintendo 2DS XL, Nintendo 3DS, Nintendo 3DS XL, and Nintendo 2DS.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/gaming-consoles/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/gaming-consoles/index.md\n---\n\n1. Go to **Settings** > **Network** > **Set Up Internet Connection**.\n\n2. Select **Wi-Fi** or **LAN** depending on your Internet connection.\n\n3. Select **Custom**.\n\n4. Set **IP Address Settings** to **Automatic**.\n\n5. Change **DHCP Host Name** to **Do Not Specify**.\n\n6. Set **DNS Settings** to **Manual**.\n\n7. Change **Primary DNS** and **Secondary DNS** to:\n\n8. If you are able to add more DNS servers, you can add the IPv6 addresses as well:\n\n9. Set **MTU Settings** to **Automatic**.\n\n10. Set **Proxy Server** to **Do Not Use**.\n\n1. Open the Network screen by pressing the Xbox button on your controller.\n\n2. Go to **Settings** > **Network** > **Network Settings**.\n\n3. Next, go to **Advanced Settings** > **DNS Settings**.\n\n4. Select **Manual**.\n\n5. Set **Primary DNS** and **Secondary DNS** to:\n\n6. If you have the option to add more DNS servers, you can add the IPv6 addresses as well:\n\n7. When you are done, you will be shown a confirmation screen. Press **B** to save.\n\nThe following instructions work on New Nintendo 3DS, New Nintendo 3DS XL, New Nintendo 2DS XL, Nintendo 3DS, Nintendo 3DS XL, and Nintendo 2DS.\n\n1. Go to the home menu and choose **System Settings** (the wrench icon).\n\n2. Select **Internet Settings** > **Connection Settings**.\n\n3. Select your Internet connection and then select **Change Settings**.\n\n4. Select **Change DNS**.\n\n5. Set **Auto-Obtain DNS** to **No**.\n\n6. Select **Detailed Setup**.\n\n7. Set **Primary DNS** and **Secondary DNS** to:\n\n8. If you are able to add more DNS servers, you can add the IPv6 addresses as well:\n\n9. Select **Save** > **OK**.\n\n1. Press the home button and select **System Settings**.\n\n2. Scroll down and select **Internet** > **Internet Settings**.\n\n3. Select your Internet connection and then select **Change Settings**.\n\n4. Select **DNS Settings** > **Manual**.\n\n5. Set **Primary DNS** and **Secondary DNS** to:\n\n6. Select **Save** > **OK**.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on Google Cloud · Cloudflare 1.1.1.1 docs\ndescription: Google Cloud supports configuring outbound server policy within\n  Cloud DNS. Policies are applied per Virtual Private Cloud (VPC) network, and\n  will affect all resources within that VPC network, including any existing\n  virtual machines.\nlastUpdated: 2025-11-21T18:29:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/google-cloud/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/google-cloud/index.md\n---\n\nGoogle Cloud supports configuring [outbound server policy](https://cloud.google.com/dns/docs/server-policies-overview#dns-server-policy-out) within Cloud DNS. Policies are applied per Virtual Private Cloud (VPC) network, and will affect all resources within that VPC network, including any existing virtual machines.\n\nIf you are using [Cloudflare Zero Trust](https://developers.cloudflare.com/cloudflare-one/), you can choose assigned [locations](https://developers.cloudflare.com/cloudflare-one/networks/resolvers-and-proxies/dns/locations/) to apply custom [DNS policies](https://developers.cloudflare.com/cloudflare-one/traffic-policies/dns-policies/) via Gateway.\n\nTo configure 1.1.1.1 for your Google Cloud VPC network(s):\n\n1. Open the [Google Cloud Console](https://console.cloud.google.com).\n\n2. Navigate to **Network Services** > **Cloud DNS** and select [**DNS Server Policies**](https://console.cloud.google.com/net-services/dns/policies).\n\n3. Select **Create Policy**.\n\n4. Provide a name for your Policy (such as `cloudflare-1-1-1-1`) and select associated VPC network or networks.\n\n5. Under **Alternate DNS servers**, select **Add Item** and type:\n\n6. Select **Create**.\n\nDNS requests within the configured VPC network(s) will now use 1.1.1.1.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on iOS · Cloudflare 1.1.1.1 docs\ndescription: \"1.1.1.1: Faster Internet is the preferred method of setting up\n  1.1.1.1 DNS resolver and 1.1.1.1 for Families in iOS devices. It allows you to\n  automatically configure your phone to use 1.1.1.1 on any network you connect\n  to, and solves iOS inability of using an alternative DNS resolver in cellular\n  connections.\"\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/ios/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/ios/index.md\n---\n\n[1.1.1.1: Faster Internet](https://apps.apple.com/us/app/1-1-1-1-faster-internet/id1423538627) is the preferred method of setting up 1.1.1.1 DNS resolver and 1.1.1.1 for Families in iOS devices. It allows you to automatically configure your phone to use 1.1.1.1 on any network you connect to, and solves iOS inability of using an alternative DNS resolver in cellular connections.\n\nThe app also allows you to enable encryption for DNS queries or enable [WARP mode](https://developers.cloudflare.com/warp-client/), which keeps all your HTTP traffic private and secure, including your DNS queries to 1.1.1.1.\n\nYou can select between the options available in the app's settings. By default, 1.1.1.1: Faster Internet is configured to WARP mode.\n\n## Set up 1.1.1.1: Faster Internet\n\n1. Download [1.1.1.1: Faster Internet from the App Store](https://apps.apple.com/us/app/1-1-1-1-faster-internet/id1423538627) for free.\n2. Launch 1.1.1.1: Faster Internet and accept the Terms of Service.\n3. Install the VPN profile that allows your phone to connect securely to 1.1.1.1.\n4. Toggle the **WARP** button to **Connected**.\n\n### Enable 1.1.1.1 for Families\n\n1. Open 1.1.1.1: Faster Internet.\n2. Tap the **menu button**.\n3. Select **Advanced** > **Connection options**.\n4. In **DNS settings** > **1.1.1.1 for Families**, select the option you want to use.\n\n## Configure 1.1.1.1 manually\n\nIf you configure 1.1.1.1 manually, you will have to do it for every Wi-Fi network your device connects to. This method does not work for cellular connections.\n\nTake note of any DNS addresses you might have set up, and save them in a safe place in case you need to use them later.\n\n1. Go to **Settings** > **Wi-Fi**.\n\n2. Select the **'i'** icon next to the Wi-Fi network you are connected to.\n\n3. Scroll down and select **Configure DNS**.\n\n4. Change the configuration from **Automatic** to **Manual**.\n\n5. Select **Add Server**.\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n7. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\nSetting up a static IP address to configure a DNS server may prevent you from connecting to some public Wi-Fi networks that use captive portals — these are the web pages some wireless networks employ to let users log in and use their services.\n\nIf you are experiencing connectivity issues related to captive portals:\n\n1. Remove the static IP addresses from the device or disable the 1.1.1.1 app.\n2. Connect to the Wi-Fi network.\n3. Once the connection has been established, re-add the static IP addresses or enable the 1.1.1.1 app.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on Linux · Cloudflare 1.1.1.1 docs\ndescription: Learn how to set up 1.1.1.1 as your DNS resolver on a Linux system.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/linux/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/linux/index.md\n---\n\nBefore you begin, take note of any DNS addresses you might have set up, and save them in a safe place in case you need to use them later.\n\nConsider the sections below to set up 1.1.1.1 using either the [command line interface (CLI)](#use-command-line-interface-cli) or a [graphical user interface (GUI)](#use-graphical-user-interface-gui) of your preference.\n\n## Use command line interface (CLI)\n\nChoose whether you want to use 1.1.1.1 or 1.1.1.1 For Families, and replace `1.1.1.1` with the corresponding [IPv4 or IPv6 address](https://developers.cloudflare.com/1.1.1.1/ip-addresses/) accordingly.\n\nUsually, `/etc/resolv.conf` is where you can configure the resolver IPs that your system is using.\n\nIn that case, you can use the following one-line command to specify `1.1.1.1` as your DNS resolver and `1.0.0.1` as backup:\n\nNote that other systems, such as dynamic host configuration protocol (DHCP), may automatically write to `/etc/resolv.conf` and change that configuration. In those cases, consider changing your network settings or DHCP to use `1.1.1.1`.\n\nAlternatively, you can use an editor (`nano` or `vim`, for example) to manually edit the file.\n\n### `systemd-resolved`\n\nIf you use `systemd-resolved` utility and the resolver IPs configuration is in `/etc/systemd/resolved.conf`, consider the steps below:\n\n1. Run the following command, replacing `<EDITOR>` with your preferred editor.\n\n1. In the editor, add or edit the following lines:\n\nTo use DNS over TLS, add `#one.one.one.one` and set `DNSOverTLS` to `yes`, as in the following example:\n\n## Use graphical user interface (GUI)\n\n1. Go to **Show Applications** > **Settings** > **Network**.\n\n2. Select the adapter you want to configure — like your Ethernet adapter or Wi-Fi card — and select the **Settings** button.\n\n3. On the **IPv4** tab > **DNS** section, disable the **Automatic** toggle.\n\n4. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n1. Go to **System Settings** > **Wi-Fi & Internet** > **Wi-Fi & Networking**. (or **Connections**, if on Plasma 5)\n\n2. Select the connection you want to configure - like your current connected network.\n\n3. On the **IPv4** tab, select the **Method** drop-down menu > *Automatic (Only addresses)*.\n\n4. Select the text box next to **DNS servers**.\n\n5. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n6. On the **IPv6** tab, select the **Method** drop-down menu > *Automatic (Only addresses)*.\n\n7. Select the text box next to **DNS servers**.\n\n8. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\nSetting up a static IP address to configure a DNS server may prevent you from connecting to some public Wi-Fi networks that use captive portals — these are the web pages some wireless networks employ to let users log in and use their services.\n\nIf you are experiencing connectivity issues related to captive portals:\n\n1. Remove the static IP addresses from the device or disable the 1.1.1.1 app.\n2. Connect to the Wi-Fi network.\n3. Once the connection has been established, re-add the static IP addresses or enable the 1.1.1.1 app.\n\n<page>\n---\ntitle: Set up 1.1.1.1 on macOS · Cloudflare 1.1.1.1 docs\ndescription: Take note of any DNS addresses you might have set up, and save them\n  in a safe place in case you need to use them later.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/macos/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/macos/index.md\n---\n\nTake note of any DNS addresses you might have set up, and save them in a safe place in case you need to use them later.\n\n1. Go to **System Settings**. You can find it by pressing `CMD + Space` on your keyboard and typing `System Settings`.\n\n2. Go to **Network**.\n\n3. Select a network service.\n\n4. Select **Details**.\n\n6. Under **DNS Servers**, select **Add**.\n\n7. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n8. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\nSetting up a static IP address to configure a DNS server may prevent you from connecting to some public Wi-Fi networks that use captive portals — these are the web pages some wireless networks employ to let users log in and use their services.\n\nIf you are experiencing connectivity issues related to captive portals:\n\n1. Remove the static IP addresses from the device or disable the 1.1.1.1 app.\n2. Connect to the Wi-Fi network.\n3. Once the connection has been established, re-add the static IP addresses or enable the 1.1.1.1 app.\n\n## Encrypt your DNS queries\n\n1.1.1.1 supports DNS over TLS (DoT) and DNS over HTTPS (DoH), two standards developed for encrypting plaintext DNS traffic. This prevents untrustworthy entities from interpreting and manipulating your queries. For more information on how to encrypt your DNS queries, please refer to the [Encrypted DNS documentation](https://developers.cloudflare.com/1.1.1.1/encryption/).\n\n<page>\n---\ntitle: Set up 1.1.1.1 on a router · Cloudflare 1.1.1.1 docs\ndescription: \"It is possible to encrypt DNS traffic out from your router using\n  DNS-over-TLS if it is running OpenWrt. For more details, see our blog post on\n  the topic: Adding DNS-Over-TLS support to OpenWrt (LEDE) with Unbound.\"\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/router/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/router/index.md\n---\n\n1. Go to the **IP address** used to access your router's admin console in your browser.\n\n* Linksys and Asus routers typically use `http://192.168.1.1` or `http://router.asus.com` (for ASUS).\n   * Netgear routers typically use `http://192.168.1.1` or `http://routerlogin.net`.\n   * D-Link routers typically use `http://192.168.0.1`.\n   * Ubiquiti routers typically use `http://unifi.ubnt.com`.\n\n2. Enter the router credentials. For consumer routers, the default credentials for the admin console are often found under or behind the device.\n\n3. In the admin console, find the place where **DNS settings** are set. This may be contained within categories such as **WAN** and **IPv6** (Asus Routers) or **Internet** (Netgear Routers). Consult your router's documentation for details.\n\n4. Take note of any DNS addresses that are currently set and save them in a safe place in case you need to use them later.\n\n5. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n7. Save the updated settings.\n\n## Using DNS-Over-TLS on OpenWrt\n\nIt is possible to encrypt DNS traffic out from your router using DNS-over-TLS if it is running OpenWrt. For more details, see our blog post on the topic: [Adding DNS-Over-TLS support to OpenWrt (LEDE) with Unbound](https://blog.cloudflare.com/dns-over-tls-for-openwrt/).\n\nStarting with [FRITZ!OS 7.20](https://en.avm.de/press/press-releases/2020/07/fritzos-720-more-performance-convenience-security/), DNS over TLS is supported, see [Configuring different DNS servers in the FRITZ!Box](https://en.avm.de/service/knowledge-base/dok/FRITZ-Box-7590/165_Configuring-different-DNS-servers-in-the-FRITZ-Box/).\n\n<page>\n---\ntitle: Set up 1.1.1.1 on Windows · Cloudflare 1.1.1.1 docs\ndescription: Take note of any DNS addresses you might have set up, and save them\n  in a safe place in case you need to use them later.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/1.1.1.1/setup/windows/\n  md: https://developers.cloudflare.com/1.1.1.1/setup/windows/index.md\n---\n\nTake note of any DNS addresses you might have set up, and save them in a safe place in case you need to use them later.\n\n1. Select the **Start menu** > **Settings**.\n\n2. On **Network and Internet**, select **Change Adapter Options**.\n\n3. Right-click on the Ethernet or Wi-Fi network you are connected to and select **Properties**.\n\n4. Choose **Internet Protocol Version 4**.\n\n5. Select **Properties** > **Use the following DNS server addresses**.\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n8. Go to **Internet Protocol Version 6**.\n\n9. Select **Properties** > **Use the following DNS server addresses**.\n\n10. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\nTake note of any DNS addresses you might have set up, and save them in a safe place in case you need to use them later.\n\n1. Select the **Start menu** > **Settings**.\n\n2. On **Network and Internet**, choose the adapter you want to configure - like your Ethernet adapter or Wi-Fi card.\n\n3. Scroll to **DNS server assignment** and select **Edit**.\n\n4. Select the **Automatic (DHCP)** drop-down menu > **Manual**.\n\n5. Select the **IPv4** toggle to turn it on.\n\n6. Depending on what you want to configure, choose one of the following DNS addresses for IPv4:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\n7. Select the **IPv6** toggle.\n\n8. Depending on what you want to configure, choose one of the following DNS addresses for IPv6:\n\nBlock malware with 1.1.1.1 for Families\n\nBlock malware and adult content with 1.1.1.1 for Families\n\nSetting up a static IP address to configure a DNS server may prevent you from connecting to some public Wi-Fi networks that use captive portals — these are the web pages some wireless networks employ to let users log in and use their services.\n\nIf you are experiencing connectivity issues related to captive portals:\n\n1. Remove the static IP addresses from the device or disable the 1.1.1.1 app.\n2. Connect to the Wi-Fi network.\n3. Once the connection has been established, re-add the static IP addresses or enable the 1.1.1.1 app.\n\n## Encrypt your DNS queries\n\n1.1.1.1 supports DNS over TLS (DoT) and DNS over HTTPS (DoH), two standards developed for encrypting plaintext DNS traffic. This prevents untrustworthy entities from interpreting and manipulating your queries. For more information on how to encrypt your DNS queries, please refer to the [Encrypted DNS documentation](https://developers.cloudflare.com/1.1.1.1/encryption/).\n\n<page>\n---\ntitle: BYOK (Store Keys) · Cloudflare AI Gateway docs\ndescription: Bring your own keys (BYOK) is a feature in Cloudflare AI Gateway\n  that allows you to securely store your AI provider API keys directly in the\n  Cloudflare dashboard. Instead of including API keys in every request to your\n  AI models, you can configure them once in the dashboard, and reference them in\n  your gateway configuration.\nlastUpdated: 2025-09-03T14:48:22.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/configuration/bring-your-own-keys/\n  md: https://developers.cloudflare.com/ai-gateway/configuration/bring-your-own-keys/index.md\n---\n\nBring your own keys (BYOK) is a feature in Cloudflare AI Gateway that allows you to securely store your AI provider API keys directly in the Cloudflare dashboard. Instead of including API keys in every request to your AI models, you can configure them once in the dashboard, and reference them in your gateway configuration.\n\nThe keys are stored securely with [Secrets Store](https://developers.cloudflare.com/secrets-store/) and allows for:\n\n* Secure storage and limit exposure\n* Easier key rotation\n* Rate limit, budget limit and other restrictions with [Dynamic Routes](https://developers.cloudflare.com/ai-gateway/features/dynamic-routing/)\n\n* Ensure your gateway is [authenticated](https://developers.cloudflare.com/ai-gateway/configuration/authentication/).\n* Ensure you have appropriate [permissions](https://developers.cloudflare.com/secrets-store/access-control/) to create and deploy secrets on Secrets Store.\n\n### Configure API keys\n\n1. Log into the [Cloudflare dashboard](https://dash.cloudflare.com/) and select your account.\n2. Go to **AI** > **AI Gateway**.\n3. Select your gateway or create a new one.\n4. Go to the **Provider Keys** section.\n5. Click **Add API Key**.\n6. Select your AI provider from the dropdown.\n7. Enter your API key and optionally provide a description.\n8. Click **Save**.\n\n### Update your applications\n\nOnce you've configured your API keys in the dashboard:\n\n1. **Remove API keys from your code**: Delete any hardcoded API keys or environment variables.\n2. **Update request headers**: Remove provider authorization headers from your requests. Note that you still need to pass `cf-aig-authorization`.\n3. **Test your integration**: Verify that requests work without including API keys.\n\nWith BYOK enabled, your workflow changes from:\n\n1. **Traditional approach**: Include API key in every request header\n\n2. **BYOK approach**: Configure key once in dashboard, make requests without exposing keys\n\n### Viewing configured keys\n\nIn the AI Gateway dashboard, you can:\n\n* View all configured API keys by provider\n* See when each key was last used\n* Check the status of each key (active, expired, invalid)\n\nTo rotate an API key:\n\n1. Generate a new API key from your AI provider\n2. In the Cloudflare dashboard, edit the existing key entry\n3. Replace the old key with the new one\n4. Save the changes\n\nYour applications will immediately start using the new key without any code changes or downtime.\n\nTo remove an API key:\n\n1. In the AI Gateway dashboard, find the key you want to remove\n2. Click the **Delete** button\n3. Confirm the deletion\n\nImpact of key deletion\n\nDeleting an API key will immediately stop all requests that depend on it. Make sure to update your applications or configure alternative keys before deletion.\n\n<page>\n---\ntitle: Authenticated Gateway · Cloudflare AI Gateway docs\ndescription: Add security by requiring a valid authorization token for each request.\nlastUpdated: 2025-10-07T18:26:33.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/configuration/authentication/\n  md: https://developers.cloudflare.com/ai-gateway/configuration/authentication/index.md\n---\n\nUsing an Authenticated Gateway in AI Gateway adds security by requiring a valid authorization token for each request. This feature is especially useful when storing logs, as it prevents unauthorized access and protects against invalid requests that can inflate log storage usage and make it harder to find the data you need. With Authenticated Gateway enabled, only requests with the correct token are processed.\n\nWe recommend enabling Authenticated Gateway when opting to store logs with AI Gateway.\n\nIf Authenticated Gateway is enabled but a request does not include the required `cf-aig-authorization` header, the request will fail. This setting ensures that only verified requests pass through the gateway. To bypass the need for the `cf-aig-authorization` header, make sure to disable Authenticated Gateway.\n\n## Setting up Authenticated Gateway using the Dashboard\n\n1. Go to the Settings for the specific gateway you want to enable authentication for.\n2. Select **Create authentication token** to generate a custom token with the required `Run` permissions. Be sure to securely save this token, as it will not be displayed again.\n3. Include the `cf-aig-authorization` header with your API token in each request for this gateway.\n4. Return to the settings page and toggle on Authenticated Gateway.\n\n## Example requests with OpenAI\n\nUsing the OpenAI SDK:\n\n## Example requests with the Vercel AI SDK\n\nWhen an AI Gateway is accessed from a Cloudflare Worker using a **binding**, the `cf-aig-authorization` header does not need to be manually included.\\\nRequests made through bindings are **pre-authenticated** within the associated Cloudflare account.\n\nThe following table outlines gateway behavior based on the authentication settings and header status:\n\n| Authentication Setting | Header Info | Gateway State | Response |\n| - | - | - | - |\n| On | Header present | Authenticated gateway | Request succeeds |\n| On | No header | Error | Request fails due to missing authorization |\n| Off | Header present | Unauthenticated gateway | Request succeeds |\n| Off | No header | Unauthenticated gateway | Request succeeds |\n\n<page>\n---\ntitle: Custom costs · Cloudflare AI Gateway docs\ndescription: Override default or public model costs on a per-request basis.\nlastUpdated: 2025-03-05T12:30:57.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/configuration/custom-costs/\n  md: https://developers.cloudflare.com/ai-gateway/configuration/custom-costs/index.md\n---\n\nAI Gateway allows you to set custom costs at the request level. By using this feature, the cost metrics can accurately reflect your unique pricing, overriding the default or public model costs.\n\nCustom costs will only apply to requests that pass tokens in their response. Requests without token information will not have costs calculated.\n\nTo add custom costs to your API requests, use the `cf-aig-custom-cost` header. This header enables you to specify the cost per token for both input (tokens sent) and output (tokens received).\n\n* **per\\_token\\_in**: The negotiated input token cost (per token).\n* **per\\_token\\_out**: The negotiated output token cost (per token).\n\nThere is no limit to the number of decimal places you can include, ensuring precise cost calculations, regardless of how small the values are.\n\nCustom costs will appear in the logs with an underline, making it easy to identify when custom pricing has been applied.\n\nIn this example, if you have a negotiated price of $1 per million input tokens and $2 per million output tokens, include the `cf-aig-custom-cost` header as shown below.\n\nIf a response is served from cache (cache hit), the cost is always `0`, even if you specified a custom cost. Custom costs only apply when the request reaches the model provider.\n\n<page>\n---\ntitle: Custom Providers · Cloudflare AI Gateway docs\ndescription: Create and manage custom AI providers for your account.\nlastUpdated: 2025-11-24T10:12:07.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/configuration/custom-providers/\n  md: https://developers.cloudflare.com/ai-gateway/configuration/custom-providers/index.md\n---\n\nCustom Providers allow you to integrate AI providers that are not natively supported by AI Gateway. This feature enables you to use AI Gateway's observability, caching, rate limiting, and other features with any AI provider that has an HTTPS API endpoint.\n\n* **Internal AI models**: Connect to your organization's self-hosted AI models\n* **Regional providers**: Integrate with AI providers specific to your region\n* **Specialized models**: Use domain-specific AI services not available through standard providers\n* **Custom endpoints**: Route requests to your own AI infrastructure\n\n* An active Cloudflare account with AI Gateway access\n* A valid API key from your custom AI provider\n* The HTTPS base URL for your provider's API\n\nThe API endpoints for creating, reading, updating, or deleting custom providers require authentication. You need to create a Cloudflare API token with the appropriate permissions.\n\nTo create an API token:\n\n1. Go to the [Cloudflare dashboard API tokens page](https://dash.cloudflare.com/?to=:account/api-tokens)\n2. Click **Create Token**\n3. Select **Custom Token** and add the following permissions:\n   * `AI Gateway - Edit`\n4. Click **Continue to summary** and then **Create Token**\n5. Copy the token - you'll use it in the `Authorization: Bearer $CLOUDFLARE_API_TOKEN` header\n\n## Create a custom provider\n\nTo create a new custom provider using the API:\n\n1. Get your [Account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids/) and Account Tag.\n\n2. Send a `POST` request to create a new custom provider:\n\n* `name` (string): Display name for your provider\n  * `slug` (string): Unique identifier (alphanumeric with hyphens). Must be unique within your account.\n  * `base_url` (string): HTTPS URL for your provider's API endpoint. Must start with `https://`.\n\n* `description` (string): Description of the provider\n  * `link` (string): URL to provider documentation\n  * `enable` (boolean): Whether the provider is active (default: `false`)\n  * `beta` (boolean): Mark as beta feature (default: `false`)\n  * `curl_example` (string): Example cURL command for using the provider\n  * `js_example` (string): Example JavaScript code for using the provider\n\nA default SVG logo is automatically generated for each custom provider. The logo is returned as a base64-encoded string.\n\nTo create a new custom provider using the dashboard:\n\n1. Log in to the [Cloudflare dashboard](https://dash.cloudflare.com) and select your account.\n\n2. Go to [**Compute & AI** > **AI Gateway** > **Custom Providers**](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway/custom-providers).\n\n3. Select **Add Custom Provider**.\n\n4. Enter the following information:\n\n* **Provider Name**: Display name for your provider\n     * **Provider Slug**: Unique identifier (alphanumeric with hyphens)\n     * **Base URL**: HTTPS URL for your provider's API endpoint (e.g., `https://api.myprovider.com/v1`)\n\n5. Select **Save** to create your custom provider.\n\n## List custom providers\n\nRetrieve all custom providers with optional filtering and pagination:\n\n**Query parameters:**\n\n* `page` (number): Page number (default: `1`)\n  * `per_page` (number): Items per page (default: `20`, max: `100`)\n  * `enable` (boolean): Filter by enabled status\n  * `beta` (boolean): Filter by beta status\n  * `search` (string): Search in id, name, or slug fields\n  * `order_by` (string): Sort field and direction (default: `\"name ASC\"`)\n\nList only enabled providers:\n\nSearch for specific providers:\n\nTo view all your custom providers:\n\n1. Log in to the [Cloudflare dashboard](https://dash.cloudflare.com) and select your account.\n  2. Go to [**Compute & AI** > **AI Gateway** > **Custom Providers**](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway/custom-providers).\n  3. You will see a list of all your custom providers with their names, slugs, base URLs, and status.\n\n## Get a specific custom provider\n\nRetrieve details for a specific custom provider by its ID:\n\n## Update a custom provider\n\nUpdate an existing custom provider. All fields are optional - only include the fields you want to change:\n\n**Updatable fields:**\n\n* `name` (string): Provider display name\n  * `slug` (string): Provider identifier\n  * `base_url` (string): API endpoint URL (must be HTTPS)\n  * `description` (string): Provider description\n  * `link` (string): Documentation URL\n  * `enable` (boolean): Active status\n  * `beta` (boolean): Beta flag\n  * `curl_example` (string): Example cURL command\n  * `js_example` (string): Example JavaScript code\n\nUpdates to custom providers automatically invalidate any cached entries related to that provider.\n\nTo update an existing custom provider:\n\n1. Log in to the [Cloudflare dashboard](https://dash.cloudflare.com) and select your account.\n  2. Go to [**Compute & AI** > **AI Gateway** > **Custom Providers**](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway/custom-providers).\n  3. Find the custom provider you want to update and select **Edit**.\n  4. Update the fields you want to change (name, slug, base URL, etc.).\n  5. Select **Save** to apply your changes.\n\n## Delete a custom provider\n\nDelete a custom provider:\n\nDeleting a custom provider will immediately stop all requests routed through it. Ensure you have updated your applications before deleting a provider. Cache entries related to the provider will also be invalidated.\n\nTo delete a custom provider:\n\n1. Log in to the [Cloudflare dashboard](https://dash.cloudflare.com) and select your account.\n  2. Go to [**Compute & AI** > **AI Gateway** > **Custom Providers**](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway/custom-providers).\n  3. Find the custom provider you want to delete and select **Delete**.\n  4. Confirm the deletion when prompted.\n\nDeleting a custom provider will immediately stop all requests routed through it. Ensure you have updated your applications before deleting a provider.\n\n## Using custom providers with AI Gateway\n\nOnce you've created a custom provider, you can route requests through AI Gateway. When referencing your custom provider, you must prefix the slug with `custom-`.\n\nCustom provider prefix\n\nAll custom provider slugs must be prefixed with `custom-` when making requests through AI Gateway. For example, if your provider slug is `some-provider`, you must use `custom-some-provider` in your requests.\n\nIn the Unified API, specify the model using the format: `custom-{slug}/{model-name}`\n\n### Via provider-specific endpoint\n\nThe request will be proxied to: `https://api.myprovider.com/your-endpoint`\n\n**Path structure:** `/{account_id}/{gateway_id}/custom-{slug}/{provider-path}`\n\n### 409 Conflict - Duplicate slug\n\nEach custom provider slug must be unique within your account. Choose a different slug or update the existing provider.\n\nThe specified provider ID does not exist or you don't have access to it. Verify the provider ID and your authentication credentials.\n\n### 400 Bad Request - Invalid base\\_url\n\nThe `base_url` field must be a valid HTTPS URL. HTTP URLs are not supported for security reasons.\n\n1. **Use descriptive slugs**: Choose slugs that clearly identify the provider (e.g., `internal-gpt`, `regional-ai`)\n2. **Document your integrations**: Use the `curl_example` and `js_example` fields to provide usage examples\n3. **Enable gradually**: Test with `enable: false` before making the provider active\n4. **Monitor usage**: Use AI Gateway's analytics to track requests to your custom providers\n5. **Secure your endpoints**: Ensure your custom provider's base URL implements proper authentication and authorization\n6. **Use BYOK**: Store provider API keys securely using [BYOK](https://developers.cloudflare.com/ai-gateway/configuration/bring-your-own-keys/) instead of including them in every request\n\n* Custom providers are account-specific and not shared across Cloudflare accounts\n* The `base_url` must use HTTPS (HTTP is not supported)\n* Provider slugs must be unique within each account\n* Cache and rate limiting settings apply globally to the provider, not per-model\n\n* [Get started with AI Gateway](https://developers.cloudflare.com/ai-gateway/get-started/)\n* [Configure authentication](https://developers.cloudflare.com/ai-gateway/configuration/authentication/)\n* [BYOK (Store Keys)](https://developers.cloudflare.com/ai-gateway/configuration/bring-your-own-keys/)\n* [Dynamic routing](https://developers.cloudflare.com/ai-gateway/features/dynamic-routing/)\n* [Caching](https://developers.cloudflare.com/ai-gateway/features/caching/)\n* [Rate limiting](https://developers.cloudflare.com/ai-gateway/features/rate-limiting/)\n\n<page>\n---\ntitle: Fallbacks · Cloudflare AI Gateway docs\ndescription: Specify model or provider fallbacks with your Universal endpoint to\n  handle request failures and ensure reliability.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/configuration/fallbacks/\n  md: https://developers.cloudflare.com/ai-gateway/configuration/fallbacks/index.md\n---\n\nSpecify model or provider fallbacks with your [Universal endpoint](https://developers.cloudflare.com/ai-gateway/usage/universal/) to handle request failures and ensure reliability.\n\nCloudflare can trigger your fallback provider in response to [request errors](#request-failures) or [predetermined request timeouts](https://developers.cloudflare.com/ai-gateway/configuration/request-handling#request-timeouts). The [response header `cf-aig-step`](#response-headercf-aig-step) indicates which step successfully processed the request.\n\nBy default, Cloudflare triggers your fallback if a model request returns an error.\n\nIn the following example, a request first goes to the [Workers AI](https://developers.cloudflare.com/workers-ai/) Inference API. If the request fails, it falls back to OpenAI. The response header `cf-aig-step` indicates which provider successfully processed the request.\n\n1. Sends a request to Workers AI Inference API.\n2. If that request fails, proceeds to OpenAI.\n\nYou can add as many fallbacks as you need, just by adding another object in the array.\n\n## Response header(cf-aig-step)\n\nWhen using the [Universal endpoint](https://developers.cloudflare.com/ai-gateway/usage/universal/) with fallbacks, the response header `cf-aig-step` indicates which model successfully processed the request by returning the step number. This header provides visibility into whether a fallback was triggered and which model ultimately processed the response.\n\n* `cf-aig-step:0` – The first (primary) model was used successfully.\n* `cf-aig-step:1` – The request fell back to the second model.\n* `cf-aig-step:2` – The request fell back to the third model.\n* Subsequent steps – Each fallback increments the step number by 1.\n\n<page>\n---\ntitle: Manage gateways · Cloudflare AI Gateway docs\ndescription: You have several different options for managing an AI Gateway.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/configuration/manage-gateway/\n  md: https://developers.cloudflare.com/ai-gateway/configuration/manage-gateway/index.md\n---\n\nYou have several different options for managing an AI Gateway.\n\n[Create a Gateway](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway#create)\n\n1. Log into the [Cloudflare dashboard](https://dash.cloudflare.com/) and select your account.\n  2. Go to **AI** > **AI Gateway**.\n  3. Select **Create Gateway**.\n  4. Enter your **Gateway name**. Note: Gateway name has a 64 character limit.\n  5. Select **Create**.\n\nTo set up an AI Gateway using the API:\n\n1. [Create an API token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/) with the following permissions:\n\n* `AI Gateway - Read`\n     * `AI Gateway - Edit`\n\n2. Get your [Account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids/).\n\n3. Using that API token and Account ID, send a [`POST` request](https://developers.cloudflare.com/api/resources/ai_gateway/methods/create/) to the Cloudflare API.\n\nTo edit an AI Gateway in the dashboard:\n\n1. Log into the [Cloudflare dashboard](https://dash.cloudflare.com/) and select your account.\n  2. Go to **AI** > **AI Gateway**.\n  3. Select your gateway.\n  4. Go to **Settings** and update as needed.\n\nTo edit an AI Gateway, send a [`PUT` request](https://developers.cloudflare.com/api/resources/ai_gateway/methods/update/) to the Cloudflare API.\n\nFor more details about what settings are available for editing, refer to [Configuration](https://developers.cloudflare.com/ai-gateway/configuration/).\n\nDeleting your gateway is permanent and can not be undone.\n\nTo delete an AI Gateway in the dashboard:\n\n1. Log into the [Cloudflare dashboard](https://dash.cloudflare.com/) and select your account.\n  2. Go to **AI** > **AI Gateway**.\n  3. Select your gateway from the list of available options.\n  4. Go to **Settings**.\n  5. For **Delete Gateway**, select **Delete** (and confirm your deletion).\n\nTo delete an AI Gateway, send a [`DELETE` request](https://developers.cloudflare.com/api/resources/ai_gateway/methods/delete/) to the Cloudflare API.\n\n<page>\n---\ntitle: Request handling · Cloudflare AI Gateway docs\ndescription: Your AI gateway supports different strategies for handling requests\n  to providers, which allows you to manage AI interactions effectively and\n  ensure your applications remain responsive and reliable.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/configuration/request-handling/\n  md: https://developers.cloudflare.com/ai-gateway/configuration/request-handling/index.md\n---\n\nWhile the request handling features described on this page still work, [Dynamic Routing](https://developers.cloudflare.com/ai-gateway/features/dynamic-routing/) is now the preferred way to achieve advanced request handling, including timeouts, retries, and fallbacks. Dynamic Routing provides a more powerful and flexible approach with a visual interface for managing complex routing scenarios.\n\nYour AI gateway supports different strategies for handling requests to providers, which allows you to manage AI interactions effectively and ensure your applications remain responsive and reliable.\n\nA request timeout allows you to trigger fallbacks or a retry if a provider takes too long to respond.\n\n* Improve user experience, by preventing users from waiting too long for a response\n* Proactively handle errors, by detecting unresponsive providers and triggering a fallback option\n\nRequest timeouts can be set on a Universal Endpoint or directly on a request to any provider.\n\nA timeout is set in milliseconds. Additionally, the timeout is based on when the first part of the response comes back. As long as the first part of the response returns within the specified timeframe - such as when streaming a response - your gateway will wait for the response.\n\n#### Universal Endpoint\n\nIf set on a [Universal Endpoint](https://developers.cloudflare.com/ai-gateway/usage/universal/), a request timeout specifies the timeout duration for requests and triggers a fallback.\n\nFor a Universal Endpoint, configure the timeout value by setting a `requestTimeout` property within the provider-specific `config` object. Each provider can have a different `requestTimeout` value for granular customization.\n\nIf set on a [provider](https://developers.cloudflare.com/ai-gateway/usage/providers/) request, request timeout specifies the timeout duration for a request and - if exceeded - returns an error.\n\nFor a provider-specific endpoint, configure the timeout value by adding a `cf-aig-request-timeout` header.\n\nAI Gateway also supports automatic retries for failed requests, with a maximum of five retry attempts.\n\nThis feature improves your application's resiliency, ensuring you can recover from temporary issues without manual intervention.\n\nRequest timeouts can be set on a Universal Endpoint or directly on a request to any provider.\n\nWith request retries, you can adjust a combination of three properties:\n\n* Number of attempts (maximum of 5 tries)\n* How long before retrying (in milliseconds, maximum of 5 seconds)\n* Backoff method (constant, linear, or exponential)\n\nOn the final retry attempt, your gateway will wait until the request completes, regardless of how long it takes.\n\n#### Universal endpoint\n\nIf set on a [Universal Endpoint](https://developers.cloudflare.com/ai-gateway/usage/universal/), a request retry will automatically retry failed requests up to five times before triggering any configured fallbacks.\n\nFor a Universal Endpoint, configure the retry settings with the following properties in the provider-specific `config`:\n\nAs with the [request timeout](https://developers.cloudflare.com/ai-gateway/configuration/request-handling/#universal-endpoint), each provider can have a different retry settings for granular customization.\n\nIf set on a [provider](https://developers.cloudflare.com/ai-gateway/usage/universal/) request, a request retry will automatically retry failed requests up to five times. On the final retry attempt, your gateway will wait until the request completes, regardless of how long it takes.\n\nFor a provider-specific endpoint, configure the retry settings by adding different header values:\n\n* `cf-aig-max-attempts` (number)\n* `cf-aig-retry-delay` (number)\n* `cf-aig-backoff` (\"constant\" | \"linear\" | \"exponential)\n\n<page>\n---\ntitle: Add Human Feedback using Dashboard · Cloudflare AI Gateway docs\ndescription: Human feedback is a valuable metric to assess the performance of\n  your AI models. By incorporating human feedback, you can gain deeper insights\n  into how the model's responses are perceived and how well it performs from a\n  user-centric perspective. This feedback can then be used in evaluations to\n  calculate performance metrics, driving optimization and ultimately enhancing\n  the reliability, accuracy, and efficiency of your AI application.\nlastUpdated: 2025-09-05T08:34:36.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback/\n  md: https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback/index.md\n---\n\nHuman feedback is a valuable metric to assess the performance of your AI models. By incorporating human feedback, you can gain deeper insights into how the model's responses are perceived and how well it performs from a user-centric perspective. This feedback can then be used in evaluations to calculate performance metrics, driving optimization and ultimately enhancing the reliability, accuracy, and efficiency of your AI application.\n\nHuman feedback measures the performance of your dataset based on direct human input. The metric is calculated as the percentage of positive feedback (thumbs up) given on logs, which are annotated in the Logs tab of the Cloudflare dashboard. This feedback helps refine model performance by considering real-world evaluations of its output.\n\nThis tutorial will guide you through the process of adding human feedback to your evaluations in AI Gateway using the Cloudflare dashboard.\n\nOn the next guide, you can [learn how to add human feedback via the API](https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback-api/).\n\n## 1. Log in to the dashboard\n\nIn the Cloudflare dashboard, go to the **AI Gateway** page.\n\n[Go to **AI Gateway**](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway)\n\n## 2. Access the Logs tab\n\n2. The Logs tab displays all logs associated with your datasets. These logs show key information, including:\n\n* Timestamp: When the interaction occurred.\n   * Status: Whether the request was successful, cached, or failed.\n   * Model: The model used in the request.\n   * Tokens: The number of tokens consumed by the response.\n   * Cost: The cost based on token usage.\n   * Duration: The time taken to complete the response.\n   * Feedback: Where you can provide human feedback on each log.\n\n## 3. Provide human feedback\n\n1. Click on the log entry you want to review. This expands the log, allowing you to see more detailed information.\n\n2. In the expanded log, you can view additional details such as:\n\n* The user prompt.\n   * The model response.\n   * HTTP response details.\n   * Endpoint information.\n\n3. You will see two icons:\n\n* Thumbs up: Indicates positive feedback.\n   * Thumbs down: Indicates negative feedback.\n\n4. Click either the thumbs up or thumbs down icon based on how you rate the model response for that particular log entry.\n\n## 4. Evaluate human feedback\n\nAfter providing feedback on your logs, it becomes a part of the evaluation process.\n\nWhen you run an evaluation (as outlined in the [Set Up Evaluations](https://developers.cloudflare.com/ai-gateway/evaluations/set-up-evaluations/) guide), the human feedback metric will be calculated based on the percentage of logs that received thumbs-up feedback.\n\nYou need to select human feedback as an evaluator to receive its metrics.\n\nAfter running the evaluation, review the results on the Evaluations tab. You will be able to see the performance of the model based on cost, speed, and now human feedback, represented as the percentage of positive feedback (thumbs up).\n\nThe human feedback score is displayed as a percentage, showing the distribution of positively rated responses from the database.\n\nFor more information on running evaluations, refer to the documentation [Set Up Evaluations](https://developers.cloudflare.com/ai-gateway/evaluations/set-up-evaluations/).\n\n<page>\n---\ntitle: Add Human Feedback using API · Cloudflare AI Gateway docs\ndescription: This guide will walk you through the steps of adding human feedback\n  to an AI Gateway request using the Cloudflare API. You will learn how to\n  retrieve the relevant request logs, and submit feedback using the API.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback-api/\n  md: https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback-api/index.md\n---\n\nThis guide will walk you through the steps of adding human feedback to an AI Gateway request using the Cloudflare API. You will learn how to retrieve the relevant request logs, and submit feedback using the API.\n\nIf you prefer to add human feedback via the dashboard, refer to [Add Human Feedback](https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback/).\n\n## 1. Create an API Token\n\n1. [Create an API token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/) with the following permissions:\n\n* `AI Gateway - Read`\n* `AI Gateway - Edit`\n\n1. Get your [Account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids/).\n2. Using that API token and Account ID, send a [`POST` request](https://developers.cloudflare.com/api/resources/ai_gateway/methods/create/) to the Cloudflare API.\n\n## 2. Retrieve the `cf-aig-log-id`\n\nThe `cf-aig-log-id` is a unique identifier for the specific log entry to which you want to add feedback. Below are two methods to obtain this identifier.\n\n### Method 1: Locate the `cf-aig-log-id` in the request response\n\nThis method allows you to directly find the `cf-aig-log-id` within the header of the response returned by the AI Gateway. This is the most straightforward approach if you have access to the original API response.\n\nThe steps below outline how to do this.\n\n1. **Make a Request to the AI Gateway**: This could be a request your application sends to the AI Gateway. Once the request is made, the response will contain various pieces of metadata.\n2. **Check the Response Headers**: The response will include a header named `cf-aig-log-id`. This is the identifier you will need to submit feedback.\n\nIn the example below, the `cf-aig-log-id` is `01JADMCQQQBWH3NXZ5GCRN98DP`.\n\n### Method 2: Retrieve the `cf-aig-log-id` via API (GET request)\n\nIf you do not have the `cf-aig-log-id` in the response body or you need to access it after the fact, you are able to retrieve it by querying the logs using the [Cloudflare API](https://developers.cloudflare.com/api/resources/ai_gateway/subresources/logs/methods/list/).\n\nSend a `GET` request to get a list of logs and then find a specific ID\n\nRequired API token permissions\n\nAt least one of the following [token permissions](https://developers.cloudflare.com/fundamentals/api/reference/permissions/) is required:\n\n* `AI Gateway Write`\n* `AI Gateway Read`\n\n### Method 3: Retrieve the `cf-aig-log-id` via a binding\n\nYou can also retrieve the `cf-aig-log-id` using a binding, which streamlines the process. Here's how to retrieve the log ID directly:\n\nThe `aiGatewayLogId` property, will only hold the last inference call log id.\n\n## 3. Submit feedback via PATCH request\n\nOnce you have both the API token and the `cf-aig-log-id`, you can send a PATCH request to submit feedback.\n\nRequired API token permissions\n\nAt least one of the following [token permissions](https://developers.cloudflare.com/fundamentals/api/reference/permissions/) is required:\n\nIf you had negative feedback, adjust the body of the request to be `-1`.\n\n## 4. Verify the feedback submission\n\nYou can verify the feedback submission in two ways:\n\n* **Through the [Cloudflare dashboard ](https://dash.cloudflare.com)**: check the updated feedback on the AI Gateway interface.\n* **Through the API**: Send another GET request to retrieve the updated log entry and confirm the feedback has been recorded.\n\n<page>\n---\ntitle: Add human feedback using Worker Bindings · Cloudflare AI Gateway docs\ndescription: This guide explains how to provide human feedback for AI Gateway\n  evaluations using Worker bindings.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback-bindings/\n  md: https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback-bindings/index.md\n---\n\nThis guide explains how to provide human feedback for AI Gateway evaluations using Worker bindings.\n\n## 1. Run an AI Evaluation\n\nStart by sending a prompt to the AI model through your AI Gateway.\n\nLet the user interact with or evaluate the AI response. This interaction will inform the feedback you send back to the AI Gateway.\n\n## 2. Send Human Feedback\n\nUse the [`patchLog()`](https://developers.cloudflare.com/ai-gateway/integrations/worker-binding-methods/#31-patchlog-send-feedback) method to provide feedback for the AI evaluation.\n\n## Feedback parameters explanation\n\n* `feedback`: is either `-1` for negative or `1` to positive, `0` is considered not evaluated.\n* `score`: A number between 0 and 100.\n* `metadata`: An object containing additional contextual information.\n\n### patchLog: Send Feedback\n\nThe `patchLog` method allows you to send feedback, score, and metadata for a specific log ID. All object properties are optional, so you can include any combination of the parameters:\n\nReturns: `Promise<void>` (Make sure to `await` the request.)\n\n<page>\n---\ntitle: Set up Evaluations · Cloudflare AI Gateway docs\ndescription: This guide walks you through the process of setting up an\n  evaluation in AI Gateway. These steps are done in the Cloudflare dashboard.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/evaluations/set-up-evaluations/\n  md: https://developers.cloudflare.com/ai-gateway/evaluations/set-up-evaluations/index.md\n---\n\nThis guide walks you through the process of setting up an evaluation in AI Gateway. These steps are done in the [Cloudflare dashboard](https://dash.cloudflare.com/).\n\n## 1. Select or create a dataset\n\nDatasets are collections of logs stored for analysis that can be used in an evaluation. You can create datasets by applying filters in the Logs tab. Datasets will update automatically based on the set filters.\n\n### Set up a dataset from the Logs tab\n\n1. Apply filters to narrow down your logs. Filter options include provider, number of tokens, request status, and more.\n2. Select **Create Dataset** to store the filtered logs for future analysis.\n\nYou can manage datasets by selecting **Manage datasets** from the Logs tab.\n\nPlease keep in mind that datasets currently use `AND` joins, so there can only be one item per filter (for example, one model or one provider). Future updates will allow more flexibility in dataset creation.\n\n### List of available filters\n\n| Filter category | Filter options | Filter by description |\n| - | - | - |\n| Status | error, status | error type or status. |\n| Cache | cached, not cached | based on whether they were cached or not. |\n| Provider | specific providers | the selected AI provider. |\n| AI Models | specific models | the selected AI model. |\n| Cost | less than, greater than | cost, specifying a threshold. |\n| Request type | Universal, Workers AI Binding, WebSockets | the type of request. |\n| Tokens | Total tokens, Tokens In, Tokens Out | token count (less than or greater than). |\n| Duration | less than, greater than | request duration. |\n| Feedback | equals, does not equal (thumbs up, thumbs down, no feedback) | feedback type. |\n| Metadata Key | equals, does not equal | specific metadata keys. |\n| Metadata Value | equals, does not equal | specific metadata values. |\n| Log ID | equals, does not equal | a specific Log ID. |\n| Event ID | equals, does not equal | a specific Event ID. |\n\n## 2. Select evaluators\n\nAfter creating a dataset, choose the evaluation parameters:\n\n* Cost: Calculates the average cost of inference requests within the dataset (only for requests with [cost data](https://developers.cloudflare.com/ai-gateway/observability/costs/)).\n* Speed: Calculates the average duration of inference requests within the dataset.\n* Performance:\n  * Human feedback: measures performance based on human feedback, calculated by the % of thumbs up on the logs, annotated from the Logs tab.\n\nAdditional evaluators will be introduced in future updates to expand performance analysis capabilities.\n\n## 3. Name, review, and run the evaluation\n\n1. Create a unique name for your evaluation to reference it in the dashboard.\n2. Review the selected dataset and evaluators.\n3. Select **Run** to start the process.\n\n## 4. Review and analyze results\n\nEvaluation results will appear in the Evaluations tab. The results show the status of the evaluation (for example, in progress, completed, or error). Metrics for the selected evaluators will be displayed, excluding any logs with missing fields. You will also see the number of logs used to calculate each metric.\n\nWhile datasets automatically update based on filters, evaluations do not. You will have to create a new evaluation if you want to evaluate new logs.\n\nUse these insights to optimize based on your application's priorities. Based on the results, you may choose to:\n\n* Change the model or [provider](https://developers.cloudflare.com/ai-gateway/usage/providers/)\n* Adjust your prompts\n* Explore further optimizations, such as setting up [Retrieval Augmented Generation (RAG)](https://developers.cloudflare.com/reference-architecture/diagrams/ai/ai-rag/)\n\n<page>\n---\ntitle: Caching · Cloudflare AI Gateway docs\ndescription: Override caching settings on a per-request basis.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/features/caching/\n  md: https://developers.cloudflare.com/ai-gateway/features/caching/index.md\n---\n\nAI Gateway can cache responses from your AI model providers, serving them directly from Cloudflare's cache for identical requests.\n\n## Benefits of Using Caching\n\n* **Reduced Latency:** Serve responses faster to your users by avoiding a round trip to the origin AI provider for repeated requests.\n* **Cost Savings:** Minimize the number of paid requests made to your AI provider, especially for frequently accessed or non-dynamic content.\n* **Increased Throughput:** Offload repetitive requests from your AI provider, allowing it to handle unique requests more efficiently.\n\nCurrently caching is supported only for text and image responses, and it applies only to identical requests.\n\nThis configuration benefits use cases with limited prompt options. For example, a support bot that asks \"How can I help you?\" and lets the user select an answer from a limited set of options works well with the current caching configuration. We plan on adding semantic search for caching in the future to improve cache hit rates.\n\n## Default configuration\n\nTo set the default caching configuration in the dashboard:\n\n1. Log into the [Cloudflare dashboard](https://dash.cloudflare.com/) and select your account.\n  2. Select **AI** > **AI Gateway**.\n  3. Select **Settings**.\n  4. Enable **Cache Responses**.\n  5. Change the default caching to whatever value you prefer.\n\nTo set the default caching configuration using the API:\n\n1. [Create an API token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/) with the following permissions:\n\n* `AI Gateway - Read`\n  * `AI Gateway - Edit`\n\n1. Get your [Account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids/).\n  2. Using that API token and Account ID, send a [`POST` request](https://developers.cloudflare.com/api/resources/ai_gateway/methods/create/) to create a new Gateway and include a value for the `cache_ttl`.\n\nThis caching behavior will be uniformly applied to all requests that support caching. If you need to modify the cache settings for specific requests, you have the flexibility to override this setting on a per-request basis.\n\nTo check whether a response comes from cache or not, **cf-aig-cache-status** will be designated as `HIT` or `MISS`.\n\n## Per-request caching\n\nWhile your gateway's default cache settings provide a good baseline, you might need more granular control. These situations could be data freshness, content with varying lifespans, or dynamic or personalized responses.\n\nTo address these needs, AI Gateway allows you to override default cache behaviors on a per-request basis using specific HTTP headers. This gives you the precision to optimize caching for individual API calls.\n\nThe following headers allow you to define this per-request cache behavior:\n\nThe following headers have been updated to new names, though the old headers will still function. We recommend updating to the new headers to ensure future compatibility:\n\n`cf-cache-ttl` is now `cf-aig-cache-ttl`\n\n`cf-skip-cache` is now `cf-aig-skip-cache`\n\n### Skip cache (cf-aig-skip-cache)\n\nSkip cache refers to bypassing the cache and fetching the request directly from the original provider, without utilizing any cached copy.\n\nYou can use the header **cf-aig-skip-cache** to bypass the cached version of the request.\n\nAs an example, when submitting a request to OpenAI, include the header in the following manner:\n\n### Cache TTL (cf-aig-cache-ttl)\n\nCache TTL, or Time To Live, is the duration a cached request remains valid before it expires and is refreshed from the original source. You can use **cf-aig-cache-ttl** to set the desired caching duration in seconds. The minimum TTL is 60 seconds and the maximum TTL is one month.\n\nFor example, if you set a TTL of one hour, it means that a request is kept in the cache for an hour. Within that hour, an identical request will be served from the cache instead of the original API. After an hour, the cache expires and the request will go to the original API for a fresh response, and that response will repopulate the cache for the next hour.\n\nAs an example, when submitting a request to OpenAI, include the header in the following manner:\n\n### Custom cache key (cf-aig-cache-key)\n\nCustom cache keys let you override the default cache key in order to precisely set the cacheability setting for any resource. To override the default cache key, you can use the header **cf-aig-cache-key**.\n\nWhen you use the **cf-aig-cache-key** header for the first time, you will receive a response from the provider. Subsequent requests with the same header will return the cached response. If the **cf-aig-cache-ttl** header is used, responses will be cached according to the specified Cache Time To Live. Otherwise, responses will be cached according to the cache settings in the dashboard. If caching is not enabled for the gateway, responses will be cached for 5 minutes by default.\n\nAs an example, when submitting a request to OpenAI, include the header in the following manner:\n\nAI Gateway caching behavior\n\nCache in AI Gateway is volatile. If two identical requests are sent simultaneously, the first request may not cache in time for the second request to use it, which may result in the second request retrieving data from the original source.\n\n<page>\n---\ntitle: Data Loss Prevention (DLP) · Cloudflare AI Gateway docs\ndescription: Data Loss Prevention (DLP) for AI Gateway helps protect your\n  organization from inadvertent exposure of sensitive data through AI\n  interactions. By integrating with Cloudflare's proven DLP technology, AI\n  Gateway can scan both incoming prompts and outgoing AI responses for sensitive\n  information, ensuring your AI applications maintain security and compliance\n  standards.\nlastUpdated: 2025-10-22T21:11:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/features/dlp/\n  md: https://developers.cloudflare.com/ai-gateway/features/dlp/index.md\n---\n\nData Loss Prevention (DLP) for AI Gateway helps protect your organization from inadvertent exposure of sensitive data through AI interactions. By integrating with Cloudflare's proven DLP technology, AI Gateway can scan both incoming prompts and outgoing AI responses for sensitive information, ensuring your AI applications maintain security and compliance standards.\n\nAI Gateway DLP leverages the same powerful detection engines used in [Cloudflare's Data Loss Prevention](https://developers.cloudflare.com/cloudflare-one/data-loss-prevention/) solution to scan AI traffic in real-time. The system analyzes both user prompts sent to AI models and responses received from AI providers, identifying sensitive data patterns and taking appropriate protective actions.\n\n* **Prevent data leakage**: Stop sensitive information from being inadvertently shared with AI providers or exposed in AI responses\n* **Maintain compliance**: Help meet regulatory requirements like GDPR, HIPAA, and PCI DSS\n* **Consistent protection**: Apply the same DLP policies across all AI providers and models\n* **Audit visibility**: Comprehensive logging and reporting for security and compliance teams\n* **Zero-code integration**: Enable protection without modifying existing AI applications\n\n## Supported AI traffic\n\nAI Gateway DLP can scan:\n\n* **User prompts** - Content submitted to AI models, including text, code, and structured data\n* **AI responses** - Output generated by AI models before being returned to users\n\nThe system works with all AI providers supported by AI Gateway, providing consistent protection regardless of which models or services you use.\n\n## Integration with Cloudflare DLP\n\nAI Gateway DLP uses the same detection profiles and policies as Cloudflare's enterprise DLP solution. This means:\n\n* **Unified management** - Configure DLP policies once and apply them across web traffic, email, SaaS applications, and AI interactions\n* **Consistent detection** - The same sensitive data patterns are detected across all channels\n* **Centralized reporting** - All DLP events appear in the same dashboard and logs\n* **Shared profiles** - Reuse existing DLP detection profiles for AI traffic\n\nFor more information about Cloudflare's DLP capabilities, refer to the [Data Loss Prevention documentation](https://developers.cloudflare.com/cloudflare-one/data-loss-prevention/).\n\nTo enable DLP for your AI Gateway:\n\n1. [Set up DLP policies](https://developers.cloudflare.com/ai-gateway/features/dlp/set-up-dlp/) for your AI Gateway\n2. Configure detection profiles and response actions\n3. Monitor DLP events through the Cloudflare dashboard\n\n* [Set up DLP for AI Gateway](https://developers.cloudflare.com/ai-gateway/features/dlp/set-up-dlp/)\n* [Cloudflare Data Loss Prevention](https://developers.cloudflare.com/cloudflare-one/data-loss-prevention/)\n* [AI Gateway Security Features](https://developers.cloudflare.com/ai-gateway/features/guardrails/)\n* [DLP Detection Profiles](https://developers.cloudflare.com/cloudflare-one/data-loss-prevention/dlp-profiles/)\n\n<page>\n---\ntitle: Dynamic routing · Cloudflare AI Gateway docs\ndescription: \"Dynamic routing enables you to create request routing flows\n  through a visual interface or a JSON-based configuration. Instead of\n  hard-coding a single model, with Dynamic Routing you compose a small flow that\n  evaluates conditions, enforces quotas, and chooses models with fallbacks. You\n  can iterate without touching application code—publish a new route version and\n  you’re done. With dynamic routing, you can easily implement advanced use cases\n  such as:\"\nlastUpdated: 2025-08-23T11:12:09.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/features/dynamic-routing/\n  md: https://developers.cloudflare.com/ai-gateway/features/dynamic-routing/index.md\n---\n\nDynamic routing enables you to create request routing flows through a **visual interface** or a **JSON-based configuration**. Instead of hard-coding a single model, with Dynamic Routing you compose a small flow that evaluates conditions, enforces quotas, and chooses models with fallbacks. You can iterate without touching application code—publish a new route version and you’re done. With dynamic routing, you can easily implement advanced use cases such as:\n\n* Directing different segments (paid/not-paid user) to different models\n* Restricting each user/project/team with budget/rate limits\n* A/B and gradual rollouts\n\nwhile making it accessible to both developers and non-technical team members.\n\n![Dynamic Routing Overview](https://developers.cloudflare.com/_astro/dynamic-routing.BtwkWywo_ZkRSjM.webp)\n\n* **Route**: A named, versioned flow (for example, dynamic/support) that you can use as instead of the model name in your requests.\n\n* **Start**: Entry point for the route.\n  * **Conditional**: If/Else branch based on expressions that reference request body, headers, or metadata (for example, user\\_plan == \"paid\").\n  * **Percentage**: Routes requests probabilistically across multiple outputs, useful for A/B testing and gradual rollouts.\n  * **Model**: Calls a provider/model with the request parameters\n  * **Rate Limit**: Enforces number of requests quotas (per your key, per period) and switches to fallback when exceeded.\n  * **Budget Limit**: Enforces cost quotas (per your key, per period) and switches to fallback when exceeded.\n  * **End**: Terminates the flow and returns the final model response.\n\n* **Metadata**: Arbitrary key-value context attached to the request (for example, userId, orgId, plan). You can pass this from your app so rules can reference it.\n\n* **Versions**: Each change produces a new draft. Deploy to make it live with instant rollback.\n\nEnsure your gateway has [authentication](https://developers.cloudflare.com/ai-gateway/configuration/authentication/) turned on, and you have your upstream providers keys stored with [BYOK](https://developers.cloudflare.com/ai-gateway/configuration/bring-your-own-keys/).\n\n* Go to **(Select your gateway)** > **Dynamic Routes** > **Add Route**, and name it (for example, `support`).\n   * Open **Editor**.\n\n2. Define conditionals, limits and other settings.\n\n3. Configure model nodes.\n\n* Node A: Provider OpenAI, Model `o4-mini-high`\n     * Node B: Provider OpenAI, Model `gpt-4.1`\n\n* Click **Save** to save the state. You can always roll back to earlier versions from **Versions**.\n   * Deploy the version to make it live.\n\n5. Call the route from your code.\n   * Use the [OpenAI compatible](https://developers.cloudflare.com/ai-gateway/usage/chat-completion/) endpoint, and use the route name in place of the model, for example, `dynamic/support`.\n\n<page>\n---\ntitle: Guardrails · Cloudflare AI Gateway docs\ndescription: Guardrails help you deploy AI applications safely by intercepting\n  and evaluating both user prompts and model responses for harmful content.\n  Acting as a proxy between your application and model providers (such as\n  OpenAI, Anthropic, DeepSeek, and others), AI Gateway's Guardrails ensure a\n  consistent and secure experience across your entire AI ecosystem.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\ntags: AI\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/features/guardrails/\n  md: https://developers.cloudflare.com/ai-gateway/features/guardrails/index.md\n---\n\nGuardrails help you deploy AI applications safely by intercepting and evaluating both user prompts and model responses for harmful content. Acting as a proxy between your application and [model providers](https://developers.cloudflare.com/ai-gateway/usage/providers/) (such as OpenAI, Anthropic, DeepSeek, and others), AI Gateway's Guardrails ensure a consistent and secure experience across your entire AI ecosystem.\n\nGuardrails proactively monitor interactions between users and AI models, giving you:\n\n* **Consistent moderation**: Uniform moderation layer that works across models and providers.\n* **Enhanced safety and user trust**: Proactively protect users from harmful or inappropriate interactions.\n* **Flexibility and control over allowed content**: Specify which categories to monitor and choose between flagging or outright blocking.\n* **Auditing and compliance capabilities**: Receive updates on evolving regulatory requirements with logs of user prompts, model responses, and enforced guardrails.\n\n## How Guardrails work\n\nAI Gateway inspects all interactions in real time by evaluating content against predefined safety parameters. Guardrails work by:\n\n1. Intercepting interactions: AI Gateway proxies requests and responses, sitting between the user and the AI model.\n\n2. Inspecting content:\n\n* User prompts: AI Gateway checks prompts against safety parameters (for example, violence, hate, or sexual content). Based on your settings, prompts can be flagged or blocked before reaching the model.\n   * Model responses: Once processed, the AI model response is inspected. If hazardous content is detected, it can be flagged or blocked before being delivered to the user.\n\n3. Applying actions: Depending on your configuration, flagged content is logged for review, while blocked content is prevented from proceeding.\n\n* [Cloudflare Blog: Keep AI interactions secure and risk-free with Guardrails in AI Gateway](https://blog.cloudflare.com/guardrails-in-ai-gateway/)\n\n<page>\n---\ntitle: Rate limiting · Cloudflare AI Gateway docs\ndescription: Rate limiting controls the traffic that reaches your application,\n  which prevents expensive bills and suspicious activity.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/features/rate-limiting/\n  md: https://developers.cloudflare.com/ai-gateway/features/rate-limiting/index.md\n---\n\nRate limiting controls the traffic that reaches your application, which prevents expensive bills and suspicious activity.\n\nYou can define rate limits as the number of requests that get sent in a specific time frame. For example, you can limit your application to 100 requests per 60 seconds.\n\nYou can also select if you would like a **fixed** or **sliding** rate limiting technique. With rate limiting, we allow a certain number of requests within a window of time. For example, if it is a fixed rate, the window is based on time, so there would be no more than `x` requests in a ten minute window. If it is a sliding rate, there would be no more than `x` requests in the last ten minutes.\n\nTo illustrate this, let us say you had a limit of ten requests per ten minutes, starting at 12:00. So the fixed window is 12:00-12:10, 12:10-12:20, and so on. If you sent ten requests at 12:09 and ten requests at 12:11, all 20 requests would be successful in a fixed window strategy. However, they would fail in a sliding window strategy since there were more than ten requests in the last ten minutes.\n\n## Handling rate limits\n\nWhen your requests exceed the allowed rate, you will encounter rate limiting. This means the server will respond with a `429 Too Many Requests` status code and your request will not be processed.\n\n## Default configuration\n\nTo set the default rate limiting configuration in the dashboard:\n\n1. Log into the [Cloudflare dashboard](https://dash.cloudflare.com/) and select your account.\n  2. Go to **AI** > **AI Gateway**.\n  3. Go to **Settings**.\n  4. Enable **Rate-limiting**.\n  5. Adjust the rate, time period, and rate limiting method as desired.\n\nTo set the default rate limiting configuration using the API:\n\n1. [Create an API token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/) with the following permissions:\n\n* `AI Gateway - Read`\n  * `AI Gateway - Edit`\n\n1. Get your [Account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids/).\n  2. Using that API token and Account ID, send a [`POST` request](https://developers.cloudflare.com/api/resources/ai_gateway/methods/create/) to create a new Gateway and include a value for the `rate_limiting_interval`, `rate_limiting_limit`, and `rate_limiting_technique`.\n\nThis rate limiting behavior will be uniformly applied to all requests for that gateway.\n\n<page>\n---\ntitle: Unified Billing · Cloudflare AI Gateway docs\ndescription: Use the Cloudflare billing to pay for and authenticate your inference requests.\nlastUpdated: 2025-11-25T17:13:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/features/unified-billing/\n  md: https://developers.cloudflare.com/ai-gateway/features/unified-billing/index.md\n---\n\nUnified Billing allows users to connect to various AI providers (such as OpenAI, Anthropic, and Google AI Studio) and receive a single Cloudflare bill. To use Unified Billing, you must purchase and load credits into your Cloudflare account in the Cloudflare dashboard, which you can then spend with AI Gateway.\n\n* Ensure your Cloudflare account has [sufficient credits loaded](#load-credits).\n* Ensure you have [authenticated](https://developers.cloudflare.com/ai-gateway/configuration/authentication/) your AI Gateway.\n\nTo load credits for AI Gateway:\n\n1. In the Cloudflare dashboard, go to the **AI Gateway** page.\n\n[Go to **AI Gateway**](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway)\n\nThe **Credits Available** card on the top right shows how many AI gateway credits you have on your account currently.\n\n2. In **Credits Available**, select **Manage**.\n\n3. If your account does not have an available payment method, AI Gateway will prompt you to add a payment method to purchase credits. Add a payment method.\n\n4. Select **Top-up credits**.\n\n5. Add the amount of credits you want to purchase, then select **Confirm and pay**.\n\nYou can configure AI Gateway to automatically replenish your credits when they fall below a certain threshold. To configure auto top-up:\n\n1. In the Cloudflare dashboard, go to the **AI Gateway** page.\n\n[Go to **AI Gateway**](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway)\n\n2. In **Credits Available**, select **Manage**.\n\n3. Select **Setup auto top-up credits**.\n\n4. Choose a threshold and a recharge amount for auto top-up.\n\nWhen your balance falls below the set threshold, AI Gateway will automatically apply the auto top-up amount to your account.\n\n## Use Unified Billing\n\nCall any supported provider without passing an API Key. The request will automatically use Cloudflare's key and deduct credits from your account.\n\nFor example, you can use the Unified API:\n\nSet spend limits to prevent unexpected charges on your loaded credits. You can define daily, weekly, or monthly limits. When a limit is reached, the AI Gateway automatically stops processing requests until the period resets or you increase the limit.\n\n### Supported providers\n\nUnified Billing supports the following AI providers:\n\n* [OpenAI](https://developers.cloudflare.com/ai-gateway/usage/providers/openai/)\n* [Anthropic](https://developers.cloudflare.com/ai-gateway/usage/providers/anthropic/)\n* [Google AI Studio](https://developers.cloudflare.com/ai-gateway/usage/providers/google-ai-studio/)\n* [xAI](https://developers.cloudflare.com/ai-gateway/usage/providers/grok/)\n* [Groq](https://developers.cloudflare.com/ai-gateway/usage/providers/groq/)\n\n<page>\n---\ntitle: Agents · Cloudflare AI Gateway docs\ndescription: Build AI-powered Agents on Cloudflare\nlastUpdated: 2025-01-29T20:30:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/integrations/agents/\n  md: https://developers.cloudflare.com/ai-gateway/integrations/agents/index.md\n---\n\n<page>\n---\ntitle: Workers AI · Cloudflare AI Gateway docs\ndescription: This guide will walk you through setting up and deploying a Workers\n  AI project. You will use Workers, an AI Gateway binding, and a large language\n  model (LLM) to deploy your first AI-powered application on the Cloudflare\n  global network.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/integrations/aig-workers-ai-binding/\n  md: https://developers.cloudflare.com/ai-gateway/integrations/aig-workers-ai-binding/index.md\n---\n\nThis guide will walk you through setting up and deploying a Workers AI project. You will use [Workers](https://developers.cloudflare.com/workers/), an AI Gateway binding, and a large language model (LLM), to deploy your first AI-powered application on the Cloudflare global network.\n\n1. Sign up for a [Cloudflare account](https://dash.cloudflare.com/sign-up/workers-and-pages).\n2. Install [`Node.js`](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).\n\nNode.js version manager\n\nUse a Node version manager like [Volta](https://volta.sh/) or [nvm](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node.js versions. [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), discussed later in this guide, requires a Node version of `16.17.0` or later.\n\n## 1. Create a Worker Project\n\nYou will create a new Worker project using the create-Cloudflare CLI (C3). C3 is a command-line tool designed to help you set up and deploy new applications to Cloudflare.\n\nCreate a new project named `hello-ai` by running:\n\nRunning `npm create cloudflare@latest` will prompt you to install the create-cloudflare package and lead you through setup. C3 will also install [Wrangler](https://developers.cloudflare.com/workers/wrangler/), the Cloudflare Developer Platform CLI.\n\nFor setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `TypeScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nThis will create a new `hello-ai` directory. Your new `hello-ai` directory will include:\n\n* A \"Hello World\" Worker at `src/index.ts`.\n* A [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/)\n\nGo to your application directory:\n\n## 2. Connect your Worker to Workers AI\n\nYou must create an AI binding for your Worker to connect to Workers AI. Bindings allow your Workers to interact with resources, like Workers AI, on the Cloudflare Developer Platform.\n\nTo bind Workers AI to your Worker, add the following to the end of your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/):\n\nYour binding is [available in your Worker code](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/#bindings-in-es-modules-format) on [`env.AI`](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/).\n\nYou will need to have your `gateway id` for the next step. You can learn [how to create an AI Gateway in this tutorial](https://developers.cloudflare.com/ai-gateway/get-started/).\n\n## 3. Run an inference task containing AI Gateway in your Worker\n\nYou are now ready to run an inference task in your Worker. In this case, you will use an LLM, [`llama-3.1-8b-instruct-fast`](https://developers.cloudflare.com/workers-ai/models/llama-3.1-8b-instruct-fast/), to answer a question. Your gateway ID is found on the dashboard.\n\nUpdate the `index.ts` file in your `hello-ai` application directory with the following code:\n\nUp to this point, you have created an AI binding for your Worker and configured your Worker to be able to execute the Llama 3.1 model. You can now test your project locally before you deploy globally.\n\n## 4. Develop locally with Wrangler\n\nWhile in your project directory, test Workers AI locally by running [`wrangler dev`](https://developers.cloudflare.com/workers/wrangler/commands/#dev):\n\nWorkers AI local development usage charges\n\nUsing Workers AI always accesses your Cloudflare account in order to run AI models and will incur usage charges even in local development.\n\nYou will be prompted to log in after you run `wrangler dev`. When you run `npx wrangler dev`, Wrangler will give you a URL (most likely `localhost:8787`) to review your Worker. After you go to the URL Wrangler provides, you will see a message that resembles the following example:\n\nmain()\n{\n  printf(\\\"Hello, World!\\\");\n}\n`\n\n## 5. Deploy your AI Worker\n\nBefore deploying your AI Worker globally, log in with your Cloudflare account by running:\n\nYou will be directed to a web page asking you to log in to the Cloudflare dashboard. After you have logged in, you will be asked if Wrangler can make changes to your Cloudflare account. Scroll down and select **Allow** to continue.\n\nFinally, deploy your Worker to make your project accessible on the Internet. To deploy your Worker, run:\n\nOnce deployed, your Worker will be available at a URL like:\n\nYour Worker will be deployed to your custom [`workers.dev`](https://developers.cloudflare.com/workers/configuration/routing/workers-dev/) subdomain. You can now visit the URL to run your AI Worker.\n\nBy completing this tutorial, you have created a Worker, connected it to Workers AI through an AI Gateway binding, and successfully ran an inference task using the Llama 3.1 model.\n\n<page>\n---\ntitle: Vercel AI SDK · Cloudflare AI Gateway docs\ndescription: >-\n  The Vercel AI SDK is a TypeScript library for building AI applications. The\n  SDK supports many different AI providers, tools for streaming completions, and\n  more.\n\nTo use Cloudflare AI Gateway with Vercel AI SDK, you will need to use the\n  ai-gateway-provider package.\nlastUpdated: 2025-12-08T07:14:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/integrations/vercel-ai-sdk/\n  md: https://developers.cloudflare.com/ai-gateway/integrations/vercel-ai-sdk/index.md\n---\n\nThe [Vercel AI SDK](https://sdk.vercel.ai/) is a TypeScript library for building AI applications. The SDK supports many different AI providers, tools for streaming completions, and more. To use Cloudflare AI Gateway with Vercel AI SDK, you will need to use the `ai-gateway-provider` package.\n\n* With Authenticated Gateway\n\n* Unauthenticated Gateway\n\nWith Stored Keys (BYOK) / Unified Billing\n\n### Fallback Providers\n\nTo specify model or provider fallbacks to handle request failures and ensure reliability, you can pass an array of models to the `model` option.\n\n<page>\n---\ntitle: AI Gateway Binding Methods · Cloudflare AI Gateway docs\ndescription: This guide provides an overview of how to use the latest Cloudflare\n  Workers AI Gateway binding methods. You will learn how to set up an AI Gateway\n  binding, access new methods, and integrate them into your Workers.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\ntags: Bindings\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/integrations/worker-binding-methods/\n  md: https://developers.cloudflare.com/ai-gateway/integrations/worker-binding-methods/index.md\n---\n\nThis guide provides an overview of how to use the latest Cloudflare Workers AI Gateway binding methods. You will learn how to set up an AI Gateway binding, access new methods, and integrate them into your Workers.\n\n## 1. Add an AI Binding to your Worker\n\nTo connect your Worker to Workers AI, add the following to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/):\n\nThis configuration sets up the AI binding accessible in your Worker code as `env.AI`.\n\nIf you're using TypeScript, run [`wrangler types`](https://developers.cloudflare.com/workers/wrangler/commands/#types) whenever you modify your Wrangler configuration file. This generates types for the `env` object based on your bindings, as well as [runtime types](https://developers.cloudflare.com/workers/languages/typescript/).\n\n## 2. Basic Usage with Workers AI + Gateway\n\nTo perform an inference task using Workers AI and an AI Gateway, you can use the following code:\n\nAdditionally, you can access the latest request log ID with:\n\n## 3. Access the Gateway Binding\n\nYou can access your AI Gateway binding using the following code:\n\nOnce you have the gateway instance, you can use the following methods:\n\n### 3.1. `patchLog`: Send Feedback\n\nThe `patchLog` method allows you to send feedback, score, and metadata for a specific log ID. All object properties are optional, so you can include any combination of the parameters:\n\n* **Returns**: `Promise<void>` (Make sure to `await` the request.)\n* **Example Use Case**: Update a log entry with user feedback or additional metadata.\n\n### 3.2. `getLog`: Read Log Details\n\nThe `getLog` method retrieves details of a specific log ID. It returns an object of type `Promise<AiGatewayLog>`. If this type is missing, ensure you have run [`wrangler types`](https://developers.cloudflare.com/workers/languages/typescript/#generate-types).\n\n* **Returns**: `Promise<AiGatewayLog>`\n* **Example Use Case**: Retrieve log information for debugging or analytics.\n\n### 3.3. `getUrl`: Get Gateway URLs\n\nThe `getUrl` method allows you to retrieve the base URL for your AI Gateway, optionally specifying a provider to get the provider-specific endpoint.\n\n* **Parameters**: Optional `provider` (string or `AIGatewayProviders` enum)\n* **Returns**: `Promise<string>`\n* **Example Use Case**: Dynamically construct URLs for direct API calls or debugging configurations.\n\n#### SDK Integration Examples\n\nThe `getUrl` method is particularly useful for integrating with popular AI SDKs:\n\n**Vercel AI SDK with OpenAI:**\n\n**Vercel AI SDK with Anthropic:**\n\n### 3.4. `run`: Universal Requests\n\nThe `run` method allows you to execute universal requests. Users can pass either a single universal request object or an array of them. This method supports all AI Gateway providers.\n\nRefer to the [Universal endpoint documentation](https://developers.cloudflare.com/ai-gateway/usage/universal/) for details about the available inputs.\n\n* **Returns**: `Promise<Response>`\n* **Example Use Case**: Perform a [universal request](https://developers.cloudflare.com/ai-gateway/usage/universal/) to any supported provider.\n\nWith these AI Gateway binding methods, you can now:\n\n* Send feedback and update metadata with `patchLog`.\n* Retrieve detailed log information using `getLog`.\n* Get gateway URLs for direct API access with `getUrl`, making it easy to integrate with popular AI SDKs.\n* Execute universal requests to any AI Gateway provider with `run`.\n\nThese methods offer greater flexibility and control over your AI integrations, empowering you to build more sophisticated applications on the Cloudflare Workers platform.\n\n<page>\n---\ntitle: Analytics · Cloudflare AI Gateway docs\ndescription: >-\n  Your AI Gateway dashboard shows metrics on requests, tokens, caching, errors,\n  and cost. You can filter these metrics by time.\n\nThese analytics help you understand traffic patterns, token consumption, and\n\npotential issues across AI providers. You can\n\nview the following analytics:\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/observability/analytics/\n  md: https://developers.cloudflare.com/ai-gateway/observability/analytics/index.md\n---\n\nYour AI Gateway dashboard shows metrics on requests, tokens, caching, errors, and cost. You can filter these metrics by time. These analytics help you understand traffic patterns, token consumption, and potential issues across AI providers. You can view the following analytics:\n\n* **Requests**: Track the total number of requests processed by AI Gateway.\n* **Token Usage**: Analyze token consumption across requests, giving insight into usage patterns.\n* **Costs**: Gain visibility into the costs associated with using different AI providers, allowing you to track spending, manage budgets, and optimize resources.\n* **Errors**: Monitor the number of errors across the gateway, helping to identify and troubleshoot issues.\n* **Cached Responses**: View the percentage of responses served from cache, which can help reduce costs and improve speed.\n\nTo view analytics in the dashboard:\n\n1. Log into the [Cloudflare dashboard](https://dash.cloudflare.com) and select your account.\n  2. Go to **AI** > **AI Gateway**.\n  3. Make sure you have your gateway selected.\n\nYou can use GraphQL to query your usage data outside of the AI Gateway dashboard. See the example query below. You will need to use your Cloudflare token when making the request, and change `{account_id}` to match your account tag.\n\n<page>\n---\ntitle: Costs · Cloudflare AI Gateway docs\ndescription: Cost metrics are only available for endpoints where the models\n  return token data and the model name in their responses.\nlastUpdated: 2025-05-15T16:26:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/observability/costs/\n  md: https://developers.cloudflare.com/ai-gateway/observability/costs/index.md\n---\n\nCost metrics are only available for endpoints where the models return token data and the model name in their responses.\n\n## Track costs across AI providers\n\nAI Gateway makes it easier to monitor and estimate token based costs across all your AI providers. This can help you:\n\n* Understand and compare usage costs between providers.\n* Monitor trends and estimate spend using consistent metrics.\n* Apply custom pricing logic to match negotiated rates.\n\nThe cost metric is an **estimation** based on the number of tokens sent and received in requests. While this metric can help you monitor and predict cost trends, refer to your provider's dashboard for the most **accurate** cost details.\n\nProviders may introduce new models or change their pricing. If you notice outdated cost data or are using a model not yet supported by our cost tracking, please [submit a request](https://forms.gle/8kRa73wRnvq7bxL48)\n\nAI Gateway allows users to set custom costs when operating under special pricing agreements or negotiated rates. Custom costs can be applied at the request level, and when applied, they will override the default or public model costs. For more information on configuration of custom costs, please visit the [Custom Costs](https://developers.cloudflare.com/ai-gateway/configuration/custom-costs/) configuration page.\n\n<page>\n---\ntitle: Custom metadata · Cloudflare AI Gateway docs\ndescription: Custom metadata in AI Gateway allows you to tag requests with user\n  IDs or other identifiers, enabling better tracking and analysis of your\n  requests. Metadata values can be strings, numbers, or booleans, and will\n  appear in your logs, making it easy to search and filter through your data.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/observability/custom-metadata/\n  md: https://developers.cloudflare.com/ai-gateway/observability/custom-metadata/index.md\n---\n\nCustom metadata in AI Gateway allows you to tag requests with user IDs or other identifiers, enabling better tracking and analysis of your requests. Metadata values can be strings, numbers, or booleans, and will appear in your logs, making it easy to search and filter through your data.\n\n* **Custom Tagging**: Add user IDs, team names, test indicators, and other relevant information to your requests.\n* **Enhanced Logging**: Metadata appears in your logs, allowing for detailed inspection and troubleshooting.\n* **Search and Filter**: Use metadata to efficiently search and filter through logged requests.\n\nAI Gateway allows you to pass up to five custom metadata entries per request. If more than five entries are provided, only the first five will be saved; additional entries will be ignored. Ensure your custom metadata is limited to five entries to avoid unprocessed or lost data.\n\n## Supported Metadata Types\n\n* String\n* Number\n* Boolean\n\nObjects are not supported as metadata values.\n\nTo include custom metadata in your request using cURL:\n\nTo include custom metadata in your request using the OpenAI SDK:\n\nTo include custom metadata in your request using [Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/):\n\n<page>\n---\ntitle: Logging · Cloudflare AI Gateway docs\ndescription: Logging is a fundamental building block for application\n  development. Logs provide insights during the early stages of development and\n  are often critical to understanding issues occurring in production.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/observability/logging/\n  md: https://developers.cloudflare.com/ai-gateway/observability/logging/index.md\n---\n\nLogging is a fundamental building block for application development. Logs provide insights during the early stages of development and are often critical to understanding issues occurring in production.\n\nYour AI Gateway dashboard shows logs of individual requests, including the user prompt, model response, provider, timestamp, request status, token usage, cost, and duration. These logs persist, giving you the flexibility to store them for your preferred duration and do more with valuable request data.\n\nBy default, each gateway can store up to 10 million logs. You can customize this limit per gateway in your gateway settings to align with your specific requirements. If your storage limit is reached, new logs will stop being saved. To continue saving logs, you must delete older logs to free up space for new logs. To learn more about your plan limits, refer to [Limits](https://developers.cloudflare.com/ai-gateway/reference/limits/).\n\nWe recommend using an authenticated gateway when storing logs to prevent unauthorized access and protects against invalid requests that can inflate log storage usage and make it harder to find the data you need. Learn more about setting up an [authenticated gateway](https://developers.cloudflare.com/ai-gateway/configuration/authentication/).\n\n## Default configuration\n\nLogs, which include metrics as well as request and response data, are enabled by default for each gateway. This logging behavior will be uniformly applied to all requests in the gateway. If you are concerned about privacy or compliance and want to turn log collection off, you can go to settings and opt out of logs. If you need to modify the log settings for specific requests, you can override this setting on a per-request basis.\n\nTo change the default log configuration in the dashboard:\n\n1. In the Cloudflare dashboard, go to the **AI Gateway** page.\n\n[Go to **AI Gateway**](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway)\n\n2. Select **Settings**.\n\n3. Change the **Logs** setting to your preference.\n\n## Per-request logging\n\nTo override the default logging behavior set in the settings tab, you can define headers on a per-request basis.\n\n### Collect logs (`cf-aig-collect-log`)\n\nThe `cf-aig-collect-log` header allows you to bypass the default log setting for the gateway. If the gateway is configured to save logs, the header will exclude the log for that specific request. Conversely, if logging is disabled at the gateway level, this header will save the log for that request.\n\nIn the example below, we use `cf-aig-collect-log` to bypass the default setting to avoid saving the log.\n\n## Managing log storage\n\nTo manage your log storage effectively, you can:\n\n* Set Storage Limits: Configure a limit on the number of logs stored per gateway in your gateway settings to ensure you only pay for what you need.\n* Enable Automatic Log Deletion: Activate the Automatic Log Deletion feature in your gateway settings to automatically delete the oldest logs once the log limit you've set or the default storage limit of 10 million logs is reached. This ensures new logs are always saved without manual intervention.\n\n## How to delete logs\n\nTo manage your log storage effectively and ensure continuous logging, you can delete logs using the following methods:\n\n### Automatic Log Deletion\n\n​To maintain continuous logging within your gateway's storage constraints, enable Automatic Log Deletion in your Gateway settings. This feature automatically deletes the oldest logs once the log limit you've set or the default storage limit of 10 million logs is reached, ensuring new logs are saved without manual intervention.\n\nTo manually delete logs through the dashboard, navigate to the Logs tab in the dashboard. Use the available filters such as status, cache, provider, cost, or any other options in the dropdown to refine the logs you wish to delete. Once filtered, select Delete logs to complete the action.\n\nSee full list of available filters and their descriptions below:\n\n| Filter category | Filter options | Filter by description |\n| - | - | - |\n| Status | error, status | error type or status. |\n| Cache | cached, not cached | based on whether they were cached or not. |\n| Provider | specific providers | the selected AI provider. |\n| AI Models | specific models | the selected AI model. |\n| Cost | less than, greater than | cost, specifying a threshold. |\n| Request type | Universal, Workers AI Binding, WebSockets | the type of request. |\n| Tokens | Total tokens, Tokens In, Tokens Out | token count (less than or greater than). |\n| Duration | less than, greater than | request duration. |\n| Feedback | equals, does not equal (thumbs up, thumbs down, no feedback) | feedback type. |\n| Metadata Key | equals, does not equal | specific metadata keys. |\n| Metadata Value | equals, does not equal | specific metadata values. |\n| Log ID | equals, does not equal | a specific Log ID. |\n| Event ID | equals, does not equal | a specific Event ID. |\n\nYou can programmatically delete logs using the AI Gateway API. For more comprehensive information on the `DELETE` logs endpoint, check out the [Cloudflare API documentation](https://developers.cloudflare.com/api/resources/ai_gateway/subresources/logs/methods/delete/).\n\n<page>\n---\ntitle: Audit logs · Cloudflare AI Gateway docs\ndescription: Audit logs provide a comprehensive summary of changes made within\n  your Cloudflare account, including those made to gateways in AI Gateway. This\n  functionality is available on all plan types, free of charge, and is enabled\n  by default.\nlastUpdated: 2025-09-05T08:34:36.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/reference/audit-logs/\n  md: https://developers.cloudflare.com/ai-gateway/reference/audit-logs/index.md\n---\n\n[Audit logs](https://developers.cloudflare.com/fundamentals/account/account-security/review-audit-logs/) provide a comprehensive summary of changes made within your Cloudflare account, including those made to gateways in AI Gateway. This functionality is available on all plan types, free of charge, and is enabled by default.\n\n## Viewing Audit Logs\n\nTo view audit logs for AI Gateway, in the Cloudflare dashboard, go to the **Audit logs** page.\n\n[Go to **Audit logs**](https://dash.cloudflare.com/?to=/:account/audit-log)\n\nFor more information on how to access and use audit logs, refer to [review audit logs documentation](https://developers.cloudflare.com/fundamentals/account/account-security/review-audit-logs/).\n\nThe following configuration actions are logged:\n\n| Operation | Description |\n| - | - |\n| gateway created | Creation of a new gateway. |\n| gateway deleted | Deletion of an existing gateway. |\n| gateway updated | Edit of an existing gateway. |\n\nBelow is an example of an audit log entry showing the creation of a new gateway:\n\n<page>\n---\ntitle: Limits · Cloudflare AI Gateway docs\ndescription: The following limits apply to gateway configurations, logs, and\n  related features in Cloudflare's platform.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/reference/limits/\n  md: https://developers.cloudflare.com/ai-gateway/reference/limits/index.md\n---\n\nThe following limits apply to gateway configurations, logs, and related features in Cloudflare's platform.\n\n| Feature | Limit |\n| - | - |\n| [Cacheable request size](https://developers.cloudflare.com/ai-gateway/features/caching/) | 25 MB per request |\n| [Cache TTL](https://developers.cloudflare.com/ai-gateway/features/caching/#cache-ttl-cf-aig-cache-ttl) | 1 month |\n| [Custom metadata](https://developers.cloudflare.com/ai-gateway/observability/custom-metadata/) | 5 entries per request |\n| [Datasets](https://developers.cloudflare.com/ai-gateway/evaluations/set-up-evaluations/) | 10 per gateway |\n| Gateways free plan | 10 per account |\n| Gateways paid plan | 20 per account |\n| Gateway name length | 64 characters |\n| Log storage rate limit | 500 logs per second per gateway |\n| Logs stored [paid plan](https://developers.cloudflare.com/ai-gateway/reference/pricing/) | 10 million per gateway 1 |\n| Logs stored [free plan](https://developers.cloudflare.com/ai-gateway/reference/pricing/) | 100,000 per account 2 |\n| [Log size stored](https://developers.cloudflare.com/ai-gateway/observability/logging/) | 10 MB per log 3 |\n| [Logpush jobs](https://developers.cloudflare.com/ai-gateway/observability/logging/logpush/) | 4 per account |\n| [Logpush size limit](https://developers.cloudflare.com/ai-gateway/observability/logging/logpush/) | 1MB per log |\n\n1 If you have reached 10 million logs stored per gateway, new logs will stop being saved. To continue saving logs, you must delete older logs in that gateway to free up space or create a new gateway. Refer to [Auto Log Cleanup](https://developers.cloudflare.com/ai-gateway/observability/logging/#auto-log-cleanup) for more details on how to automatically delete logs.\n\n2 If you have reached 100,000 logs stored per account, across all gateways, new logs will stop being saved. To continue saving logs, you must delete older logs. Refer to [Auto Log Cleanup](https://developers.cloudflare.com/ai-gateway/observability/logging/#auto-log-cleanup) for more details on how to automatically delete logs.\n\n3 Logs larger than 10 MB will not be stored.\n\nTo request an increase to a limit, complete the [Limit Increase Request Form](https://forms.gle/cuXu1QnQCrSNkkaS8). If the limit can be increased, Cloudflare will contact you with next steps.\n\n<page>\n---\ntitle: Pricing · Cloudflare AI Gateway docs\ndescription: AI Gateway is available to use on all plans.\nlastUpdated: 2025-11-10T11:01:10.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/reference/pricing/\n  md: https://developers.cloudflare.com/ai-gateway/reference/pricing/index.md\n---\n\nAI Gateway is available to use on all plans.\n\nAI Gateway's core features available today are offered for free, and all it takes is a Cloudflare account and one line of code to [get started](https://developers.cloudflare.com/ai-gateway/get-started/). Core features include: dashboard analytics, caching, and rate limiting.\n\nWe will continue to build and expand AI Gateway. Some new features may be additional core features that will be free while others may be part of a premium plan. We will announce these as they become available.\n\nYou can monitor your usage in the AI Gateway dashboard.\n\nPersistent logs are available on all plans, with a free allocation for both free and paid plans. Charges for additional logs beyond those limits are based on the number of logs stored per month.\n\n### Free allocation and overage pricing\n\n| Plan | Free logs stored | Overage pricing |\n| - | - | - |\n| Workers Free | 100,000 logs total | N/A - Upgrade to Workers Paid |\n| Workers Paid | 1,000,000 logs total | N/A |\n\nAllocations are based on the total logs stored across all gateways. For guidance on managing or deleting logs, please see our [documentation](https://developers.cloudflare.com/ai-gateway/observability/logging).\n\nLogpush is only available on the Workers Paid plan.\n\n| | Paid plan |\n| - | - |\n| Requests | 10 million / month, +$0.05/million |\n\nPrices subject to change. If you are an Enterprise customer, reach out to your account team to confirm pricing details.\n\n<page>\n---\ntitle: Create your first AI Gateway using Workers AI · Cloudflare AI Gateway docs\ndescription: This tutorial guides you through creating your first AI Gateway\n  using Workers AI on the Cloudflare dashboard.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/tutorials/create-first-aig-workers/\n  md: https://developers.cloudflare.com/ai-gateway/tutorials/create-first-aig-workers/index.md\n---\n\nThis tutorial guides you through creating your first AI Gateway using Workers AI on the Cloudflare dashboard. The intended audience is beginners who are new to AI Gateway and Workers AI. Creating an AI Gateway enables the user to efficiently manage and secure AI requests, allowing them to utilize AI models for tasks such as content generation, data processing, or predictive analysis with enhanced control and performance.\n\n## Sign up and log in\n\n1. **Sign up**: If you do not have a Cloudflare account, [sign up](https://cloudflare.com/sign-up).\n2. **Log in**: Access the Cloudflare dashboard by logging in to the [Cloudflare dashboard](https://dash.cloudflare.com/login).\n\nThen, create a new AI Gateway.\n\n[Create a Gateway](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway#create)\n\n1. Log into the [Cloudflare dashboard](https://dash.cloudflare.com/) and select your account.\n  2. Go to **AI** > **AI Gateway**.\n  3. Select **Create Gateway**.\n  4. Enter your **Gateway name**. Note: Gateway name has a 64 character limit.\n  5. Select **Create**.\n\nTo set up an AI Gateway using the API:\n\n1. [Create an API token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/) with the following permissions:\n\n* `AI Gateway - Read`\n     * `AI Gateway - Edit`\n\n2. Get your [Account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids/).\n\n3. Using that API token and Account ID, send a [`POST` request](https://developers.cloudflare.com/api/resources/ai_gateway/methods/create/) to the Cloudflare API.\n\n## Connect Your AI Provider\n\n1. In the AI Gateway section, select the gateway you created.\n2. Select **Workers AI** as your provider to set up an endpoint specific to Workers AI. You will receive an endpoint URL for sending requests.\n\n## Configure Your Workers AI\n\n1. Go to **AI** > **Workers AI** in the Cloudflare dashboard.\n\n2. Select **Use REST API** and follow the steps to create and copy the API token and Account ID.\n\n3. **Send Requests to Workers AI**: Use the provided API endpoint. For example, you can run a model via the API using a curl command. Replace `{account_id}`, `{gateway_id}` and `{cf_api_token}` with your actual account ID and API token:\n\nThe expected output would be similar to :\n\nMonitor your AI Gateway to view usage metrics.\n\n1. Go to **AI** > **AI Gateway** in the dashboard.\n2. Select your gateway to view metrics such as request counts, token usage, caching efficiency, errors, and estimated costs. You can also turn on additional configurations like logging and rate limiting.\n\n## Optional - Next steps\n\nTo build more with Workers, refer to [Tutorials](https://developers.cloudflare.com/workers/tutorials/).\n\nIf you have any questions, need assistance, or would like to share your project, join the Cloudflare Developer community on [Discord](https://discord.cloudflare.com) to connect with other developers and the Cloudflare team.\n\n<page>\n---\ntitle: Deploy a Worker that connects to OpenAI via AI Gateway · Cloudflare AI\n  Gateway docs\ndescription: Learn how to deploy a Worker that makes calls to OpenAI through AI Gateway\nlastUpdated: 2025-11-14T10:07:26.000Z\nchatbotDeprioritize: false\ntags: AI,JavaScript\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/tutorials/deploy-aig-worker/\n  md: https://developers.cloudflare.com/ai-gateway/tutorials/deploy-aig-worker/index.md\n---\n\nIn this tutorial, you will learn how to deploy a Worker that makes calls to OpenAI through AI Gateway. AI Gateway helps you better observe and control your AI applications with more analytics, caching, rate limiting, and logging.\n\nThis tutorial uses the most recent v4 OpenAI node library, an update released in August 2023.\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## 1. Create an AI Gateway and OpenAI API key\n\nOn the AI Gateway page in the Cloudflare dashboard, create a new AI Gateway by clicking the plus button on the top right. You should be able to name the gateway as well as the endpoint. Click on the API Endpoints button to copy the endpoint. You can choose from provider-specific endpoints such as OpenAI, HuggingFace, and Replicate. Or you can use the universal endpoint that accepts a specific schema and supports model fallback and retries.\n\nFor this tutorial, we will be using the OpenAI provider-specific endpoint, so select OpenAI in the dropdown and copy the new endpoint.\n\nYou will also need an OpenAI account and API key for this tutorial. If you do not have one, create a new OpenAI account and create an API key to continue with this tutorial. Make sure to store your API key somewhere safe so you can use it later.\n\n## 2. Create a new Worker\n\nCreate a Worker project in the command line:\n\nFor setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nGo to your new open Worker project:\n\nInside of your new openai-aig directory, find and open the `src/index.js` file. You will configure this file for most of the tutorial.\n\nInitially, your generated `index.js` file should look like this:\n\n## 3. Configure OpenAI in your Worker\n\nWith your Worker project created, we can learn how to make your first request to OpenAI. You will use the OpenAI node library to interact with the OpenAI API. Install the OpenAI node library with `npm`:\n\nIn your `src/index.js` file, add the import for `openai` above `export default`:\n\nWithin your `fetch` function, set up the configuration and instantiate your `OpenAIApi` client with the AI Gateway endpoint you created:\n\nTo make this work, you need to use [`wrangler secret put`](https://developers.cloudflare.com/workers/wrangler/commands/#secret-put) to set your `OPENAI_API_KEY`. This will save the API key to your environment so your Worker can access it when deployed. This key is the API key you created earlier in the OpenAI dashboard:\n\nTo make this work in local development, create a new file `.dev.vars` in your Worker project and add this line. Make sure to replace `OPENAI_API_KEY` with your own OpenAI API key:\n\n## 4. Make an OpenAI request\n\nNow we can make a request to the OpenAI [Chat Completions API](https://platform.openai.com/docs/guides/gpt/chat-completions-api).\n\nYou can specify what model you'd like, the role and prompt, as well as the max number of tokens you want in your total request.\n\n## 5. Deploy your Worker application\n\nTo deploy your application, run the `npx wrangler deploy` command to deploy your Worker application:\n\nYou can now preview your Worker at \\<YOUR\\_WORKER>.\\<YOUR\\_SUBDOMAIN>.workers.dev.\n\n## 6. Review your AI Gateway\n\nWhen you go to AI Gateway in your Cloudflare dashboard, you should see your recent request being logged. You can also [tweak your settings](https://developers.cloudflare.com/ai-gateway/configuration/) to manage your logs, caching, and rate limiting settings.\n\n<page>\n---\ntitle: Unified API (OpenAI compat) · Cloudflare AI Gateway docs\ndescription: Cloudflare's AI Gateway offers an OpenAI-compatible\n  /chat/completions endpoint, enabling integration with multiple AI providers\n  using a single URL. This feature simplifies the integration process, allowing\n  for seamless switching between different models without significant code\n  modifications.\nlastUpdated: 2025-12-08T07:14:56.000Z\nchatbotDeprioritize: false\ntags: AI\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/usage/chat-completion/\n  md: https://developers.cloudflare.com/ai-gateway/usage/chat-completion/index.md\n---\n\nCloudflare's AI Gateway offers an OpenAI-compatible `/chat/completions` endpoint, enabling integration with multiple AI providers using a single URL. This feature simplifies the integration process, allowing for seamless switching between different models without significant code modifications.\n\nReplace `{account_id}` and `{gateway_id}` with your Cloudflare account and gateway IDs.\n\nSwitch providers by changing the `model` and `apiKey` parameters.\n\nSpecify the model using `{provider}/{model}` format. For example:\n\n* `openai/gpt-5-mini`\n* `google-ai-studio/gemini-2.5-flash`\n* `anthropic/claude-sonnet-4-5`\n\n* With Authenticated Gateway\n\n* Unauthenticated Gateway\n\nWith Stored Keys (BYOK) / Unified Billing\n\n* With Authenticated Gateway\n\n* Unauthenticated Gateway\n\nWith Stored Keys (BYOK) / Unified Billing\n\n## Supported Providers\n\nThe OpenAI-compatible endpoint supports models from the following providers:\n\n* [Anthropic](https://developers.cloudflare.com/ai-gateway/usage/providers/anthropic/)\n* [OpenAI](https://developers.cloudflare.com/ai-gateway/usage/providers/openai/)\n* [Groq](https://developers.cloudflare.com/ai-gateway/usage/providers/groq/)\n* [Mistral](https://developers.cloudflare.com/ai-gateway/usage/providers/mistral/)\n* [Cohere](https://developers.cloudflare.com/ai-gateway/usage/providers/cohere/)\n* [Perplexity](https://developers.cloudflare.com/ai-gateway/usage/providers/perplexity/)\n* [Workers AI](https://developers.cloudflare.com/ai-gateway/usage/providers/workersai/)\n* [Google-AI-Studio](https://developers.cloudflare.com/ai-gateway/usage/providers/google-ai-studio/)\n* [Google Vertex AI](https://developers.cloudflare.com/ai-gateway/usage/providers/vertex/)\n* [xAI](https://developers.cloudflare.com/ai-gateway/usage/providers/grok/)\n* [DeepSeek](https://developers.cloudflare.com/ai-gateway/usage/providers/deepseek/)\n* [Cerebras](https://developers.cloudflare.com/ai-gateway/usage/providers/cerebras/)\n* [Baseten](https://developers.cloudflare.com/ai-gateway/usage/providers/baseten/)\n* [Parallel](https://developers.cloudflare.com/ai-gateway/usage/providers/parallel/)\n\n<page>\n---\ntitle: Universal Endpoint · Cloudflare AI Gateway docs\ndescription: You can use the Universal Endpoint to contact every provider.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/usage/universal/\n  md: https://developers.cloudflare.com/ai-gateway/usage/universal/index.md\n---\n\nIt is recommended to use the Dynamic Routes to implement model fallback feature\n\nYou can use the Universal Endpoint to contact every provider.\n\nAI Gateway offers multiple endpoints for each Gateway you create - one endpoint per provider, and one Universal Endpoint. The Universal Endpoint requires some adjusting to your schema, but supports additional features. Some of these features are, for example, retrying a request if it fails the first time, or configuring a [fallback model/provider](https://developers.cloudflare.com/ai-gateway/configuration/fallbacks/).\n\nYou can use the Universal endpoint to contact every provider. The payload is expecting an array of message, and each message is an object with the following parameters:\n\n* `provider` : the name of the provider you would like to direct this message to. Can be OpenAI, workers-ai, or any of our supported providers.\n* `endpoint`: the pathname of the provider API you’re trying to reach. For example, on OpenAI it can be `chat/completions`, and for Workers AI this might be [`@cf/meta/llama-3.1-8b-instruct`](https://developers.cloudflare.com/workers-ai/models/llama-3.1-8b-instruct/). See more in the sections that are specific to [each provider](https://developers.cloudflare.com/ai-gateway/usage/providers/).\n* `authorization`: the content of the Authorization HTTP Header that should be used when contacting this provider. This usually starts with 'Token' or 'Bearer'.\n* `query`: the payload as the provider expects it in their official API.\n\nThe above will send a request to Workers AI Inference API, if it fails it will proceed to OpenAI. You can add as many fallbacks as you need, just by adding another JSON in the array.\n\n## WebSockets API beta\n\nThe Universal Endpoint can also be accessed via a [WebSockets API](https://developers.cloudflare.com/ai-gateway/usage/websockets-api/) which provides a single persistent connection, enabling continuous communication. This API supports all AI providers connected to AI Gateway, including those that do not natively support WebSockets.\n\n## WebSockets example\n\n## Workers Binding example\n\n## Header configuration hierarchy\n\nThe Universal Endpoint allows you to set fallback models or providers and customize headers for each provider or request. You can configure headers at three levels:\n\n1. **Provider level**: Headers specific to a particular provider.\n2. **Request level**: Headers included in individual requests.\n3. **Gateway settings**: Default headers configured in your gateway dashboard.\n\nSince the same settings can be configured in multiple locations, AI Gateway applies a hierarchy to determine which configuration takes precedence:\n\n* **Provider-level headers** override all other configurations.\n* **Request-level headers** are used if no provider-level headers are set.\n* **Gateway-level settings** are used only if no headers are configured at the provider or request levels.\n\nThis hierarchy ensures consistent behavior, prioritizing the most specific configurations. Use provider-level and request-level headers for fine-tuned control, and gateway settings for general defaults.\n\nThis example demonstrates how headers set at different levels impact caching behavior:\n\n* **Request-level header**: The `cf-aig-cache-ttl` is set to `3600` seconds, applying this caching duration to the request by default.\n* **Provider-level header**: For the fallback provider (OpenAI), `cf-aig-cache-ttl` is explicitly set to `0` seconds, overriding the request-level header and disabling caching for responses when OpenAI is used as the provider.\n\nThis shows how provider-level headers take precedence over request-level headers, allowing for granular control of caching behavior.\n\n<page>\n---\ntitle: Provider Native · Cloudflare AI Gateway docs\ndescription: \"Here is a quick list of the providers we support:\"\nlastUpdated: 2025-08-27T13:32:22.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/usage/providers/\n  md: https://developers.cloudflare.com/ai-gateway/usage/providers/index.md\n---\n\nHere is a quick list of the providers we support:\n\n* [Amazon Bedrock](https://developers.cloudflare.com/ai-gateway/usage/providers/bedrock/)\n* [Anthropic](https://developers.cloudflare.com/ai-gateway/usage/providers/anthropic/)\n* [Azure OpenAI](https://developers.cloudflare.com/ai-gateway/usage/providers/azureopenai/)\n* [Baseten](https://developers.cloudflare.com/ai-gateway/usage/providers/baseten/)\n* [Cartesia](https://developers.cloudflare.com/ai-gateway/usage/providers/cartesia/)\n* [Cerebras](https://developers.cloudflare.com/ai-gateway/usage/providers/cerebras/)\n* [Cohere](https://developers.cloudflare.com/ai-gateway/usage/providers/cohere/)\n* [Deepgram](https://developers.cloudflare.com/ai-gateway/usage/providers/deepgram/)\n* [DeepSeek](https://developers.cloudflare.com/ai-gateway/usage/providers/deepseek/)\n* [ElevenLabs](https://developers.cloudflare.com/ai-gateway/usage/providers/elevenlabs/)\n* [Fal AI](https://developers.cloudflare.com/ai-gateway/usage/providers/fal/)\n* [Google AI Studio](https://developers.cloudflare.com/ai-gateway/usage/providers/google-ai-studio/)\n* [Google Vertex AI](https://developers.cloudflare.com/ai-gateway/usage/providers/vertex/)\n* [Groq](https://developers.cloudflare.com/ai-gateway/usage/providers/groq/)\n* [HuggingFace](https://developers.cloudflare.com/ai-gateway/usage/providers/huggingface/)\n* [Ideogram](https://developers.cloudflare.com/ai-gateway/usage/providers/ideogram/)\n* [Mistral AI](https://developers.cloudflare.com/ai-gateway/usage/providers/mistral/)\n* [OpenAI](https://developers.cloudflare.com/ai-gateway/usage/providers/openai/)\n* [OpenRouter](https://developers.cloudflare.com/ai-gateway/usage/providers/openrouter/)\n* [Parallel](https://developers.cloudflare.com/ai-gateway/usage/providers/parallel/)\n* [Perplexity](https://developers.cloudflare.com/ai-gateway/usage/providers/perplexity/)\n* [Replicate](https://developers.cloudflare.com/ai-gateway/usage/providers/replicate/)\n* [xAI](https://developers.cloudflare.com/ai-gateway/usage/providers/grok/)\n* [Workers AI](https://developers.cloudflare.com/ai-gateway/usage/providers/workersai/)\n\n<page>\n---\ntitle: WebSockets API · Cloudflare AI Gateway docs\ndescription: \"The AI Gateway WebSockets API provides a persistent connection for\n  AI interactions, eliminating repeated handshakes and reducing latency. This\n  API is divided into two categories:\"\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/usage/websockets-api/\n  md: https://developers.cloudflare.com/ai-gateway/usage/websockets-api/index.md\n---\n\nThe AI Gateway WebSockets API provides a persistent connection for AI interactions, eliminating repeated handshakes and reducing latency. This API is divided into two categories:\n\n* **Realtime APIs** - Designed for AI providers that offer low-latency, multimodal interactions over WebSockets.\n* **Non-Realtime APIs** - Supports standard WebSocket communication for AI providers, including those that do not natively support WebSockets.\n\n## When to use WebSockets\n\nWebSockets are long-lived TCP connections that enable bi-directional, real-time and non realtime communication between client and server. Unlike HTTP connections, which require repeated handshakes for each request, WebSockets maintain the connection, supporting continuous data exchange with reduced overhead. WebSockets are ideal for applications needing low-latency, real-time data, such as voice assistants.\n\n* **Reduced overhead**: Avoid overhead of repeated handshakes and TLS negotiations by maintaining a single, persistent connection.\n* **Provider compatibility**: Works with all AI providers in AI Gateway. Even if your chosen provider does not support WebSockets, Cloudflare handles it for you, managing the requests to your preferred AI provider.\n\n| Feature | Realtime APIs | Non-Realtime APIs |\n| - | - | - |\n| **Purpose** | Enables real-time, multimodal AI interactions for providers that offer dedicated WebSocket endpoints. | Supports WebSocket-based AI interactions with providers that do not natively support WebSockets. |\n| **Use Case** | Streaming responses for voice, video, and live interactions. | Text-based queries and responses, such as LLM requests. |\n| **AI Provider Support** | [Limited to providers offering real-time WebSocket APIs.](https://developers.cloudflare.com/ai-gateway/usage/websockets-api/realtime-api/#supported-providers) | [All AI providers in AI Gateway.](https://developers.cloudflare.com/ai-gateway/usage/providers/) |\n| **Streaming Support** | Providers natively support real-time data streaming. | AI Gateway handles streaming via WebSockets. |\n\nFor details on implementation, refer to the next sections:\n\n* [Realtime WebSockets API](https://developers.cloudflare.com/ai-gateway/usage/websockets-api/realtime-api/)\n* [Non-Realtime WebSockets API](https://developers.cloudflare.com/ai-gateway/usage/websockets-api/non-realtime-api/)\n\n<page>\n---\ntitle: Agents API · Cloudflare Agents docs\ndescription: This page provides an overview of the Agent SDK API, including the\n  Agent class, methods and properties built-in to the Agents SDK.\nlastUpdated: 2025-12-12T16:34:43.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/agents-api/\n  md: https://developers.cloudflare.com/agents/api-reference/agents-api/index.md\n---\n\nThis page provides an overview of the Agent SDK API, including the `Agent` class, methods and properties built-in to the Agents SDK.\n\nThe Agents SDK exposes two main APIs:\n\n* The server-side `Agent` class. An Agent encapsulates all of the logic for an Agent, including how clients can connect to it, how it stores state, the methods it exposes, how to call AI models, and any error handling.\n* The client-side `AgentClient` class, which allows you to connect to an Agent instance from a client-side application. The client APIs also include React hooks, including `useAgent` and `useAgentChat`, and allow you to automatically synchronize state between each unique Agent (running server-side) and your client applications.\n\nAgents require [Cloudflare Durable Objects](https://developers.cloudflare.com/durable-objects/), see [Configuration](https://developers.cloudflare.com/agents/getting-started/testing-your-agent/#add-the-agent-configuration) to learn how to add the required bindings to your project.\n\nYou can also find more specific usage examples for each API in the [Agents API Reference](https://developers.cloudflare.com/agents/api-reference/).\n\nAn Agent can have many (millions of) instances: each instance is a separate micro-server that runs independently of the others. This allows Agents to scale horizontally: an Agent can be associated with a single user, or many thousands of users, depending on the agent you're building.\n\nInstances of an Agent are addressed by a unique identifier: that identifier (ID) can be the user ID, an email address, GitHub username, a flight ticket number, an invoice ID, or any other identifier that helps to uniquely identify the instance and for whom it is acting on behalf of.\n\nAn instance of an Agent is globally unique: given the same name (or ID), you will always get the same instance of an agent.\n\nThis allows you to avoid synchronizing state across requests: if an Agent instance represents a specific user, team, channel or other entity, you can use the Agent instance to store state for that entity. No need to set up a centralized session store.\n\nIf the client disconnects, you can always route the client back to the exact same Agent and pick up where they left off.\n\nWriting an Agent requires you to define a class that extends the `Agent` class from the Agents SDK package. An Agent encapsulates all of the logic for an Agent, including how clients can connect to it, how it stores state, the methods it exposes, and any error handling.\n\nYou can also define your own methods on an Agent: it's technically valid to publish an Agent that only has your own methods exposed, and create/get Agents directly from a Worker.\n\nYour own methods can access the Agent's environment variables and bindings on `this.env`, state on `this.setState`, and call other methods on the Agent via `this.yourMethodName`.\n\nThe WebSocket API allows you to accept and manage WebSocket connections made to an Agent.\n\nRepresents a WebSocket connection to an Agent.\n\nTypes of messages that can be received from a WebSocket.\n\n#### ConnectionContext\n\nContext information for a WebSocket connection.\n\n### State synchronization API\n\nTo learn more about how to manage state within an Agent, refer to the documentation on [managing and syncing state](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/).\n\nMethods and types for managing Agent state.\n\n#### Scheduling tasks\n\nSchedule tasks to run at a specified time in the future.\n\nRepresents a scheduled task.\n\nEach Agent instance has an embedded SQLite database that can be accessed using the `this.sql` method within any method on your `Agent` class.\n\nExecute SQL queries against the Agent's built-in SQLite database using the `this.sql` method within any method on your `Agent` class.\n\nVisit the [state management API documentation](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) within the Agents SDK, including the native `state` APIs and the built-in `this.sql` API for storing and querying data within your Agents.\n\nThe Agents SDK allows your Agent to act as an MCP (Model Context Protocol) client, connecting to remote MCP servers and using their tools, resources, and prompts.\n\nWhen your Agent connects to MCP servers, it can dynamically discover and use tools provided by those servers, enabling powerful integrations with external services.\n\nFor complete MCP client API documentation, including OAuth configuration and advanced usage, refer to the [Agent — MCP Client API](https://developers.cloudflare.com/agents/model-context-protocol/mcp-client-api/).\n\nThe Agents SDK provides a set of client APIs for interacting with Agents from client-side JavaScript code, including:\n\n* React hooks, including `useAgent` and `useAgentChat`, for connecting to Agents from client applications.\n* Client-side [state syncing](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) that allows you to subscribe to state updates between the Agent and any connected client(s) when calling `this.setState` within your Agent's code.\n* The ability to call remote methods (Remote Procedure Calls; RPC) on the Agent from client-side JavaScript code using the `@callable` method decorator.\n\nClient for connecting to an Agent from the browser.\n\nMake an HTTP request to an Agent.\n\nThe Agents SDK provides a React API for simplifying connection and routing to Agents from front-end frameworks, including React Router (Remix), Next.js, and Astro.\n\nReact hook for connecting to an Agent.\n\nThe Agents SDK exposes an `AIChatAgent` class that extends the `Agent` class and exposes an `onChatMessage` method that simplifies building interactive chat agents.\n\nYou can combine this with the `useAgentChat` React hook from the `agents/ai-react` package to manage chat state and messages between a user and your Agent(s).\n\nExtension of the `Agent` class with built-in chat capabilities.\n\n#### Resumable streaming\n\nThe `AIChatAgent` class provides **automatic resumable streaming** out of the box. When a client disconnects and reconnects during an active stream, the response automatically resumes from where it left off. This works across browser tabs and devices.\n\nWhen you use `AIChatAgent` with `useAgentChat`:\n\n1. **During streaming**: All chunks are automatically persisted to SQLite\n2. **On disconnect**: The stream continues server-side, buffering chunks\n3. **On reconnect**: Client receives all buffered chunks and continues streaming\n\n##### Disabling resume\n\nIf you don't want automatic resume (for example, for short responses), disable it:\n\n### Chat Agent React API\n\nReact hook for building AI chat interfaces using an Agent.\n\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n<page>\n---\ntitle: Browse the web · Cloudflare Agents docs\ndescription: Agents can browse the web using the Browser Rendering API or your\n  preferred headless browser service.\nlastUpdated: 2025-05-16T16:37:37.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/browse-the-web/\n  md: https://developers.cloudflare.com/agents/api-reference/browse-the-web/index.md\n---\n\nAgents can browse the web using the [Browser Rendering](https://developers.cloudflare.com/browser-rendering/) API or your preferred headless browser service.\n\n### Browser Rendering API\n\nThe [Browser Rendering](https://developers.cloudflare.com/browser-rendering/) allows you to spin up headless browser instances, render web pages, and interact with websites through your Agent.\n\nYou can define a method that uses Puppeteer to pull the content of a web page, parse the DOM, and extract relevant information by calling the OpenAI model:\n\nYou'll also need to add install the `@cloudflare/puppeteer` package and add the following to the wrangler configuration of your Agent:\n\nYou can also use [Browserbase](https://docs.browserbase.com/integrations/cloudflare/typescript) by using the Browserbase API directly from within your Agent.\n\nOnce you have your [Browserbase API key](https://docs.browserbase.com/integrations/cloudflare/typescript), you can add it to your Agent by creating a [secret](https://developers.cloudflare.com/workers/configuration/secrets/):\n\nInstall the `@cloudflare/puppeteer` package and use it from within your Agent to call the Browserbase API:\n\n<page>\n---\ntitle: Calling Agents · Cloudflare Agents docs\ndescription: Learn how to call your Agents from Workers, including how to create\n  Agents on-the-fly, address them, and route requests to specific instances of\n  an Agent.\nlastUpdated: 2025-08-27T15:01:29.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/calling-agents/\n  md: https://developers.cloudflare.com/agents/api-reference/calling-agents/index.md\n---\n\nLearn how to call your Agents from Workers, including how to create Agents on-the-fly, address them, and route requests to specific instances of an Agent.\n\n### Calling your Agent\n\nAgents are created on-the-fly and can serve multiple requests concurrently. Each Agent instance is isolated from other instances, can maintain its own state, and has a unique address.\n\nAn instance of an Agent is globally unique: given the same name (or ID), you will always get the same instance of an agent.\n\nThis allows you to avoid synchronizing state across requests: if an Agent instance represents a specific user, team, channel or other entity, you can use the Agent instance to store state for that entity. No need to set up a centralized session store.\n\nIf the client disconnects, you can always route the client back to the exact same Agent and pick up where they left off.\n\nYou can create and run an instance of an Agent directly from a Worker using either:\n\n* The `routeAgentRequest` helper: this will automatically map requests to an individual Agent based on the `/agents/:agent/:name` URL pattern. The value of `:agent` will be the name of your Agent class converted to `kebab-case`, and the value of `:name` will be the name of the Agent instance you want to create or retrieve.\n* `getAgentByName`, which will create a new Agent instance if none exists by that name, or retrieve a handle to an existing instance.\n\nSee the usage patterns in the following example:\n\nYou can also call other Agents from within an Agent and build multi-Agent systems.\n\nCalling other Agents uses the same APIs as calling into an Agent directly.\n\n### Calling methods on Agents\n\nWhen using `getAgentByName`, you can pass both requests (including WebSocket) connections and call methods defined directly on the Agent itself using the native [JavaScript RPC](https://developers.cloudflare.com/workers/runtime-apis/rpc/) (JSRPC) API.\n\nFor example, once you have a handle (or \"stub\") to an unique instance of your Agent, you can call methods on it:\n\nWhen using TypeScript, ensure you pass your Agent class as a TypeScript type parameter to the AgentNamespace type so that types are correctly inferred:\n\n### Naming your Agents\n\nWhen creating names for your Agents, think about what the Agent represents. A unique user? A team or company? A room or channel for collaboration?\n\nA consistent approach to naming allows you to:\n\n* direct incoming requests directly to the right Agent\n* deterministically route new requests back to that Agent, no matter where the client is in the world.\n* avoid having to rely on centralized session storage or external services for state management, since each Agent instance can maintain its own state.\n\nFor a given Agent definition (or 'namespace' in the code below), there can be millions (or tens of millions) of instances of that Agent, each handling their own requests, making calls to LLMs, and maintaining their own state.\n\nFor example, you might have an Agent for every user using your new AI-based code editor. In that case, you'd want to create Agents based on the user ID from your system, which would then allow that Agent to handle all requests for that user.\n\nIt also ensures that [state within the Agent](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/), including chat history, language preferences, model configuration and other context can associated specifically with that user, making it easier to manage state.\n\nThe example below shows how to create a unique agent Agent for each `userId` in a request:\n\nReplace `userId` with `teamName`, `channel`, `companyName` as fits your Agents goals - and/or configure authentication to ensure Agents are only created for known, authenticated users.\n\n### Authenticating Agents\n\nWhen building and deploying Agents using the Agents SDK, you will often want to authenticate clients before passing requests to an Agent in order to restrict who the Agent will call, authorize specific users for specific Agents, and/or to limit who can access administrative or debug APIs exposed by an Agent.\n\n* Handle authentication in your Workers code, before you invoke your Agent.\n* Use the built-in hooks when using the `routeAgentRequest` helper - `onBeforeConnect` and `onBeforeRequest`\n* Use your preferred router (such as Hono) and authentication middleware or provider to apply custom authentication schemes before calling an Agent using other methods.\n\nThe `routeAgentRequest` helper documented earlier in this guide exposes two useful hooks (`onBeforeConnect`, `onBeforeRequest`) that allow you to apply custom logic before creating or retrieving an Agent:\n\nIf you are using `getAgentByName` or the underlying Durable Objects routing API, you should authenticate incoming requests or WebSocket connections before calling `getAgentByName`.\n\nFor example, if you are using [Hono](https://hono.dev/), you can authenticate in the middleware before calling an Agent and passing a request (or a WebSocket connection) to it:\n\nThis ensures we only create Agents for authenticated users, and allows you to validate whether Agent names conform to your preferred naming scheme before instances are created.\n\n* Review the [API documentation](https://developers.cloudflare.com/agents/api-reference/agents-api/) for the Agents class to learn how to define\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n<page>\n---\ntitle: Configuration · Cloudflare Agents docs\ndescription: An Agent is configured like any other Cloudflare Workers project,\n  and uses a wrangler configuration file to define where your code is and what\n  services (bindings) it will use.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/configuration/\n  md: https://developers.cloudflare.com/agents/api-reference/configuration/index.md\n---\n\nAn Agent is configured like any other Cloudflare Workers project, and uses [a wrangler configuration](https://developers.cloudflare.com/workers/wrangler/configuration/) file to define where your code is and what services (bindings) it will use.\n\n### Project structure\n\nThe typical file structure for an Agent project created from `npm create cloudflare@latest agents-starter -- --template cloudflare/agents-starter` follows:\n\n### Example configuration\n\nBelow is a minimal `wrangler.jsonc` file that defines the configuration for an Agent, including the entry point, `durable_object` namespace, and code `migrations`:\n\nThe configuration includes:\n\n* A `main` field that points to the entry point of your Agent, which is typically a TypeScript (or JavaScript) file.\n* A `durable_objects` field that defines the [Durable Object namespace](https://developers.cloudflare.com/durable-objects/reference/glossary/) that your Agents will run within.\n* A `migrations` field that defines the code migrations that your Agent will use. This field is mandatory and must contain at least one migration. The `new_sqlite_classes` field is mandatory for the Agent to store state.\n\nAgents must define these fields in their `wrangler.jsonc` (or `wrangler.toml`) config file.\n\n<page>\n---\ntitle: HTTP and Server-Sent Events · Cloudflare Agents docs\ndescription: The Agents SDK allows you to handle HTTP requests and has native\n  support for Server-Sent Events (SSE). This allows you build applications that\n  can push data to clients and avoid buffering.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/http-sse/\n  md: https://developers.cloudflare.com/agents/api-reference/http-sse/index.md\n---\n\nThe Agents SDK allows you to handle HTTP requests and has native support for [Server-Sent Events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) (SSE). This allows you build applications that can push data to clients and avoid buffering.\n\n### Handling HTTP requests\n\nAgents can handle HTTP requests using the `onRequest` method, which is called whenever an HTTP request is received by the Agent instance. The method takes a `Request` object as a parameter and returns a `Response` object.\n\nReview the [Agents API reference](https://developers.cloudflare.com/agents/api-reference/agents-api/) to learn more about the `Agent` class and its methods.\n\n### Implementing Server-Sent Events\n\nThe Agents SDK support Server-Sent Events directly: you can use SSE to stream data back to the client over a long running connection. This avoids buffering large responses, which can both make your Agent feel slow, and forces you to buffer the entire response in memory.\n\nWhen an Agent is deployed to Cloudflare Workers, there is no effective limit on the total time it takes to stream the response back: large AI model responses that take several minutes to reason and then respond will not be prematurely terminated.\n\nNote that this does not mean the client can't potentially disconnect during the streaming process: you can account for this by either [writing to the Agent's stateful storage](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) and/or [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/). Because you can always [route to the same Agent](https://developers.cloudflare.com/agents/api-reference/calling-agents/), you do not need to use a centralized session store to pick back up where you left off when a client disconnects.\n\nThe following example uses the AI SDK to generate text and stream it back to the client. It will automatically stream the response back to the client as the model generates it:\n\n### WebSockets vs. Server-Sent Events\n\nBoth WebSockets and Server-Sent Events (SSE) enable real-time communication between clients and Agents. Agents built on the Agents SDK can expose both WebSocket and SSE endpoints directly.\n\n* WebSockets provide full-duplex communication, allowing data to flow in both directions simultaneously. SSE only supports server-to-client communication, requiring additional HTTP requests if the client needs to send data back.\n* WebSockets establish a single persistent connection that stays open for the duration of the session. SSE, being built on HTTP, may experience more overhead due to reconnection attempts and header transmission with each reconnection, especially when there is a lot of client-server communication.\n* While SSE works well for simple streaming scenarios, WebSockets are better suited for applications requiring minutes or hours of connection time, as they maintain a more stable connection with built-in ping/pong mechanisms to keep connections alive.\n* WebSockets use their own protocol (ws\\:// or wss\\://), separating them from HTTP after the initial handshake. This separation allows WebSockets to better handle binary data transmission and implement custom subprotocols for specialized use cases.\n\nIf you're unsure of which is better for your use-case, we recommend WebSockets. The [WebSockets API documentation](https://developers.cloudflare.com/agents/api-reference/websockets/) provides detailed information on how to use WebSockets with the Agents SDK.\n\n* Review the [API documentation](https://developers.cloudflare.com/agents/api-reference/agents-api/) for the Agents class to learn how to define them.\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n<page>\n---\ntitle: Retrieval Augmented Generation · Cloudflare Agents docs\ndescription: Agents can use Retrieval Augmented Generation (RAG) to retrieve\n  relevant information and use it augment calls to AI models. Store a user's\n  chat history to use as context for future conversations, summarize documents\n  to bootstrap an Agent's knowledge base, and/or use data from your Agent's web\n  browsing tasks to enhance your Agent's capabilities.\nlastUpdated: 2025-05-14T14:20:47.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/rag/\n  md: https://developers.cloudflare.com/agents/api-reference/rag/index.md\n---\n\nAgents can use Retrieval Augmented Generation (RAG) to retrieve relevant information and use it augment [calls to AI models](https://developers.cloudflare.com/agents/api-reference/using-ai-models/). Store a user's chat history to use as context for future conversations, summarize documents to bootstrap an Agent's knowledge base, and/or use data from your Agent's [web browsing](https://developers.cloudflare.com/agents/api-reference/browse-the-web/) tasks to enhance your Agent's capabilities.\n\nYou can use the Agent's own [SQL database](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state) as the source of truth for your data and store embeddings in [Vectorize](https://developers.cloudflare.com/vectorize/) (or any other vector-enabled database) to allow your Agent to retrieve relevant information.\n\nIf you're brand-new to vector databases and Vectorize, visit the [Vectorize tutorial](https://developers.cloudflare.com/vectorize/get-started/intro/) to learn the basics, including how to create an index, insert data, and generate embeddings.\n\nYou can query a vector index (or indexes) from any method on your Agent: any Vectorize index you attach is available on `this.env` within your Agent. If you've [associated metadata](https://developers.cloudflare.com/vectorize/best-practices/insert-vectors/#metadata) with your vectors that maps back to data stored in your Agent, you can then look up the data directly within your Agent using `this.sql`.\n\nHere's an example of how to give an Agent retrieval capabilities:\n\nYou'll also need to connect your Agent to your vector indexes:\n\nIf you have multiple indexes you want to make available, you can provide an array of `vectorize` bindings.\n\n* Learn more on how to [combine Vectorize and Workers AI](https://developers.cloudflare.com/vectorize/get-started/embeddings/)\n* Review the [Vectorize query API](https://developers.cloudflare.com/vectorize/reference/client-api/)\n* Use [metadata filtering](https://developers.cloudflare.com/vectorize/reference/metadata-filtering/) to add context to your results\n\n<page>\n---\ntitle: Run Workflows · Cloudflare Agents docs\ndescription: Agents can trigger asynchronous Workflows, allowing your Agent to\n  run complex, multi-step tasks in the background. This can include\n  post-processing files that a user has uploaded, updating the embeddings in a\n  vector database, and/or managing long-running user-lifecycle email or SMS\n  notification workflows.\nlastUpdated: 2025-05-14T14:20:47.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/run-workflows/\n  md: https://developers.cloudflare.com/agents/api-reference/run-workflows/index.md\n---\n\nAgents can trigger asynchronous [Workflows](https://developers.cloudflare.com/workflows/), allowing your Agent to run complex, multi-step tasks in the background. This can include post-processing files that a user has uploaded, updating the embeddings in a [vector database](https://developers.cloudflare.com/vectorize/), and/or managing long-running user-lifecycle email or SMS notification workflows.\n\nBecause an Agent is just like a Worker script, it can create Workflows defined in the same project (script) as the Agent *or* in a different project.\n\nAgents and Workflows have some similarities: they can both run tasks asynchronously. For straightforward tasks that are linear or need to run to completion, a Workflow can be ideal: steps can be retried, they can be cancelled, and can act on events.\n\nAgents do not have to run to completion: they can loop, branch and run forever, and they can also interact directly with users (over HTTP or WebSockets). An Agent can be used to trigger multiple Workflows as it runs, and can thus be used to co-ordinate and manage Workflows to achieve its goals.\n\n## Trigger a Workflow\n\nAn Agent can trigger one or more Workflows from within any method, whether from an incoming HTTP request, a WebSocket connection, on a delay or schedule, and/or from any other action the Agent takes.\n\nTriggering a Workflow from an Agent is no different from [triggering a Workflow from a Worker script](https://developers.cloudflare.com/workflows/build/trigger-workflows/):\n\nYou'll also need to make sure your Agent [has a binding to your Workflow](https://developers.cloudflare.com/workflows/build/trigger-workflows/#workers-api-bindings) so that it can call it:\n\n## Trigger a Workflow from another project\n\nYou can also call a Workflow that is defined in a different Workers script from your Agent by setting the `script_name` property in the `workflows` binding of your Agent:\n\nRefer to the [cross-script calls](https://developers.cloudflare.com/workflows/build/workers-api/#cross-script-calls) section of the Workflows documentation for more examples.\n\n<page>\n---\ntitle: Schedule tasks · Cloudflare Agents docs\ndescription: An Agent can schedule tasks to be run in the future by calling\n  this.schedule(when, callback, data), where when can be a delay, a Date, or a\n  cron string; callback the function name to call, and data is an object of data\n  to pass to the function.\nlastUpdated: 2025-09-24T13:21:38.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/schedule-tasks/\n  md: https://developers.cloudflare.com/agents/api-reference/schedule-tasks/index.md\n---\n\nAn Agent can schedule tasks to be run in the future by calling `this.schedule(when, callback, data)`, where `when` can be a delay, a `Date`, or a cron string; `callback` the function name to call, and `data` is an object of data to pass to the function.\n\nScheduled tasks can do anything a request or message from a user can: make requests, query databases, send emails, read+write state: scheduled tasks can invoke any regular method on your Agent.\n\nYou can call `this.schedule` within any method on an Agent, and schedule tens-of-thousands of tasks per individual Agent:\n\nTasks that set a callback for a method that does not exist will throw an exception: ensure that the method named in the `callback` argument of `this.schedule` exists on your `Agent` class.\n\nYou can schedule tasks in multiple ways:\n\nCalling `await this.schedule` returns a `Schedule`, which includes the task's randomly generated `id`. You can use this `id` to retrieve or cancel the task in the future. It also provides a `type` property that indicates the type of schedule, for example, one of `\"scheduled\" | \"delayed\" | \"cron\"`.\n\nMaximum scheduled tasks\n\nEach task is mapped to a row in the Agent's underlying [SQLite database](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/), which means that each task can be up to 2 MB in size. The maximum number of tasks must be `(task_size * tasks) + all_other_state < maximum_database_size` (currently 1GB per Agent).\n\n### Managing scheduled tasks\n\nYou can get, cancel and filter across scheduled tasks within an Agent using the scheduling API:\n\n<page>\n---\ntitle: Store and sync state · Cloudflare Agents docs\ndescription: Every Agent has built-in state management capabilities, including\n  built-in storage and synchronization between the Agent and frontend\n  applications.\nlastUpdated: 2025-10-23T15:22:15.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/\n  md: https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/index.md\n---\n\nEvery Agent has built-in state management capabilities, including built-in storage and synchronization between the Agent and frontend applications.\n\nState within an Agent is:\n\n* Persisted across Agent restarts: data is permanently stored within an Agent.\n* Automatically serialized/deserialized: you can store any JSON-serializable data.\n* Immediately consistent within the Agent: read your own writes.\n* Thread-safe for concurrent updates\n* Fast: state is colocated wherever the Agent is running. Reads and writes do not need to traverse the network.\n\nAgent state is stored in a SQL database that is embedded within each individual Agent instance: you can interact with it using the higher-level `this.setState` API (recommended), which allows you to sync state and trigger events on state changes, or by directly querying the database with `this.sql`.\n\nEvery Agent has built-in state management capabilities. You can set and update the Agent's state directly using `this.setState`:\n\nIf you're using TypeScript, you can also provide a type for your Agent's state by passing in a type as a [type parameter](https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints) as the *second* type parameter to the `Agent` class definition.\n\n### Set the initial state for an Agent\n\nYou can also set the initial state for an Agent via the `initialState` property on the `Agent` class:\n\nAny initial state is synced to clients connecting via [the `useAgent` hook](#synchronizing-state).\n\n### Synchronizing state\n\nClients can connect to an Agent and stay synchronized with its state using the React hooks provided as part of `agents/react`.\n\nA React application can call `useAgent` to connect to a named Agent over WebSockets at\n\nThe state synchronization system:\n\n* Automatically syncs the Agent's state to all connected clients\n* Handles client disconnections and reconnections gracefully\n* Provides immediate local updates\n* Supports multiple simultaneous client connections\n\n* Real-time collaborative features\n* Multi-window/tab synchronization\n* Live updates across multiple devices\n* Maintaining consistent UI state across clients\n* When new clients connect, they automatically receive the current state from the Agent, ensuring all clients start with the latest data.\n\nEvery individual Agent instance has its own SQL (SQLite) database that runs *within the same context* as the Agent itself. This means that inserting or querying data within your Agent is effectively zero-latency: the Agent doesn't have to round-trip across a continent or the world to access its own data.\n\nYou can access the SQL API within any method on an Agent via `this.sql`. The SQL API accepts template literals, and\n\nYou can also supply a [TypeScript type argument](https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints) to the query, which will be used to infer the type of the result:\n\nYou do not need to specify an array type (`User[]` or `Array<User>`) as `this.sql` will always return an array of the specified type.\n\nProviding a type parameter does not validate that the result matches your type definition. In TypeScript, properties (fields) that do not exist or conform to the type you provided will be dropped. If you need to validate incoming events, we recommend a library such as [zod](https://zod.dev/) or your own validator logic.\n\nLearn more about the zero-latency SQL storage that powers both Agents and Durable Objects [on our blog](https://blog.cloudflare.com/sqlite-in-durable-objects/).\n\nThe SQL API exposed to an Agent is similar to the one [within Durable Objects](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/#sql-api): Durable Object SQL methods available on `this.ctx.storage.sql`. You can use the same SQL queries with the Agent's database, create tables, and query data, just as you would with Durable Objects or [D1](https://developers.cloudflare.com/d1/).\n\n### Use Agent state as model context\n\nYou can combine the state and SQL APIs in your Agent with its ability to [call AI models](https://developers.cloudflare.com/agents/api-reference/using-ai-models/) to include historical context within your prompts to a model. Modern Large Language Models (LLMs) often have very large context windows (up to millions of tokens), which allows you to pull relevant context into your prompt directly.\n\nFor example, you can use an Agent's built-in SQL database to pull history, query a model with it, and append to that history ahead of the next call to the model:\n\nThis works because each instance of an Agent has its *own* database, the state stored in that database is private to that Agent: whether it's acting on behalf of a single user, a room or channel, or a deep research tool. By default, you don't have to manage contention or reach out over the network to a centralized database to retrieve and store state.\n\n* Review the [API documentation](https://developers.cloudflare.com/agents/api-reference/agents-api/) for the Agents class to learn how to define them.\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n<page>\n---\ntitle: Using AI Models · Cloudflare Agents docs\ndescription: \"Agents can communicate with AI models hosted on any provider, including:\"\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\ntags: AI\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/using-ai-models/\n  md: https://developers.cloudflare.com/agents/api-reference/using-ai-models/index.md\n---\n\nAgents can communicate with AI models hosted on any provider, including:\n\n* [Workers AI](https://developers.cloudflare.com/workers-ai/)\n* The [AI SDK](https://sdk.vercel.ai/docs/ai-sdk-core/overview)\n* [OpenAI](https://platform.openai.com/docs/quickstart?language=javascript)\n* [Anthropic](https://docs.anthropic.com/en/api/client-sdks#typescript)\n* [Google's Gemini](https://ai.google.dev/gemini-api/docs/openai)\n\nYou can also use the model routing features in [AI Gateway](https://developers.cloudflare.com/ai-gateway/) to route across providers, eval responses, and manage AI provider rate limits.\n\nBecause Agents are built on top of [Durable Objects](https://developers.cloudflare.com/durable-objects/), each Agent or chat session is associated with a stateful compute instance. Traditional serverless architectures often present challenges for persistent connections needed in real-time applications like chat.\n\nA user can disconnect during a long-running response from a modern reasoning model (such as `o3-mini` or DeepSeek R1), or lose conversational context when refreshing the browser. Instead of relying on request-response patterns and managing an external database to track & store conversation state, state can be stored directly within the Agent. If a client disconnects, the Agent can write to its own distributed storage, and catch the client up as soon as it reconnects: even if it's hours or days later.\n\nYou can call models from any method within an Agent, including from HTTP requests using the [`onRequest`](https://developers.cloudflare.com/agents/api-reference/agents-api/) handler, when a [scheduled task](https://developers.cloudflare.com/agents/api-reference/schedule-tasks/) runs, when handling a WebSocket message in the [`onMessage`](https://developers.cloudflare.com/agents/api-reference/websockets/) handler, or from any of your own methods.\n\nImportantly, Agents can call AI models on their own — autonomously — and can handle long-running responses that can take minutes (or longer) to respond in full.\n\n### Long-running model requests\n\nModern [reasoning models](https://platform.openai.com/docs/guides/reasoning) or \"thinking\" model can take some time to both generate a response *and* stream the response back to the client.\n\nInstead of buffering the entire response, or risking the client disconnecting, you can stream the response back to the client by using the [WebSocket API](https://developers.cloudflare.com/agents/api-reference/websockets/).\n\nYou can also persist AI model responses back to [Agent's internal state](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) by using the `this.setState` method. For example, if you run a [scheduled task](https://developers.cloudflare.com/agents/api-reference/schedule-tasks/), you can store the output of the task and read it later. Or, if a user disconnects, read the message history back and send it to the user when they reconnect.\n\nYou can use [any of the models available in Workers AI](https://developers.cloudflare.com/workers-ai/models/) within your Agent by [configuring a binding](https://developers.cloudflare.com/workers-ai/configuration/bindings/).\n\nWorkers AI supports streaming responses out-of-the-box by setting `stream: true`, and we strongly recommend using them to avoid buffering and delaying responses, especially for larger models or reasoning models that require more time to generate a response.\n\nYour Wrangler configuration will need an `ai` binding added:\n\nYou can also use the model routing features in [AI Gateway](https://developers.cloudflare.com/ai-gateway/) directly from an Agent by specifying a [`gateway` configuration](https://developers.cloudflare.com/ai-gateway/usage/providers/workersai/) when calling the AI binding.\n\nModel routing allows you to route requests to different AI models based on whether they are reachable, rate-limiting your client, and/or if you've exceeded your cost budget for a specific provider.\n\nYour Wrangler configuration will need an `ai` binding added. This is shared across both Workers AI and AI Gateway.\n\nVisit the [AI Gateway documentation](https://developers.cloudflare.com/ai-gateway/) to learn how to configure a gateway and retrieve a gateway ID.\n\nThe [AI SDK](https://sdk.vercel.ai/docs/introduction) provides a unified API for using AI models, including for text generation, tool calling, structured responses, image generation, and more.\n\nTo use the AI SDK, install the `ai` package and use it within your Agent. The example below shows how it use it to generate text on request, but you can use it from any method within your Agent, including WebSocket handlers, as part of a scheduled task, or even when the Agent is initialized.\n\n### OpenAI compatible endpoints\n\nAgents can call models across any service, including those that support the OpenAI API. For example, you can use the OpenAI SDK to use one of [Google's Gemini models](https://ai.google.dev/gemini-api/docs/openai#node.js) directly from your Agent.\n\nAgents can stream responses back over HTTP using Server Sent Events (SSE) from within an `onRequest` handler, or by using the native [WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) API in your Agent to responses back to a client, which is especially useful for larger models that can take over 30+ seconds to reply.\n\n<page>\n---\ntitle: Using WebSockets · Cloudflare Agents docs\ndescription: Users and clients can connect to an Agent directly over WebSockets,\n  allowing long-running, bi-directional communication with your Agent as it\n  operates.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/websockets/\n  md: https://developers.cloudflare.com/agents/api-reference/websockets/index.md\n---\n\nUsers and clients can connect to an Agent directly over WebSockets, allowing long-running, bi-directional communication with your Agent as it operates.\n\nTo enable an Agent to accept WebSockets, define `onConnect` and `onMessage` methods on your Agent.\n\n* `onConnect(connection: Connection, ctx: ConnectionContext)` is called when a client establishes a new WebSocket connection. The original HTTP request, including request headers, cookies, and the URL itself, are available on `ctx.request`.\n* `onMessage(connection: Connection, message: WSMessage)` is called for each incoming WebSocket message. Messages are one of `ArrayBuffer | ArrayBufferView | string`, and you can send messages back to a client using `connection.send()`. You can distinguish between client connections by checking `connection.id`, which is unique for each connected client.\n\nHere's an example of an Agent that echoes back any message it receives:\n\n### Connecting clients\n\nThe Agent framework includes a useful helper package for connecting directly to your Agent (or other Agents) from a client application. Import `agents/client`, create an instance of `AgentClient` and use it to connect to an instance of your Agent:\n\nReact-based applications can import `agents/react` and use the `useAgent` hook to connect to an instance of an Agent directly:\n\nThe `useAgent` hook automatically handles the lifecycle of the connection, ensuring that it is properly initialized and cleaned up when the component mounts and unmounts. You can also [combine `useAgent` with `useState`](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) to automatically synchronize state across all clients connected to your Agent.\n\n### Handling WebSocket events\n\nDefine `onError` and `onClose` methods on your Agent to explicitly handle WebSocket client errors and close events. Log errors, clean up state, and/or emit metrics:\n\n<page>\n---\ntitle: Agent class internals · Cloudflare Agents docs\ndescription: The core of the agents library is the exported Agent class.\n  Following the pattern from Durable Objects, the main API for developers is to\n  extend the Agent class to inherit all the built-in features. While this\n  effectively is a supercharged primitive that allows developers to only write\n  the logic they need in their agents, it obscures the inner workings.\nlastUpdated: 2025-11-07T18:37:32.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/agent-class/\n  md: https://developers.cloudflare.com/agents/concepts/agent-class/index.md\n---\n\nThe core of the `agents` library is the exported `Agent` class. Following the pattern from [Durable Objects](https://developers.cloudflare.com/durable-objects/api/), the main API for developers is to extend the `Agent` class to inherit all the built-in features. While this effectively is a supercharged primitive that allows developers to only write the logic they need in their agents, it obscures the inner workings.\n\nThis document tries to bridge that gap, empowering any developer aiming to get started writing agents to get the full picture and avoid common pitfalls. The snippets shown here are primarily illustrative, and do not necessarily represent best practices. For a more in-depth look at the inner workings of the `Agent` class, check out the [API reference](https://developers.cloudflare.com/agents/api-reference/) and the [source code](https://github.com/cloudflare/agents/blob/main/packages/agents/src/index.ts).\n\n## What is the Agent?\n\nThe `Agent` class is an extension of `DurableObject`. That is to say, they *are* Durable Objects. If you are not familiar with Durable Objects, it is highly recommended that you read [What are Durable Objects](https://developers.cloudflare.com/durable-objects/), but at their core, Durable Objects are globally addressable (each instance has a unique ID) single-threaded compute instances with long term storage (key-value/SQLite).\n\nNote that `Agent` does not extend `DurableObject` directly, but instead extends `Server`. `Server` is a class provided by [PartyKit](https://github.com/cloudflare/partykit/tree/main/packages/partyserver).\n\nYou can visualize the logic as a Matryoshka doll: **DurableObject** > **Server** > **Agent**.\n\n## Layer 0: Durable Object\n\nLet's briefly consider which primitives are exposed by Durable Objects so we understand how the outer layers make use of them. The Durable Object class comes with:\n\nThe Workers runtime always calls the constructor to handle things internally. This means two things:\n\n1. While the constructor is called every time the Durable Object is initialized, the signature is fixed. Developers cannot add or update parameters from the constructor.\n2. Instead of instantiating the class manually, developers must use the binding APIs and do it through the [DurableObjectNamespace](https://developers.cloudflare.com/durable-objects/api/namespace/).\n\nBy writing a Durable Object class which inherits from the built-in type `DurableObject`, public methods are exposed as RPC methods, which developers can call using a [DurableObjectStub from a Worker](https://developers.cloudflare.com/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/#invoking-methods-on-a-durable-object).\n\nDurable Objects can take a `Request` from a Worker and send a `Response` back. This can only be done through the [`fetch`](https://developers.cloudflare.com/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/#invoking-the-fetch-handler) method (which the developer must implement).\n\nDurable Objects include first-class support for [WebSockets](https://developers.cloudflare.com/durable-objects/best-practices/websockets/). A Durable Object can accept a WebSocket it receives from a `Request` in `fetch` and forget about it. The base class provides methods that developers can implement that are called as callbacks. They effectively replace the need for event listeners.\n\nThe base class provides `webSocketMessage(ws, message)`, `webSocketClose(ws, code, reason, wasClean)` and `webSocketError(ws , error)` ([API](https://developers.cloudflare.com/workers/runtime-apis/websockets)).\n\nHTTP and RPC requests are not the only entrypoints for a Durable Object. Alarms allow developers to schedule an event to trigger at a later time. Whenever the next alarm is due, the runtime will call the `alarm()` method, which is left to the developer to implement.\n\nTo schedule an alarm, you can use the `this.ctx.storage.setAlarm()` method. For more information, refer to [Alarms](https://developers.cloudflare.com/durable-objects/api/alarms/).\n\nThe base `DurableObject` class sets the [DurableObjectState](https://developers.cloudflare.com/durable-objects/api/state/) into `this.ctx`. There are a lot of interesting methods and properties, but we will focus on `this.ctx.storage`.\n\n### `this.ctx.storage`\n\n[DurableObjectStorage](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/) is the main interface with the Durable Object's persistence mechanisms, which include both a KV and SQLITE **synchronous** APIs.\n\nLastly, it is worth mentioning that the Durable Object also has the Worker `Env` in `this.env`. Learn more in [Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings).\n\n## Layer 1: Partykit `Server`\n\nNow that you have seen what Durable Objects come with out-of-the-box, what [PartyKit](https://github.com/cloudflare/partykit)'s `Server` (package `partyserver`) implements will be clearer. It is an opinionated `DurableObject` wrapper that improves DX by hiding away Durable Object primitives in favor of more developer friendly callbacks.\n\nAn important note is that `Server` does NOT persist to the Durable Object storage, so you will not see extra storage operations by using it.\n\n`partyserver` exposes helper to address your Durable Objects instead of manually through your bindings. This allows `partyserver` to implement several improvements, including a unique URL routing scheme for your Durable Objects (e.g. `<your-worker>/servers/:durableClass/:durableName`).\n\nCompare this to the Durable Object addressing [example above](#rpc).\n\nSince we have a URL addressing scheme, we also get access to `routePartykitRequest()`.\n\nYou can also refer to [the implementation](https://github.com/cloudflare/partykit/blob/main/packages/partyserver/src/index.ts#L122) to learn more.\n\nThe extra plumbing that `Server` includes on addressing allows it to expose an `onStart` callback that is executed every time the Durable Object starts up (the Durable Object was evicted, hibernated or never created at all) and before any `fetch` or RPC.\n\n### `onRequest` and `onConnect`\n\n`Server` already implements `fetch` for the underlying Durable Object and exposes two different callbacks that developers can make use of, `onRequest` and `onConnect` for HTTP requests and incoming WS connections, respectively (WebSocket connections are accepted by default).\n\nJust as `onConnect` is the callback for every new connection, `Server` also provides wrappers on top of the default callbacks from the `DurableObject` class: `onMessage`, `onClose` and `onError`.\n\nThere's also `this.broadcast` that sends a WS message to all connected clients (no magic, just a loop over `this.getConnections()`!).\n\nIt is hard to get a Durable Object's `name` from within it. `partyserver` tries to make it available in `this.name` but it is not a perfect solution. Learn more about it in [this GitHub issue](https://github.com/cloudflare/workerd/issues/2240).\n\nNow finally, the `Agent` class. `Agent` extends `Server` and provides opinionated primitives for stateful, schedulable, and observable agents that can communicate via RPC, WebSockets, and (even!) email.\n\n### `this.state` and `this.setState()`\n\nOne of the core features of `Agent` is **automatic state persistence**. Developers define the shape of their state via the generic parameter and `initialState` (which is only used if no state exists in storage), and the Agent handles loading, saving, and broadcasting state changes (check `Server`'s `this.broadcast()` above).\n\n`this.state` is a getter that lazily loads state from storage (SQL). State is persisted across Durable Object evictions when it is updated with `this.setState()`, which automatically serializes the state and writes it back to storage.\n\nThere's also `this.onStateUpdate` that you can override to react to state changes.\n\nState is stored in the `cf_agents_state` SQL table. State messages are sent with `type: \"cf_agent_state\"` (both from the client and the server). Since the `agents` provides [JS and React clients](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/#synchronizing-state), real-time state updates are available out of the box.\n\nThe Agent provides a convenient `sql` template tag for executing queries against the Durable Object's SQL storage. It constructs parameterized queries and executes them. This uses the **synchronous** SQL API from `this.ctx.storage.sql`.\n\n### RPC and Callable Methods\n\n`agents` take Durable Objects RPC one step forward by implementing RPC through WebSockets, so clients can also call methods on the Agent directly. To make a method callable through WS, developers can use the `@callable` decorator. Methods can return a serializable value or a stream (when using `@callable({ stream: true })`).\n\nClients can invoke this method by sending a WebSocket message:\n\nFor example, with the provided `React` client, it is as easy as:\n\n### `this.queue` and friends\n\nAgents include a built-in task queue for deferred execution. This is useful for offloading work or retrying operations. The available methods are `this.queue`, `this.dequeue`, `this.dequeueAll`, `this.dequeueAllByCallback`, `this.getQueue`, and `this.getQueues`.\n\nTasks are stored in the `cf_agents_queues` SQL table and are automatically flushed in sequence. If a task succeeds, it is automatically dequeued.\n\n### `this.schedule` and friends\n\nAgents support scheduled execution of methods by wrapping the Durable Object's `alarm()`. The available methods are `this.schedule`, `this.getSchedule`, `this.getSchedules`, `this.cancelSchedule`. Schedules can be one-time, delayed, or recurring (using cron expressions).\n\nSince Durable Objects only allow one alarm at a time, the `Agent` class works around this by managing multiple schedules in SQL and using a single alarm.\n\nSchedules are stored in the `cf_agents_schedules` SQL table. Cron schedules automatically reschedule themselves after execution, while one-time schedules are deleted.\n\n### `this.mcp` and friends\n\n`Agent` includes a multi-server MCP client. This enables your Agent to interact with external services that expose MCP interfaces. The MCP client is properly documented in [MCP client API](https://developers.cloudflare.com/agents/model-context-protocol/mcp-client-api/).\n\nAgents can receive and reply to emails using Cloudflare's [Email Routing](https://developers.cloudflare.com/email-routing/email-workers/).\n\nTo route emails to your Agent, use `routeAgentEmail` in your Worker's email handler:\n\n### Context Management\n\n`agents` wraps all your methods with an `AsyncLocalStorage` to maintain context throughout the request lifecycle. This allows you to access the current agent, connection, request, or email (depending of what event is being handled) from anywhere in your code:\n\n`Agent` extends `Server`'s `onError` so it can be used to handle errors that are not necessarily WebSocket errors. It is called with a `Connection` or `unknown` error.\n\n`this.destroy()` drops all tables, deletes alarms, clears storage, and aborts the context. To ensure that the Durable Object is fully evicted, `this.ctx.abort()` is called, which throws an uncatchable error that will show up in your logs (read more about it in [abort()](https://developers.cloudflare.com/durable-objects/api/state/#abort)).\n\nThe `Agent` class re-exports PartyKit's [addressing helpers](#addressing) as `getAgentByName` and `routeAgentRequest`.\n\n<page>\n---\ntitle: Calling LLMs · Cloudflare Agents docs\ndescription: Different LLM providers offer models optimized for specific types\n  of tasks. When building AI systems, choosing the right model is crucial for\n  both performance and cost efficiency.\nlastUpdated: 2025-08-15T20:11:52.000Z\nchatbotDeprioritize: false\ntags: LLM\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/calling-llms/\n  md: https://developers.cloudflare.com/agents/concepts/calling-llms/index.md\n---\n\n### Understanding LLM providers and model types\n\nDifferent LLM providers offer models optimized for specific types of tasks. When building AI systems, choosing the right model is crucial for both performance and cost efficiency.\n\n#### Reasoning Models\n\nModels like OpenAI's o1, Anthropic's Claude, and DeepSeek's R1 are particularly well-suited for complex reasoning tasks. These models excel at:\n\n* Breaking down problems into steps\n* Following complex instructions\n* Maintaining context across long conversations\n* Generating code and technical content\n\nFor example, when implementing a travel booking system, you might use a reasoning model to analyze travel requirements and generate appropriate booking strategies.\n\n#### Instruction Models\n\nModels like GPT-4 and Claude Instant are optimized for following straightforward instructions efficiently. They work well for:\n\n* Content generation\n* Simple classification tasks\n* Basic question answering\n* Text transformation\n\nThese models are often more cost-effective for straightforward tasks that do not require complex reasoning.\n\n<page>\n---\ntitle: Human in the Loop · Cloudflare Agents docs\ndescription: Human-in-the-Loop (HITL) workflows integrate human judgment and\n  oversight into automated processes. These workflows pause at critical points\n  for human review, validation, or decision-making before proceeding. This\n  approach combines the efficiency of automation with human expertise and\n  oversight where it matters most.\nlastUpdated: 2025-04-30T09:59:18.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/human-in-the-loop/\n  md: https://developers.cloudflare.com/agents/concepts/human-in-the-loop/index.md\n---\n\n### What is Human-in-the-Loop?\n\nHuman-in-the-Loop (HITL) workflows integrate human judgment and oversight into automated processes. These workflows pause at critical points for human review, validation, or decision-making before proceeding. This approach combines the efficiency of automation with human expertise and oversight where it matters most.\n\n![A human-in-the-loop diagram](https://developers.cloudflare.com/_astro/human-in-the-loop.C2xls7fV_1vt7N8.svg)\n\n#### Understanding Human-in-the-Loop workflows\n\nIn a Human-in-the-Loop workflow, processes are not fully automated. Instead, they include designated checkpoints where human intervention is required. For example, in a travel booking system, a human may want to confirm the travel before an agent follows through with a transaction. The workflow manages this interaction, ensuring that:\n\n1. The process pauses at appropriate review points\n2. Human reviewers receive necessary context\n3. The system maintains state during the review period\n4. Review decisions are properly incorporated\n5. The process continues once approval is received\n\n### Best practices for Human-in-the-Loop workflows\n\n#### Long-Term State Persistence\n\nHuman review processes do not operate on predictable timelines. A reviewer might need days or weeks to make a decision, especially for complex cases requiring additional investigation or multiple approvals. Your system needs to maintain perfect state consistency throughout this period, including:\n\n* The original request and context\n* All intermediate decisions and actions\n* Any partial progress or temporary states\n* Review history and feedback\n\n[Durable Objects](https://developers.cloudflare.com/durable-objects/) provide an ideal solution for managing state in Human-in-the-Loop workflows, offering persistent compute instances that maintain state for hours, weeks, or months.\n\n#### Continuous Improvement Through Evals\n\nHuman reviewers play a crucial role in evaluating and improving LLM performance. Implement a systematic evaluation process where human feedback is collected not just on the final output, but on the LLM's decision-making process. This can include:\n\n* Decision Quality Assessment: Have reviewers evaluate the LLM's reasoning process and decision points, not just the final output.\n* Edge Case Identification: Use human expertise to identify scenarios where the LLM's performance could be improved.\n* Feedback Collection: Gather structured feedback that can be used to fine-tune the LLM or adjust the workflow. [AI Gateway](https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback/) can be a useful tool for setting up an LLM feedback loop.\n\n#### Error handling and recovery\n\nRobust error handling is essential for maintaining workflow integrity. Your system should gracefully handle various failure scenarios, including reviewer unavailability, system outages, or conflicting reviews. Implement clear escalation paths for handling exceptional cases that fall outside normal parameters.\n\nThe system should maintain stability during paused states, ensuring that no work is lost even during extended review periods. Consider implementing automatic checkpointing that allows workflows to be resumed from the last stable state after any interruption.\n\n<page>\n---\ntitle: Tools · Cloudflare Agents docs\ndescription: Tools enable AI systems to interact with external services and\n  perform actions. They provide a structured way for agents and workflows to\n  invoke APIs, manipulate data, and integrate with external systems. Tools form\n  the bridge between AI decision-making capabilities and real-world actions.\nlastUpdated: 2025-02-28T20:23:07.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/tools/\n  md: https://developers.cloudflare.com/agents/concepts/tools/index.md\n---\n\nTools enable AI systems to interact with external services and perform actions. They provide a structured way for agents and workflows to invoke APIs, manipulate data, and integrate with external systems. Tools form the bridge between AI decision-making capabilities and real-world actions.\n\n### Understanding tools\n\nIn an AI system, tools are typically implemented as function calls that the AI can use to accomplish specific tasks. For example, a travel booking agent might have tools for:\n\n* Searching flight availability\n* Checking hotel rates\n* Processing payments\n* Sending confirmation emails\n\nEach tool has a defined interface specifying its inputs, outputs, and expected behavior. This allows the AI system to understand when and how to use each tool appropriately.\n\n### Common tool patterns\n\n#### API integration tools\n\nThe most common type of tools are those that wrap external APIs. These tools handle the complexity of API authentication, request formatting, and response parsing, presenting a clean interface to the AI system.\n\n#### Model Context Protocol (MCP)\n\nThe [Model Context Protocol](https://modelcontextprotocol.io/introduction) provides a standardized way to define and interact with tools. Think of it as an abstraction on top of APIs designed for LLMs to interact with external resources. MCP defines a consistent interface for:\n\n* **Tool Discovery**: Systems can dynamically discover available tools\n* **Parameter Validation**: Tools specify their input requirements using JSON Schema\n* **Error Handling**: Standardized error reporting and recovery\n* **State Management**: Tools can maintain state across invocations\n\n#### Data processing tools\n\nTools that handle data transformation and analysis are essential for many AI workflows. These might include:\n\n* CSV parsing and analysis\n* Image processing\n* Text extraction\n* Data validation\n\n<page>\n---\ntitle: Agents · Cloudflare Agents docs\ndescription: An agent is an AI system that can autonomously execute tasks by\n  making decisions about tool usage and process flow. Unlike traditional\n  automation that follows predefined paths, agents can dynamically adapt their\n  approach based on context and intermediate results. Agents are also distinct\n  from co-pilots (e.g. traditional chat applications) in that they can fully\n  automate a task, as opposed to simply augmenting and extending human input.\nlastUpdated: 2025-08-15T20:11:52.000Z\nchatbotDeprioritize: false\ntags: AI,LLM\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/what-are-agents/\n  md: https://developers.cloudflare.com/agents/concepts/what-are-agents/index.md\n---\n\nAn agent is an AI system that can autonomously execute tasks by making decisions about tool usage and process flow. Unlike traditional automation that follows predefined paths, agents can dynamically adapt their approach based on context and intermediate results. Agents are also distinct from co-pilots (e.g. traditional chat applications) in that they can fully automate a task, as opposed to simply augmenting and extending human input.\n\n* **Agents** → non-linear, non-deterministic (can change from run to run)\n* **Workflows** → linear, deterministic execution paths\n* **Co-pilots** → augmentative AI assistance requiring human intervention\n\n### Example: Booking vacations\n\nIf this is your first time working with, or interacting with agents, this example will illustrate how an agent works within a context like booking a vacation. If you are already familiar with the topic, read on.\n\nImagine you're trying to book a vacation. You need to research flights, find hotels, check restaurant reviews, and keep track of your budget.\n\n#### Traditional workflow automation\n\nA traditional automation system follows a predetermined sequence:\n\n* Takes specific inputs (dates, location, budget)\n* Calls predefined API endpoints in a fixed order\n* Returns results based on hardcoded criteria\n* Cannot adapt if unexpected situations arise\n\n![Traditional workflow automation diagram](https://developers.cloudflare.com/_astro/workflow-automation.D1rsykgR_15theP.svg)\n\nA co-pilot acts as an intelligent assistant that:\n\n* Provides hotel and itinerary recommendations based on your preferences\n* Can understand and respond to natural language queries\n* Offers guidance and suggestions\n* Requires human decision-making and action for execution\n\n![A co-pilot diagram](https://developers.cloudflare.com/_astro/co-pilot.BZ_kRuK6_Z9KfL9.svg)\n\nAn agent combines AI's ability to make judgements and call the relevant tools to execute the task. An agent's output will be nondeterministic given:\n\n* Real-time availability and pricing changes\n* Dynamic prioritization of constraints\n* Ability to recover from failures\n* Adaptive decision-making based on intermediate results\n\n![An agent diagram](https://developers.cloudflare.com/_astro/agent-workflow.5VDKtHdO_ALLGh.svg)\n\nAn agents can dynamically generate an itinerary and execute on booking reservations, similarly to what you would expect from a travel agent.\n\n### Three primary components of agent systems:\n\n* **Decision Engine**: Usually an LLM (Large Language Model) that determines action steps\n* **Tool Integration**: APIs, functions, and services the agent can utilize\n* **Memory System**: Maintains context and tracks task progress\n\nAgents operate in a continuous loop of:\n\n1. **Observing** the current state or task\n2. **Planning** what actions to take, using AI for reasoning\n3. **Executing** those actions using available tools (often APIs or [MCPs](https://modelcontextprotocol.io/introduction))\n4. **Learning** from the results (storing results in memory, updating task progress, and preparing for next iteration)\n\n<page>\n---\ntitle: Workflows · Cloudflare Agents docs\ndescription: A workflow is the orchestration layer that coordinates how an\n  agent's components work together. It defines the structured paths through\n  which tasks are processed, tools are called, and results are managed. While\n  agents make dynamic decisions about what to do, workflows provide the\n  underlying framework that governs how those decisions are executed.\nlastUpdated: 2025-02-25T13:55:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/workflows/\n  md: https://developers.cloudflare.com/agents/concepts/workflows/index.md\n---\n\n## What are workflows?\n\nA workflow is the orchestration layer that coordinates how an agent's components work together. It defines the structured paths through which tasks are processed, tools are called, and results are managed. While agents make dynamic decisions about what to do, workflows provide the underlying framework that governs how those decisions are executed.\n\n### Understanding workflows in agent systems\n\nThink of a workflow like the operating procedures of a company. The company (agent) can make various decisions, but how those decisions get implemented follows established processes (workflows). For example, when you book a flight through a travel agent, they might make different decisions about which flights to recommend, but the process of actually booking the flight follows a fixed sequence of steps.\n\nLet's examine a basic agent workflow:\n\n### Core components of a workflow\n\nA workflow typically consists of several key elements:\n\n1. **Input Processing** The workflow defines how inputs are received and validated before being processed by the agent. This includes standardizing formats, checking permissions, and ensuring all required information is present.\n2. **Tool Integration** Workflows manage how external tools and services are accessed. They handle authentication, rate limiting, error recovery, and ensuring tools are used in the correct sequence.\n3. **State Management** The workflow maintains the state of ongoing processes, tracking progress through multiple steps and ensuring consistency across operations.\n4. **Output Handling** Results from the agent's actions are processed according to defined rules, whether that means storing data, triggering notifications, or formatting responses.\n\n<page>\n---\ntitle: Build a Chat Agent · Cloudflare Agents docs\ndescription: A starter template for building AI-powered chat agents using\n  Cloudflare's Agent platform, powered by the Agents SDK. This project provides\n  a foundation for creating interactive chat experiences with AI, complete with\n  a modern UI and tool integration capabilities.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/\n  md: https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/index.md\n---\n\n<page>\n---\ntitle: Prompt an AI model · Cloudflare Agents docs\ndescription: Use the Workers \"mega prompt\" to build a Agents using your\n  preferred AI tools and/or IDEs. The prompt understands the Agents SDK APIs,\n  best practices and guidelines, and makes it easier to build valid Agents and\n  Workers.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/getting-started/prompting/\n  md: https://developers.cloudflare.com/agents/getting-started/prompting/index.md\n---\n\n<page>\n---\ntitle: Testing your Agents · Cloudflare Agents docs\ndescription: Because Agents run on Cloudflare Workers and Durable Objects, they\n  can be tested using the same tools and techniques as Workers and Durable\n  Objects.\nlastUpdated: 2025-05-16T16:37:37.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/getting-started/testing-your-agent/\n  md: https://developers.cloudflare.com/agents/getting-started/testing-your-agent/index.md\n---\n\nBecause Agents run on Cloudflare Workers and Durable Objects, they can be tested using the same tools and techniques as Workers and Durable Objects.\n\n## Writing and running tests\n\nThe `agents-starter` template and new Cloudflare Workers projects already include the relevant `vitest` and `@cloudflare/vitest-pool-workers` packages, as well as a valid `vitest.config.js` file.\n\nBefore you write your first test, install the necessary packages:\n\nEnsure that your `vitest.config.js` file is identical to the following:\n\n### Add the Agent configuration\n\nAdd a `durableObjects` configuration to `vitest.config.js` with the name of your Agent class:\n\nReview the [Vitest documentation](https://vitest.dev/) for more information on testing, including the test API reference and advanced testing techniques.\n\nTests use the `vitest` framework. A basic test suite for your Agent can validate how your Agent responds to requests, but can also unit test your Agent's methods and state.\n\nRunning tests is done using the `vitest` CLI:",
  "code_samples": [
    {
      "code": "<componentName-embedName attribute=\"value\"></componentName-embedName>",
      "language": "html"
    },
    {
      "code": "<twitter-post tweet-id=\"12345\"></twitter-post>",
      "language": "html"
    },
    {
      "code": "<instagram-post post-url=\"https://www.instagram.com/p/ABC/\" captions=\"true\"></instagram-post>",
      "language": "html"
    },
    {
      "code": "gtag(\"event\", \"conversion\", {\n  send_to: \"AW-123456789/AbC-D_efG-h12_34-567\",\n  value: 1.0,\n  currency: \"USD\",\n});",
      "language": "js"
    },
    {
      "code": "{\n  \"events\": [\n    {\n      \"client\": {\n        \"__zarazTrack\": \"transaction successful\",\n        \"value\": \"200\"\n      }\n    }\n  ]\n}",
      "language": "json"
    },
    {
      "code": "{\n  \"events\": [\n    {\n      \"client\": {\n        \"__zarazTrack\": \"transaction successful\",\n        \"value\": \"200\"\n      },\n      \"system\": {\n        \"page\": {\n          \"url\": \"https://example.com\",\n          \"title\": \"My website\"\n        },\n        \"device\": {\n          \"language\": \"en-US\",\n          \"ip\": \"192.168.0.1\"\n        }\n      }\n    }\n  ]\n}",
      "language": "json"
    },
    {
      "code": "function NSLookup(type, domain, useCache = false, minCacheTTL = 30) {\n\n\n  if (typeof type == 'undefined') {\n    throw new Error('Missing parameter 1 dns type');\n  }\n\n\n  if (typeof domain == 'undefined') {\n    throw new Error('Missing parameter 2 domain name');\n  }\n\n\n  if (typeof useCache != \"boolean\") {\n    throw new Error('Only boolean values allowed in 3 use cache');\n  }\n\n\n  if (typeof minCacheTTL != \"number\") {\n    throw new Error('Only numeric values allowed in 4 min cache ttl');\n  }\n\n\n  type = type.toUpperCase();\n  domain = domain.toLowerCase();\n\n\n  let cache = null;\n  if (useCache) {\n    // Cache key and hash\n    cacheKey = domain + \"@\" + type;\n    cacheHash = Utilities.base64Encode(cacheKey);\n    cacheBinKey = \"nslookup-result-\" + cacheHash;\n\n\n    cache = CacheService.getScriptCache();\n    const cachedResult = cache.get(cacheBinKey);\n    if (cachedResult != null) {\n      return cachedResult;\n    }\n  }\n\n\n  const url = 'https://cloudflare-dns.com/dns-query?name=' + encodeURIComponent(domain) + '&type=' + encodeURIComponent(type);\n  const options = {\n    muteHttpExceptions: true,\n    headers: {\n      accept: \"application/dns-json\"\n    }\n  };\n\n\n  const result = UrlFetchApp.fetch(url, options);\n  const rc = result.getResponseCode();\n  const resultText = result.getContentText();\n\n\n  if (rc !== 200) {\n    throw new Error(rc);\n  }\n\n\n  const errors = [\n    { name: \"NoError\", description: \"No Error\"}, // 0\n    { name: \"FormErr\", description: \"Format Error\"}, // 1\n    { name: \"ServFail\", description: \"Server Failure\"}, // 2\n    { name: \"NXDomain\", description: \"Non-Existent Domain\"}, // 3\n    { name: \"NotImp\", description: \"Not Implemented\"}, // 4\n    { name: \"Refused\", description: \"Query Refused\"}, // 5\n    { name: \"YXDomain\", description: \"Name Exists when it should not\"}, // 6\n    { name: \"YXRRSet\", description: \"RR Set Exists when it should not\"}, // 7\n    { name: \"NXRRSet\", description: \"RR Set that should exist does not\"}, // 8\n    { name: \"NotAuth\", description: \"Not Authorized\"} // 9\n  ];\n\n\n  const response = JSON.parse(resultText);\n\n\n  if (response.Status !== 0) {\n    return errors[response.Status].name;\n  }\n\n\n  const outputData = [];\n  let cacheTTL = 0;\n\n\n  for (const i in response.Answer) {\n    outputData.push(response.Answer[i].data);\n    const ttl = response.Answer[i].TTL;\n    cacheTTL = Math.min(cacheTTL || ttl, ttl);\n  }\n\n\n  const outputString = outputData.join(',');\n\n\n  if (useCache) {\n    cache.put(cacheBinKey, outputString, Math.max(cacheTTL, minCacheTTL));\n  }\n\n\n  return outputString;\n}",
      "language": "js"
    },
    {
      "code": "NSLookup(B1, B2)",
      "language": "txt"
    },
    {
      "code": "NSLookup(B1; B2)",
      "language": "txt"
    },
    {
      "code": "198.41.214.162, 198.41.215.162",
      "language": "txt"
    },
    {
      "code": "/dig domain: cloudflare.com",
      "language": "txt"
    },
    {
      "code": "/dig domain: cloudflare.com type: AAAA records short: True",
      "language": "txt"
    },
    {
      "code": "/dig domain: cloudflare.com type: AAAA records cdflag: True",
      "language": "txt"
    },
    {
      "code": "/multi-dig domain: cloudflare.com types: A AAAA",
      "language": "txt"
    },
    {
      "code": "/multi-dig domain: cloudflare.com types: CDS CDNSKEY short: True",
      "language": "txt"
    },
    {
      "code": "/multi-dig domain: cloudflare.com type: AAAA records cdflag: True",
      "language": "txt"
    },
    {
      "code": "/whois query: cloudflare.com\n/whois query: 104.16.132.229\n/whois query: 2606:4700::6810:84e5\n/whois query: 13335",
      "language": "txt"
    },
    {
      "code": "/help",
      "language": "txt"
    },
    {
      "code": "/privacy",
      "language": "txt"
    },
    {
      "code": "/terms",
      "language": "txt"
    },
    {
      "code": "/github",
      "language": "txt"
    },
    {
      "code": "/invite",
      "language": "txt"
    },
    {
      "code": "SOCKSPort 9150",
      "language": "txt"
    },
    {
      "code": "tor -f tor.conf",
      "language": "sh"
    },
    {
      "code": "https://dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion/",
      "language": "txt"
    },
    {
      "code": "curl -sI https://tor.cloudflare-dns.com | grep -i alt-svc",
      "language": "sh"
    },
    {
      "code": "alt-svc: h2=\"dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion:443\"; ma=315360000; persist=1",
      "language": "sh"
    },
    {
      "code": "PORT=853; socat TCP4-LISTEN:${PORT},reuseaddr,fork SOCKS4A:127.0.0.1:dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion:${PORT},socksport=9150",
      "language": "sh"
    },
    {
      "code": "socat TCP4-LISTEN:443,reuseaddr,fork SOCKS4A:127.0.0.1:dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion:443,socksport=9150",
      "language": "sh"
    },
    {
      "code": "cat << EOF >> /etc/hosts\n127.0.0.1 dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion\nEOF",
      "language": "bash"
    },
    {
      "code": "cloudflared proxy-dns --upstream \"https://dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion/dns-query\"",
      "language": "sh"
    },
    {
      "code": "INFO[0000] Adding DNS upstream                           url=\"https://dns4torpnlfs2ifuz2s2yf3fc7rdmsbhm6rw75euj35pac6ap25zgqad.onion/dns-query\"\nINFO[0000] Starting DNS over HTTPS proxy server          addr=\"dns://localhost:53\"\nINFO[0000] Starting metrics server                       addr=\"127.0.0.1:35659\"",
      "language": "sh"
    },
    {
      "code": "kdig -d @1.1.1.1 +tls-ca +tls-host=one.one.one.one example.com",
      "language": "sh"
    },
    {
      "code": ";; DEBUG: Querying for owner(example.com.), class(1), type(1), server(1.1.1.1), port(853), protocol(TCP)\n;; DEBUG: TLS, imported 138 system certificates\n;; DEBUG: TLS, received certificate hierarchy:\n;; DEBUG:  #1, C=US,ST=California,L=San Francisco,O=Cloudflare\\, Inc.,CN=cloudflare-dns.com\n;; DEBUG:      SHA-256 PIN: GP8Knf7qBae+aIfythytMbYnL+yowaWVeD6MoLHkVRg=\n;; DEBUG:  #2, C=US,O=DigiCert Inc,CN=DigiCert TLS Hybrid ECC SHA384 2020 CA1\n;; DEBUG:      SHA-256 PIN: e0IRz5Tio3GA1Xs4fUVWmH1xHDiH2dMbVtCBSkOIdqM=\n;; DEBUG: TLS, skipping certificate PIN check\n;; DEBUG: TLS, The certificate is trusted.\n;; TLS session (TLS1.3)-(ECDHE-X25519)-(ECDSA-SECP256R1-SHA256)-(AES-256-GCM)\n;; ->>HEADER<<- opcode: QUERY; status: NOERROR; id: 3395\n;; Flags: qr rd ra; QUERY: 1; ANSWER: 1; AUTHORITY: 0; ADDITIONAL: 1\n\n\n;; EDNS PSEUDOSECTION:\n;; Version: 0; flags: ; UDP size: 1232 B; ext-rcode: NOERROR\n;; PADDING: 408 B\n\n\n;; QUESTION SECTION:\n;; example.com.            IN  A\n\n\n;; ANSWER SECTION:\nexample.com.          75897  IN  A  93.184.216.34\n\n\n;; Received 468 B\n;; Time 2023-06-23 18:05:42 PDT\n;; From 1.1.1.1@853(TCP) in 12.1 ms",
      "language": "sh"
    },
    {
      "code": "2606:4700:4700::64\n2606:4700:4700::6400",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700:0:0:0:0:64\n2606:4700:4700:0:0:0:0:6400",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "echo -e \"nameserver 1.1.1.1\\nnameserver 1.0.0.1\" | sudo tee /etc/resolv.conf",
      "language": "sh"
    },
    {
      "code": "sudo <EDITOR> /etc/systemd/resolved.conf",
      "language": "sh"
    },
    {
      "code": "[Resolve]\nDNS=1.1.1.1",
      "language": "txt"
    },
    {
      "code": "[Resolve]\nDNS=1.1.1.1#one.one.one.one\nDNSOverTLS=yes",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n    2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n    2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n    2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "1.1.1.1\n   1.0.0.1",
      "language": "txt"
    },
    {
      "code": "1.1.1.2\n   1.0.0.2",
      "language": "txt"
    },
    {
      "code": "1.1.1.3\n   1.0.0.3",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1111\n   2606:4700:4700::1001",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1112\n   2606:4700:4700::1002",
      "language": "txt"
    },
    {
      "code": "2606:4700:4700::1113\n   2606:4700:4700::1003",
      "language": "txt"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/openai/chat/completions \\\n     -H 'cf-aig-authorization: Bearer {CF_AIG_TOKEN}' \\\n     -H \"Authorization: Bearer YOUR_OPENAI_API_KEY\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"model\": \"gpt-4\", \"messages\": [...]}'",
      "language": "bash"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/openai/chat/completions \\\n     -H 'cf-aig-authorization: Bearer {CF_AIG_TOKEN}' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"model\": \"gpt-4\", \"messages\": [...]}'",
      "language": "bash"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/openai/chat/completions \\\n  --header 'cf-aig-authorization: Bearer {CF_AIG_TOKEN}' \\\n  --header 'Authorization: Bearer OPENAI_TOKEN' \\\n  --header 'Content-Type: application/json' \\\n  --data '{\"model\": \"gpt-5-mini\", \"messages\": [{\"role\": \"user\", \"content\": \"What is Cloudflare?\"}]}'",
      "language": "bash"
    },
    {
      "code": "import OpenAI from \"openai\";\n\n\nconst openai = new OpenAI({\n  apiKey: process.env.OPENAI_API_KEY,\n  baseURL: \"https://gateway.ai.cloudflare.com/v1/account-id/gateway/openai\",\n  defaultHeaders: {\n    \"cf-aig-authorization\": `Bearer {token}`,\n  },\n});",
      "language": "javascript"
    },
    {
      "code": "import { createOpenAI } from \"@ai-sdk/openai\";\n\n\nconst openai = createOpenAI({\n  baseURL: \"https://gateway.ai.cloudflare.com/v1/account-id/gateway/openai\",\n  headers: {\n    \"cf-aig-authorization\": `Bearer {token}`,\n  },\n});",
      "language": "javascript"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/openai/chat/completions \\\n  --header \"Authorization: Bearer $TOKEN\" \\\n  --header 'Content-Type: application/json' \\\n  --header 'cf-aig-custom-cost: {\"per_token_in\":0.000001,\"per_token_out\":0.000002}' \\\n  --data ' {\n        \"model\": \"gpt-4o-mini\",\n        \"messages\": [\n          {\n            \"role\": \"user\",\n            \"content\": \"When is Cloudflare’s Birthday Week?\"\n          }\n        ]\n      }'",
      "language": "bash"
    },
    {
      "code": "curl -X POST \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/custom-providers\" \\\n    -H \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"name\": \"My Custom Provider\",\n      \"slug\": \"some-provider\",\n      \"base_url\": \"https://api.myprovider.com\",\n      \"description\": \"Custom AI provider for internal models\",\n      \"enable\": true\n    }'",
      "language": "bash"
    },
    {
      "code": "{\n    \"success\": true,\n    \"result\": {\n      \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n      \"account_id\": \"abc123def456\",\n      \"account_tag\": \"my-account\",\n      \"name\": \"My Custom Provider\",\n      \"slug\": \"some-provider\",\n      \"base_url\": \"https://api.myprovider.com\",\n      \"description\": \"Custom AI provider for internal models\",\n      \"enable\": true,\n      \"beta\": false,\n      \"logo\": \"Base64 encoded SVG logo\",\n      \"link\": null,\n      \"curl_example\": null,\n      \"js_example\": null,\n      \"created_at\": 1700000000,\n      \"modified_at\": 1700000000\n    }\n  }",
      "language": "json"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/custom-providers\" \\\n    -H \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\"",
      "language": "bash"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/custom-providers?enable=true\" \\\n    -H \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\"",
      "language": "bash"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/custom-providers?search=custom\" \\\n    -H \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\"",
      "language": "bash"
    },
    {
      "code": "{\n    \"success\": true,\n    \"result\": [\n      {\n        \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n        \"name\": \"My Custom Provider\",\n        \"slug\": \"some-provider\",\n        \"base_url\": \"https://api.myprovider.com\",\n        \"enable\": true,\n        \"created_at\": 1700000000,\n        \"modified_at\": 1700000000\n      }\n    ],\n    \"result_info\": {\n      \"page\": 1,\n      \"per_page\": 20,\n      \"total_count\": 1,\n      \"total_pages\": 1\n    }\n  }",
      "language": "json"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/custom-providers/{provider_id}\" \\\n    -H \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\"",
      "language": "bash"
    },
    {
      "code": "{\n    \"success\": true,\n    \"result\": {\n      \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n      \"account_id\": \"abc123def456\",\n      \"account_tag\": \"my-account\",\n      \"name\": \"My Custom Provider\",\n      \"slug\": \"some-provider\",\n      \"base_url\": \"https://api.myprovider.com\",\n      \"description\": \"Custom AI provider for internal models\",\n      \"enable\": true,\n      \"beta\": false,\n      \"logo\": \"Base64 encoded SVG logo\",\n      \"link\": \"https://docs.myprovider.com\",\n      \"curl_example\": \"curl -X POST https://api.myprovider.com/v1/chat ...\",\n      \"js_example\": \"fetch('https://api.myprovider.com/v1/chat', {...})\",\n      \"created_at\": 1700000000,\n      \"modified_at\": 1700000000\n    }\n  }",
      "language": "json"
    },
    {
      "code": "curl -X PATCH \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/custom-providers/{provider_id}\" \\\n    -H \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n      \"name\": \"Updated Provider Name\",\n      \"enable\": true,\n      \"description\": \"Updated description\"\n    }'",
      "language": "bash"
    },
    {
      "code": "curl -X PATCH \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/custom-providers/{provider_id}\" \\\n    -H \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"enable\": true}'",
      "language": "bash"
    },
    {
      "code": "curl -X PATCH \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/custom-providers/{provider_id}\" \\\n    -H \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"base_url\": \"https://api.newprovider.com\"}'",
      "language": "bash"
    },
    {
      "code": "curl -X DELETE \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/custom-providers/{provider_id}\" \\\n    -H \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\"",
      "language": "bash"
    },
    {
      "code": "{\n    \"success\": true,\n    \"result\": {\n      \"id\": \"550e8400-e29b-41d4-a716-446655440000\",\n      \"name\": \"My Custom Provider\",\n      \"slug\": \"some-provider\"\n    }\n  }",
      "language": "json"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/compat/chat/completions \\\n  -H \"Authorization: Bearer $PROVIDER_API_KEY\" \\\n  -H \"cf-aig-authorization: Bearer $CF_AIG_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"model\": \"custom-some-provider/model-name\",\n    \"messages\": [{\"role\": \"user\", \"content\": \"Hello!\"}]\n  }'",
      "language": "bash"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/custom-some-provider/your-endpoint \\\n  -H \"Authorization: Bearer $PROVIDER_API_KEY\" \\\n  -H \"cf-aig-authorization: Bearer $CF_AIG_TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"your\": \"request payload\"\n  }'",
      "language": "bash"
    },
    {
      "code": "{\n  \"success\": false,\n  \"errors\": [\n    {\n      \"code\": 1003,\n      \"message\": \"A custom provider with this slug already exists\",\n      \"path\": [\"body\", \"slug\"]\n    }\n  ]\n}",
      "language": "json"
    },
    {
      "code": "{\n  \"success\": false,\n  \"errors\": [\n    {\n      \"code\": 1004,\n      \"message\": \"Custom Provider not found\"\n    }\n  ]\n}",
      "language": "json"
    },
    {
      "code": "{\n  \"success\": false,\n  \"errors\": [\n    {\n      \"code\": 1002,\n      \"message\": \"base_url must be a valid HTTPS URL starting with https://\",\n      \"path\": [\"body\", \"base_url\"]\n    }\n  ]\n}",
      "language": "json"
    },
    {
      "code": "graph TD\n    A[AI Gateway] --> B[Request to Workers AI Inference API]\n    B -->|Success| C[Return Response]\n    B -->|Failure| D[Request to OpenAI API]\n    D --> E[Return Response]",
      "language": "mermaid"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id} \\\n  --header 'Content-Type: application/json' \\\n  --data '[\n  {\n    \"provider\": \"workers-ai\",\n    \"endpoint\": \"@cf/meta/llama-3.1-8b-instruct\",\n    \"headers\": {\n      \"Authorization\": \"Bearer {cloudflare_token}\",\n      \"Content-Type\": \"application/json\"\n    },\n    \"query\": {\n      \"messages\": [\n        {\n          \"role\": \"system\",\n          \"content\": \"You are a friendly assistant\"\n        },\n        {\n          \"role\": \"user\",\n          \"content\": \"What is Cloudflare?\"\n        }\n      ]\n    }\n  },\n  {\n    \"provider\": \"openai\",\n    \"endpoint\": \"chat/completions\",\n    \"headers\": {\n      \"Authorization\": \"Bearer {open_ai_token}\",\n      \"Content-Type\": \"application/json\"\n    },\n    \"query\": {\n      \"model\": \"gpt-4o-mini\",\n      \"stream\": true,\n      \"messages\": [\n        {\n          \"role\": \"user\",\n          \"content\": \"What is Cloudflare?\"\n        }\n      ]\n    }\n  }\n]'",
      "language": "bash"
    },
    {
      "code": "curl 'https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}' \\\n  --header 'Content-Type: application/json' \\\n  --data '[\n    {\n        \"provider\": \"workers-ai\",\n        \"endpoint\": \"@cf/meta/llama-3.1-8b-instruct\",\n        \"headers\": {\n            \"Authorization\": \"Bearer {cloudflare_token}\",\n            \"Content-Type\": \"application/json\"\n        },\n        \"config\": {\n            \"requestTimeout\": 1000\n        },\n        \"query\": {\n34 collapsed lines\n            \"messages\": [\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are a friendly assistant\"\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": \"What is Cloudflare?\"\n                }\n            ]\n        }\n    },\n    {\n        \"provider\": \"workers-ai\",\n        \"endpoint\": \"@cf/meta/llama-3.1-8b-instruct-fast\",\n        \"headers\": {\n            \"Authorization\": \"Bearer {cloudflare_token}\",\n            \"Content-Type\": \"application/json\"\n        },\n        \"query\": {\n            \"messages\": [\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are a friendly assistant\"\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": \"What is Cloudflare?\"\n                }\n            ]\n        },\n        \"config\": {\n            \"requestTimeout\": 3000\n        },\n    }\n]'",
      "language": "bash"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/workers-ai/@cf/meta/llama-3.1-8b-instruct \\\n --header 'Authorization: Bearer {cf_api_token}' \\\n --header 'Content-Type: application/json' \\\n --header 'cf-aig-request-timeout: 5000'\n --data '{\"prompt\": \"What is Cloudflare?\"}'",
      "language": "bash"
    },
    {
      "code": "config:{\n  maxAttempts?: number;\n  retryDelay?: number;\n  backoff?: \"constant\" | \"linear\" | \"exponential\";\n}",
      "language": "json"
    },
    {
      "code": "curl 'https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}' \\\n  --header 'Content-Type: application/json' \\\n  --data '[\n    {\n        \"provider\": \"workers-ai\",\n        \"endpoint\": \"@cf/meta/llama-3.1-8b-instruct\",\n        \"headers\": {\n            \"Authorization\": \"Bearer {cloudflare_token}\",\n            \"Content-Type\": \"application/json\"\n        },\n        \"config\": {\n            \"maxAttempts\": 2,\n            \"retryDelay\": 1000,\n            \"backoff\": \"constant\"\n        },\n39 collapsed lines\n        \"query\": {\n            \"messages\": [\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are a friendly assistant\"\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": \"What is Cloudflare?\"\n                }\n            ]\n        }\n    },\n    {\n        \"provider\": \"workers-ai\",\n        \"endpoint\": \"@cf/meta/llama-3.1-8b-instruct-fast\",\n        \"headers\": {\n            \"Authorization\": \"Bearer {cloudflare_token}\",\n            \"Content-Type\": \"application/json\"\n        },\n        \"query\": {\n            \"messages\": [\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are a friendly assistant\"\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": \"What is Cloudflare?\"\n                }\n            ]\n        },\n        \"config\": {\n            \"maxAttempts\": 4,\n            \"retryDelay\": 1000,\n            \"backoff\": \"exponential\"\n        },\n    }\n]'",
      "language": "bash"
    },
    {
      "code": "{\n  \"status\": \"success\",\n  \"headers\": {\n    \"cf-aig-log-id\": \"01JADMCQQQBWH3NXZ5GCRN98DP\"\n  },\n  \"data\": {\n    \"response\": \"Sample response data\"\n  }\n}",
      "language": "json"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/gateways/$GATEWAY_ID/logs\" \\\n  --request GET \\\n  --header \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\"",
      "language": "bash"
    },
    {
      "code": "{\n  \"result\": [\n    {\n      \"id\": \"01JADMCQQQBWH3NXZ5GCRN98DP\",\n      \"cached\": true,\n      \"created_at\": \"2019-08-24T14:15:22Z\",\n      \"custom_cost\": true,\n      \"duration\": 0,\n      \"id\": \"string\",\n      \"metadata\": \"string\",\n      \"model\": \"string\",\n      \"model_type\": \"string\",\n      \"path\": \"string\",\n      \"provider\": \"string\",\n      \"request_content_type\": \"string\",\n      \"request_type\": \"string\",\n      \"response_content_type\": \"string\",\n      \"status_code\": 0,\n      \"step\": 0,\n      \"success\": true,\n      \"tokens_in\": 0,\n      \"tokens_out\": 0\n    }\n  ]\n}",
      "language": "json"
    },
    {
      "code": "const resp = await env.AI.run(\n  \"@cf/meta/llama-3-8b-instruct\",\n  {\n    prompt: \"tell me a joke\",\n  },\n  {\n    gateway: {\n      id: \"my_gateway_id\",\n    },\n  },\n);\n\n\nconst myLogId = env.AI.aiGatewayLogId;",
      "language": "js"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/ai-gateway/gateways/$GATEWAY_ID/logs/$ID\" \\\n  --request PATCH \\\n  --header \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\" \\\n  --json '{\n    \"feedback\": 1\n  }'",
      "language": "bash"
    },
    {
      "code": "{\n  \"feedback\": -1\n}",
      "language": "json"
    },
    {
      "code": "const resp = await env.AI.run(\n  \"@cf/meta/llama-3.1-8b-instruct\",\n  {\n    prompt: \"tell me a joke\",\n  },\n  {\n    gateway: {\n      id: \"my-gateway\",\n    },\n  },\n);\n\n\nconst myLogId = env.AI.aiGatewayLogId;",
      "language": "javascript"
    },
    {
      "code": "await env.AI.gateway(\"my-gateway\").patchLog(myLogId, {\n  feedback: 1, // all fields are optional; set values that fit your use case\n  score: 100,\n  metadata: {\n    user: \"123\", // Optional metadata to provide additional context\n  },\n});",
      "language": "javascript"
    },
    {
      "code": "gateway.patchLog(\"my-log-id\", {\n  feedback: 1,\n  score: 100,\n  metadata: {\n    user: \"123\",\n  },\n});",
      "language": "javascript"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/openai/chat/completions \\\n  --header \"Authorization: Bearer $TOKEN\" \\\n  --header 'Content-Type: application/json' \\\n  --header 'cf-aig-skip-cache: true' \\\n  --data ' {\n        \"model\": \"gpt-4o-mini\",\n        \"messages\": [\n          {\n            \"role\": \"user\",\n            \"content\": \"how to build a wooden spoon in 3 short steps? give as short as answer as possible\"\n          }\n        ]\n      }\n'",
      "language": "bash"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/openai/chat/completions \\\n  --header \"Authorization: Bearer $TOKEN\" \\\n  --header 'Content-Type: application/json' \\\n  --header 'cf-aig-cache-ttl: 3600' \\\n  --data ' {\n        \"model\": \"gpt-4o-mini\",\n        \"messages\": [\n          {\n            \"role\": \"user\",\n            \"content\": \"how to build a wooden spoon in 3 short steps? give as short as answer as possible\"\n          }\n        ]\n      }\n'",
      "language": "bash"
    },
    {
      "code": "curl https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/openai/chat/completions \\\n  --header 'Authorization: Bearer {openai_token}' \\\n  --header 'Content-Type: application/json' \\\n  --header 'cf-aig-cache-key: responseA' \\\n  --data ' {\n        \"model\": \"gpt-4o-mini\",\n        \"messages\": [\n          {\n            \"role\": \"user\",\n            \"content\": \"how to build a wooden spoon in 3 short steps? give as short as answer as possible\"\n          }\n        ]\n      }\n'",
      "language": "bash"
    },
    {
      "code": "curl -X POST https://gateway.ai.cloudflare.com/v1/{account_id}/{gateway_id}/compat/chat/completions \\\n  --header 'cf-aig-authorization: Bearer {CLOUDFLARE_TOKEN}' \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n    \"model\": \"google-ai-studio/gemini-2.5-pro\",\n    \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": \"What is Cloudflare?\"\n      }\n    ]\n  }'",
      "language": "bash"
    },
    {
      "code": "npm create cloudflare@latest -- hello-ai",
      "language": "sh"
    },
    {
      "code": "yarn create cloudflare hello-ai",
      "language": "sh"
    },
    {
      "code": "pnpm create cloudflare@latest hello-ai",
      "language": "sh"
    },
    {
      "code": "cd hello-ai",
      "language": "bash"
    },
    {
      "code": "{\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"ai\": {\n      \"binding\": \"AI\"\n    }\n  }",
      "language": "jsonc"
    },
    {
      "code": "[ai]\n  binding = \"AI\"",
      "language": "toml"
    },
    {
      "code": "export interface Env {\n  // If you set another name in the [Wrangler configuration file](/workers/wrangler/configuration/) as the value for 'binding',\n  // replace \"AI\" with the variable name you defined.\n  AI: Ai;\n}\n\n\nexport default {\n  async fetch(request, env): Promise<Response> {\n    // Specify the gateway label and other options here\n    const response = await env.AI.run(\n      \"@cf/meta/llama-3.1-8b-instruct-fast\",\n      {\n        prompt: \"What is the origin of the phrase Hello, World\",\n      },\n      {\n        gateway: {\n          id: \"GATEWAYID\", // Use your gateway label here\n          skipCache: true, // Optional: Skip cache if needed\n        },\n      },\n    );\n\n\n    // Return the AI response as a JSON object\n    return new Response(JSON.stringify(response), {\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  },\n} satisfies ExportedHandler<Env>;",
      "language": "typescript"
    },
    {
      "code": "npx wrangler dev",
      "language": "bash"
    },
    {
      "code": "{\n  \"response\": \"A fascinating question!\\n\\nThe phrase \\\"Hello, World!\\\" originates from a simple computer program written in the early days of programming. It is often attributed to Brian Kernighan, a Canadian computer scientist and a pioneer in the field of computer programming.\\n\\nIn the early 1970s, Kernighan, along with his colleague Dennis Ritchie, were working on the C programming language. They wanted to create a simple program that would output a message to the screen to demonstrate the basic structure of a program. They chose the phrase \\\"Hello, World!\\\" because it was a simple and recognizable message that would illustrate how a program could print text to the screen.\\n\\nThe exact code was written in the 5th edition of Kernighan and Ritchie's book \\\"The C Programming Language,\\\" published in 1988. The code, literally known as \\\"Hello, World!\\\" is as follows:\\n\\n",
      "language": "json"
    },
    {
      "code": "## 5. Deploy your AI Worker\n\nBefore deploying your AI Worker globally, log in with your Cloudflare account by running:",
      "language": "unknown"
    },
    {
      "code": "You will be directed to a web page asking you to log in to the Cloudflare dashboard. After you have logged in, you will be asked if Wrangler can make changes to your Cloudflare account. Scroll down and select **Allow** to continue.\n\nFinally, deploy your Worker to make your project accessible on the Internet. To deploy your Worker, run:",
      "language": "unknown"
    },
    {
      "code": "Once deployed, your Worker will be available at a URL like:",
      "language": "unknown"
    },
    {
      "code": "Your Worker will be deployed to your custom [`workers.dev`](https://developers.cloudflare.com/workers/configuration/routing/workers-dev/) subdomain. You can now visit the URL to run your AI Worker.\n\nBy completing this tutorial, you have created a Worker, connected it to Workers AI through an AI Gateway binding, and successfully ran an inference task using the Llama 3.1 model.\n\n</page>\n\n<page>\n---\ntitle: Vercel AI SDK · Cloudflare AI Gateway docs\ndescription: >-\n  The Vercel AI SDK is a TypeScript library for building AI applications. The\n  SDK supports many different AI providers, tools for streaming completions, and\n  more.\n\n  To use Cloudflare AI Gateway with Vercel AI SDK, you will need to use the\n  ai-gateway-provider package.\nlastUpdated: 2025-12-08T07:14:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/integrations/vercel-ai-sdk/\n  md: https://developers.cloudflare.com/ai-gateway/integrations/vercel-ai-sdk/index.md\n---\n\nThe [Vercel AI SDK](https://sdk.vercel.ai/) is a TypeScript library for building AI applications. The SDK supports many different AI providers, tools for streaming completions, and more. To use Cloudflare AI Gateway with Vercel AI SDK, you will need to use the `ai-gateway-provider` package.\n\n## Installation",
      "language": "unknown"
    },
    {
      "code": "## Examples\n\nWith Key in Request\n\n* With Authenticated Gateway",
      "language": "unknown"
    },
    {
      "code": "* Unauthenticated Gateway",
      "language": "unknown"
    },
    {
      "code": "With Stored Keys (BYOK) / Unified Billing",
      "language": "unknown"
    },
    {
      "code": "### Fallback Providers\n\nTo specify model or provider fallbacks to handle request failures and ensure reliability, you can pass an array of models to the `model` option.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: AI Gateway Binding Methods · Cloudflare AI Gateway docs\ndescription: This guide provides an overview of how to use the latest Cloudflare\n  Workers AI Gateway binding methods. You will learn how to set up an AI Gateway\n  binding, access new methods, and integrate them into your Workers.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\ntags: Bindings\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/integrations/worker-binding-methods/\n  md: https://developers.cloudflare.com/ai-gateway/integrations/worker-binding-methods/index.md\n---\n\nThis guide provides an overview of how to use the latest Cloudflare Workers AI Gateway binding methods. You will learn how to set up an AI Gateway binding, access new methods, and integrate them into your Workers.\n\n## 1. Add an AI Binding to your Worker\n\nTo connect your Worker to Workers AI, add the following to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/):\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "This configuration sets up the AI binding accessible in your Worker code as `env.AI`.\n\nIf you're using TypeScript, run [`wrangler types`](https://developers.cloudflare.com/workers/wrangler/commands/#types) whenever you modify your Wrangler configuration file. This generates types for the `env` object based on your bindings, as well as [runtime types](https://developers.cloudflare.com/workers/languages/typescript/).\n\n## 2. Basic Usage with Workers AI + Gateway\n\nTo perform an inference task using Workers AI and an AI Gateway, you can use the following code:",
      "language": "unknown"
    },
    {
      "code": "Additionally, you can access the latest request log ID with:",
      "language": "unknown"
    },
    {
      "code": "## 3. Access the Gateway Binding\n\nYou can access your AI Gateway binding using the following code:",
      "language": "unknown"
    },
    {
      "code": "Once you have the gateway instance, you can use the following methods:\n\n### 3.1. `patchLog`: Send Feedback\n\nThe `patchLog` method allows you to send feedback, score, and metadata for a specific log ID. All object properties are optional, so you can include any combination of the parameters:",
      "language": "unknown"
    },
    {
      "code": "* **Returns**: `Promise<void>` (Make sure to `await` the request.)\n* **Example Use Case**: Update a log entry with user feedback or additional metadata.\n\n### 3.2. `getLog`: Read Log Details\n\nThe `getLog` method retrieves details of a specific log ID. It returns an object of type `Promise<AiGatewayLog>`. If this type is missing, ensure you have run [`wrangler types`](https://developers.cloudflare.com/workers/languages/typescript/#generate-types).",
      "language": "unknown"
    },
    {
      "code": "* **Returns**: `Promise<AiGatewayLog>`\n* **Example Use Case**: Retrieve log information for debugging or analytics.\n\n### 3.3. `getUrl`: Get Gateway URLs\n\nThe `getUrl` method allows you to retrieve the base URL for your AI Gateway, optionally specifying a provider to get the provider-specific endpoint.",
      "language": "unknown"
    },
    {
      "code": "* **Parameters**: Optional `provider` (string or `AIGatewayProviders` enum)\n* **Returns**: `Promise<string>`\n* **Example Use Case**: Dynamically construct URLs for direct API calls or debugging configurations.\n\n#### SDK Integration Examples\n\nThe `getUrl` method is particularly useful for integrating with popular AI SDKs:\n\n**OpenAI SDK:**",
      "language": "unknown"
    },
    {
      "code": "**Vercel AI SDK with OpenAI:**",
      "language": "unknown"
    },
    {
      "code": "**Vercel AI SDK with Anthropic:**",
      "language": "unknown"
    },
    {
      "code": "### 3.4. `run`: Universal Requests\n\nThe `run` method allows you to execute universal requests. Users can pass either a single universal request object or an array of them. This method supports all AI Gateway providers.\n\nRefer to the [Universal endpoint documentation](https://developers.cloudflare.com/ai-gateway/usage/universal/) for details about the available inputs.",
      "language": "unknown"
    },
    {
      "code": "* **Returns**: `Promise<Response>`\n* **Example Use Case**: Perform a [universal request](https://developers.cloudflare.com/ai-gateway/usage/universal/) to any supported provider.\n\n## Conclusion\n\nWith these AI Gateway binding methods, you can now:\n\n* Send feedback and update metadata with `patchLog`.\n* Retrieve detailed log information using `getLog`.\n* Get gateway URLs for direct API access with `getUrl`, making it easy to integrate with popular AI SDKs.\n* Execute universal requests to any AI Gateway provider with `run`.\n\nThese methods offer greater flexibility and control over your AI integrations, empowering you to build more sophisticated applications on the Cloudflare Workers platform.\n\n</page>\n\n<page>\n---\ntitle: Analytics · Cloudflare AI Gateway docs\ndescription: >-\n  Your AI Gateway dashboard shows metrics on requests, tokens, caching, errors,\n  and cost. You can filter these metrics by time.\n\n  These analytics help you understand traffic patterns, token consumption, and\n\n  potential issues across AI providers. You can\n\n  view the following analytics:\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/observability/analytics/\n  md: https://developers.cloudflare.com/ai-gateway/observability/analytics/index.md\n---\n\nYour AI Gateway dashboard shows metrics on requests, tokens, caching, errors, and cost. You can filter these metrics by time. These analytics help you understand traffic patterns, token consumption, and potential issues across AI providers. You can view the following analytics:\n\n* **Requests**: Track the total number of requests processed by AI Gateway.\n* **Token Usage**: Analyze token consumption across requests, giving insight into usage patterns.\n* **Costs**: Gain visibility into the costs associated with using different AI providers, allowing you to track spending, manage budgets, and optimize resources.\n* **Errors**: Monitor the number of errors across the gateway, helping to identify and troubleshoot issues.\n* **Cached Responses**: View the percentage of responses served from cache, which can help reduce costs and improve speed.\n\n## View analytics\n\n* Dashboard\n\n  To view analytics in the dashboard:\n\n  1. Log into the [Cloudflare dashboard](https://dash.cloudflare.com) and select your account.\n  2. Go to **AI** > **AI Gateway**.\n  3. Make sure you have your gateway selected.\n\n* graphql\n\n  You can use GraphQL to query your usage data outside of the AI Gateway dashboard. See the example query below. You will need to use your Cloudflare token when making the request, and change `{account_id}` to match your account tag.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Costs · Cloudflare AI Gateway docs\ndescription: Cost metrics are only available for endpoints where the models\n  return token data and the model name in their responses.\nlastUpdated: 2025-05-15T16:26:01.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/observability/costs/\n  md: https://developers.cloudflare.com/ai-gateway/observability/costs/index.md\n---\n\nCost metrics are only available for endpoints where the models return token data and the model name in their responses.\n\n## Track costs across AI providers\n\nAI Gateway makes it easier to monitor and estimate token based costs across all your AI providers. This can help you:\n\n* Understand and compare usage costs between providers.\n* Monitor trends and estimate spend using consistent metrics.\n* Apply custom pricing logic to match negotiated rates.\n\nNote\n\nThe cost metric is an **estimation** based on the number of tokens sent and received in requests. While this metric can help you monitor and predict cost trends, refer to your provider's dashboard for the most **accurate** cost details.\n\nCaution\n\nProviders may introduce new models or change their pricing. If you notice outdated cost data or are using a model not yet supported by our cost tracking, please [submit a request](https://forms.gle/8kRa73wRnvq7bxL48)\n\n## Custom costs\n\nAI Gateway allows users to set custom costs when operating under special pricing agreements or negotiated rates. Custom costs can be applied at the request level, and when applied, they will override the default or public model costs. For more information on configuration of custom costs, please visit the [Custom Costs](https://developers.cloudflare.com/ai-gateway/configuration/custom-costs/) configuration page.\n\n</page>\n\n<page>\n---\ntitle: Custom metadata · Cloudflare AI Gateway docs\ndescription: Custom metadata in AI Gateway allows you to tag requests with user\n  IDs or other identifiers, enabling better tracking and analysis of your\n  requests. Metadata values can be strings, numbers, or booleans, and will\n  appear in your logs, making it easy to search and filter through your data.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/observability/custom-metadata/\n  md: https://developers.cloudflare.com/ai-gateway/observability/custom-metadata/index.md\n---\n\nCustom metadata in AI Gateway allows you to tag requests with user IDs or other identifiers, enabling better tracking and analysis of your requests. Metadata values can be strings, numbers, or booleans, and will appear in your logs, making it easy to search and filter through your data.\n\n## Key Features\n\n* **Custom Tagging**: Add user IDs, team names, test indicators, and other relevant information to your requests.\n* **Enhanced Logging**: Metadata appears in your logs, allowing for detailed inspection and troubleshooting.\n* **Search and Filter**: Use metadata to efficiently search and filter through logged requests.\n\nNote\n\nAI Gateway allows you to pass up to five custom metadata entries per request. If more than five entries are provided, only the first five will be saved; additional entries will be ignored. Ensure your custom metadata is limited to five entries to avoid unprocessed or lost data.\n\n## Supported Metadata Types\n\n* String\n* Number\n* Boolean\n\nNote\n\nObjects are not supported as metadata values.\n\n## Implementations\n\n### Using cURL\n\nTo include custom metadata in your request using cURL:",
      "language": "unknown"
    },
    {
      "code": "### Using SDK\n\nTo include custom metadata in your request using the OpenAI SDK:",
      "language": "unknown"
    },
    {
      "code": "### Using Binding\n\nTo include custom metadata in your request using [Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/):",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Logging · Cloudflare AI Gateway docs\ndescription: Logging is a fundamental building block for application\n  development. Logs provide insights during the early stages of development and\n  are often critical to understanding issues occurring in production.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/observability/logging/\n  md: https://developers.cloudflare.com/ai-gateway/observability/logging/index.md\n---\n\nLogging is a fundamental building block for application development. Logs provide insights during the early stages of development and are often critical to understanding issues occurring in production.\n\nYour AI Gateway dashboard shows logs of individual requests, including the user prompt, model response, provider, timestamp, request status, token usage, cost, and duration. These logs persist, giving you the flexibility to store them for your preferred duration and do more with valuable request data.\n\nBy default, each gateway can store up to 10 million logs. You can customize this limit per gateway in your gateway settings to align with your specific requirements. If your storage limit is reached, new logs will stop being saved. To continue saving logs, you must delete older logs to free up space for new logs. To learn more about your plan limits, refer to [Limits](https://developers.cloudflare.com/ai-gateway/reference/limits/).\n\nWe recommend using an authenticated gateway when storing logs to prevent unauthorized access and protects against invalid requests that can inflate log storage usage and make it harder to find the data you need. Learn more about setting up an [authenticated gateway](https://developers.cloudflare.com/ai-gateway/configuration/authentication/).\n\n## Default configuration\n\nLogs, which include metrics as well as request and response data, are enabled by default for each gateway. This logging behavior will be uniformly applied to all requests in the gateway. If you are concerned about privacy or compliance and want to turn log collection off, you can go to settings and opt out of logs. If you need to modify the log settings for specific requests, you can override this setting on a per-request basis.\n\nTo change the default log configuration in the dashboard:\n\n1. In the Cloudflare dashboard, go to the **AI Gateway** page.\n\n   [Go to **AI Gateway**](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway)\n\n2. Select **Settings**.\n\n3. Change the **Logs** setting to your preference.\n\n## Per-request logging\n\nTo override the default logging behavior set in the settings tab, you can define headers on a per-request basis.\n\n### Collect logs (`cf-aig-collect-log`)\n\nThe `cf-aig-collect-log` header allows you to bypass the default log setting for the gateway. If the gateway is configured to save logs, the header will exclude the log for that specific request. Conversely, if logging is disabled at the gateway level, this header will save the log for that request.\n\nIn the example below, we use `cf-aig-collect-log` to bypass the default setting to avoid saving the log.",
      "language": "unknown"
    },
    {
      "code": "## Managing log storage\n\nTo manage your log storage effectively, you can:\n\n* Set Storage Limits: Configure a limit on the number of logs stored per gateway in your gateway settings to ensure you only pay for what you need.\n* Enable Automatic Log Deletion: Activate the Automatic Log Deletion feature in your gateway settings to automatically delete the oldest logs once the log limit you've set or the default storage limit of 10 million logs is reached. This ensures new logs are always saved without manual intervention.\n\n## How to delete logs\n\nTo manage your log storage effectively and ensure continuous logging, you can delete logs using the following methods:\n\n### Automatic Log Deletion\n\n​To maintain continuous logging within your gateway's storage constraints, enable Automatic Log Deletion in your Gateway settings. This feature automatically deletes the oldest logs once the log limit you've set or the default storage limit of 10 million logs is reached, ensuring new logs are saved without manual intervention.\n\n### Manual deletion\n\nTo manually delete logs through the dashboard, navigate to the Logs tab in the dashboard. Use the available filters such as status, cache, provider, cost, or any other options in the dropdown to refine the logs you wish to delete. Once filtered, select Delete logs to complete the action.\n\nSee full list of available filters and their descriptions below:\n\n| Filter category | Filter options | Filter by description |\n| - | - | - |\n| Status | error, status | error type or status. |\n| Cache | cached, not cached | based on whether they were cached or not. |\n| Provider | specific providers | the selected AI provider. |\n| AI Models | specific models | the selected AI model. |\n| Cost | less than, greater than | cost, specifying a threshold. |\n| Request type | Universal, Workers AI Binding, WebSockets | the type of request. |\n| Tokens | Total tokens, Tokens In, Tokens Out | token count (less than or greater than). |\n| Duration | less than, greater than | request duration. |\n| Feedback | equals, does not equal (thumbs up, thumbs down, no feedback) | feedback type. |\n| Metadata Key | equals, does not equal | specific metadata keys. |\n| Metadata Value | equals, does not equal | specific metadata values. |\n| Log ID | equals, does not equal | a specific Log ID. |\n| Event ID | equals, does not equal | a specific Event ID. |\n\n### API deletion\n\nYou can programmatically delete logs using the AI Gateway API. For more comprehensive information on the `DELETE` logs endpoint, check out the [Cloudflare API documentation](https://developers.cloudflare.com/api/resources/ai_gateway/subresources/logs/methods/delete/).\n\n</page>\n\n<page>\n---\ntitle: Audit logs · Cloudflare AI Gateway docs\ndescription: Audit logs provide a comprehensive summary of changes made within\n  your Cloudflare account, including those made to gateways in AI Gateway. This\n  functionality is available on all plan types, free of charge, and is enabled\n  by default.\nlastUpdated: 2025-09-05T08:34:36.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/reference/audit-logs/\n  md: https://developers.cloudflare.com/ai-gateway/reference/audit-logs/index.md\n---\n\n[Audit logs](https://developers.cloudflare.com/fundamentals/account/account-security/review-audit-logs/) provide a comprehensive summary of changes made within your Cloudflare account, including those made to gateways in AI Gateway. This functionality is available on all plan types, free of charge, and is enabled by default.\n\n## Viewing Audit Logs\n\nTo view audit logs for AI Gateway, in the Cloudflare dashboard, go to the **Audit logs** page.\n\n[Go to **Audit logs**](https://dash.cloudflare.com/?to=/:account/audit-log)\n\nFor more information on how to access and use audit logs, refer to [review audit logs documentation](https://developers.cloudflare.com/fundamentals/account/account-security/review-audit-logs/).\n\n## Logged Operations\n\nThe following configuration actions are logged:\n\n| Operation | Description |\n| - | - |\n| gateway created | Creation of a new gateway. |\n| gateway deleted | Deletion of an existing gateway. |\n| gateway updated | Edit of an existing gateway. |\n\n## Example Log Entry\n\nBelow is an example of an audit log entry showing the creation of a new gateway:",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Limits · Cloudflare AI Gateway docs\ndescription: The following limits apply to gateway configurations, logs, and\n  related features in Cloudflare's platform.\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/reference/limits/\n  md: https://developers.cloudflare.com/ai-gateway/reference/limits/index.md\n---\n\nThe following limits apply to gateway configurations, logs, and related features in Cloudflare's platform.\n\n| Feature | Limit |\n| - | - |\n| [Cacheable request size](https://developers.cloudflare.com/ai-gateway/features/caching/) | 25 MB per request |\n| [Cache TTL](https://developers.cloudflare.com/ai-gateway/features/caching/#cache-ttl-cf-aig-cache-ttl) | 1 month |\n| [Custom metadata](https://developers.cloudflare.com/ai-gateway/observability/custom-metadata/) | 5 entries per request |\n| [Datasets](https://developers.cloudflare.com/ai-gateway/evaluations/set-up-evaluations/) | 10 per gateway |\n| Gateways free plan | 10 per account |\n| Gateways paid plan | 20 per account |\n| Gateway name length | 64 characters |\n| Log storage rate limit | 500 logs per second per gateway |\n| Logs stored [paid plan](https://developers.cloudflare.com/ai-gateway/reference/pricing/) | 10 million per gateway 1 |\n| Logs stored [free plan](https://developers.cloudflare.com/ai-gateway/reference/pricing/) | 100,000 per account 2 |\n| [Log size stored](https://developers.cloudflare.com/ai-gateway/observability/logging/) | 10 MB per log 3 |\n| [Logpush jobs](https://developers.cloudflare.com/ai-gateway/observability/logging/logpush/) | 4 per account |\n| [Logpush size limit](https://developers.cloudflare.com/ai-gateway/observability/logging/logpush/) | 1MB per log |\n\n1 If you have reached 10 million logs stored per gateway, new logs will stop being saved. To continue saving logs, you must delete older logs in that gateway to free up space or create a new gateway. Refer to [Auto Log Cleanup](https://developers.cloudflare.com/ai-gateway/observability/logging/#auto-log-cleanup) for more details on how to automatically delete logs.\n\n2 If you have reached 100,000 logs stored per account, across all gateways, new logs will stop being saved. To continue saving logs, you must delete older logs. Refer to [Auto Log Cleanup](https://developers.cloudflare.com/ai-gateway/observability/logging/#auto-log-cleanup) for more details on how to automatically delete logs.\n\n3 Logs larger than 10 MB will not be stored.\n\nNeed a higher limit?\n\nTo request an increase to a limit, complete the [Limit Increase Request Form](https://forms.gle/cuXu1QnQCrSNkkaS8). If the limit can be increased, Cloudflare will contact you with next steps.\n\n</page>\n\n<page>\n---\ntitle: Pricing · Cloudflare AI Gateway docs\ndescription: AI Gateway is available to use on all plans.\nlastUpdated: 2025-11-10T11:01:10.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/reference/pricing/\n  md: https://developers.cloudflare.com/ai-gateway/reference/pricing/index.md\n---\n\nAI Gateway is available to use on all plans.\n\nAI Gateway's core features available today are offered for free, and all it takes is a Cloudflare account and one line of code to [get started](https://developers.cloudflare.com/ai-gateway/get-started/). Core features include: dashboard analytics, caching, and rate limiting.\n\nWe will continue to build and expand AI Gateway. Some new features may be additional core features that will be free while others may be part of a premium plan. We will announce these as they become available.\n\nYou can monitor your usage in the AI Gateway dashboard.\n\n## Persistent logs\n\nPersistent logs are available on all plans, with a free allocation for both free and paid plans. Charges for additional logs beyond those limits are based on the number of logs stored per month.\n\n### Free allocation and overage pricing\n\n| Plan | Free logs stored | Overage pricing |\n| - | - | - |\n| Workers Free | 100,000 logs total | N/A - Upgrade to Workers Paid |\n| Workers Paid | 1,000,000 logs total | N/A |\n\nAllocations are based on the total logs stored across all gateways. For guidance on managing or deleting logs, please see our [documentation](https://developers.cloudflare.com/ai-gateway/observability/logging).\n\n## Logpush\n\nLogpush is only available on the Workers Paid plan.\n\n| | Paid plan |\n| - | - |\n| Requests | 10 million / month, +$0.05/million |\n\n## Fine print\n\nPrices subject to change. If you are an Enterprise customer, reach out to your account team to confirm pricing details.\n\n</page>\n\n<page>\n---\ntitle: Create your first AI Gateway using Workers AI · Cloudflare AI Gateway docs\ndescription: This tutorial guides you through creating your first AI Gateway\n  using Workers AI on the Cloudflare dashboard.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/tutorials/create-first-aig-workers/\n  md: https://developers.cloudflare.com/ai-gateway/tutorials/create-first-aig-workers/index.md\n---\n\nThis tutorial guides you through creating your first AI Gateway using Workers AI on the Cloudflare dashboard. The intended audience is beginners who are new to AI Gateway and Workers AI. Creating an AI Gateway enables the user to efficiently manage and secure AI requests, allowing them to utilize AI models for tasks such as content generation, data processing, or predictive analysis with enhanced control and performance.\n\n## Sign up and log in\n\n1. **Sign up**: If you do not have a Cloudflare account, [sign up](https://cloudflare.com/sign-up).\n2. **Log in**: Access the Cloudflare dashboard by logging in to the [Cloudflare dashboard](https://dash.cloudflare.com/login).\n\n## Create gateway\n\nThen, create a new AI Gateway.\n\n* Dashboard\n\n  [Create a Gateway](https://dash.cloudflare.com/?to=/:account/ai/ai-gateway#create)\n\n  1. Log into the [Cloudflare dashboard](https://dash.cloudflare.com/) and select your account.\n  2. Go to **AI** > **AI Gateway**.\n  3. Select **Create Gateway**.\n  4. Enter your **Gateway name**. Note: Gateway name has a 64 character limit.\n  5. Select **Create**.\n\n* API\n\n  To set up an AI Gateway using the API:\n\n  1. [Create an API token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/) with the following permissions:\n\n     * `AI Gateway - Read`\n     * `AI Gateway - Edit`\n\n  2. Get your [Account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids/).\n\n  3. Using that API token and Account ID, send a [`POST` request](https://developers.cloudflare.com/api/resources/ai_gateway/methods/create/) to the Cloudflare API.\n\n## Connect Your AI Provider\n\n1. In the AI Gateway section, select the gateway you created.\n2. Select **Workers AI** as your provider to set up an endpoint specific to Workers AI. You will receive an endpoint URL for sending requests.\n\n## Configure Your Workers AI\n\n1. Go to **AI** > **Workers AI** in the Cloudflare dashboard.\n\n2. Select **Use REST API** and follow the steps to create and copy the API token and Account ID.\n\n3. **Send Requests to Workers AI**: Use the provided API endpoint. For example, you can run a model via the API using a curl command. Replace `{account_id}`, `{gateway_id}` and `{cf_api_token}` with your actual account ID and API token:",
      "language": "unknown"
    },
    {
      "code": "The expected output would be similar to :",
      "language": "unknown"
    },
    {
      "code": "## View Analytics\n\nMonitor your AI Gateway to view usage metrics.\n\n1. Go to **AI** > **AI Gateway** in the dashboard.\n2. Select your gateway to view metrics such as request counts, token usage, caching efficiency, errors, and estimated costs. You can also turn on additional configurations like logging and rate limiting.\n\n## Optional - Next steps\n\nTo build more with Workers, refer to [Tutorials](https://developers.cloudflare.com/workers/tutorials/).\n\nIf you have any questions, need assistance, or would like to share your project, join the Cloudflare Developer community on [Discord](https://discord.cloudflare.com) to connect with other developers and the Cloudflare team.\n\n</page>\n\n<page>\n---\ntitle: Deploy a Worker that connects to OpenAI via AI Gateway · Cloudflare AI\n  Gateway docs\ndescription: Learn how to deploy a Worker that makes calls to OpenAI through AI Gateway\nlastUpdated: 2025-11-14T10:07:26.000Z\nchatbotDeprioritize: false\ntags: AI,JavaScript\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/tutorials/deploy-aig-worker/\n  md: https://developers.cloudflare.com/ai-gateway/tutorials/deploy-aig-worker/index.md\n---\n\nIn this tutorial, you will learn how to deploy a Worker that makes calls to OpenAI through AI Gateway. AI Gateway helps you better observe and control your AI applications with more analytics, caching, rate limiting, and logging.\n\nThis tutorial uses the most recent v4 OpenAI node library, an update released in August 2023.\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## 1. Create an AI Gateway and OpenAI API key\n\nOn the AI Gateway page in the Cloudflare dashboard, create a new AI Gateway by clicking the plus button on the top right. You should be able to name the gateway as well as the endpoint. Click on the API Endpoints button to copy the endpoint. You can choose from provider-specific endpoints such as OpenAI, HuggingFace, and Replicate. Or you can use the universal endpoint that accepts a specific schema and supports model fallback and retries.\n\nFor this tutorial, we will be using the OpenAI provider-specific endpoint, so select OpenAI in the dropdown and copy the new endpoint.\n\nYou will also need an OpenAI account and API key for this tutorial. If you do not have one, create a new OpenAI account and create an API key to continue with this tutorial. Make sure to store your API key somewhere safe so you can use it later.\n\n## 2. Create a new Worker\n\nCreate a Worker project in the command line:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nGo to your new open Worker project:",
      "language": "unknown"
    },
    {
      "code": "Inside of your new openai-aig directory, find and open the `src/index.js` file. You will configure this file for most of the tutorial.\n\nInitially, your generated `index.js` file should look like this:",
      "language": "unknown"
    },
    {
      "code": "## 3. Configure OpenAI in your Worker\n\nWith your Worker project created, we can learn how to make your first request to OpenAI. You will use the OpenAI node library to interact with the OpenAI API. Install the OpenAI node library with `npm`:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "In your `src/index.js` file, add the import for `openai` above `export default`:",
      "language": "unknown"
    },
    {
      "code": "Within your `fetch` function, set up the configuration and instantiate your `OpenAIApi` client with the AI Gateway endpoint you created:",
      "language": "unknown"
    },
    {
      "code": "To make this work, you need to use [`wrangler secret put`](https://developers.cloudflare.com/workers/wrangler/commands/#secret-put) to set your `OPENAI_API_KEY`. This will save the API key to your environment so your Worker can access it when deployed. This key is the API key you created earlier in the OpenAI dashboard:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "To make this work in local development, create a new file `.dev.vars` in your Worker project and add this line. Make sure to replace `OPENAI_API_KEY` with your own OpenAI API key:",
      "language": "unknown"
    },
    {
      "code": "## 4. Make an OpenAI request\n\nNow we can make a request to the OpenAI [Chat Completions API](https://platform.openai.com/docs/guides/gpt/chat-completions-api).\n\nYou can specify what model you'd like, the role and prompt, as well as the max number of tokens you want in your total request.",
      "language": "unknown"
    },
    {
      "code": "## 5. Deploy your Worker application\n\nTo deploy your application, run the `npx wrangler deploy` command to deploy your Worker application:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "You can now preview your Worker at \\<YOUR\\_WORKER>.\\<YOUR\\_SUBDOMAIN>.workers.dev.\n\n## 6. Review your AI Gateway\n\nWhen you go to AI Gateway in your Cloudflare dashboard, you should see your recent request being logged. You can also [tweak your settings](https://developers.cloudflare.com/ai-gateway/configuration/) to manage your logs, caching, and rate limiting settings.\n\n</page>\n\n<page>\n---\ntitle: Unified API (OpenAI compat) · Cloudflare AI Gateway docs\ndescription: Cloudflare's AI Gateway offers an OpenAI-compatible\n  /chat/completions endpoint, enabling integration with multiple AI providers\n  using a single URL. This feature simplifies the integration process, allowing\n  for seamless switching between different models without significant code\n  modifications.\nlastUpdated: 2025-12-08T07:14:56.000Z\nchatbotDeprioritize: false\ntags: AI\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/usage/chat-completion/\n  md: https://developers.cloudflare.com/ai-gateway/usage/chat-completion/index.md\n---\n\nCloudflare's AI Gateway offers an OpenAI-compatible `/chat/completions` endpoint, enabling integration with multiple AI providers using a single URL. This feature simplifies the integration process, allowing for seamless switching between different models without significant code modifications.\n\n## Endpoint URL",
      "language": "unknown"
    },
    {
      "code": "Replace `{account_id}` and `{gateway_id}` with your Cloudflare account and gateway IDs.\n\n## Parameters\n\nSwitch providers by changing the `model` and `apiKey` parameters.\n\nSpecify the model using `{provider}/{model}` format. For example:\n\n* `openai/gpt-5-mini`\n* `google-ai-studio/gemini-2.5-flash`\n* `anthropic/claude-sonnet-4-5`\n\n## Examples\n\n### OpenAI SDK\n\nWith Key in Request\n\n* With Authenticated Gateway",
      "language": "unknown"
    },
    {
      "code": "* Unauthenticated Gateway",
      "language": "unknown"
    },
    {
      "code": "With Stored Keys (BYOK) / Unified Billing",
      "language": "unknown"
    },
    {
      "code": "### cURL\n\nWith Key in Request\n\n* With Authenticated Gateway",
      "language": "unknown"
    },
    {
      "code": "* Unauthenticated Gateway",
      "language": "unknown"
    },
    {
      "code": "With Stored Keys (BYOK) / Unified Billing",
      "language": "unknown"
    },
    {
      "code": "## Supported Providers\n\nThe OpenAI-compatible endpoint supports models from the following providers:\n\n* [Anthropic](https://developers.cloudflare.com/ai-gateway/usage/providers/anthropic/)\n* [OpenAI](https://developers.cloudflare.com/ai-gateway/usage/providers/openai/)\n* [Groq](https://developers.cloudflare.com/ai-gateway/usage/providers/groq/)\n* [Mistral](https://developers.cloudflare.com/ai-gateway/usage/providers/mistral/)\n* [Cohere](https://developers.cloudflare.com/ai-gateway/usage/providers/cohere/)\n* [Perplexity](https://developers.cloudflare.com/ai-gateway/usage/providers/perplexity/)\n* [Workers AI](https://developers.cloudflare.com/ai-gateway/usage/providers/workersai/)\n* [Google-AI-Studio](https://developers.cloudflare.com/ai-gateway/usage/providers/google-ai-studio/)\n* [Google Vertex AI](https://developers.cloudflare.com/ai-gateway/usage/providers/vertex/)\n* [xAI](https://developers.cloudflare.com/ai-gateway/usage/providers/grok/)\n* [DeepSeek](https://developers.cloudflare.com/ai-gateway/usage/providers/deepseek/)\n* [Cerebras](https://developers.cloudflare.com/ai-gateway/usage/providers/cerebras/)\n* [Baseten](https://developers.cloudflare.com/ai-gateway/usage/providers/baseten/)\n* [Parallel](https://developers.cloudflare.com/ai-gateway/usage/providers/parallel/)\n\n</page>\n\n<page>\n---\ntitle: Universal Endpoint · Cloudflare AI Gateway docs\ndescription: You can use the Universal Endpoint to contact every provider.\nlastUpdated: 2025-08-20T18:25:25.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/usage/universal/\n  md: https://developers.cloudflare.com/ai-gateway/usage/universal/index.md\n---\n\nNote\n\nIt is recommended to use the Dynamic Routes to implement model fallback feature\n\nYou can use the Universal Endpoint to contact every provider.",
      "language": "unknown"
    },
    {
      "code": "AI Gateway offers multiple endpoints for each Gateway you create - one endpoint per provider, and one Universal Endpoint. The Universal Endpoint requires some adjusting to your schema, but supports additional features. Some of these features are, for example, retrying a request if it fails the first time, or configuring a [fallback model/provider](https://developers.cloudflare.com/ai-gateway/configuration/fallbacks/).\n\nYou can use the Universal endpoint to contact every provider. The payload is expecting an array of message, and each message is an object with the following parameters:\n\n* `provider` : the name of the provider you would like to direct this message to. Can be OpenAI, workers-ai, or any of our supported providers.\n* `endpoint`: the pathname of the provider API you’re trying to reach. For example, on OpenAI it can be `chat/completions`, and for Workers AI this might be [`@cf/meta/llama-3.1-8b-instruct`](https://developers.cloudflare.com/workers-ai/models/llama-3.1-8b-instruct/). See more in the sections that are specific to [each provider](https://developers.cloudflare.com/ai-gateway/usage/providers/).\n* `authorization`: the content of the Authorization HTTP Header that should be used when contacting this provider. This usually starts with 'Token' or 'Bearer'.\n* `query`: the payload as the provider expects it in their official API.\n\n## cURL example",
      "language": "unknown"
    },
    {
      "code": "The above will send a request to Workers AI Inference API, if it fails it will proceed to OpenAI. You can add as many fallbacks as you need, just by adding another JSON in the array.\n\n## WebSockets API beta\n\nThe Universal Endpoint can also be accessed via a [WebSockets API](https://developers.cloudflare.com/ai-gateway/usage/websockets-api/) which provides a single persistent connection, enabling continuous communication. This API supports all AI providers connected to AI Gateway, including those that do not natively support WebSockets.\n\n## WebSockets example",
      "language": "unknown"
    },
    {
      "code": "## Workers Binding example\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## Header configuration hierarchy\n\nThe Universal Endpoint allows you to set fallback models or providers and customize headers for each provider or request. You can configure headers at three levels:\n\n1. **Provider level**: Headers specific to a particular provider.\n2. **Request level**: Headers included in individual requests.\n3. **Gateway settings**: Default headers configured in your gateway dashboard.\n\nSince the same settings can be configured in multiple locations, AI Gateway applies a hierarchy to determine which configuration takes precedence:\n\n* **Provider-level headers** override all other configurations.\n* **Request-level headers** are used if no provider-level headers are set.\n* **Gateway-level settings** are used only if no headers are configured at the provider or request levels.\n\nThis hierarchy ensures consistent behavior, prioritizing the most specific configurations. Use provider-level and request-level headers for fine-tuned control, and gateway settings for general defaults.\n\n## Hierarchy example\n\nThis example demonstrates how headers set at different levels impact caching behavior:\n\n* **Request-level header**: The `cf-aig-cache-ttl` is set to `3600` seconds, applying this caching duration to the request by default.\n* **Provider-level header**: For the fallback provider (OpenAI), `cf-aig-cache-ttl` is explicitly set to `0` seconds, overriding the request-level header and disabling caching for responses when OpenAI is used as the provider.\n\nThis shows how provider-level headers take precedence over request-level headers, allowing for granular control of caching behavior.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Provider Native · Cloudflare AI Gateway docs\ndescription: \"Here is a quick list of the providers we support:\"\nlastUpdated: 2025-08-27T13:32:22.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/usage/providers/\n  md: https://developers.cloudflare.com/ai-gateway/usage/providers/index.md\n---\n\nHere is a quick list of the providers we support:\n\n* [Amazon Bedrock](https://developers.cloudflare.com/ai-gateway/usage/providers/bedrock/)\n* [Anthropic](https://developers.cloudflare.com/ai-gateway/usage/providers/anthropic/)\n* [Azure OpenAI](https://developers.cloudflare.com/ai-gateway/usage/providers/azureopenai/)\n* [Baseten](https://developers.cloudflare.com/ai-gateway/usage/providers/baseten/)\n* [Cartesia](https://developers.cloudflare.com/ai-gateway/usage/providers/cartesia/)\n* [Cerebras](https://developers.cloudflare.com/ai-gateway/usage/providers/cerebras/)\n* [Cohere](https://developers.cloudflare.com/ai-gateway/usage/providers/cohere/)\n* [Deepgram](https://developers.cloudflare.com/ai-gateway/usage/providers/deepgram/)\n* [DeepSeek](https://developers.cloudflare.com/ai-gateway/usage/providers/deepseek/)\n* [ElevenLabs](https://developers.cloudflare.com/ai-gateway/usage/providers/elevenlabs/)\n* [Fal AI](https://developers.cloudflare.com/ai-gateway/usage/providers/fal/)\n* [Google AI Studio](https://developers.cloudflare.com/ai-gateway/usage/providers/google-ai-studio/)\n* [Google Vertex AI](https://developers.cloudflare.com/ai-gateway/usage/providers/vertex/)\n* [Groq](https://developers.cloudflare.com/ai-gateway/usage/providers/groq/)\n* [HuggingFace](https://developers.cloudflare.com/ai-gateway/usage/providers/huggingface/)\n* [Ideogram](https://developers.cloudflare.com/ai-gateway/usage/providers/ideogram/)\n* [Mistral AI](https://developers.cloudflare.com/ai-gateway/usage/providers/mistral/)\n* [OpenAI](https://developers.cloudflare.com/ai-gateway/usage/providers/openai/)\n* [OpenRouter](https://developers.cloudflare.com/ai-gateway/usage/providers/openrouter/)\n* [Parallel](https://developers.cloudflare.com/ai-gateway/usage/providers/parallel/)\n* [Perplexity](https://developers.cloudflare.com/ai-gateway/usage/providers/perplexity/)\n* [Replicate](https://developers.cloudflare.com/ai-gateway/usage/providers/replicate/)\n* [xAI](https://developers.cloudflare.com/ai-gateway/usage/providers/grok/)\n* [Workers AI](https://developers.cloudflare.com/ai-gateway/usage/providers/workersai/)\n\n</page>\n\n<page>\n---\ntitle: WebSockets API · Cloudflare AI Gateway docs\ndescription: \"The AI Gateway WebSockets API provides a persistent connection for\n  AI interactions, eliminating repeated handshakes and reducing latency. This\n  API is divided into two categories:\"\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/ai-gateway/usage/websockets-api/\n  md: https://developers.cloudflare.com/ai-gateway/usage/websockets-api/index.md\n---\n\nThe AI Gateway WebSockets API provides a persistent connection for AI interactions, eliminating repeated handshakes and reducing latency. This API is divided into two categories:\n\n* **Realtime APIs** - Designed for AI providers that offer low-latency, multimodal interactions over WebSockets.\n* **Non-Realtime APIs** - Supports standard WebSocket communication for AI providers, including those that do not natively support WebSockets.\n\n## When to use WebSockets\n\nWebSockets are long-lived TCP connections that enable bi-directional, real-time and non realtime communication between client and server. Unlike HTTP connections, which require repeated handshakes for each request, WebSockets maintain the connection, supporting continuous data exchange with reduced overhead. WebSockets are ideal for applications needing low-latency, real-time data, such as voice assistants.\n\n## Key benefits\n\n* **Reduced overhead**: Avoid overhead of repeated handshakes and TLS negotiations by maintaining a single, persistent connection.\n* **Provider compatibility**: Works with all AI providers in AI Gateway. Even if your chosen provider does not support WebSockets, Cloudflare handles it for you, managing the requests to your preferred AI provider.\n\n## Key differences\n\n| Feature | Realtime APIs | Non-Realtime APIs |\n| - | - | - |\n| **Purpose** | Enables real-time, multimodal AI interactions for providers that offer dedicated WebSocket endpoints. | Supports WebSocket-based AI interactions with providers that do not natively support WebSockets. |\n| **Use Case** | Streaming responses for voice, video, and live interactions. | Text-based queries and responses, such as LLM requests. |\n| **AI Provider Support** | [Limited to providers offering real-time WebSocket APIs.](https://developers.cloudflare.com/ai-gateway/usage/websockets-api/realtime-api/#supported-providers) | [All AI providers in AI Gateway.](https://developers.cloudflare.com/ai-gateway/usage/providers/) |\n| **Streaming Support** | Providers natively support real-time data streaming. | AI Gateway handles streaming via WebSockets. |\n\nFor details on implementation, refer to the next sections:\n\n* [Realtime WebSockets API](https://developers.cloudflare.com/ai-gateway/usage/websockets-api/realtime-api/)\n* [Non-Realtime WebSockets API](https://developers.cloudflare.com/ai-gateway/usage/websockets-api/non-realtime-api/)\n\n</page>\n\n<page>\n---\ntitle: Agents API · Cloudflare Agents docs\ndescription: This page provides an overview of the Agent SDK API, including the\n  Agent class, methods and properties built-in to the Agents SDK.\nlastUpdated: 2025-12-12T16:34:43.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/agents-api/\n  md: https://developers.cloudflare.com/agents/api-reference/agents-api/index.md\n---\n\nThis page provides an overview of the Agent SDK API, including the `Agent` class, methods and properties built-in to the Agents SDK.\n\nThe Agents SDK exposes two main APIs:\n\n* The server-side `Agent` class. An Agent encapsulates all of the logic for an Agent, including how clients can connect to it, how it stores state, the methods it exposes, how to call AI models, and any error handling.\n* The client-side `AgentClient` class, which allows you to connect to an Agent instance from a client-side application. The client APIs also include React hooks, including `useAgent` and `useAgentChat`, and allow you to automatically synchronize state between each unique Agent (running server-side) and your client applications.\n\nNote\n\nAgents require [Cloudflare Durable Objects](https://developers.cloudflare.com/durable-objects/), see [Configuration](https://developers.cloudflare.com/agents/getting-started/testing-your-agent/#add-the-agent-configuration) to learn how to add the required bindings to your project.\n\nYou can also find more specific usage examples for each API in the [Agents API Reference](https://developers.cloudflare.com/agents/api-reference/).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "An Agent can have many (millions of) instances: each instance is a separate micro-server that runs independently of the others. This allows Agents to scale horizontally: an Agent can be associated with a single user, or many thousands of users, depending on the agent you're building.\n\nInstances of an Agent are addressed by a unique identifier: that identifier (ID) can be the user ID, an email address, GitHub username, a flight ticket number, an invoice ID, or any other identifier that helps to uniquely identify the instance and for whom it is acting on behalf of.\n\nNote\n\nAn instance of an Agent is globally unique: given the same name (or ID), you will always get the same instance of an agent.\n\nThis allows you to avoid synchronizing state across requests: if an Agent instance represents a specific user, team, channel or other entity, you can use the Agent instance to store state for that entity. No need to set up a centralized session store.\n\nIf the client disconnects, you can always route the client back to the exact same Agent and pick up where they left off.\n\n### Agent class API\n\nWriting an Agent requires you to define a class that extends the `Agent` class from the Agents SDK package. An Agent encapsulates all of the logic for an Agent, including how clients can connect to it, how it stores state, the methods it exposes, and any error handling.\n\nYou can also define your own methods on an Agent: it's technically valid to publish an Agent that only has your own methods exposed, and create/get Agents directly from a Worker.\n\nYour own methods can access the Agent's environment variables and bindings on `this.env`, state on `this.setState`, and call other methods on the Agent via `this.yourMethodName`.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "### WebSocket API\n\nThe WebSocket API allows you to accept and manage WebSocket connections made to an Agent.\n\n#### Connection\n\nRepresents a WebSocket connection to an Agent.",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "#### WSMessage\n\nTypes of messages that can be received from a WebSocket.",
      "language": "unknown"
    },
    {
      "code": "#### ConnectionContext\n\nContext information for a WebSocket connection.",
      "language": "unknown"
    },
    {
      "code": "### State synchronization API\n\nNote\n\nTo learn more about how to manage state within an Agent, refer to the documentation on [managing and syncing state](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/).\n\n#### State\n\nMethods and types for managing Agent state.",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Scheduling API\n\n#### Scheduling tasks\n\nSchedule tasks to run at a specified time in the future.",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "#### Schedule object\n\nRepresents a scheduled task.",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### SQL API\n\nEach Agent instance has an embedded SQLite database that can be accessed using the `this.sql` method within any method on your `Agent` class.\n\n#### SQL queries\n\nExecute SQL queries against the Agent's built-in SQLite database using the `this.sql` method within any method on your `Agent` class.",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Note\n\nVisit the [state management API documentation](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) within the Agents SDK, including the native `state` APIs and the built-in `this.sql` API for storing and querying data within your Agents.\n\n### MCP Client API\n\nThe Agents SDK allows your Agent to act as an MCP (Model Context Protocol) client, connecting to remote MCP servers and using their tools, resources, and prompts.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "When your Agent connects to MCP servers, it can dynamically discover and use tools provided by those servers, enabling powerful integrations with external services.\n\nNote\n\nFor complete MCP client API documentation, including OAuth configuration and advanced usage, refer to the [Agent — MCP Client API](https://developers.cloudflare.com/agents/model-context-protocol/mcp-client-api/).\n\n### Client API\n\nThe Agents SDK provides a set of client APIs for interacting with Agents from client-side JavaScript code, including:\n\n* React hooks, including `useAgent` and `useAgentChat`, for connecting to Agents from client applications.\n* Client-side [state syncing](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) that allows you to subscribe to state updates between the Agent and any connected client(s) when calling `this.setState` within your Agent's code.\n* The ability to call remote methods (Remote Procedure Calls; RPC) on the Agent from client-side JavaScript code using the `@callable` method decorator.\n\n#### AgentClient\n\nClient for connecting to an Agent from the browser.",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "#### agentFetch\n\nMake an HTTP request to an Agent.",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### React API\n\nThe Agents SDK provides a React API for simplifying connection and routing to Agents from front-end frameworks, including React Router (Remix), Next.js, and Astro.\n\n#### useAgent\n\nReact hook for connecting to an Agent.",
      "language": "unknown"
    },
    {
      "code": "### Chat Agent\n\nThe Agents SDK exposes an `AIChatAgent` class that extends the `Agent` class and exposes an `onChatMessage` method that simplifies building interactive chat agents.\n\nYou can combine this with the `useAgentChat` React hook from the `agents/ai-react` package to manage chat state and messages between a user and your Agent(s).\n\n#### AIChatAgent\n\nExtension of the `Agent` class with built-in chat capabilities.",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "#### Resumable streaming\n\nThe `AIChatAgent` class provides **automatic resumable streaming** out of the box. When a client disconnects and reconnects during an active stream, the response automatically resumes from where it left off. This works across browser tabs and devices.\n\n##### How it works\n\nWhen you use `AIChatAgent` with `useAgentChat`:\n\n1. **During streaming**: All chunks are automatically persisted to SQLite\n2. **On disconnect**: The stream continues server-side, buffering chunks\n3. **On reconnect**: Client receives all buffered chunks and continues streaming\n\n##### Server\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "##### Disabling resume\n\nIf you don't want automatic resume (for example, for short responses), disable it:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Chat Agent React API\n\n#### useAgentChat\n\nReact hook for building AI chat interfaces using an Agent.",
      "language": "unknown"
    },
    {
      "code": "* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Next steps\n\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n</page>\n\n<page>\n---\ntitle: Browse the web · Cloudflare Agents docs\ndescription: Agents can browse the web using the Browser Rendering API or your\n  preferred headless browser service.\nlastUpdated: 2025-05-16T16:37:37.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/browse-the-web/\n  md: https://developers.cloudflare.com/agents/api-reference/browse-the-web/index.md\n---\n\nAgents can browse the web using the [Browser Rendering](https://developers.cloudflare.com/browser-rendering/) API or your preferred headless browser service.\n\n### Browser Rendering API\n\nThe [Browser Rendering](https://developers.cloudflare.com/browser-rendering/) allows you to spin up headless browser instances, render web pages, and interact with websites through your Agent.\n\nYou can define a method that uses Puppeteer to pull the content of a web page, parse the DOM, and extract relevant information by calling the OpenAI model:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "You'll also need to add install the `@cloudflare/puppeteer` package and add the following to the wrangler configuration of your Agent:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "- wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "- wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "### Browserbase\n\nYou can also use [Browserbase](https://docs.browserbase.com/integrations/cloudflare/typescript) by using the Browserbase API directly from within your Agent.\n\nOnce you have your [Browserbase API key](https://docs.browserbase.com/integrations/cloudflare/typescript), you can add it to your Agent by creating a [secret](https://developers.cloudflare.com/workers/configuration/secrets/):",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "Install the `@cloudflare/puppeteer` package and use it from within your Agent to call the Browserbase API:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Calling Agents · Cloudflare Agents docs\ndescription: Learn how to call your Agents from Workers, including how to create\n  Agents on-the-fly, address them, and route requests to specific instances of\n  an Agent.\nlastUpdated: 2025-08-27T15:01:29.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/calling-agents/\n  md: https://developers.cloudflare.com/agents/api-reference/calling-agents/index.md\n---\n\nLearn how to call your Agents from Workers, including how to create Agents on-the-fly, address them, and route requests to specific instances of an Agent.\n\n### Calling your Agent\n\nAgents are created on-the-fly and can serve multiple requests concurrently. Each Agent instance is isolated from other instances, can maintain its own state, and has a unique address.\n\nNote\n\nAn instance of an Agent is globally unique: given the same name (or ID), you will always get the same instance of an agent.\n\nThis allows you to avoid synchronizing state across requests: if an Agent instance represents a specific user, team, channel or other entity, you can use the Agent instance to store state for that entity. No need to set up a centralized session store.\n\nIf the client disconnects, you can always route the client back to the exact same Agent and pick up where they left off.\n\nYou can create and run an instance of an Agent directly from a Worker using either:\n\n* The `routeAgentRequest` helper: this will automatically map requests to an individual Agent based on the `/agents/:agent/:name` URL pattern. The value of `:agent` will be the name of your Agent class converted to `kebab-case`, and the value of `:name` will be the name of the Agent instance you want to create or retrieve.\n* `getAgentByName`, which will create a new Agent instance if none exists by that name, or retrieve a handle to an existing instance.\n\nSee the usage patterns in the following example:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Calling other Agents\n\nYou can also call other Agents from within an Agent and build multi-Agent systems.\n\nCalling other Agents uses the same APIs as calling into an Agent directly.\n\n### Calling methods on Agents\n\nWhen using `getAgentByName`, you can pass both requests (including WebSocket) connections and call methods defined directly on the Agent itself using the native [JavaScript RPC](https://developers.cloudflare.com/workers/runtime-apis/rpc/) (JSRPC) API.\n\nFor example, once you have a handle (or \"stub\") to an unique instance of your Agent, you can call methods on it:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "When using TypeScript, ensure you pass your Agent class as a TypeScript type parameter to the AgentNamespace type so that types are correctly inferred:",
      "language": "unknown"
    },
    {
      "code": "### Naming your Agents\n\nWhen creating names for your Agents, think about what the Agent represents. A unique user? A team or company? A room or channel for collaboration?\n\nA consistent approach to naming allows you to:\n\n* direct incoming requests directly to the right Agent\n* deterministically route new requests back to that Agent, no matter where the client is in the world.\n* avoid having to rely on centralized session storage or external services for state management, since each Agent instance can maintain its own state.\n\nFor a given Agent definition (or 'namespace' in the code below), there can be millions (or tens of millions) of instances of that Agent, each handling their own requests, making calls to LLMs, and maintaining their own state.\n\nFor example, you might have an Agent for every user using your new AI-based code editor. In that case, you'd want to create Agents based on the user ID from your system, which would then allow that Agent to handle all requests for that user.\n\nIt also ensures that [state within the Agent](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/), including chat history, language preferences, model configuration and other context can associated specifically with that user, making it easier to manage state.\n\nThe example below shows how to create a unique agent Agent for each `userId` in a request:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Replace `userId` with `teamName`, `channel`, `companyName` as fits your Agents goals - and/or configure authentication to ensure Agents are only created for known, authenticated users.\n\n### Authenticating Agents\n\nWhen building and deploying Agents using the Agents SDK, you will often want to authenticate clients before passing requests to an Agent in order to restrict who the Agent will call, authorize specific users for specific Agents, and/or to limit who can access administrative or debug APIs exposed by an Agent.\n\nAs best practices:\n\n* Handle authentication in your Workers code, before you invoke your Agent.\n* Use the built-in hooks when using the `routeAgentRequest` helper - `onBeforeConnect` and `onBeforeRequest`\n* Use your preferred router (such as Hono) and authentication middleware or provider to apply custom authentication schemes before calling an Agent using other methods.\n\nThe `routeAgentRequest` helper documented earlier in this guide exposes two useful hooks (`onBeforeConnect`, `onBeforeRequest`) that allow you to apply custom logic before creating or retrieving an Agent:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "If you are using `getAgentByName` or the underlying Durable Objects routing API, you should authenticate incoming requests or WebSocket connections before calling `getAgentByName`.\n\nFor example, if you are using [Hono](https://hono.dev/), you can authenticate in the middleware before calling an Agent and passing a request (or a WebSocket connection) to it:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "This ensures we only create Agents for authenticated users, and allows you to validate whether Agent names conform to your preferred naming scheme before instances are created.\n\n### Next steps\n\n* Review the [API documentation](https://developers.cloudflare.com/agents/api-reference/agents-api/) for the Agents class to learn how to define\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n</page>\n\n<page>\n---\ntitle: Configuration · Cloudflare Agents docs\ndescription: An Agent is configured like any other Cloudflare Workers project,\n  and uses a wrangler configuration file to define where your code is and what\n  services (bindings) it will use.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/configuration/\n  md: https://developers.cloudflare.com/agents/api-reference/configuration/index.md\n---\n\nAn Agent is configured like any other Cloudflare Workers project, and uses [a wrangler configuration](https://developers.cloudflare.com/workers/wrangler/configuration/) file to define where your code is and what services (bindings) it will use.\n\n### Project structure\n\nThe typical file structure for an Agent project created from `npm create cloudflare@latest agents-starter -- --template cloudflare/agents-starter` follows:",
      "language": "unknown"
    },
    {
      "code": "### Example configuration\n\nBelow is a minimal `wrangler.jsonc` file that defines the configuration for an Agent, including the entry point, `durable_object` namespace, and code `migrations`:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "The configuration includes:\n\n* A `main` field that points to the entry point of your Agent, which is typically a TypeScript (or JavaScript) file.\n* A `durable_objects` field that defines the [Durable Object namespace](https://developers.cloudflare.com/durable-objects/reference/glossary/) that your Agents will run within.\n* A `migrations` field that defines the code migrations that your Agent will use. This field is mandatory and must contain at least one migration. The `new_sqlite_classes` field is mandatory for the Agent to store state.\n\nAgents must define these fields in their `wrangler.jsonc` (or `wrangler.toml`) config file.\n\n</page>\n\n<page>\n---\ntitle: HTTP and Server-Sent Events · Cloudflare Agents docs\ndescription: The Agents SDK allows you to handle HTTP requests and has native\n  support for Server-Sent Events (SSE). This allows you build applications that\n  can push data to clients and avoid buffering.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/http-sse/\n  md: https://developers.cloudflare.com/agents/api-reference/http-sse/index.md\n---\n\nThe Agents SDK allows you to handle HTTP requests and has native support for [Server-Sent Events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events) (SSE). This allows you build applications that can push data to clients and avoid buffering.\n\n### Handling HTTP requests\n\nAgents can handle HTTP requests using the `onRequest` method, which is called whenever an HTTP request is received by the Agent instance. The method takes a `Request` object as a parameter and returns a `Response` object.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Review the [Agents API reference](https://developers.cloudflare.com/agents/api-reference/agents-api/) to learn more about the `Agent` class and its methods.\n\n### Implementing Server-Sent Events\n\nThe Agents SDK support Server-Sent Events directly: you can use SSE to stream data back to the client over a long running connection. This avoids buffering large responses, which can both make your Agent feel slow, and forces you to buffer the entire response in memory.\n\nWhen an Agent is deployed to Cloudflare Workers, there is no effective limit on the total time it takes to stream the response back: large AI model responses that take several minutes to reason and then respond will not be prematurely terminated.\n\nNote that this does not mean the client can't potentially disconnect during the streaming process: you can account for this by either [writing to the Agent's stateful storage](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) and/or [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/). Because you can always [route to the same Agent](https://developers.cloudflare.com/agents/api-reference/calling-agents/), you do not need to use a centralized session store to pick back up where you left off when a client disconnects.\n\nThe following example uses the AI SDK to generate text and stream it back to the client. It will automatically stream the response back to the client as the model generates it:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### WebSockets vs. Server-Sent Events\n\nBoth WebSockets and Server-Sent Events (SSE) enable real-time communication between clients and Agents. Agents built on the Agents SDK can expose both WebSocket and SSE endpoints directly.\n\n* WebSockets provide full-duplex communication, allowing data to flow in both directions simultaneously. SSE only supports server-to-client communication, requiring additional HTTP requests if the client needs to send data back.\n* WebSockets establish a single persistent connection that stays open for the duration of the session. SSE, being built on HTTP, may experience more overhead due to reconnection attempts and header transmission with each reconnection, especially when there is a lot of client-server communication.\n* While SSE works well for simple streaming scenarios, WebSockets are better suited for applications requiring minutes or hours of connection time, as they maintain a more stable connection with built-in ping/pong mechanisms to keep connections alive.\n* WebSockets use their own protocol (ws\\:// or wss\\://), separating them from HTTP after the initial handshake. This separation allows WebSockets to better handle binary data transmission and implement custom subprotocols for specialized use cases.\n\nIf you're unsure of which is better for your use-case, we recommend WebSockets. The [WebSockets API documentation](https://developers.cloudflare.com/agents/api-reference/websockets/) provides detailed information on how to use WebSockets with the Agents SDK.\n\n### Next steps\n\n* Review the [API documentation](https://developers.cloudflare.com/agents/api-reference/agents-api/) for the Agents class to learn how to define them.\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n</page>\n\n<page>\n---\ntitle: Retrieval Augmented Generation · Cloudflare Agents docs\ndescription: Agents can use Retrieval Augmented Generation (RAG) to retrieve\n  relevant information and use it augment calls to AI models. Store a user's\n  chat history to use as context for future conversations, summarize documents\n  to bootstrap an Agent's knowledge base, and/or use data from your Agent's web\n  browsing tasks to enhance your Agent's capabilities.\nlastUpdated: 2025-05-14T14:20:47.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/rag/\n  md: https://developers.cloudflare.com/agents/api-reference/rag/index.md\n---\n\nAgents can use Retrieval Augmented Generation (RAG) to retrieve relevant information and use it augment [calls to AI models](https://developers.cloudflare.com/agents/api-reference/using-ai-models/). Store a user's chat history to use as context for future conversations, summarize documents to bootstrap an Agent's knowledge base, and/or use data from your Agent's [web browsing](https://developers.cloudflare.com/agents/api-reference/browse-the-web/) tasks to enhance your Agent's capabilities.\n\nYou can use the Agent's own [SQL database](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state) as the source of truth for your data and store embeddings in [Vectorize](https://developers.cloudflare.com/vectorize/) (or any other vector-enabled database) to allow your Agent to retrieve relevant information.\n\n### Vector search\n\nNote\n\nIf you're brand-new to vector databases and Vectorize, visit the [Vectorize tutorial](https://developers.cloudflare.com/vectorize/get-started/intro/) to learn the basics, including how to create an index, insert data, and generate embeddings.\n\nYou can query a vector index (or indexes) from any method on your Agent: any Vectorize index you attach is available on `this.env` within your Agent. If you've [associated metadata](https://developers.cloudflare.com/vectorize/best-practices/insert-vectors/#metadata) with your vectors that maps back to data stored in your Agent, you can then look up the data directly within your Agent using `this.sql`.\n\nHere's an example of how to give an Agent retrieval capabilities:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "You'll also need to connect your Agent to your vector indexes:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "If you have multiple indexes you want to make available, you can provide an array of `vectorize` bindings.\n\n#### Next steps\n\n* Learn more on how to [combine Vectorize and Workers AI](https://developers.cloudflare.com/vectorize/get-started/embeddings/)\n* Review the [Vectorize query API](https://developers.cloudflare.com/vectorize/reference/client-api/)\n* Use [metadata filtering](https://developers.cloudflare.com/vectorize/reference/metadata-filtering/) to add context to your results\n\n</page>\n\n<page>\n---\ntitle: Run Workflows · Cloudflare Agents docs\ndescription: Agents can trigger asynchronous Workflows, allowing your Agent to\n  run complex, multi-step tasks in the background. This can include\n  post-processing files that a user has uploaded, updating the embeddings in a\n  vector database, and/or managing long-running user-lifecycle email or SMS\n  notification workflows.\nlastUpdated: 2025-05-14T14:20:47.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/run-workflows/\n  md: https://developers.cloudflare.com/agents/api-reference/run-workflows/index.md\n---\n\nAgents can trigger asynchronous [Workflows](https://developers.cloudflare.com/workflows/), allowing your Agent to run complex, multi-step tasks in the background. This can include post-processing files that a user has uploaded, updating the embeddings in a [vector database](https://developers.cloudflare.com/vectorize/), and/or managing long-running user-lifecycle email or SMS notification workflows.\n\nBecause an Agent is just like a Worker script, it can create Workflows defined in the same project (script) as the Agent *or* in a different project.\n\nAgents vs. Workflows\n\nAgents and Workflows have some similarities: they can both run tasks asynchronously. For straightforward tasks that are linear or need to run to completion, a Workflow can be ideal: steps can be retried, they can be cancelled, and can act on events.\n\nAgents do not have to run to completion: they can loop, branch and run forever, and they can also interact directly with users (over HTTP or WebSockets). An Agent can be used to trigger multiple Workflows as it runs, and can thus be used to co-ordinate and manage Workflows to achieve its goals.\n\n## Trigger a Workflow\n\nAn Agent can trigger one or more Workflows from within any method, whether from an incoming HTTP request, a WebSocket connection, on a delay or schedule, and/or from any other action the Agent takes.\n\nTriggering a Workflow from an Agent is no different from [triggering a Workflow from a Worker script](https://developers.cloudflare.com/workflows/build/trigger-workflows/):\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "You'll also need to make sure your Agent [has a binding to your Workflow](https://developers.cloudflare.com/workflows/build/trigger-workflows/#workers-api-bindings) so that it can call it:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "## Trigger a Workflow from another project\n\nYou can also call a Workflow that is defined in a different Workers script from your Agent by setting the `script_name` property in the `workflows` binding of your Agent:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Refer to the [cross-script calls](https://developers.cloudflare.com/workflows/build/workers-api/#cross-script-calls) section of the Workflows documentation for more examples.\n\n</page>\n\n<page>\n---\ntitle: Schedule tasks · Cloudflare Agents docs\ndescription: An Agent can schedule tasks to be run in the future by calling\n  this.schedule(when, callback, data), where when can be a delay, a Date, or a\n  cron string; callback the function name to call, and data is an object of data\n  to pass to the function.\nlastUpdated: 2025-09-24T13:21:38.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/schedule-tasks/\n  md: https://developers.cloudflare.com/agents/api-reference/schedule-tasks/index.md\n---\n\nAn Agent can schedule tasks to be run in the future by calling `this.schedule(when, callback, data)`, where `when` can be a delay, a `Date`, or a cron string; `callback` the function name to call, and `data` is an object of data to pass to the function.\n\nScheduled tasks can do anything a request or message from a user can: make requests, query databases, send emails, read+write state: scheduled tasks can invoke any regular method on your Agent.\n\n### Scheduling tasks\n\nYou can call `this.schedule` within any method on an Agent, and schedule tens-of-thousands of tasks per individual Agent:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Warning\n\nTasks that set a callback for a method that does not exist will throw an exception: ensure that the method named in the `callback` argument of `this.schedule` exists on your `Agent` class.\n\nYou can schedule tasks in multiple ways:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Calling `await this.schedule` returns a `Schedule`, which includes the task's randomly generated `id`. You can use this `id` to retrieve or cancel the task in the future. It also provides a `type` property that indicates the type of schedule, for example, one of `\"scheduled\" | \"delayed\" | \"cron\"`.\n\nMaximum scheduled tasks\n\nEach task is mapped to a row in the Agent's underlying [SQLite database](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/), which means that each task can be up to 2 MB in size. The maximum number of tasks must be `(task_size * tasks) + all_other_state < maximum_database_size` (currently 1GB per Agent).\n\n### Managing scheduled tasks\n\nYou can get, cancel and filter across scheduled tasks within an Agent using the scheduling API:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Store and sync state · Cloudflare Agents docs\ndescription: Every Agent has built-in state management capabilities, including\n  built-in storage and synchronization between the Agent and frontend\n  applications.\nlastUpdated: 2025-10-23T15:22:15.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/\n  md: https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/index.md\n---\n\nEvery Agent has built-in state management capabilities, including built-in storage and synchronization between the Agent and frontend applications.\n\nState within an Agent is:\n\n* Persisted across Agent restarts: data is permanently stored within an Agent.\n* Automatically serialized/deserialized: you can store any JSON-serializable data.\n* Immediately consistent within the Agent: read your own writes.\n* Thread-safe for concurrent updates\n* Fast: state is colocated wherever the Agent is running. Reads and writes do not need to traverse the network.\n\nAgent state is stored in a SQL database that is embedded within each individual Agent instance: you can interact with it using the higher-level `this.setState` API (recommended), which allows you to sync state and trigger events on state changes, or by directly querying the database with `this.sql`.\n\n#### State API\n\nEvery Agent has built-in state management capabilities. You can set and update the Agent's state directly using `this.setState`:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "If you're using TypeScript, you can also provide a type for your Agent's state by passing in a type as a [type parameter](https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints) as the *second* type parameter to the `Agent` class definition.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Set the initial state for an Agent\n\nYou can also set the initial state for an Agent via the `initialState` property on the `Agent` class:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Any initial state is synced to clients connecting via [the `useAgent` hook](#synchronizing-state).\n\n### Synchronizing state\n\nClients can connect to an Agent and stay synchronized with its state using the React hooks provided as part of `agents/react`.\n\nA React application can call `useAgent` to connect to a named Agent over WebSockets at\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "The state synchronization system:\n\n* Automatically syncs the Agent's state to all connected clients\n* Handles client disconnections and reconnections gracefully\n* Provides immediate local updates\n* Supports multiple simultaneous client connections\n\nCommon use cases:\n\n* Real-time collaborative features\n* Multi-window/tab synchronization\n* Live updates across multiple devices\n* Maintaining consistent UI state across clients\n* When new clients connect, they automatically receive the current state from the Agent, ensuring all clients start with the latest data.\n\n### SQL API\n\nEvery individual Agent instance has its own SQL (SQLite) database that runs *within the same context* as the Agent itself. This means that inserting or querying data within your Agent is effectively zero-latency: the Agent doesn't have to round-trip across a continent or the world to access its own data.\n\nYou can access the SQL API within any method on an Agent via `this.sql`. The SQL API accepts template literals, and\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "You can also supply a [TypeScript type argument](https://www.typescriptlang.org/docs/handbook/2/generics.html#using-type-parameters-in-generic-constraints) to the query, which will be used to infer the type of the result:",
      "language": "unknown"
    },
    {
      "code": "You do not need to specify an array type (`User[]` or `Array<User>`) as `this.sql` will always return an array of the specified type.\n\nProviding a type parameter does not validate that the result matches your type definition. In TypeScript, properties (fields) that do not exist or conform to the type you provided will be dropped. If you need to validate incoming events, we recommend a library such as [zod](https://zod.dev/) or your own validator logic.\n\nNote\n\nLearn more about the zero-latency SQL storage that powers both Agents and Durable Objects [on our blog](https://blog.cloudflare.com/sqlite-in-durable-objects/).\n\nThe SQL API exposed to an Agent is similar to the one [within Durable Objects](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/#sql-api): Durable Object SQL methods available on `this.ctx.storage.sql`. You can use the same SQL queries with the Agent's database, create tables, and query data, just as you would with Durable Objects or [D1](https://developers.cloudflare.com/d1/).\n\n### Use Agent state as model context\n\nYou can combine the state and SQL APIs in your Agent with its ability to [call AI models](https://developers.cloudflare.com/agents/api-reference/using-ai-models/) to include historical context within your prompts to a model. Modern Large Language Models (LLMs) often have very large context windows (up to millions of tokens), which allows you to pull relevant context into your prompt directly.\n\nFor example, you can use an Agent's built-in SQL database to pull history, query a model with it, and append to that history ahead of the next call to the model:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "This works because each instance of an Agent has its *own* database, the state stored in that database is private to that Agent: whether it's acting on behalf of a single user, a room or channel, or a deep research tool. By default, you don't have to manage contention or reach out over the network to a centralized database to retrieve and store state.\n\n### Next steps\n\n* Review the [API documentation](https://developers.cloudflare.com/agents/api-reference/agents-api/) for the Agents class to learn how to define them.\n* [Build a chat Agent](https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/) using the Agents SDK and deploy it to Workers.\n* Learn more [using WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) to build interactive Agents and stream data back from your Agent.\n* [Orchestrate asynchronous workflows](https://developers.cloudflare.com/agents/api-reference/run-workflows) from your Agent by combining the Agents SDK and [Workflows](https://developers.cloudflare.com/workflows).\n\n</page>\n\n<page>\n---\ntitle: Using AI Models · Cloudflare Agents docs\ndescription: \"Agents can communicate with AI models hosted on any provider, including:\"\nlastUpdated: 2025-08-19T11:42:14.000Z\nchatbotDeprioritize: false\ntags: AI\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/using-ai-models/\n  md: https://developers.cloudflare.com/agents/api-reference/using-ai-models/index.md\n---\n\nAgents can communicate with AI models hosted on any provider, including:\n\n* [Workers AI](https://developers.cloudflare.com/workers-ai/)\n* The [AI SDK](https://sdk.vercel.ai/docs/ai-sdk-core/overview)\n* [OpenAI](https://platform.openai.com/docs/quickstart?language=javascript)\n* [Anthropic](https://docs.anthropic.com/en/api/client-sdks#typescript)\n* [Google's Gemini](https://ai.google.dev/gemini-api/docs/openai)\n\nYou can also use the model routing features in [AI Gateway](https://developers.cloudflare.com/ai-gateway/) to route across providers, eval responses, and manage AI provider rate limits.\n\nBecause Agents are built on top of [Durable Objects](https://developers.cloudflare.com/durable-objects/), each Agent or chat session is associated with a stateful compute instance. Traditional serverless architectures often present challenges for persistent connections needed in real-time applications like chat.\n\nA user can disconnect during a long-running response from a modern reasoning model (such as `o3-mini` or DeepSeek R1), or lose conversational context when refreshing the browser. Instead of relying on request-response patterns and managing an external database to track & store conversation state, state can be stored directly within the Agent. If a client disconnects, the Agent can write to its own distributed storage, and catch the client up as soon as it reconnects: even if it's hours or days later.\n\n## Calling AI Models\n\nYou can call models from any method within an Agent, including from HTTP requests using the [`onRequest`](https://developers.cloudflare.com/agents/api-reference/agents-api/) handler, when a [scheduled task](https://developers.cloudflare.com/agents/api-reference/schedule-tasks/) runs, when handling a WebSocket message in the [`onMessage`](https://developers.cloudflare.com/agents/api-reference/websockets/) handler, or from any of your own methods.\n\nImportantly, Agents can call AI models on their own — autonomously — and can handle long-running responses that can take minutes (or longer) to respond in full.\n\n### Long-running model requests\n\nModern [reasoning models](https://platform.openai.com/docs/guides/reasoning) or \"thinking\" model can take some time to both generate a response *and* stream the response back to the client.\n\nInstead of buffering the entire response, or risking the client disconnecting, you can stream the response back to the client by using the [WebSocket API](https://developers.cloudflare.com/agents/api-reference/websockets/).\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "You can also persist AI model responses back to [Agent's internal state](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) by using the `this.setState` method. For example, if you run a [scheduled task](https://developers.cloudflare.com/agents/api-reference/schedule-tasks/), you can store the output of the task and read it later. Or, if a user disconnects, read the message history back and send it to the user when they reconnect.\n\n### Workers AI\n\n### Hosted models\n\nYou can use [any of the models available in Workers AI](https://developers.cloudflare.com/workers-ai/models/) within your Agent by [configuring a binding](https://developers.cloudflare.com/workers-ai/configuration/bindings/).\n\nWorkers AI supports streaming responses out-of-the-box by setting `stream: true`, and we strongly recommend using them to avoid buffering and delaying responses, especially for larger models or reasoning models that require more time to generate a response.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Your Wrangler configuration will need an `ai` binding added:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "### Model routing\n\nYou can also use the model routing features in [AI Gateway](https://developers.cloudflare.com/ai-gateway/) directly from an Agent by specifying a [`gateway` configuration](https://developers.cloudflare.com/ai-gateway/usage/providers/workersai/) when calling the AI binding.\n\nNote\n\nModel routing allows you to route requests to different AI models based on whether they are reachable, rate-limiting your client, and/or if you've exceeded your cost budget for a specific provider.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "Your Wrangler configuration will need an `ai` binding added. This is shared across both Workers AI and AI Gateway.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Visit the [AI Gateway documentation](https://developers.cloudflare.com/ai-gateway/) to learn how to configure a gateway and retrieve a gateway ID.\n\n### AI SDK\n\nThe [AI SDK](https://sdk.vercel.ai/docs/introduction) provides a unified API for using AI models, including for text generation, tool calling, structured responses, image generation, and more.\n\nTo use the AI SDK, install the `ai` package and use it within your Agent. The example below shows how it use it to generate text on request, but you can use it from any method within your Agent, including WebSocket handlers, as part of a scheduled task, or even when the Agent is initialized.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "- JavaScript",
      "language": "unknown"
    },
    {
      "code": "- TypeScript",
      "language": "unknown"
    },
    {
      "code": "### OpenAI compatible endpoints\n\nAgents can call models across any service, including those that support the OpenAI API. For example, you can use the OpenAI SDK to use one of [Google's Gemini models](https://ai.google.dev/gemini-api/docs/openai#node.js) directly from your Agent.\n\nAgents can stream responses back over HTTP using Server Sent Events (SSE) from within an `onRequest` handler, or by using the native [WebSockets](https://developers.cloudflare.com/agents/api-reference/websockets/) API in your Agent to responses back to a client, which is especially useful for larger models that can take over 30+ seconds to reply.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Using WebSockets · Cloudflare Agents docs\ndescription: Users and clients can connect to an Agent directly over WebSockets,\n  allowing long-running, bi-directional communication with your Agent as it\n  operates.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/api-reference/websockets/\n  md: https://developers.cloudflare.com/agents/api-reference/websockets/index.md\n---\n\nUsers and clients can connect to an Agent directly over WebSockets, allowing long-running, bi-directional communication with your Agent as it operates.\n\nTo enable an Agent to accept WebSockets, define `onConnect` and `onMessage` methods on your Agent.\n\n* `onConnect(connection: Connection, ctx: ConnectionContext)` is called when a client establishes a new WebSocket connection. The original HTTP request, including request headers, cookies, and the URL itself, are available on `ctx.request`.\n* `onMessage(connection: Connection, message: WSMessage)` is called for each incoming WebSocket message. Messages are one of `ArrayBuffer | ArrayBufferView | string`, and you can send messages back to a client using `connection.send()`. You can distinguish between client connections by checking `connection.id`, which is unique for each connected client.\n\nHere's an example of an Agent that echoes back any message it receives:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### Connecting clients\n\nThe Agent framework includes a useful helper package for connecting directly to your Agent (or other Agents) from a client application. Import `agents/client`, create an instance of `AgentClient` and use it to connect to an instance of your Agent:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "### React clients\n\nReact-based applications can import `agents/react` and use the `useAgent` hook to connect to an instance of an Agent directly:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "The `useAgent` hook automatically handles the lifecycle of the connection, ensuring that it is properly initialized and cleaned up when the component mounts and unmounts. You can also [combine `useAgent` with `useState`](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/) to automatically synchronize state across all clients connected to your Agent.\n\n### Handling WebSocket events\n\nDefine `onError` and `onClose` methods on your Agent to explicitly handle WebSocket client errors and close events. Log errors, clean up state, and/or emit metrics:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Agent class internals · Cloudflare Agents docs\ndescription: The core of the agents library is the exported Agent class.\n  Following the pattern from Durable Objects, the main API for developers is to\n  extend the Agent class to inherit all the built-in features. While this\n  effectively is a supercharged primitive that allows developers to only write\n  the logic they need in their agents, it obscures the inner workings.\nlastUpdated: 2025-11-07T18:37:32.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/agent-class/\n  md: https://developers.cloudflare.com/agents/concepts/agent-class/index.md\n---\n\nThe core of the `agents` library is the exported `Agent` class. Following the pattern from [Durable Objects](https://developers.cloudflare.com/durable-objects/api/), the main API for developers is to extend the `Agent` class to inherit all the built-in features. While this effectively is a supercharged primitive that allows developers to only write the logic they need in their agents, it obscures the inner workings.\n\nThis document tries to bridge that gap, empowering any developer aiming to get started writing agents to get the full picture and avoid common pitfalls. The snippets shown here are primarily illustrative, and do not necessarily represent best practices. For a more in-depth look at the inner workings of the `Agent` class, check out the [API reference](https://developers.cloudflare.com/agents/api-reference/) and the [source code](https://github.com/cloudflare/agents/blob/main/packages/agents/src/index.ts).\n\n## What is the Agent?\n\nThe `Agent` class is an extension of `DurableObject`. That is to say, they *are* Durable Objects. If you are not familiar with Durable Objects, it is highly recommended that you read [What are Durable Objects](https://developers.cloudflare.com/durable-objects/), but at their core, Durable Objects are globally addressable (each instance has a unique ID) single-threaded compute instances with long term storage (key-value/SQLite).\n\nNote that `Agent` does not extend `DurableObject` directly, but instead extends `Server`. `Server` is a class provided by [PartyKit](https://github.com/cloudflare/partykit/tree/main/packages/partyserver).\n\nYou can visualize the logic as a Matryoshka doll: **DurableObject** > **Server** > **Agent**.\n\n## Layer 0: Durable Object\n\nLet's briefly consider which primitives are exposed by Durable Objects so we understand how the outer layers make use of them. The Durable Object class comes with:\n\n### `constructor`",
      "language": "unknown"
    },
    {
      "code": "The Workers runtime always calls the constructor to handle things internally. This means two things:\n\n1. While the constructor is called every time the Durable Object is initialized, the signature is fixed. Developers cannot add or update parameters from the constructor.\n2. Instead of instantiating the class manually, developers must use the binding APIs and do it through the [DurableObjectNamespace](https://developers.cloudflare.com/durable-objects/api/namespace/).\n\n### RPC\n\nBy writing a Durable Object class which inherits from the built-in type `DurableObject`, public methods are exposed as RPC methods, which developers can call using a [DurableObjectStub from a Worker](https://developers.cloudflare.com/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/#invoking-methods-on-a-durable-object).",
      "language": "unknown"
    },
    {
      "code": "### `fetch()`\n\nDurable Objects can take a `Request` from a Worker and send a `Response` back. This can only be done through the [`fetch`](https://developers.cloudflare.com/durable-objects/best-practices/create-durable-object-stubs-and-send-requests/#invoking-the-fetch-handler) method (which the developer must implement).\n\n### WebSockets\n\nDurable Objects include first-class support for [WebSockets](https://developers.cloudflare.com/durable-objects/best-practices/websockets/). A Durable Object can accept a WebSocket it receives from a `Request` in `fetch` and forget about it. The base class provides methods that developers can implement that are called as callbacks. They effectively replace the need for event listeners.\n\nThe base class provides `webSocketMessage(ws, message)`, `webSocketClose(ws, code, reason, wasClean)` and `webSocketError(ws , error)` ([API](https://developers.cloudflare.com/workers/runtime-apis/websockets)).",
      "language": "unknown"
    },
    {
      "code": "### `alarm()`\n\nHTTP and RPC requests are not the only entrypoints for a Durable Object. Alarms allow developers to schedule an event to trigger at a later time. Whenever the next alarm is due, the runtime will call the `alarm()` method, which is left to the developer to implement.\n\nTo schedule an alarm, you can use the `this.ctx.storage.setAlarm()` method. For more information, refer to [Alarms](https://developers.cloudflare.com/durable-objects/api/alarms/).\n\n### `this.ctx`\n\nThe base `DurableObject` class sets the [DurableObjectState](https://developers.cloudflare.com/durable-objects/api/state/) into `this.ctx`. There are a lot of interesting methods and properties, but we will focus on `this.ctx.storage`.\n\n### `this.ctx.storage`\n\n[DurableObjectStorage](https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/) is the main interface with the Durable Object's persistence mechanisms, which include both a KV and SQLITE **synchronous** APIs.",
      "language": "unknown"
    },
    {
      "code": "### `this.ctx.env`\n\nLastly, it is worth mentioning that the Durable Object also has the Worker `Env` in `this.env`. Learn more in [Bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings).\n\n## Layer 1: Partykit `Server`\n\nNow that you have seen what Durable Objects come with out-of-the-box, what [PartyKit](https://github.com/cloudflare/partykit)'s `Server` (package `partyserver`) implements will be clearer. It is an opinionated `DurableObject` wrapper that improves DX by hiding away Durable Object primitives in favor of more developer friendly callbacks.\n\nAn important note is that `Server` does NOT persist to the Durable Object storage, so you will not see extra storage operations by using it.\n\n### Addressing\n\n`partyserver` exposes helper to address your Durable Objects instead of manually through your bindings. This allows `partyserver` to implement several improvements, including a unique URL routing scheme for your Durable Objects (e.g. `<your-worker>/servers/:durableClass/:durableName`).\n\nCompare this to the Durable Object addressing [example above](#rpc).",
      "language": "unknown"
    },
    {
      "code": "Since we have a URL addressing scheme, we also get access to `routePartykitRequest()`.",
      "language": "unknown"
    },
    {
      "code": "You can also refer to [the implementation](https://github.com/cloudflare/partykit/blob/main/packages/partyserver/src/index.ts#L122) to learn more.\n\n### `onStart`\n\nThe extra plumbing that `Server` includes on addressing allows it to expose an `onStart` callback that is executed every time the Durable Object starts up (the Durable Object was evicted, hibernated or never created at all) and before any `fetch` or RPC.",
      "language": "unknown"
    },
    {
      "code": "### `onRequest` and `onConnect`\n\n`Server` already implements `fetch` for the underlying Durable Object and exposes two different callbacks that developers can make use of, `onRequest` and `onConnect` for HTTP requests and incoming WS connections, respectively (WebSocket connections are accepted by default).",
      "language": "unknown"
    },
    {
      "code": "### WebSockets\n\nJust as `onConnect` is the callback for every new connection, `Server` also provides wrappers on top of the default callbacks from the `DurableObject` class: `onMessage`, `onClose` and `onError`.\n\nThere's also `this.broadcast` that sends a WS message to all connected clients (no magic, just a loop over `this.getConnections()`!).\n\n### `this.name`\n\nIt is hard to get a Durable Object's `name` from within it. `partyserver` tries to make it available in `this.name` but it is not a perfect solution. Learn more about it in [this GitHub issue](https://github.com/cloudflare/workerd/issues/2240).\n\n## Layer 2: Agent\n\nNow finally, the `Agent` class. `Agent` extends `Server` and provides opinionated primitives for stateful, schedulable, and observable agents that can communicate via RPC, WebSockets, and (even!) email.\n\n### `this.state` and `this.setState()`\n\nOne of the core features of `Agent` is **automatic state persistence**. Developers define the shape of their state via the generic parameter and `initialState` (which is only used if no state exists in storage), and the Agent handles loading, saving, and broadcasting state changes (check `Server`'s `this.broadcast()` above).\n\n`this.state` is a getter that lazily loads state from storage (SQL). State is persisted across Durable Object evictions when it is updated with `this.setState()`, which automatically serializes the state and writes it back to storage.\n\nThere's also `this.onStateUpdate` that you can override to react to state changes.",
      "language": "unknown"
    },
    {
      "code": "State is stored in the `cf_agents_state` SQL table. State messages are sent with `type: \"cf_agent_state\"` (both from the client and the server). Since the `agents` provides [JS and React clients](https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/#synchronizing-state), real-time state updates are available out of the box.\n\n### `this.sql`\n\nThe Agent provides a convenient `sql` template tag for executing queries against the Durable Object's SQL storage. It constructs parameterized queries and executes them. This uses the **synchronous** SQL API from `this.ctx.storage.sql`.",
      "language": "unknown"
    },
    {
      "code": "### RPC and Callable Methods\n\n`agents` take Durable Objects RPC one step forward by implementing RPC through WebSockets, so clients can also call methods on the Agent directly. To make a method callable through WS, developers can use the `@callable` decorator. Methods can return a serializable value or a stream (when using `@callable({ stream: true })`).",
      "language": "unknown"
    },
    {
      "code": "Clients can invoke this method by sending a WebSocket message:",
      "language": "unknown"
    },
    {
      "code": "For example, with the provided `React` client, it is as easy as:",
      "language": "unknown"
    },
    {
      "code": "### `this.queue` and friends\n\nAgents include a built-in task queue for deferred execution. This is useful for offloading work or retrying operations. The available methods are `this.queue`, `this.dequeue`, `this.dequeueAll`, `this.dequeueAllByCallback`, `this.getQueue`, and `this.getQueues`.",
      "language": "unknown"
    },
    {
      "code": "Tasks are stored in the `cf_agents_queues` SQL table and are automatically flushed in sequence. If a task succeeds, it is automatically dequeued.\n\n### `this.schedule` and friends\n\nAgents support scheduled execution of methods by wrapping the Durable Object's `alarm()`. The available methods are `this.schedule`, `this.getSchedule`, `this.getSchedules`, `this.cancelSchedule`. Schedules can be one-time, delayed, or recurring (using cron expressions).\n\nSince Durable Objects only allow one alarm at a time, the `Agent` class works around this by managing multiple schedules in SQL and using a single alarm.",
      "language": "unknown"
    },
    {
      "code": "Schedules are stored in the `cf_agents_schedules` SQL table. Cron schedules automatically reschedule themselves after execution, while one-time schedules are deleted.\n\n### `this.mcp` and friends\n\n`Agent` includes a multi-server MCP client. This enables your Agent to interact with external services that expose MCP interfaces. The MCP client is properly documented in [MCP client API](https://developers.cloudflare.com/agents/model-context-protocol/mcp-client-api/).",
      "language": "unknown"
    },
    {
      "code": "### Email Handling\n\nAgents can receive and reply to emails using Cloudflare's [Email Routing](https://developers.cloudflare.com/email-routing/email-workers/).",
      "language": "unknown"
    },
    {
      "code": "To route emails to your Agent, use `routeAgentEmail` in your Worker's email handler:",
      "language": "unknown"
    },
    {
      "code": "### Context Management\n\n`agents` wraps all your methods with an `AsyncLocalStorage` to maintain context throughout the request lifecycle. This allows you to access the current agent, connection, request, or email (depending of what event is being handled) from anywhere in your code:",
      "language": "unknown"
    },
    {
      "code": "### `this.onError`\n\n`Agent` extends `Server`'s `onError` so it can be used to handle errors that are not necessarily WebSocket errors. It is called with a `Connection` or `unknown` error.",
      "language": "unknown"
    },
    {
      "code": "### `this.destroy`\n\n`this.destroy()` drops all tables, deletes alarms, clears storage, and aborts the context. To ensure that the Durable Object is fully evicted, `this.ctx.abort()` is called, which throws an uncatchable error that will show up in your logs (read more about it in [abort()](https://developers.cloudflare.com/durable-objects/api/state/#abort)).",
      "language": "unknown"
    },
    {
      "code": "### Routing\n\nThe `Agent` class re-exports PartyKit's [addressing helpers](#addressing) as `getAgentByName` and `routeAgentRequest`.",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Calling LLMs · Cloudflare Agents docs\ndescription: Different LLM providers offer models optimized for specific types\n  of tasks. When building AI systems, choosing the right model is crucial for\n  both performance and cost efficiency.\nlastUpdated: 2025-08-15T20:11:52.000Z\nchatbotDeprioritize: false\ntags: LLM\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/calling-llms/\n  md: https://developers.cloudflare.com/agents/concepts/calling-llms/index.md\n---\n\n### Understanding LLM providers and model types\n\nDifferent LLM providers offer models optimized for specific types of tasks. When building AI systems, choosing the right model is crucial for both performance and cost efficiency.\n\n#### Reasoning Models\n\nModels like OpenAI's o1, Anthropic's Claude, and DeepSeek's R1 are particularly well-suited for complex reasoning tasks. These models excel at:\n\n* Breaking down problems into steps\n* Following complex instructions\n* Maintaining context across long conversations\n* Generating code and technical content\n\nFor example, when implementing a travel booking system, you might use a reasoning model to analyze travel requirements and generate appropriate booking strategies.\n\n#### Instruction Models\n\nModels like GPT-4 and Claude Instant are optimized for following straightforward instructions efficiently. They work well for:\n\n* Content generation\n* Simple classification tasks\n* Basic question answering\n* Text transformation\n\nThese models are often more cost-effective for straightforward tasks that do not require complex reasoning.\n\n</page>\n\n<page>\n---\ntitle: Human in the Loop · Cloudflare Agents docs\ndescription: Human-in-the-Loop (HITL) workflows integrate human judgment and\n  oversight into automated processes. These workflows pause at critical points\n  for human review, validation, or decision-making before proceeding. This\n  approach combines the efficiency of automation with human expertise and\n  oversight where it matters most.\nlastUpdated: 2025-04-30T09:59:18.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/human-in-the-loop/\n  md: https://developers.cloudflare.com/agents/concepts/human-in-the-loop/index.md\n---\n\n### What is Human-in-the-Loop?\n\nHuman-in-the-Loop (HITL) workflows integrate human judgment and oversight into automated processes. These workflows pause at critical points for human review, validation, or decision-making before proceeding. This approach combines the efficiency of automation with human expertise and oversight where it matters most.\n\n![A human-in-the-loop diagram](https://developers.cloudflare.com/_astro/human-in-the-loop.C2xls7fV_1vt7N8.svg)\n\n#### Understanding Human-in-the-Loop workflows\n\nIn a Human-in-the-Loop workflow, processes are not fully automated. Instead, they include designated checkpoints where human intervention is required. For example, in a travel booking system, a human may want to confirm the travel before an agent follows through with a transaction. The workflow manages this interaction, ensuring that:\n\n1. The process pauses at appropriate review points\n2. Human reviewers receive necessary context\n3. The system maintains state during the review period\n4. Review decisions are properly incorporated\n5. The process continues once approval is received\n\n### Best practices for Human-in-the-Loop workflows\n\n#### Long-Term State Persistence\n\nHuman review processes do not operate on predictable timelines. A reviewer might need days or weeks to make a decision, especially for complex cases requiring additional investigation or multiple approvals. Your system needs to maintain perfect state consistency throughout this period, including:\n\n* The original request and context\n* All intermediate decisions and actions\n* Any partial progress or temporary states\n* Review history and feedback\n\nTip\n\n[Durable Objects](https://developers.cloudflare.com/durable-objects/) provide an ideal solution for managing state in Human-in-the-Loop workflows, offering persistent compute instances that maintain state for hours, weeks, or months.\n\n#### Continuous Improvement Through Evals\n\nHuman reviewers play a crucial role in evaluating and improving LLM performance. Implement a systematic evaluation process where human feedback is collected not just on the final output, but on the LLM's decision-making process. This can include:\n\n* Decision Quality Assessment: Have reviewers evaluate the LLM's reasoning process and decision points, not just the final output.\n* Edge Case Identification: Use human expertise to identify scenarios where the LLM's performance could be improved.\n* Feedback Collection: Gather structured feedback that can be used to fine-tune the LLM or adjust the workflow. [AI Gateway](https://developers.cloudflare.com/ai-gateway/evaluations/add-human-feedback/) can be a useful tool for setting up an LLM feedback loop.\n\n#### Error handling and recovery\n\nRobust error handling is essential for maintaining workflow integrity. Your system should gracefully handle various failure scenarios, including reviewer unavailability, system outages, or conflicting reviews. Implement clear escalation paths for handling exceptional cases that fall outside normal parameters.\n\nThe system should maintain stability during paused states, ensuring that no work is lost even during extended review periods. Consider implementing automatic checkpointing that allows workflows to be resumed from the last stable state after any interruption.\n\n</page>\n\n<page>\n---\ntitle: Tools · Cloudflare Agents docs\ndescription: Tools enable AI systems to interact with external services and\n  perform actions. They provide a structured way for agents and workflows to\n  invoke APIs, manipulate data, and integrate with external systems. Tools form\n  the bridge between AI decision-making capabilities and real-world actions.\nlastUpdated: 2025-02-28T20:23:07.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/tools/\n  md: https://developers.cloudflare.com/agents/concepts/tools/index.md\n---\n\n### What are tools?\n\nTools enable AI systems to interact with external services and perform actions. They provide a structured way for agents and workflows to invoke APIs, manipulate data, and integrate with external systems. Tools form the bridge between AI decision-making capabilities and real-world actions.\n\n### Understanding tools\n\nIn an AI system, tools are typically implemented as function calls that the AI can use to accomplish specific tasks. For example, a travel booking agent might have tools for:\n\n* Searching flight availability\n* Checking hotel rates\n* Processing payments\n* Sending confirmation emails\n\nEach tool has a defined interface specifying its inputs, outputs, and expected behavior. This allows the AI system to understand when and how to use each tool appropriately.\n\n### Common tool patterns\n\n#### API integration tools\n\nThe most common type of tools are those that wrap external APIs. These tools handle the complexity of API authentication, request formatting, and response parsing, presenting a clean interface to the AI system.\n\n#### Model Context Protocol (MCP)\n\nThe [Model Context Protocol](https://modelcontextprotocol.io/introduction) provides a standardized way to define and interact with tools. Think of it as an abstraction on top of APIs designed for LLMs to interact with external resources. MCP defines a consistent interface for:\n\n* **Tool Discovery**: Systems can dynamically discover available tools\n* **Parameter Validation**: Tools specify their input requirements using JSON Schema\n* **Error Handling**: Standardized error reporting and recovery\n* **State Management**: Tools can maintain state across invocations\n\n#### Data processing tools\n\nTools that handle data transformation and analysis are essential for many AI workflows. These might include:\n\n* CSV parsing and analysis\n* Image processing\n* Text extraction\n* Data validation\n\n</page>\n\n<page>\n---\ntitle: Agents · Cloudflare Agents docs\ndescription: An agent is an AI system that can autonomously execute tasks by\n  making decisions about tool usage and process flow. Unlike traditional\n  automation that follows predefined paths, agents can dynamically adapt their\n  approach based on context and intermediate results. Agents are also distinct\n  from co-pilots (e.g. traditional chat applications) in that they can fully\n  automate a task, as opposed to simply augmenting and extending human input.\nlastUpdated: 2025-08-15T20:11:52.000Z\nchatbotDeprioritize: false\ntags: AI,LLM\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/what-are-agents/\n  md: https://developers.cloudflare.com/agents/concepts/what-are-agents/index.md\n---\n\n### What are agents?\n\nAn agent is an AI system that can autonomously execute tasks by making decisions about tool usage and process flow. Unlike traditional automation that follows predefined paths, agents can dynamically adapt their approach based on context and intermediate results. Agents are also distinct from co-pilots (e.g. traditional chat applications) in that they can fully automate a task, as opposed to simply augmenting and extending human input.\n\n* **Agents** → non-linear, non-deterministic (can change from run to run)\n* **Workflows** → linear, deterministic execution paths\n* **Co-pilots** → augmentative AI assistance requiring human intervention\n\n### Example: Booking vacations\n\nIf this is your first time working with, or interacting with agents, this example will illustrate how an agent works within a context like booking a vacation. If you are already familiar with the topic, read on.\n\nImagine you're trying to book a vacation. You need to research flights, find hotels, check restaurant reviews, and keep track of your budget.\n\n#### Traditional workflow automation\n\nA traditional automation system follows a predetermined sequence:\n\n* Takes specific inputs (dates, location, budget)\n* Calls predefined API endpoints in a fixed order\n* Returns results based on hardcoded criteria\n* Cannot adapt if unexpected situations arise\n\n![Traditional workflow automation diagram](https://developers.cloudflare.com/_astro/workflow-automation.D1rsykgR_15theP.svg)\n\n#### AI Co-pilot\n\nA co-pilot acts as an intelligent assistant that:\n\n* Provides hotel and itinerary recommendations based on your preferences\n* Can understand and respond to natural language queries\n* Offers guidance and suggestions\n* Requires human decision-making and action for execution\n\n![A co-pilot diagram](https://developers.cloudflare.com/_astro/co-pilot.BZ_kRuK6_Z9KfL9.svg)\n\n#### Agent\n\nAn agent combines AI's ability to make judgements and call the relevant tools to execute the task. An agent's output will be nondeterministic given:\n\n* Real-time availability and pricing changes\n* Dynamic prioritization of constraints\n* Ability to recover from failures\n* Adaptive decision-making based on intermediate results\n\n![An agent diagram](https://developers.cloudflare.com/_astro/agent-workflow.5VDKtHdO_ALLGh.svg)\n\nAn agents can dynamically generate an itinerary and execute on booking reservations, similarly to what you would expect from a travel agent.\n\n### Three primary components of agent systems:\n\n* **Decision Engine**: Usually an LLM (Large Language Model) that determines action steps\n* **Tool Integration**: APIs, functions, and services the agent can utilize\n* **Memory System**: Maintains context and tracks task progress\n\n#### How agents work\n\nAgents operate in a continuous loop of:\n\n1. **Observing** the current state or task\n2. **Planning** what actions to take, using AI for reasoning\n3. **Executing** those actions using available tools (often APIs or [MCPs](https://modelcontextprotocol.io/introduction))\n4. **Learning** from the results (storing results in memory, updating task progress, and preparing for next iteration)\n\n</page>\n\n<page>\n---\ntitle: Workflows · Cloudflare Agents docs\ndescription: A workflow is the orchestration layer that coordinates how an\n  agent's components work together. It defines the structured paths through\n  which tasks are processed, tools are called, and results are managed. While\n  agents make dynamic decisions about what to do, workflows provide the\n  underlying framework that governs how those decisions are executed.\nlastUpdated: 2025-02-25T13:55:21.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/concepts/workflows/\n  md: https://developers.cloudflare.com/agents/concepts/workflows/index.md\n---\n\n## What are workflows?\n\nA workflow is the orchestration layer that coordinates how an agent's components work together. It defines the structured paths through which tasks are processed, tools are called, and results are managed. While agents make dynamic decisions about what to do, workflows provide the underlying framework that governs how those decisions are executed.\n\n### Understanding workflows in agent systems\n\nThink of a workflow like the operating procedures of a company. The company (agent) can make various decisions, but how those decisions get implemented follows established processes (workflows). For example, when you book a flight through a travel agent, they might make different decisions about which flights to recommend, but the process of actually booking the flight follows a fixed sequence of steps.\n\nLet's examine a basic agent workflow:\n\n### Core components of a workflow\n\nA workflow typically consists of several key elements:\n\n1. **Input Processing** The workflow defines how inputs are received and validated before being processed by the agent. This includes standardizing formats, checking permissions, and ensuring all required information is present.\n2. **Tool Integration** Workflows manage how external tools and services are accessed. They handle authentication, rate limiting, error recovery, and ensuring tools are used in the correct sequence.\n3. **State Management** The workflow maintains the state of ongoing processes, tracking progress through multiple steps and ensuring consistency across operations.\n4. **Output Handling** Results from the agent's actions are processed according to defined rules, whether that means storing data, triggering notifications, or formatting responses.\n\n</page>\n\n<page>\n---\ntitle: Build a Chat Agent · Cloudflare Agents docs\ndescription: A starter template for building AI-powered chat agents using\n  Cloudflare's Agent platform, powered by the Agents SDK. This project provides\n  a foundation for creating interactive chat experiences with AI, complete with\n  a modern UI and tool integration capabilities.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/\n  md: https://developers.cloudflare.com/agents/getting-started/build-a-chat-agent/index.md\n---\n\n\n</page>\n\n<page>\n---\ntitle: Prompt an AI model · Cloudflare Agents docs\ndescription: Use the Workers \"mega prompt\" to build a Agents using your\n  preferred AI tools and/or IDEs. The prompt understands the Agents SDK APIs,\n  best practices and guidelines, and makes it easier to build valid Agents and\n  Workers.\nlastUpdated: 2025-03-18T12:13:40.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/getting-started/prompting/\n  md: https://developers.cloudflare.com/agents/getting-started/prompting/index.md\n---\n\n\n</page>\n\n<page>\n---\ntitle: Testing your Agents · Cloudflare Agents docs\ndescription: Because Agents run on Cloudflare Workers and Durable Objects, they\n  can be tested using the same tools and techniques as Workers and Durable\n  Objects.\nlastUpdated: 2025-05-16T16:37:37.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/agents/getting-started/testing-your-agent/\n  md: https://developers.cloudflare.com/agents/getting-started/testing-your-agent/index.md\n---\n\nBecause Agents run on Cloudflare Workers and Durable Objects, they can be tested using the same tools and techniques as Workers and Durable Objects.\n\n## Writing and running tests\n\n### Setup\n\nNote\n\nThe `agents-starter` template and new Cloudflare Workers projects already include the relevant `vitest` and `@cloudflare/vitest-pool-workers` packages, as well as a valid `vitest.config.js` file.\n\nBefore you write your first test, install the necessary packages:",
      "language": "unknown"
    },
    {
      "code": "Ensure that your `vitest.config.js` file is identical to the following:",
      "language": "unknown"
    },
    {
      "code": "### Add the Agent configuration\n\nAdd a `durableObjects` configuration to `vitest.config.js` with the name of your Agent class:",
      "language": "unknown"
    },
    {
      "code": "### Write a test\n\nNote\n\nReview the [Vitest documentation](https://vitest.dev/) for more information on testing, including the test API reference and advanced testing techniques.\n\nTests use the `vitest` framework. A basic test suite for your Agent can validate how your Agent responds to requests, but can also unit test your Agent's methods and state.",
      "language": "unknown"
    },
    {
      "code": "### Run tests\n\nRunning tests is done using the `vitest` CLI:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "2025-02-11",
      "id": "2025-02-11"
    },
    {
      "level": "h2",
      "text": "2024-12-16",
      "id": "2024-12-16"
    },
    {
      "level": "h2",
      "text": "2024-11-12",
      "id": "2024-11-12"
    },
    {
      "level": "h2",
      "text": "2024-09-17",
      "id": "2024-09-17"
    },
    {
      "level": "h2",
      "text": "2024-08-23",
      "id": "2024-08-23"
    },
    {
      "level": "h2",
      "text": "2024-08-15",
      "id": "2024-08-15"
    },
    {
      "level": "h2",
      "text": "2024-08-12",
      "id": "2024-08-12"
    },
    {
      "level": "h2",
      "text": "2024-07-23",
      "id": "2024-07-23"
    },
    {
      "level": "h2",
      "text": "2024-06-21",
      "id": "2024-06-21"
    },
    {
      "level": "h2",
      "text": "2024-06-18",
      "id": "2024-06-18"
    },
    {
      "level": "h2",
      "text": "2024-05-03",
      "id": "2024-05-03"
    },
    {
      "level": "h2",
      "text": "2024-04-19",
      "id": "2024-04-19"
    },
    {
      "level": "h2",
      "text": "2024-04-08",
      "id": "2024-04-08"
    },
    {
      "level": "h2",
      "text": "2024-02-15",
      "id": "2024-02-15"
    },
    {
      "level": "h2",
      "text": "2024-02-05",
      "id": "2024-02-05"
    },
    {
      "level": "h2",
      "text": "2023-12-19",
      "id": "2023-12-19"
    },
    {
      "level": "h2",
      "text": "2023-11-13",
      "id": "2023-11-13"
    },
    {
      "level": "h2",
      "text": "2023-10-31",
      "id": "2023-10-31"
    },
    {
      "level": "h2",
      "text": "2023-10-26",
      "id": "2023-10-26"
    },
    {
      "level": "h2",
      "text": "2023-10-20",
      "id": "2023-10-20"
    },
    {
      "level": "h2",
      "text": "2023-10-03",
      "id": "2023-10-03"
    },
    {
      "level": "h2",
      "text": "2023-09-13",
      "id": "2023-09-13"
    },
    {
      "level": "h2",
      "text": "2023-09-11",
      "id": "2023-09-11"
    },
    {
      "level": "h2",
      "text": "2023-09-06",
      "id": "2023-09-06"
    },
    {
      "level": "h2",
      "text": "2023-09-05",
      "id": "2023-09-05"
    },
    {
      "level": "h2",
      "text": "2023-08-21",
      "id": "2023-08-21"
    },
    {
      "level": "h2",
      "text": "Crucial vocabulary",
      "id": "crucial-vocabulary"
    },
    {
      "level": "h2",
      "text": "Purposes and tools",
      "id": "purposes-and-tools"
    },
    {
      "level": "h2",
      "text": "Important things to note",
      "id": "important-things-to-note"
    },
    {
      "level": "h2",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h3",
      "text": "X (Twitter) embed",
      "id": "x-(twitter)-embed"
    },
    {
      "level": "h3",
      "text": "Instagram embed",
      "id": "instagram-embed"
    },
    {
      "level": "h2",
      "text": "General",
      "id": "general"
    },
    {
      "level": "h3",
      "text": "Setting up Zaraz",
      "id": "setting-up-zaraz"
    },
    {
      "level": "h3",
      "text": "Zaraz Web API",
      "id": "zaraz-web-api"
    },
    {
      "level": "h2",
      "text": "Tools",
      "id": "tools"
    },
    {
      "level": "h3",
      "text": "Google Analytics",
      "id": "google-analytics"
    },
    {
      "level": "h3",
      "text": "Facebook Pixel",
      "id": "facebook-pixel"
    },
    {
      "level": "h3",
      "text": "Google Ads",
      "id": "google-ads"
    },
    {
      "level": "h3",
      "text": "Custom HTML",
      "id": "custom-html"
    },
    {
      "level": "h3",
      "text": "Other tools",
      "id": "other-tools"
    },
    {
      "level": "h2",
      "text": "Consent",
      "id": "consent"
    },
    {
      "level": "h3",
      "text": "How do I show the consent modal again to all users?",
      "id": "how-do-i-show-the-consent-modal-again-to-all-users?"
    },
    {
      "level": "h2",
      "text": "Add a third-party tool to your website",
      "id": "add-a-third-party-tool-to-your-website"
    },
    {
      "level": "h2",
      "text": "Events, triggers and actions",
      "id": "events,-triggers-and-actions"
    },
    {
      "level": "h2",
      "text": "Web API",
      "id": "web-api"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h2",
      "text": "Platform plugins",
      "id": "platform-plugins"
    },
    {
      "level": "h3",
      "text": "WooCommerce",
      "id": "woocommerce"
    },
    {
      "level": "h2",
      "text": "Footnotes",
      "id": "footnotes"
    },
    {
      "level": "h2",
      "text": "Configure the API endpoint",
      "id": "configure-the-api-endpoint"
    },
    {
      "level": "h2",
      "text": "Send events",
      "id": "send-events"
    },
    {
      "level": "h3",
      "text": "The `system` key",
      "id": "the-`system`-key"
    },
    {
      "level": "h2",
      "text": "Process API responses",
      "id": "process-api-responses"
    },
    {
      "level": "h2",
      "text": "Zaraz Monitoring options",
      "id": "zaraz-monitoring-options"
    },
    {
      "level": "h2",
      "text": "The Zaraz Event unit",
      "id": "the-zaraz-event-unit"
    },
    {
      "level": "h2",
      "text": "Enabling Zaraz Paid",
      "id": "enabling-zaraz-paid"
    },
    {
      "level": "h2",
      "text": "Using Zaraz Free",
      "id": "using-zaraz-free"
    },
    {
      "level": "h2",
      "text": "Create a function",
      "id": "create-a-function"
    },
    {
      "level": "h2",
      "text": "Using 1.1.1.1",
      "id": "using-1.1.1.1"
    },
    {
      "level": "h2",
      "text": "Perform DNS lookups",
      "id": "perform-dns-lookups"
    },
    {
      "level": "h3",
      "text": "Supported record types",
      "id": "supported-record-types"
    },
    {
      "level": "h3",
      "text": "Short form response",
      "id": "short-form-response"
    },
    {
      "level": "h3",
      "text": "Disable DNSSEC checking",
      "id": "disable-dnssec-checking"
    },
    {
      "level": "h3",
      "text": "Refreshing existing results",
      "id": "refreshing-existing-results"
    },
    {
      "level": "h3",
      "text": "Changing DNS provider",
      "id": "changing-dns-provider"
    },
    {
      "level": "h2",
      "text": "`multi-dig` command",
      "id": "`multi-dig`-command"
    },
    {
      "level": "h3",
      "text": "Supported record types",
      "id": "supported-record-types"
    },
    {
      "level": "h3",
      "text": "Short form response",
      "id": "short-form-response"
    },
    {
      "level": "h3",
      "text": "Disable DNSSEC checking",
      "id": "disable-dnssec-checking"
    },
    {
      "level": "h3",
      "text": "Refreshing existing results",
      "id": "refreshing-existing-results"
    },
    {
      "level": "h3",
      "text": "Changing DNS provider",
      "id": "changing-dns-provider"
    },
    {
      "level": "h2",
      "text": "`whois` command",
      "id": "`whois`-command"
    },
    {
      "level": "h2",
      "text": "Other commands",
      "id": "other-commands"
    },
    {
      "level": "h3",
      "text": "`help` command",
      "id": "`help`-command"
    },
    {
      "level": "h3",
      "text": "`privacy` command",
      "id": "`privacy`-command"
    },
    {
      "level": "h3",
      "text": "`terms` command",
      "id": "`terms`-command"
    },
    {
      "level": "h3",
      "text": "`github` command",
      "id": "`github`-command"
    },
    {
      "level": "h3",
      "text": "`invite` command",
      "id": "`invite`-command"
    },
    {
      "level": "h2",
      "text": "Development",
      "id": "development"
    },
    {
      "level": "h2",
      "text": "Setting up a Tor client",
      "id": "setting-up-a-tor-client"
    },
    {
      "level": "h2",
      "text": "Setting up a local DNS proxy using socat",
      "id": "setting-up-a-local-dns-proxy-using-socat"
    },
    {
      "level": "h3",
      "text": "DNS over TCP, TLS, and HTTPS",
      "id": "dns-over-tcp,-tls,-and-https"
    },
    {
      "level": "h3",
      "text": "DNS over HTTPS",
      "id": "dns-over-https"
    },
    {
      "level": "h2",
      "text": "How it works",
      "id": "how-it-works"
    },
    {
      "level": "h2",
      "text": "Example",
      "id": "example"
    },
    {
      "level": "h2",
      "text": "Supported TLS versions",
      "id": "supported-tls-versions"
    },
    {
      "level": "h2",
      "text": "How ODoH works",
      "id": "how-odoh-works"
    },
    {
      "level": "h2",
      "text": "Cloudflare and third-party products",
      "id": "cloudflare-and-third-party-products"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Configure DNS64",
      "id": "configure-dns64"
    },
    {
      "level": "h2",
      "text": "Test DNS64",
      "id": "test-dns64"
    },
    {
      "level": "h2",
      "text": "Configuring 1.1.1.1",
      "id": "configuring-1.1.1.1"
    },
    {
      "level": "h2",
      "text": "Available Endpoints",
      "id": "available-endpoints"
    },
    {
      "level": "h2",
      "text": "Rate Limiting",
      "id": "rate-limiting"
    },
    {
      "level": "h2",
      "text": "Help",
      "id": "help"
    },
    {
      "level": "h2",
      "text": "Frequently asked questions about the Cloudflare resolver for Firefox",
      "id": "frequently-asked-questions-about-the-cloudflare-resolver-for-firefox"
    },
    {
      "level": "h3",
      "text": "What is the Cloudflare resolver for Firefox?",
      "id": "what-is-the-cloudflare-resolver-for-firefox?"
    },
    {
      "level": "h3",
      "text": "What information does the Cloudflare resolver for Firefox collect?",
      "id": "what-information-does-the-cloudflare-resolver-for-firefox-collect?"
    },
    {
      "level": "h3",
      "text": "What is the Cloudflare promise?",
      "id": "what-is-the-cloudflare-promise?"
    },
    {
      "level": "h3",
      "text": "What about government requests for content blocking?",
      "id": "what-about-government-requests-for-content-blocking?"
    },
    {
      "level": "h2",
      "text": "Cloudflare’s commitment to privacy: 1.1.1.1 Public DNS Resolver",
      "id": "cloudflare’s-commitment-to-privacy:-1.1.1.1-public-dns-resolver"
    },
    {
      "level": "h2",
      "text": "Limited data sharing with APNIC",
      "id": "limited-data-sharing-with-apnic"
    },
    {
      "level": "h2",
      "text": "Data in public resolver logs",
      "id": "data-in-public-resolver-logs"
    },
    {
      "level": "h2",
      "text": "What about requests for content blocking?",
      "id": "what-about-requests-for-content-blocking?"
    },
    {
      "level": "h2",
      "text": "Set up 1.1.1.1: Faster Internet",
      "id": "set-up-1.1.1.1:-faster-internet"
    },
    {
      "level": "h3",
      "text": "Enable 1.1.1.1 for Families",
      "id": "enable-1.1.1.1-for-families"
    },
    {
      "level": "h2",
      "text": "Configure 1.1.1.1 manually",
      "id": "configure-1.1.1.1-manually"
    },
    {
      "level": "h3",
      "text": "Android 11 or later",
      "id": "android-11-or-later"
    },
    {
      "level": "h3",
      "text": "Android 9 or 10",
      "id": "android-9-or-10"
    },
    {
      "level": "h3",
      "text": "Previous Android versions",
      "id": "previous-android-versions"
    },
    {
      "level": "h2",
      "text": "PS4",
      "id": "ps4"
    },
    {
      "level": "h2",
      "text": "Xbox One",
      "id": "xbox-one"
    },
    {
      "level": "h2",
      "text": "Nintendo",
      "id": "nintendo"
    },
    {
      "level": "h2",
      "text": "Nintendo Switch",
      "id": "nintendo-switch"
    },
    {
      "level": "h2",
      "text": "Set up 1.1.1.1: Faster Internet",
      "id": "set-up-1.1.1.1:-faster-internet"
    },
    {
      "level": "h3",
      "text": "Enable 1.1.1.1 for Families",
      "id": "enable-1.1.1.1-for-families"
    },
    {
      "level": "h2",
      "text": "Configure 1.1.1.1 manually",
      "id": "configure-1.1.1.1-manually"
    },
    {
      "level": "h2",
      "text": "Use command line interface (CLI)",
      "id": "use-command-line-interface-(cli)"
    },
    {
      "level": "h3",
      "text": "`resolv.conf`",
      "id": "`resolv.conf`"
    },
    {
      "level": "h3",
      "text": "`systemd-resolved`",
      "id": "`systemd-resolved`"
    },
    {
      "level": "h2",
      "text": "Use graphical user interface (GUI)",
      "id": "use-graphical-user-interface-(gui)"
    },
    {
      "level": "h3",
      "text": "GNOME",
      "id": "gnome"
    },
    {
      "level": "h3",
      "text": "KDE Plasma",
      "id": "kde-plasma"
    },
    {
      "level": "h2",
      "text": "Encrypt your DNS queries",
      "id": "encrypt-your-dns-queries"
    },
    {
      "level": "h2",
      "text": "Using DNS-Over-TLS on OpenWrt",
      "id": "using-dns-over-tls-on-openwrt"
    },
    {
      "level": "h2",
      "text": "FRITZ!Box",
      "id": "fritz!box"
    },
    {
      "level": "h2",
      "text": "Windows 10",
      "id": "windows-10"
    },
    {
      "level": "h2",
      "text": "Windows 11",
      "id": "windows-11"
    },
    {
      "level": "h2",
      "text": "Encrypt your DNS queries",
      "id": "encrypt-your-dns-queries"
    },
    {
      "level": "h2",
      "text": "Introduction",
      "id": "introduction"
    },
    {
      "level": "h2",
      "text": "Setting up BYOK",
      "id": "setting-up-byok"
    },
    {
      "level": "h3",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h3",
      "text": "Configure API keys",
      "id": "configure-api-keys"
    },
    {
      "level": "h3",
      "text": "Update your applications",
      "id": "update-your-applications"
    },
    {
      "level": "h2",
      "text": "Example",
      "id": "example"
    },
    {
      "level": "h2",
      "text": "Managing API keys",
      "id": "managing-api-keys"
    },
    {
      "level": "h3",
      "text": "Viewing configured keys",
      "id": "viewing-configured-keys"
    },
    {
      "level": "h3",
      "text": "Rotating keys",
      "id": "rotating-keys"
    },
    {
      "level": "h3",
      "text": "Revoking access",
      "id": "revoking-access"
    },
    {
      "level": "h2",
      "text": "Setting up Authenticated Gateway using the Dashboard",
      "id": "setting-up-authenticated-gateway-using-the-dashboard"
    },
    {
      "level": "h2",
      "text": "Example requests with OpenAI",
      "id": "example-requests-with-openai"
    },
    {
      "level": "h2",
      "text": "Example requests with the Vercel AI SDK",
      "id": "example-requests-with-the-vercel-ai-sdk"
    },
    {
      "level": "h2",
      "text": "Expected behavior",
      "id": "expected-behavior"
    },
    {
      "level": "h2",
      "text": "Custom cost",
      "id": "custom-cost"
    },
    {
      "level": "h2",
      "text": "Overview",
      "id": "overview"
    },
    {
      "level": "h2",
      "text": "Use cases",
      "id": "use-cases"
    },
    {
      "level": "h2",
      "text": "Before you begin",
      "id": "before-you-begin"
    },
    {
      "level": "h3",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h3",
      "text": "Authentication",
      "id": "authentication"
    },
    {
      "level": "h2",
      "text": "Create a custom provider",
      "id": "create-a-custom-provider"
    },
    {
      "level": "h2",
      "text": "List custom providers",
      "id": "list-custom-providers"
    },
    {
      "level": "h2",
      "text": "Get a specific custom provider",
      "id": "get-a-specific-custom-provider"
    },
    {
      "level": "h2",
      "text": "Update a custom provider",
      "id": "update-a-custom-provider"
    },
    {
      "level": "h2",
      "text": "Delete a custom provider",
      "id": "delete-a-custom-provider"
    },
    {
      "level": "h2",
      "text": "Using custom providers with AI Gateway",
      "id": "using-custom-providers-with-ai-gateway"
    },
    {
      "level": "h3",
      "text": "Via Unified API",
      "id": "via-unified-api"
    },
    {
      "level": "h3",
      "text": "Via provider-specific endpoint",
      "id": "via-provider-specific-endpoint"
    },
    {
      "level": "h2",
      "text": "Common errors",
      "id": "common-errors"
    },
    {
      "level": "h3",
      "text": "409 Conflict - Duplicate slug",
      "id": "409-conflict---duplicate-slug"
    },
    {
      "level": "h3",
      "text": "404 Not Found",
      "id": "404-not-found"
    },
    {
      "level": "h3",
      "text": "400 Bad Request - Invalid base\\_url",
      "id": "400-bad-request---invalid-base\\_url"
    },
    {
      "level": "h2",
      "text": "Best practices",
      "id": "best-practices"
    },
    {
      "level": "h2",
      "text": "Limitations",
      "id": "limitations"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Request failures",
      "id": "request-failures"
    },
    {
      "level": "h3",
      "text": "Example",
      "id": "example"
    },
    {
      "level": "h2",
      "text": "Response header(cf-aig-step)",
      "id": "response-header(cf-aig-step)"
    },
    {
      "level": "h2",
      "text": "Create gateway",
      "id": "create-gateway"
    },
    {
      "level": "h2",
      "text": "Edit gateway",
      "id": "edit-gateway"
    },
    {
      "level": "h2",
      "text": "Delete gateway",
      "id": "delete-gateway"
    },
    {
      "level": "h2",
      "text": "Request timeouts",
      "id": "request-timeouts"
    },
    {
      "level": "h3",
      "text": "Definitions",
      "id": "definitions"
    },
    {
      "level": "h3",
      "text": "Configuration",
      "id": "configuration"
    },
    {
      "level": "h2",
      "text": "Request retries",
      "id": "request-retries"
    },
    {
      "level": "h3",
      "text": "Definitions",
      "id": "definitions"
    },
    {
      "level": "h3",
      "text": "Configuration",
      "id": "configuration"
    },
    {
      "level": "h2",
      "text": "1. Log in to the dashboard",
      "id": "1.-log-in-to-the-dashboard"
    },
    {
      "level": "h2",
      "text": "2. Access the Logs tab",
      "id": "2.-access-the-logs-tab"
    },
    {
      "level": "h2",
      "text": "3. Provide human feedback",
      "id": "3.-provide-human-feedback"
    },
    {
      "level": "h2",
      "text": "4. Evaluate human feedback",
      "id": "4.-evaluate-human-feedback"
    },
    {
      "level": "h2",
      "text": "5. Review results",
      "id": "5.-review-results"
    },
    {
      "level": "h2",
      "text": "1. Create an API Token",
      "id": "1.-create-an-api-token"
    },
    {
      "level": "h2",
      "text": "2. Retrieve the `cf-aig-log-id`",
      "id": "2.-retrieve-the-`cf-aig-log-id`"
    },
    {
      "level": "h3",
      "text": "Method 1: Locate the `cf-aig-log-id` in the request response",
      "id": "method-1:-locate-the-`cf-aig-log-id`-in-the-request-response"
    },
    {
      "level": "h3",
      "text": "Method 2: Retrieve the `cf-aig-log-id` via API (GET request)",
      "id": "method-2:-retrieve-the-`cf-aig-log-id`-via-api-(get-request)"
    },
    {
      "level": "h3",
      "text": "Method 3: Retrieve the `cf-aig-log-id` via a binding",
      "id": "method-3:-retrieve-the-`cf-aig-log-id`-via-a-binding"
    },
    {
      "level": "h2",
      "text": "3. Submit feedback via PATCH request",
      "id": "3.-submit-feedback-via-patch-request"
    },
    {
      "level": "h2",
      "text": "4. Verify the feedback submission",
      "id": "4.-verify-the-feedback-submission"
    },
    {
      "level": "h2",
      "text": "1. Run an AI Evaluation",
      "id": "1.-run-an-ai-evaluation"
    },
    {
      "level": "h2",
      "text": "2. Send Human Feedback",
      "id": "2.-send-human-feedback"
    },
    {
      "level": "h2",
      "text": "Feedback parameters explanation",
      "id": "feedback-parameters-explanation"
    },
    {
      "level": "h3",
      "text": "patchLog: Send Feedback",
      "id": "patchlog:-send-feedback"
    },
    {
      "level": "h2",
      "text": "1. Select or create a dataset",
      "id": "1.-select-or-create-a-dataset"
    },
    {
      "level": "h3",
      "text": "Set up a dataset from the Logs tab",
      "id": "set-up-a-dataset-from-the-logs-tab"
    },
    {
      "level": "h3",
      "text": "List of available filters",
      "id": "list-of-available-filters"
    },
    {
      "level": "h2",
      "text": "2. Select evaluators",
      "id": "2.-select-evaluators"
    },
    {
      "level": "h2",
      "text": "3. Name, review, and run the evaluation",
      "id": "3.-name,-review,-and-run-the-evaluation"
    },
    {
      "level": "h2",
      "text": "4. Review and analyze results",
      "id": "4.-review-and-analyze-results"
    },
    {
      "level": "h2",
      "text": "Benefits of Using Caching",
      "id": "benefits-of-using-caching"
    },
    {
      "level": "h2",
      "text": "Default configuration",
      "id": "default-configuration"
    },
    {
      "level": "h2",
      "text": "Per-request caching",
      "id": "per-request-caching"
    },
    {
      "level": "h3",
      "text": "Skip cache (cf-aig-skip-cache)",
      "id": "skip-cache-(cf-aig-skip-cache)"
    },
    {
      "level": "h3",
      "text": "Cache TTL (cf-aig-cache-ttl)",
      "id": "cache-ttl-(cf-aig-cache-ttl)"
    },
    {
      "level": "h3",
      "text": "Custom cache key (cf-aig-cache-key)",
      "id": "custom-cache-key-(cf-aig-cache-key)"
    },
    {
      "level": "h2",
      "text": "How it works",
      "id": "how-it-works"
    },
    {
      "level": "h2",
      "text": "Key benefits",
      "id": "key-benefits"
    },
    {
      "level": "h2",
      "text": "Supported AI traffic",
      "id": "supported-ai-traffic"
    },
    {
      "level": "h2",
      "text": "Integration with Cloudflare DLP",
      "id": "integration-with-cloudflare-dlp"
    },
    {
      "level": "h2",
      "text": "Getting started",
      "id": "getting-started"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Introduction",
      "id": "introduction"
    },
    {
      "level": "h2",
      "text": "Core Concepts",
      "id": "core-concepts"
    },
    {
      "level": "h2",
      "text": "Getting Started",
      "id": "getting-started"
    },
    {
      "level": "h2",
      "text": "Video demo",
      "id": "video-demo"
    },
    {
      "level": "h2",
      "text": "How Guardrails work",
      "id": "how-guardrails-work"
    },
    {
      "level": "h2",
      "text": "Related resource",
      "id": "related-resource"
    },
    {
      "level": "h2",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h2",
      "text": "Handling rate limits",
      "id": "handling-rate-limits"
    },
    {
      "level": "h2",
      "text": "Default configuration",
      "id": "default-configuration"
    },
    {
      "level": "h2",
      "text": "Pre-requisites",
      "id": "pre-requisites"
    },
    {
      "level": "h2",
      "text": "Load credits",
      "id": "load-credits"
    },
    {
      "level": "h3",
      "text": "Auto-top up",
      "id": "auto-top-up"
    },
    {
      "level": "h2",
      "text": "Use Unified Billing",
      "id": "use-unified-billing"
    },
    {
      "level": "h3",
      "text": "Spend limits",
      "id": "spend-limits"
    },
    {
      "level": "h3",
      "text": "Supported providers",
      "id": "supported-providers"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Create a Worker Project",
      "id": "1.-create-a-worker-project"
    },
    {
      "level": "h2",
      "text": "2. Connect your Worker to Workers AI",
      "id": "2.-connect-your-worker-to-workers-ai"
    },
    {
      "level": "h2",
      "text": "3. Run an inference task containing AI Gateway in your Worker",
      "id": "3.-run-an-inference-task-containing-ai-gateway-in-your-worker"
    },
    {
      "level": "h2",
      "text": "4. Develop locally with Wrangler",
      "id": "4.-develop-locally-with-wrangler"
    },
    {
      "level": "h2",
      "text": "5. Deploy your AI Worker",
      "id": "5.-deploy-your-ai-worker"
    },
    {
      "level": "h2",
      "text": "Installation",
      "id": "installation"
    },
    {
      "level": "h2",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h3",
      "text": "Fallback Providers",
      "id": "fallback-providers"
    },
    {
      "level": "h2",
      "text": "1. Add an AI Binding to your Worker",
      "id": "1.-add-an-ai-binding-to-your-worker"
    },
    {
      "level": "h2",
      "text": "2. Basic Usage with Workers AI + Gateway",
      "id": "2.-basic-usage-with-workers-ai-+-gateway"
    },
    {
      "level": "h2",
      "text": "3. Access the Gateway Binding",
      "id": "3.-access-the-gateway-binding"
    },
    {
      "level": "h3",
      "text": "3.1. `patchLog`: Send Feedback",
      "id": "3.1.-`patchlog`:-send-feedback"
    },
    {
      "level": "h3",
      "text": "3.2. `getLog`: Read Log Details",
      "id": "3.2.-`getlog`:-read-log-details"
    },
    {
      "level": "h3",
      "text": "3.3. `getUrl`: Get Gateway URLs",
      "id": "3.3.-`geturl`:-get-gateway-urls"
    },
    {
      "level": "h3",
      "text": "3.4. `run`: Universal Requests",
      "id": "3.4.-`run`:-universal-requests"
    },
    {
      "level": "h2",
      "text": "Conclusion",
      "id": "conclusion"
    },
    {
      "level": "h2",
      "text": "View analytics",
      "id": "view-analytics"
    },
    {
      "level": "h2",
      "text": "Track costs across AI providers",
      "id": "track-costs-across-ai-providers"
    },
    {
      "level": "h2",
      "text": "Custom costs",
      "id": "custom-costs"
    },
    {
      "level": "h2",
      "text": "Key Features",
      "id": "key-features"
    },
    {
      "level": "h2",
      "text": "Supported Metadata Types",
      "id": "supported-metadata-types"
    },
    {
      "level": "h2",
      "text": "Implementations",
      "id": "implementations"
    },
    {
      "level": "h3",
      "text": "Using cURL",
      "id": "using-curl"
    },
    {
      "level": "h3",
      "text": "Using SDK",
      "id": "using-sdk"
    },
    {
      "level": "h3",
      "text": "Using Binding",
      "id": "using-binding"
    },
    {
      "level": "h2",
      "text": "Default configuration",
      "id": "default-configuration"
    },
    {
      "level": "h2",
      "text": "Per-request logging",
      "id": "per-request-logging"
    },
    {
      "level": "h3",
      "text": "Collect logs (`cf-aig-collect-log`)",
      "id": "collect-logs-(`cf-aig-collect-log`)"
    },
    {
      "level": "h2",
      "text": "Managing log storage",
      "id": "managing-log-storage"
    },
    {
      "level": "h2",
      "text": "How to delete logs",
      "id": "how-to-delete-logs"
    },
    {
      "level": "h3",
      "text": "Automatic Log Deletion",
      "id": "automatic-log-deletion"
    },
    {
      "level": "h3",
      "text": "Manual deletion",
      "id": "manual-deletion"
    },
    {
      "level": "h3",
      "text": "API deletion",
      "id": "api-deletion"
    },
    {
      "level": "h2",
      "text": "Viewing Audit Logs",
      "id": "viewing-audit-logs"
    },
    {
      "level": "h2",
      "text": "Logged Operations",
      "id": "logged-operations"
    },
    {
      "level": "h2",
      "text": "Example Log Entry",
      "id": "example-log-entry"
    },
    {
      "level": "h2",
      "text": "Persistent logs",
      "id": "persistent-logs"
    },
    {
      "level": "h3",
      "text": "Free allocation and overage pricing",
      "id": "free-allocation-and-overage-pricing"
    },
    {
      "level": "h2",
      "text": "Logpush",
      "id": "logpush"
    },
    {
      "level": "h2",
      "text": "Fine print",
      "id": "fine-print"
    },
    {
      "level": "h2",
      "text": "Sign up and log in",
      "id": "sign-up-and-log-in"
    },
    {
      "level": "h2",
      "text": "Create gateway",
      "id": "create-gateway"
    },
    {
      "level": "h2",
      "text": "Connect Your AI Provider",
      "id": "connect-your-ai-provider"
    },
    {
      "level": "h2",
      "text": "Configure Your Workers AI",
      "id": "configure-your-workers-ai"
    },
    {
      "level": "h2",
      "text": "View Analytics",
      "id": "view-analytics"
    },
    {
      "level": "h2",
      "text": "Optional - Next steps",
      "id": "optional---next-steps"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "1. Create an AI Gateway and OpenAI API key",
      "id": "1.-create-an-ai-gateway-and-openai-api-key"
    },
    {
      "level": "h2",
      "text": "2. Create a new Worker",
      "id": "2.-create-a-new-worker"
    },
    {
      "level": "h2",
      "text": "3. Configure OpenAI in your Worker",
      "id": "3.-configure-openai-in-your-worker"
    },
    {
      "level": "h2",
      "text": "4. Make an OpenAI request",
      "id": "4.-make-an-openai-request"
    },
    {
      "level": "h2",
      "text": "5. Deploy your Worker application",
      "id": "5.-deploy-your-worker-application"
    },
    {
      "level": "h2",
      "text": "6. Review your AI Gateway",
      "id": "6.-review-your-ai-gateway"
    },
    {
      "level": "h2",
      "text": "Endpoint URL",
      "id": "endpoint-url"
    },
    {
      "level": "h2",
      "text": "Parameters",
      "id": "parameters"
    },
    {
      "level": "h2",
      "text": "Examples",
      "id": "examples"
    },
    {
      "level": "h3",
      "text": "OpenAI SDK",
      "id": "openai-sdk"
    },
    {
      "level": "h3",
      "text": "cURL",
      "id": "curl"
    },
    {
      "level": "h2",
      "text": "Supported Providers",
      "id": "supported-providers"
    },
    {
      "level": "h2",
      "text": "cURL example",
      "id": "curl-example"
    },
    {
      "level": "h2",
      "text": "WebSockets API beta",
      "id": "websockets-api-beta"
    },
    {
      "level": "h2",
      "text": "WebSockets example",
      "id": "websockets-example"
    },
    {
      "level": "h2",
      "text": "Workers Binding example",
      "id": "workers-binding-example"
    },
    {
      "level": "h2",
      "text": "Header configuration hierarchy",
      "id": "header-configuration-hierarchy"
    },
    {
      "level": "h2",
      "text": "Hierarchy example",
      "id": "hierarchy-example"
    },
    {
      "level": "h2",
      "text": "When to use WebSockets",
      "id": "when-to-use-websockets"
    },
    {
      "level": "h2",
      "text": "Key benefits",
      "id": "key-benefits"
    },
    {
      "level": "h2",
      "text": "Key differences",
      "id": "key-differences"
    },
    {
      "level": "h3",
      "text": "Agent class API",
      "id": "agent-class-api"
    },
    {
      "level": "h3",
      "text": "WebSocket API",
      "id": "websocket-api"
    },
    {
      "level": "h3",
      "text": "State synchronization API",
      "id": "state-synchronization-api"
    },
    {
      "level": "h3",
      "text": "Scheduling API",
      "id": "scheduling-api"
    },
    {
      "level": "h3",
      "text": "SQL API",
      "id": "sql-api"
    },
    {
      "level": "h3",
      "text": "MCP Client API",
      "id": "mcp-client-api"
    },
    {
      "level": "h3",
      "text": "Client API",
      "id": "client-api"
    },
    {
      "level": "h3",
      "text": "React API",
      "id": "react-api"
    },
    {
      "level": "h3",
      "text": "Chat Agent",
      "id": "chat-agent"
    },
    {
      "level": "h3",
      "text": "Chat Agent React API",
      "id": "chat-agent-react-api"
    },
    {
      "level": "h3",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h3",
      "text": "Browser Rendering API",
      "id": "browser-rendering-api"
    },
    {
      "level": "h3",
      "text": "Browserbase",
      "id": "browserbase"
    },
    {
      "level": "h3",
      "text": "Calling your Agent",
      "id": "calling-your-agent"
    },
    {
      "level": "h3",
      "text": "Calling methods on Agents",
      "id": "calling-methods-on-agents"
    },
    {
      "level": "h3",
      "text": "Naming your Agents",
      "id": "naming-your-agents"
    },
    {
      "level": "h3",
      "text": "Authenticating Agents",
      "id": "authenticating-agents"
    },
    {
      "level": "h3",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h3",
      "text": "Project structure",
      "id": "project-structure"
    },
    {
      "level": "h3",
      "text": "Example configuration",
      "id": "example-configuration"
    },
    {
      "level": "h3",
      "text": "Handling HTTP requests",
      "id": "handling-http-requests"
    },
    {
      "level": "h3",
      "text": "Implementing Server-Sent Events",
      "id": "implementing-server-sent-events"
    },
    {
      "level": "h3",
      "text": "WebSockets vs. Server-Sent Events",
      "id": "websockets-vs.-server-sent-events"
    },
    {
      "level": "h3",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h3",
      "text": "Vector search",
      "id": "vector-search"
    },
    {
      "level": "h2",
      "text": "Trigger a Workflow",
      "id": "trigger-a-workflow"
    },
    {
      "level": "h2",
      "text": "Trigger a Workflow from another project",
      "id": "trigger-a-workflow-from-another-project"
    },
    {
      "level": "h3",
      "text": "Scheduling tasks",
      "id": "scheduling-tasks"
    },
    {
      "level": "h3",
      "text": "Managing scheduled tasks",
      "id": "managing-scheduled-tasks"
    },
    {
      "level": "h3",
      "text": "Set the initial state for an Agent",
      "id": "set-the-initial-state-for-an-agent"
    },
    {
      "level": "h3",
      "text": "Synchronizing state",
      "id": "synchronizing-state"
    },
    {
      "level": "h3",
      "text": "SQL API",
      "id": "sql-api"
    },
    {
      "level": "h3",
      "text": "Use Agent state as model context",
      "id": "use-agent-state-as-model-context"
    },
    {
      "level": "h3",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Calling AI Models",
      "id": "calling-ai-models"
    },
    {
      "level": "h3",
      "text": "Long-running model requests",
      "id": "long-running-model-requests"
    },
    {
      "level": "h3",
      "text": "Workers AI",
      "id": "workers-ai"
    },
    {
      "level": "h3",
      "text": "Hosted models",
      "id": "hosted-models"
    },
    {
      "level": "h3",
      "text": "Model routing",
      "id": "model-routing"
    },
    {
      "level": "h3",
      "text": "AI SDK",
      "id": "ai-sdk"
    },
    {
      "level": "h3",
      "text": "OpenAI compatible endpoints",
      "id": "openai-compatible-endpoints"
    },
    {
      "level": "h3",
      "text": "Connecting clients",
      "id": "connecting-clients"
    },
    {
      "level": "h3",
      "text": "React clients",
      "id": "react-clients"
    },
    {
      "level": "h3",
      "text": "Handling WebSocket events",
      "id": "handling-websocket-events"
    },
    {
      "level": "h2",
      "text": "What is the Agent?",
      "id": "what-is-the-agent?"
    },
    {
      "level": "h2",
      "text": "Layer 0: Durable Object",
      "id": "layer-0:-durable-object"
    },
    {
      "level": "h3",
      "text": "`constructor`",
      "id": "`constructor`"
    },
    {
      "level": "h3",
      "text": "RPC",
      "id": "rpc"
    },
    {
      "level": "h3",
      "text": "`fetch()`",
      "id": "`fetch()`"
    },
    {
      "level": "h3",
      "text": "WebSockets",
      "id": "websockets"
    },
    {
      "level": "h3",
      "text": "`alarm()`",
      "id": "`alarm()`"
    },
    {
      "level": "h3",
      "text": "`this.ctx`",
      "id": "`this.ctx`"
    },
    {
      "level": "h3",
      "text": "`this.ctx.storage`",
      "id": "`this.ctx.storage`"
    },
    {
      "level": "h3",
      "text": "`this.ctx.env`",
      "id": "`this.ctx.env`"
    },
    {
      "level": "h2",
      "text": "Layer 1: Partykit `Server`",
      "id": "layer-1:-partykit-`server`"
    },
    {
      "level": "h3",
      "text": "Addressing",
      "id": "addressing"
    },
    {
      "level": "h3",
      "text": "`onStart`",
      "id": "`onstart`"
    },
    {
      "level": "h3",
      "text": "`onRequest` and `onConnect`",
      "id": "`onrequest`-and-`onconnect`"
    },
    {
      "level": "h3",
      "text": "WebSockets",
      "id": "websockets"
    },
    {
      "level": "h3",
      "text": "`this.name`",
      "id": "`this.name`"
    },
    {
      "level": "h2",
      "text": "Layer 2: Agent",
      "id": "layer-2:-agent"
    },
    {
      "level": "h3",
      "text": "`this.state` and `this.setState()`",
      "id": "`this.state`-and-`this.setstate()`"
    },
    {
      "level": "h3",
      "text": "`this.sql`",
      "id": "`this.sql`"
    },
    {
      "level": "h3",
      "text": "RPC and Callable Methods",
      "id": "rpc-and-callable-methods"
    },
    {
      "level": "h3",
      "text": "`this.queue` and friends",
      "id": "`this.queue`-and-friends"
    },
    {
      "level": "h3",
      "text": "`this.schedule` and friends",
      "id": "`this.schedule`-and-friends"
    },
    {
      "level": "h3",
      "text": "`this.mcp` and friends",
      "id": "`this.mcp`-and-friends"
    },
    {
      "level": "h3",
      "text": "Email Handling",
      "id": "email-handling"
    },
    {
      "level": "h3",
      "text": "Context Management",
      "id": "context-management"
    },
    {
      "level": "h3",
      "text": "`this.onError`",
      "id": "`this.onerror`"
    },
    {
      "level": "h3",
      "text": "`this.destroy`",
      "id": "`this.destroy`"
    },
    {
      "level": "h3",
      "text": "Routing",
      "id": "routing"
    },
    {
      "level": "h3",
      "text": "Understanding LLM providers and model types",
      "id": "understanding-llm-providers-and-model-types"
    },
    {
      "level": "h3",
      "text": "What is Human-in-the-Loop?",
      "id": "what-is-human-in-the-loop?"
    },
    {
      "level": "h3",
      "text": "Best practices for Human-in-the-Loop workflows",
      "id": "best-practices-for-human-in-the-loop-workflows"
    },
    {
      "level": "h3",
      "text": "What are tools?",
      "id": "what-are-tools?"
    },
    {
      "level": "h3",
      "text": "Understanding tools",
      "id": "understanding-tools"
    },
    {
      "level": "h3",
      "text": "Common tool patterns",
      "id": "common-tool-patterns"
    },
    {
      "level": "h3",
      "text": "What are agents?",
      "id": "what-are-agents?"
    },
    {
      "level": "h3",
      "text": "Example: Booking vacations",
      "id": "example:-booking-vacations"
    },
    {
      "level": "h3",
      "text": "Three primary components of agent systems:",
      "id": "three-primary-components-of-agent-systems:"
    },
    {
      "level": "h2",
      "text": "What are workflows?",
      "id": "what-are-workflows?"
    },
    {
      "level": "h3",
      "text": "Understanding workflows in agent systems",
      "id": "understanding-workflows-in-agent-systems"
    },
    {
      "level": "h3",
      "text": "Core components of a workflow",
      "id": "core-components-of-a-workflow"
    },
    {
      "level": "h2",
      "text": "Writing and running tests",
      "id": "writing-and-running-tests"
    },
    {
      "level": "h3",
      "text": "Setup",
      "id": "setup"
    },
    {
      "level": "h3",
      "text": "Add the Agent configuration",
      "id": "add-the-agent-configuration"
    },
    {
      "level": "h3",
      "text": "Write a test",
      "id": "write-a-test"
    },
    {
      "level": "h3",
      "text": "Run tests",
      "id": "run-tests"
    }
  ],
  "url": "llms-txt#404",
  "links": []
}