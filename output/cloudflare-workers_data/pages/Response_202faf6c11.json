{
  "title": "Response:",
  "content": "{\n  \"result\": {\n    \"id\": \"7b163417-1d2b-4c84-a38a-2fb7a0cd7752\",\n    \"country\": \"US\",\n    \"state\": \"MA\",\n    \"locality\": \"Boston\",\n    \"organization\": \"City of Boston\",\n    \"organizational_unit\": \"Championship Parade Detail\",\n    \"common_name\": \"app.example.com\",\n    \"sans\": [\n      \"app.example.com\",\n      \"www.example.com\",\n      \"blog.example.com\",\n      \"example.com\",\n    ],\n    \"key_type\": \"p256v1\",\n    \"csr\": \"-----BEGIN CERTIFICATE REQUEST-----\\nMIIBSzCB8gIBADBiMQswaQYDVQQGEwJVUzELMAkGA1UECBMCTUExDzANBgNVBAcT\\nBkJvc3RvbjEaMBgGA1UEChMRQ2l0eSBvZiBDaGFtcGlvbnMxGTAXBgNVBAMTEGNz\\nci1wcm9kLnRscy5mdW4wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAaTKf70NYlwr\\n20P6P8xj8/4mTN5q28dbZR/gM3u4m/RPs24+PxAfMZCNvkVKAPVWYfUAadZI4Ha/\\ndxLh5Q6X5bhIoC4wLAYJKoZIhvcNAQkOMR8wHTAbBqNVHREEFDASghBjc3ItcHJv\\nZC50bHMuZnVuMAoGCCqGSM49BAMCA0gAMEUCIQDgtFUZav466SbT2FGBsIBlahDI\\nVkg4y+u+V/K5DlY1+gIgQ9xLfUSKnSnJYbM9TwWr4Z964+lBtB9af4O5pp7/PSA=\\n-----END CERTIFICATE REQUEST-----\\n\"\n  },\n  \"success\": true\nbash\ncurl https://api.cloudflare.com/client/v4/zones/{zone_id}/custom_csrs \\\n--header \"X-Auth-Email: <EMAIL>\" \\\n--header \"X-Auth-Key: <API_KEY>\" \\\n--header \"Content-Type: application/json\" \\\n--data \"$request_body\" | jq .result.csr | perl -npe s'/\\\\n/\\n/g; s/\"//g' > csr.txt\nbash\n$ MYCERT=\"$(cat app_example_com.pem|perl -pe 's/\\r?\\n/\\\\n/'|sed -e 's/..$//')\"\n\n$ request_body=$(< <(cat <<EOF\n{\n  \"hostname\": \"app.example.com\",\n  \"ssl\": {\n    \"custom_csr_id\": \"7b163417-1d2b-4c84-a38a-2fb7a0cd7752\",\n    \"custom_certificate\": \"$MYCERT\"\n  }\n}\nEOF\n))\nsh\n  cat app_example_com.pem\n  sh\n  -----BEGIN CERTIFICATE-----\n  MIIFJDCCBAygAwIBAgIQD0ifmj/Yi5NP/2gdUySbfzANBgkqhkiG9w0BAQsFADBN\n  MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMScwJQYDVQQDEx5E\n  ...\n  SzSHfXp5lnu/3V08I72q1QNzOCgY1XeL4GKVcj4or6cT6tX6oJH7ePPmfrBfqI/O\n  OeH8gMJ+FuwtXYEPa4hBf38M5eU5xWG7\n  -----END CERTIFICATE-----\n  sh\n  MYCERT=\"$(cat app_example_com.pem|perl -pe 's/\\r?\\n/\\\\n/'|sed -e 's/..$//')\"\n  MYKEY=\"$(cat app_example_com.key|perl -pe 's/\\r?\\n/\\\\n/'|sed -e's/..$//')\"\n  bash\n  $ echo $MYCERT\n  -----BEGIN CERTIFICATE-----\\nMIIFJDCCBAygAwIBAgIQD0ifmj/Yi5NP/2gdUySbfzANBgkqhkiG9w0BAQsFADBN\\nMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMScwJQYDVQQDEx5E...SzSHfXp5lnu/3V08I72q1QNzOCgY1XeL4GKVcj4or6cT6tX6oJH7ePPmfrBfqI/O\\nOeH8gMJ+FuwtXYEPa4hBf38M5eU5xWG7\\n-----END CERTIFICATE-----\\n\n\n$ request_body=$(< <(cat <<EOF\n  {\n    \"hostname\": \"app.example.com\",\n    \"ssl\": {\n      \"custom_certificate\": \"$MYCERT\",\n      \"custom_key\": \"$MYKEY\"\n    }\n  }\n  EOF\n  ))\n  txt\nexample.com.  60  IN  A   192.0.2.1\ntxt\nmystore.com CNAME customers.saasprovider.com\ntxt\n   headers: {\n     'Access-Control-Allow-Origin': 'https://example.com',\n     'Access-Control-Allow-Credentials' : true,\n     'Access-Control-Allow-Methods': 'GET, OPTIONS',\n     'Access-Control-Allow-Headers': 'office',\n     'Content-Type': 'application/json',\n   }\n   bash\n   curl --head --request OPTIONS https://api.mysite.com \\\n   --header 'origin: https://example.com' \\\n   --header 'access-control-request-method: GET'\n   txt\n   HTTP/2 200\n   date: Tue, 24 May 2022 21:51:21 GMT\n   vary: Origin, Access-Control-Request-Method, Access-Control-Request-Headers\n   access-control-allow-origin: https://example.com\n   access-control-allow-methods: GET\n   access-control-allow-credentials: true\n   expect-ct: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\"\n   report-to: {\"endpoints\":[{\"url\":\"https:\\/\\/a.nel.cloudflare.com\\/report\\/v3?s=A%2FbOOWJio%2B%2FjuJv5NC%2FE3%2Bo1zBl2UdjzJssw8gJLC4lE1lzIUPQKqJoLRTaVtFd21JK1d4g%2BnlEGNpx0mGtsR6jerNfr2H5mlQdO6u2RdOaJ6n%2F%2BS%2BF9%2Fa12UromVLcHsSA5Y%2Fj72tM%3D\"}],\"group\":\"cf-nel\",\"max_age\":604800}\n   nel: {\"success_fraction\":0.01,\"report_to\":\"cf-nel\",\"max_age\":604800}\n   server: cloudflare\n   cf-ray: 7109408e6b84efe4-EWR\n   sh\n  npm create cloudflare@latest -- authentication-worker\n  sh\n  yarn create cloudflare authentication-worker\n  sh\n  pnpm create cloudflare@latest authentication-worker\n  sh\ncd authentication-worker\njs\n// The hostname where your API lives\nconst originalAPIHostname = \"api.mysite.com\";\n\nexport default {\n  async fetch(request, env) {\n    // Change just the host. If the request comes in on example.com/api/name, the new URL is api.mysite.com/api/name\n    const url = new URL(request.url);\n    url.hostname = originalAPIHostname;\n\n// If your API is located on api.mysite.com/anyname (without \"api/\" in the path),\n    // remove the \"api/\" part of example.com/api/name\n\n// url.pathname = url.pathname.substring(4)\n\n// Best practice is to always use the original request to construct the new request\n    // to clone all the attributes. Applying the URL also requires a constructor\n    // since once a Request has been constructed, its URL is immutable.\n    const newRequest = new Request(url.toString(), request);\n\nnewRequest.headers.set(\"cf-access-client-id\", env.CF_ACCESS_CLIENT_ID);\n    newRequest.headers.set(\"cf-access-client-secret\", env.CF_ACCESS_CLIENT_SECRET);\n    try {\n      const response = await fetch(newRequest);\n\n// Copy over the response\n      const modifiedResponse = new Response(response.body, response);\n\n// Delete the set-cookie from the response so it doesn't override existing cookies\n      modifiedResponse.headers.delete(\"set-cookie\");\n\nreturn modifiedResponse;\n    } catch (e) {\n      return new Response(JSON.stringify({ error: e.message }), {\n        status: 500,\n      });\n    }\n  },\n};\nsh\nnpx wrangler deploy\njson\n{\n  \"alg\": \"RS256\",\n  \"kid\": \"9338abe1baf2fe492f646a736f25afbf7b025e35c627be4f60c414d4c73069b8\",\n  \"typ\": \"JWT\"\n}\njson\n{\n  \"aud\": [\"32eafc7626e974616deaf0dc3ce63d7bcbed58a2731e84d06bc3cdf1b53c4228\"],\n  \"email\": \"user@example.com\",\n  \"exp\": 1659474457,\n  \"iat\": 1659474397,\n  \"nbf\": 1659474397,\n  \"iss\": \"https://yourteam.cloudflareaccess.com\",\n  \"type\": \"app\",\n  \"identity_nonce\": \"6ei69kawdKzMIAPF\",\n  \"sub\": \"7335d417-61da-459d-899c-0a01c76a2f94\",\n  \"country\": \"US\"\n}\nsh\ncurl -H 'cookie: CF_Authorization=<user-token>' https://<your-team-name>.cloudflareaccess.com/cdn-cgi/access/get-identity\njson\n{\n  \"type\": \"app\",\n  \"aud\": [\"32eafc7626e974616deaf0dc3ce63d7bcbed58a2731e84d06bc3cdf1b53c4228\"],\n  \"exp\": 1659474457,\n  \"iss\": \"https://yourteam.cloudflareaccess.com\",\n  \"common_name\": \"e367826f93b8d71185e03fe518aff3b4.access\",\n  \"iat\": 1659474397,\n  \"sub\": \"\"\n}\ntxt\n{\n  \"keys\": [\n    {\n      \"kid\": \"1a1c3986a44ce6390be42ec772b031df8f433fdc71716db821dc0c39af3bce49\",\n      \"kty\": \"RSA\",\n      \"alg\": \"RS256\",\n      \"use\": \"sig\",\n      \"e\": \"AQAB\",\n      \"n\": \"5PKw-...-AG7MyQ\"\n    },\n    {\n      \"kid\": \"6c3bffef71bb0a90c9cbef3b7c0d4a1c7b4b8b76b80292a623afd9dac45d1c65\",\n      \"kty\": \"RSA\",\n      \"alg\": \"RS256\",\n      \"use\": \"sig\",\n      \"e\": \"AQAB\",\n      \"n\": \"pwVn...AA6Hw\"\n    }\n  ],\n  \"public_cert\": {\n    \"kid\": \"6c3bffef71bb0a90c9cbef3b7c0d4a1c7b4b8b76b80292a623afd9dac45d1c65\",\n    \"cert\": \"-----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- \"\n  },\n  \"public_certs\": [\n    {\n      \"kid\": \"1a1c3986a44ce6390be42ec772b031df8f433fdc71716db821dc0c39af3bce49\",\n      \"cert\": \"-----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- \"\n    },\n    {\n      \"kid\": \"6c3bffef71bb0a90c9cbef3b7c0d4a1c7b4b8b76b80292a623afd9dac45d1c65\",\n      \"cert\": \"-----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- \"\n    }\n  ]\n}\njs\n  import { jwtVerify, createRemoteJWKSet } from \"jose\";\n\nexport default {\n    async fetch(request, env, ctx) {\n      // Verify the POLICY_AUD environment variable is set\n      if (!env.POLICY_AUD) {\n        return new Response(\"Missing required audience\", {\n          status: 403,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      }\n\n// Get the JWT from the request headers\n      const token = request.headers.get(\"cf-access-jwt-assertion\");\n\n// Check if token exists\n      if (!token) {\n        return new Response(\"Missing required CF Access JWT\", {\n          status: 403,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      }\n\ntry {\n        // Create JWKS from your team domain\n        const JWKS = createRemoteJWKSet(\n          new URL(`${env.TEAM_DOMAIN}/cdn-cgi/access/certs`),\n        );\n\n// Verify the JWT\n        const { payload } = await jwtVerify(token, JWKS, {\n          issuer: env.TEAM_DOMAIN,\n          audience: env.POLICY_AUD,\n        });\n\n// Token is valid, proceed with your application logic\n        return new Response(`Hello ${payload.email || \"authenticated user\"}!`, {\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      } catch (error) {\n        // Token verification failed\n        const message = error instanceof Error ? error.message : \"Unknown error\";\n        return new Response(`Invalid token: ${message}`, {\n          status: 403,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      }\n    },\n  };\n  ts\n  import { jwtVerify, createRemoteJWKSet } from \"jose\";\n\ninterface Env {\n    POLICY_AUD: string;\n    TEAM_DOMAIN: string;\n  }\n\nexport default {\n    async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {\n      // Verify the POLICY_AUD environment variable is set\n      if (!env.POLICY_AUD) {\n        return new Response(\"Missing required audience\", {\n          status: 403,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      }\n\n// Get the JWT from the request headers\n      const token = request.headers.get(\"cf-access-jwt-assertion\");\n\n// Check if token exists\n      if (!token) {\n        return new Response(\"Missing required CF Access JWT\", {\n          status: 403,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      }\n\ntry {\n        // Create JWKS from your team domain\n        const JWKS = createRemoteJWKSet(\n          new URL(`${env.TEAM_DOMAIN}/cdn-cgi/access/certs`)\n        );\n\n// Verify the JWT\n        const { payload } = await jwtVerify(token, JWKS, {\n          issuer: env.TEAM_DOMAIN,\n          audience: env.POLICY_AUD,\n        });\n\n// Token is valid, proceed with your application logic\n        return new Response(\n          `Hello ${payload.email || \"authenticated user\"}!`,\n          {\n            headers: { \"Content-Type\": \"text/plain\" },\n          }\n        );\n      } catch (error) {\n        // Token verification failed\n        const message = error instanceof Error ? error.message : \"Unknown error\";\n        return new Response(`Invalid token: ${message}`, {\n          status: 403,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      }\n    },\n  };\n  go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"net/http\"\n\n\"github.com/coreos/go-oidc/v3/oidc\"\n)\n\nvar (\n    ctx        = context.TODO()\n    teamDomain = \"https://test.cloudflareaccess.com\"\n    certsURL   = fmt.Sprintf(\"%s/cdn-cgi/access/certs\", teamDomain)\n\n// The Application Audience (AUD) tag for your application\n    policyAUD = \"4714c1358e65fe4b408ad6d432a5f878f08194bdb4752441fd56faefa9b2b6f2\"\n\nconfig = &oidc.Config{\n        ClientID: policyAUD,\n    }\n    keySet   = oidc.NewRemoteKeySet(ctx, certsURL)\n    verifier = oidc.NewVerifier(teamDomain, keySet, config)\n)\n\n// VerifyToken is a middleware to verify a CF Access token\nfunc VerifyToken(next http.Handler) http.Handler {\n    fn := func(w http.ResponseWriter, r *http.Request) {\n        headers := r.Header\n\n// Make sure that the incoming request has our token header\n        //  Could also look in the cookies for CF_AUTHORIZATION\n        accessJWT := headers.Get(\"Cf-Access-Jwt-Assertion\")\n        if accessJWT == \"\" {\n            w.WriteHeader(http.StatusUnauthorized)\n            w.Write([]byte(\"No token on the request\"))\n            return\n        }\n\n// Verify the access token\n        ctx := r.Context()\n        _, err := verifier.Verify(ctx, accessJWT)\n        if err != nil {\n            w.WriteHeader(http.StatusUnauthorized)\n            w.Write([]byte(fmt.Sprintf(\"Invalid token: %s\", err.Error())))\n            return\n        }\n        next.ServeHTTP(w, r)\n    }\n    return http.HandlerFunc(fn)\n}\n\nfunc MainHandler() http.Handler {\n    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(\"welcome\"))\n    })\n}\n\nfunc main() {\n    http.Handle(\"/\", VerifyToken(MainHandler()))\n    http.ListenAndServe(\":3000\", nil)\n}\npython\nfrom flask import Flask, request\nimport requests\nimport jwt\nimport json\nimport os\napp = Flask(__name__)",
  "code_samples": [
    {
      "code": "Replace the `\\n` characters with actual newlines before passing to your customer. This can be accomplished by piping the output of the prior call to a tool like jq and perl, such as:",
      "language": "unknown"
    },
    {
      "code": "### 3. Customer obtains certificate\n\nYour customer will take the provided CSR and work with their CA to obtain a signed, publicly trusted certificate.\n\n### 4. Upload the certificate\n\nUpload the certificate and reference the ID that was provided when you generated the CSR.\n\nYou should replace newlines in the certificate with literal `\\n` characters, as illustrated above in the custom certificate upload example. After doing so, build the request body and provide the ID that was returned in a previous step.\n\nCloudflare only accepts publicly trusted certificates. If you attempt to upload a self-signed certificate, it will be rejected.",
      "language": "unknown"
    },
    {
      "code": "With the request body built, [create the custom hostname](https://developers.cloudflare.com/api/resources/custom_hostnames/methods/create/) with the supplied custom certificate. If you intend to use the certificate with multiple hostnames, make multiple API calls replacing the `hostname` field.\n\n***\n\n## Other actions\n\n### List all CSRs\n\nYou can request the (paginated) collection of all previously generated custom CSRs by making a `GET` request to `https://api.cloudflare.com/client/v4/zones/{zone_id}/custom_csrs`.\n\n### Delete a CSR\n\nDelete one or more of the CSRs to delete the underlying private key by making a `DELETE` request to `https://api.cloudflare.com/client/v4/zones/{zone_id}/custom_csrs/{csr_id}`.\n\nYou may delete a CSR provided there are no custom certificates using the private key that was generated for the CSR. If you attempt to delete a CSR whose private key is still in use, you will receive an error.\n\n</page>\n\n<page>\n---\ntitle: Manage custom certificates · Cloudflare for Platforms docs\ndescription: Learn how to manage custom certificates for your Cloudflare for\n  SaaS custom hostnames.\nlastUpdated: 2025-02-07T17:10:08.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/custom-certificates/uploading-certificates/\n  md: https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/custom-certificates/uploading-certificates/index.md\n---\n\nLearn how to manage custom certificates for your Cloudflare for SaaS custom hostnames. For use cases and limitations, refer to [custom certificates](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/custom-certificates/).\n\n## Upload certificates\n\nThis section describes the general process for uploading a custom certificate corresponding to one of the [supported types](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/custom-certificates/#limitations).\n\nNote\n\nIf you must support both RSA and ECDSA refer to [certificate packs](#use-certificate-packs-rsa-and-ecdsa) below.\n\n* Dashboard\n\n  To upload a custom certificate in the dashboard, select **Custom certificate** while [creating your custom hostname](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/create-custom-hostnames/).\n\n  For information about the **bundle method** options, refer to the [Cloudflare SSL/TLS documentation](https://developers.cloudflare.com/ssl/edge-certificates/custom-certificates/bundling-methodologies/).\n\n* API\n\n  The call below will upload a certificate for use with `app.example.com`.\n\n  Note that if you are using an ECC key generated by OpenSSL, you will need to first remove the `-----BEGIN EC PARAMETERS-----...-----END EC PARAMETERS-----` section of the file.\n\n  1. Update the file and build the payload",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "With the certificate and key saved to environment variables (using escaped newlines), build the payload:",
      "language": "unknown"
    },
    {
      "code": "1. Use a [`POST` request](https://developers.cloudflare.com/api/resources/custom_hostnames/methods/create/) to upload your certificate and key.\n\n  Note\n\n  The serial number returned is unique to the issuer, but not globally unique. Additionally, it is returned as a string, not an integer.\n\n## Use certificate packs: RSA and ECDSA\n\nA certificate pack allows you to upload up to one RSA and one ECDSA custom certificates to a custom hostname. This process is currently only supported via API.\n\nTo upload an RSA and ECDSA certificate to a custom hostname, set the `bundle_method` to `force` and define the `custom_cert_bundle` property when [creating a custom hostname via API](https://developers.cloudflare.com/api/resources/custom_hostnames/methods/create/).\n\nYou can also use `\"bundle_method\": \"force\"` and `custom_cert_bundle` with a `PATCH` request to the [Edit Custom Hostname](https://developers.cloudflare.com/api/resources/custom_hostnames/methods/edit/) endpoint.\n\n### Delete a custom certificate and private key\n\nUse the [Delete Single Certificate And Key For Custom Hostname](https://developers.cloudflare.com/api/resources/custom_hostnames/subresources/certificate_pack/subresources/certificates/methods/delete/) endpoint to remove one of the custom certificates and corresponding key from a certificate pack.\n\nYou cannot delete a certificate if it is the only remaining certificate in the pack.\n\n### Replace a custom certificate and private key\n\nTo replace a single custom certificate within a certificate pack that contains two bundled certificates, use the [Replace Custom Certificate And Custom Key In Custom Hostname](https://developers.cloudflare.com/api/resources/custom_hostnames/subresources/certificate_pack/subresources/certificates/methods/update/) endpoint.\n\nYou can only replace an RSA certificate with another RSA certificate, or an ECDSA certificate with another ECDSA certificate.\n\n***\n\n## Move to a Cloudflare certificate\n\nIf you want to switch from maintaining a custom certificate to using one issued by Cloudflare, you can migrate that certificate with zero downtime.\n\nSend a [`PATCH` request](https://developers.cloudflare.com/api/resources/custom_hostnames/methods/edit/) to your custom hostname with a value for the DCV `method`. As soon as the [certificate is validated](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/) and the [hostname is validated](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/hostname-validation/), Cloudflare will remove the old custom certificate and begin serving the new one.\n\n</page>\n\n<page>\n---\ntitle: Issue certificates · Cloudflare for Platforms docs\ndescription: Cloudflare automatically issues certificates when you create a custom hostname.\nlastUpdated: 2025-08-20T21:45:15.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/issue-certificates/\n  md: https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/issue-certificates/index.md\n---\n\nCloudflare automatically issues certificates when you [create a custom hostname](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/create-custom-hostnames/).\n\nNote\n\nThere are several required steps before a custom hostname and its certificate can become active. For more details, refer to our [Get started guide](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/getting-started/).\n\n## Certificate authorities\n\nIf you create the custom hostname via API, you can leave the `certificate_authority` parameter empty to set it to “default CA”. With this option, Cloudflare checks the CAA records before requesting the certificates, which helps ensure the certificates can be issued from the CA.\n\nRefer to [this certificate authorities reference page](https://developers.cloudflare.com/ssl/reference/certificate-authorities/) to learn more about the CAs that Cloudflare uses to issue SSL/TLS certificates.\n\n## Certificate details and compatibility\n\nFor each custom hostname, Cloudflare issues two certificates bundled in chains that maximize browser compatibility (unless you [upload custom certificates](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/custom-certificates/uploading-certificates/)).\n\nThe primary certificate uses a `P-256` key, is `SHA-2/ECDSA` signed, and will be presented to browsers that support elliptic curve cryptography (ECC). The secondary or fallback certificate uses an `RSA 2048-bit` key, is `SHA-2/RSA` signed, and will be presented to browsers that do not support ECC.\n\n</page>\n\n<page>\n---\ntitle: Validate certificates · Cloudflare for Platforms docs\ndescription: Learn which methods you should use to validate Cloudflare for SaaS\n  certificates.\nlastUpdated: 2025-08-20T21:45:15.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/\n  md: https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/index.md\n---\n\nBefore a certificate authority (CA) will issue a certificate for a domain, the requester must prove they have control over that domain. This process is known as domain control validation (DCV).\n\n\n\n## DCV situations\n\n### Non-wildcard certificates\n\nSpecific (non-wildcard) custom hostnames can use [HTTP based DCV](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/http/) for certificate renewals, as long as:\n\n* The hostname is pointing to the SaaS provider.\n* The hostname's traffic is proxying through the Cloudflare network.\n\nIf your custom hostnames do not meet these requirements, use another validation method.\n\n### Wildcard certificates\n\nWildcard custom hostnames require TXT-based validation. As the SaaS provider, you have two options for wildcard custom hostname certificate renewals:\n\n\n\n* [DCV Delegation](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/delegated-dcv/) (auto-issuance)\n* [Manual](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/txt/)\n\n### Minimize downtime\n\nIf you want to minimize downtime, explore one of the following methods to issue and deploy the certificate before onboarding your customers:\n\n* [Delegated DCV](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/delegated-dcv/): Place a one-time record at your authoritative DNS that allows Cloudflare to auto-renew all future certificate orders.\n* [TXT validation](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/txt/): Have your customers add a `TXT` record to their authoritative DNS.\n* [Manual HTTP validation](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/http/#http-manual): Add a `TXT` record at your origin.\n\n### Minimize customer effort\n\nIf you value simplicity and your customers can handle a few minutes of downtime, you can rely on Cloudflare [automatic HTTP validation](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/http/#http-automatic).\n\n## Potential issues\n\nTo avoid or solve potential issues, refer to our [troubleshooting guide](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/troubleshooting/).\n\n</page>\n\n<page>\n---\ntitle: Set up apex proxying · Cloudflare for Platforms docs\ndescription: To set up Cloudflare for SaaS for apex proxying - as opposed to the\n  normal setup - perform the following steps.\nlastUpdated: 2025-08-22T14:24:45.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/advanced-settings/apex-proxying/setup/\n  md: https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/advanced-settings/apex-proxying/setup/index.md\n---\n\nTo set up Cloudflare for SaaS for [apex proxying](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/advanced-settings/apex-proxying/) - as opposed to the [normal setup](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/getting-started/) - perform the following steps.\n\n***\n\n## Before you begin\n\nBefore you start creating custom hostnames:\n\n1. [Add](https://developers.cloudflare.com/fundamentals/manage-domains/add-site/) your zone to Cloudflare (this should be within the account associated with your IP prefixes).\n2. [Enable](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/enable/) Cloudflare for SaaS for your zone.\n3. Review the [Hostname prioritization guidelines](https://developers.cloudflare.com/ssl/reference/certificate-and-hostname-priority/#hostname-priority). Wildcard custom hostnames behave differently than an exact hostname match.\n4. (optional) Review the following documentation:\n\n* [API documentation](https://developers.cloudflare.com/fundamentals/api/) (if you have not worked with the Cloudflare API before).\n* [Certificate validation](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/).\n\n***\n\n## Initial setup\n\nWhen you first [enable](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/enable/) Cloudflare for SaaS, you need to perform a few steps prior to creating any custom hostnames.\n\n\n\n### 1. Get IP range\n\nWith apex proxying, you can either [bring your own IP range](https://developers.cloudflare.com/byoip/) or use a set of IP addresses provided by Cloudflare.\n\nFor more details on this step, reach out to your account team.\n\nWarning\n\nThese IP addresses are different than those associated with your Cloudflare zone.\n\n### 2. Create fallback origin\n\nThe fallback origin is where Cloudflare will route traffic sent to your custom hostnames (must be proxied).\n\nNote\n\nTo route custom hostnames to distinct origins, refer to [custom origin server](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/advanced-settings/custom-origin/).\n\nTo create your fallback origin:\n\n1. [Create](https://developers.cloudflare.com/dns/manage-dns-records/how-to/create-dns-records/#create-dns-records) a proxied `A`, `AAAA`, or `CNAME` record pointing to the IP address of your fallback origin (where Cloudflare will send custom hostname traffic).\n\n| **Type** | **Name** | **IPv4 address** | **Proxy status** |\n| - | - | - | - |\n| `A` | `proxy-fallback` | `192.0.2.1` | Proxied |\n\n1. Designate that record as your fallback origin.\n\n* Dashboard\n\n  1. In the Cloudflare dashboard, go to the **Custom Hostnames** page.\n\n     [Go to **Custom Hostnames**](https://dash.cloudflare.com/?to=/:account/:zone/ssl-tls/custom-hostnames)\n\n  2. For **Fallback Origin**, enter the hostname for your fallback origin.\n\n  3. Select **Add Fallback Origin**.\n\n* API\n\n  Using the hostname of the record you just created, [update the fallback origin value](https://developers.cloudflare.com/api/resources/custom_hostnames/subresources/fallback_origin/methods/update/).\n\n1. Once you have added the fallback origin, confirm that its status is **Active**.\n\nNote\n\nWhen Cloudflare marks your fallback origin as **Active**, that only reflects that we are ready to send traffic to that DNS record.\n\nYou need to make sure your DNS record is sending traffic to the correct origin location.\n\n***\n\n## Per-hostname setup\n\nYou need to perform the following steps for each custom hostname.\n\n### 1. Plan for validation\n\nBefore you create a hostname, you need to plan for:\n\n1. [Certificate validation](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/): Upon successful validation, the certificates are deployed to Cloudflare’s global network.\n2. [Hostname validation](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/hostname-validation/): Upon successful validation, Cloudflare proxies traffic for this hostname.\n\nYou must complete both these steps for the hostname to work as expected.\n\nNote\n\nDepending on which method you select for each of these options, additional steps might be required for you and your customers.\n\n### 2. Create custom hostname\n\nAfter planning for certification and hostname validation, you can create the custom hostname.\n\nZone name restriction\n\nDo not configure a custom hostname which matches the zone name. For example, if your SaaS zone is `example.com`, do not create a custom hostname named `example.com`.\n\nTo create a custom hostname:\n\n* Dashboard\n\n  1. In the Cloudflare dashboard, go to the **Custom Hostnames** page.\n\n     [Go to **Custom Hostnames**](https://dash.cloudflare.com/?to=/:account/:zone/ssl-tls/custom-hostnames)\n\n  2. Select **Add Custom Hostname**.\n\n  3. Add your customer's hostname `app.customer.com` and set the relevant options, including:\n\n     * The [minimum TLS version](https://developers.cloudflare.com/ssl/reference/protocols/).\n     * Defining whether you want to use a certificate provided by Cloudflare or [upload a custom certificate](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/custom-certificates/uploading-certificates/).\n     * Selecting the [certificate authority (CA)](https://developers.cloudflare.com/ssl/reference/certificate-authorities/) that will issue the certificate.\n     * Choosing the [validation method](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/).\n     * Whether you want to **Enable wildcard**, which adds a `*.<custom-hostname>` SAN to the custom hostname certificate. For more details, refer to [Hostname priority](https://developers.cloudflare.com/ssl/reference/certificate-and-hostname-priority/#hostname-priority).\n     * Choosing a value for [Custom origin server](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/advanced-settings/custom-origin/).\n\n  4. Select **Add Custom Hostname**.\n\n  Default behavior\n\n  When you create a custom hostname:\n\n  * If you issue a custom hostname certificate with wildcards enabled, you cannot customize TLS settings for these wildcard hostnames.\n  * If you do not specify the **Minimum TLS Version**, it defaults to the zone's Minimum TLS Version. You can still [edit this setting](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/enforce-mtls/#minimum-tls-version) after creation.\n\n* API\n\n  1. To create a custom hostname using the API, use the [Create Custom Hostname](https://developers.cloudflare.com/api/resources/custom_hostnames/methods/create/) endpoint.\n\n     * You can leave the `certificate_authority` parameter empty to set it to \"default CA\". With this option, Cloudflare checks the CAA records before requesting the certificates, which helps ensure the certificates can be issued from the CA.\n\n  2. For the newly created custom hostname, the `POST` response may not return the DCV validation token `validation_records`. It is recommended to make a second [`GET` command](https://developers.cloudflare.com/api/resources/custom_hostnames/methods/list/) (with a delay) to retrieve these details.\n\n  The response contains the complete definition of the new custom hostname.\n\n  Default behavior\n\n  When you create a custom hostname:\n\n  * If you issue a custom hostname certificate with wildcards enabled, you cannot customize TLS settings for these wildcard hostnames.\n  * If you do not specify the **Minimum TLS Version**, it defaults to the zone's Minimum TLS Version. You can still [edit this setting](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/enforce-mtls/#minimum-tls-version) after creation.\n\nNote\n\nFor each custom hostname, Cloudflare issues two certificates bundled in chains that maximize browser compatibility (unless you [upload custom certificates](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/custom-certificates/uploading-certificates/)).\n\nThe primary certificate uses a `P-256` key, is `SHA-2/ECDSA` signed, and will be presented to browsers that support elliptic curve cryptography (ECC). The secondary or fallback certificate uses an `RSA 2048-bit` key, is `SHA-2/RSA` signed, and will be presented to browsers that do not support ECC.\n\n### 3. Have customer create DNS record\n\nTo finish the custom hostname setup, your customer can set up either an A or CNAME record at their authoritative DNS provider.\n\nNote\n\nIf you want your customers to be able to use CNAME records, you will need to complete the [normal setup process](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/getting-started/) as well.\n\n#### A record\n\nIf your customer uses an A record at their authoritative DNS provider, they need to point their hostname to the IP prefix allocated for your account. You should also make sure that they point to the specific IPs that you want to use for apex proxying - if you have Static IPs or BYOIP, and your customer points to any of the IPs associated to your account, validation will run.\n\nWarning\n\nBefore your customer does this step, confirm that the hostname's **Certificate status** and **Hostname status** are both **Active**.\n\nIf not, confirm that you are using a method of [certificate](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/http/#http-automatic) or [hostnames](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/hostname-validation/realtime-validation/) validation that occurs after your customer adds their DNS record.\n\nYour customer's A record might look like the following:",
      "language": "unknown"
    },
    {
      "code": "#### CNAME record\n\nIf your customer uses a CNAME record at their authoritative DNS, they need to point their hostname to your [CNAME target](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/getting-started/#2-optional-create-cname-target) [1](#user-content-fn-1).\n\nWarning\n\nBefore your customer does this step, confirm that the hostname's **Certificate status** and **Hostname status** are both **Active**.\n\nIf not, confirm that you are using a method of [certificate](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/http/#http-automatic) or [hostnames](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/hostname-validation/realtime-validation/) validation that occurs after your customer adds their DNS record.\n\nYour customer's CNAME record might look like the following:",
      "language": "unknown"
    },
    {
      "code": "#### Service continuation\n\nIf your customer is also using Cloudflare for their domain, they should keep their DNS record pointing to your SaaS provider in place for as long as they want to use your service.\n\nFor more details, refer to [Remove custom hostnames](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/remove-custom-hostnames/).\n\n## Footnotes\n\n1. If you have [regional services](https://developers.cloudflare.com/data-localization/regional-services/) set up for your custom hostnames, Cloudflare always uses the processing region associated with your DNS target record (instead of the processing region of any [custom origins](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/start/advanced-settings/custom-origin/)).\n\n   [↩](#user-content-fnref-1)\n\n</page>\n\n<page>\n---\ntitle: CORS · Cloudflare One docs\ndescription: Cross-Origin Resource Sharing (CORS) is a mechanism that uses HTTP\n  headers to grant a web application running on one origin permission to reach\n  selected resources in a different origin. The web application executes a\n  cross-origin HTTP request when it requests a resource that has a different\n  origin from its own, including domain, protocol, or port.\nlastUpdated: 2025-10-28T17:49:06.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/cors/\n  md: https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/cors/index.md\n---\n\nCross-Origin Resource Sharing ([CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)) is a mechanism that uses HTTP headers to grant a web application running on one origin permission to reach selected resources in a different origin. The web application executes a cross-origin HTTP request when it requests a resource that has a different origin from its own, including domain, protocol, or port.\n\nFor a CORS request to reach a site protected by Access, the request must include a valid `CF-Authorization` cookie. This may require additional configuration depending on the type of request:\n\n* [Simple requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests) are sent directly to the origin, without triggering a preflight request. For configuration instructions, refer to [Allow simple requests](#allow-simple-requests).\n\n* [Preflighted requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#preflighted_requests) cause the browser to send an OPTIONS request before sending the actual request. The OPTIONS request checks which methods and headers are allowed by the origin. For configuration instructions, refer to [Allow preflighted requests](#allow-preflighted-requests).\n\nImportant\n\n* Do not troubleshoot CORS in Incognito mode, as this will cause disruptions with Access due to `CF-Authorization` being blocked as a third-party cookie on cross origin requests.\n\n* Safari, in particular Safari 13.1, handles cookies in a unique format. In some cases, this can cause CORS to fail. This will be dependent on Apple releasing a patch for handling cookies. This is known to impact macOS 10.15.4 when running Safari 13.1 (15609.1.20.111.8).\n\n## Allow simple requests\n\nIf you make a simple CORS request to an Access-protected domain and have not yet logged in, the request will return a `CORS error`. There are two ways you can resolve this error:\n\n* **Option 1** — [Log in and refresh the page](#authenticate-manually).\n* **Option 2** — [Create a Cloudflare Worker which automatically sends an authentication token](#send-authentication-token-with-cloudflare-worker). This method only works if both sites involved in the CORS exchange are behind Access.\n\n### Authenticate manually\n\n1. Visit the target domain in your browser. You will see the Access login page.\n2. Log in to the target domain. This generates a `CF-Authorization` cookie.\n3. Refresh the page that made the CORS request. The refresh resends the request with the newly generated cookie.\n\n## Allow preflighted requests\n\nIf you make a preflighted cross-origin request to an Access-protected domain, the OPTIONS request will return a `403` error. This error occurs regardless of whether you have logged in to the domain. This is because the browser never includes cookies with OPTIONS requests, by design. Cloudflare will therefore block the preflight request, causing the CORS exchange to fail.\n\nThere are three ways you can resolve this error:\n\n* **Option 1** — [Bypass OPTIONS requests to origin](#bypass-options-requests-to-origin).\n* **Option 2** — [Configure Cloudflare to respond to the OPTIONS request](#configure-response-to-preflight-requests).\n* **Option 3** — [Create a Cloudflare Worker which automatically sends an authentication token](#send-authentication-token-with-cloudflare-worker). This method only works if both sites involved in the CORS exchange are behind Access.\n\n### Bypass OPTIONS requests to origin\n\nYou can configure Cloudflare to send OPTIONS requests directly to your origin server. To bypass Access for OPTIONS requests:\n\n1. In [Cloudflare One](https://one.dash.cloudflare.com), go to **Access controls** > **Applications**.\n2. Locate the origin that will be receiving OPTIONS requests and select **Configure**.\n3. Go to **Advanced settings** > **Cross-Origin Resource Sharing (CORS) settings**.\n4. Turn on **Bypass options requests to origin**. This will remove all existing CORS settings for this application.\n\nIt is still important to enforce CORS for the Access JWT -- this option should only be used if you have CORS enforcement established in your origin server.\n\n### Configure response to preflight requests\n\nYou can configure Cloudflare to respond to the OPTIONS request on your behalf. The OPTIONS request never reaches your origin. After the preflight exchange resolves, the browser will then send the main request which does include the authentication cookie (assuming you have logged into the Access-protected domain).\n\nTo configure how Cloudflare responds to preflight requests:\n\n1. In [Cloudflare One](https://one.dash.cloudflare.com), go to **Access controls** > **Applications**.\n\n2. Locate the origin that will be receiving OPTIONS requests and select **Configure**.\n\n3. Go to **Advanced settings** > **Cross-Origin Resource Sharing (CORS) settings**.\n\n4. Configure these [CORS settings](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#the_http_response_headers) to match the response headers sent by your origin.\n\n   For example, if you have configured `api.mysite.com`to return the following headers:",
      "language": "unknown"
    },
    {
      "code": "then go to `api.mysite.com` in Access and configure **Access-Control-Allow-Origin**, **Access-Control-Allow-Credentials**, **Access-Control-Allow-Methods**, and **Access-Control-Allow-Headers**. ![Example CORS settings configuration in Cloudflare One](https://developers.cloudflare.com/_astro/CORS-settings.C9-43Ja__1c3pM6.webp)\n\n5. Select **Save application**.\n\n6. (Optional) You can check your configuration by sending an OPTIONS request to the origin with `curl`. For example,",
      "language": "unknown"
    },
    {
      "code": "should return a response similar to:",
      "language": "unknown"
    },
    {
      "code": "## Send authentication token with Cloudflare Worker\n\nIf you have two sites protected by Cloudflare Access, `example.com` and `api.mysite.com`, requests made between the two will be subject to CORS checks. Users who log in to `example.com` will be issued a cookie for `example.com`. When the user's browser requests `api.mysite.com`, Cloudflare Access looks for a cookie specific to `api.mysite.com`. The request will fail if the user has not already logged in to `api.mysite.com`.\n\nTo avoid having to log in twice, you can create a Cloudflare Worker that automatically sends authentication credentials to `api.mysite.com`.\n\n### Prerequisites\n\n* [Workers account](https://developers.cloudflare.com/workers/get-started/guide/)\n* `wrangler` installation\n* `example.com` and `api.mysite.com` domains [protected by Access](https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/)\n\n### 1. Generate a service token\n\nFollow [these instructions](https://developers.cloudflare.com/cloudflare-one/access-controls/service-credentials/service-tokens/) to generate a new Access service token. Copy the `Client ID` and `Client Secret` to a safe place, as you will use them in a later step.\n\n### 2. Add a Service Auth policy\n\n1. In [Cloudflare One](https://one.dash.cloudflare.com/), go to **Access controls** > **Applications**.\n\n2. Find your `api.mysite.com` application and select **Configure**.\n\n3. Select the **Policies** tab.\n\n4. Add the following policy:\n\n   | Action | Rule type | Selector |\n   | - | - | - |\n   | Service Auth | Include | Service Token |\n\n### 3. Create a new Worker\n\nOpen a terminal and run the following command:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "This will prompt you to install the [`create-cloudflare`](https://www.npmjs.com/package/create-cloudflare) package and lead you through setup.\n\nFor setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nGo to your project directory.",
      "language": "unknown"
    },
    {
      "code": "Open `/src/index.js` and delete the existing code and paste in the following example:",
      "language": "unknown"
    },
    {
      "code": "Then, deploy the Worker to your Cloudflare account:",
      "language": "unknown"
    },
    {
      "code": "### 4. Configure the Worker\n\n1. In the [Cloudflare dashboard](https://dash.cloudflare.com/), go to the **Workers & Pages** page.\n\n   [Go to **Workers & Pages**](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\n\n2. Select your newly created Worker.\n\n3. In the **Triggers** tab, go to **Routes** and add `example.com/api/*`. The Worker is placed on a subpath of `example.com` to avoid making a cross-origin request.\n\n4. In the **Settings** tab, select **Variables**.\n\n5. Under **Environment Variables**, add the following [secret variables](https://developers.cloudflare.com/workers/configuration/environment-variables/#add-environment-variables-via-the-dashboard):\n\n   * `CF_ACCESS_CLIENT_ID` = `<service token Client ID>`\n   * `CF_ACCESS_CLIENT_SECRET` = `<service token Client Secret>`\n\nThe Client ID and Client Secret are copied from your [service token](#1-generate-a-service-token).\n\n1. Enable the **Encrypt** option for each variable and select **Save**.\n\n### 5. Update HTTP request URLs\n\nModify your `example.com` application to send all requests to `example.com/api/` instead of `api.mysite.com`.\n\nHTTP requests should now work seamlessly between two different Access-protected domains. When a user logs in to `example.com`, the browser makes a request to the Worker instead of to `api.mysite.com`. The Worker adds the Access service token to the request headers and then forwards the request to `api.mysite.com`. Since the service token matches a Service Auth policy, the user no longer needs to log in to `api.mysite.com`.\n\n## Troubleshooting\n\nIn general, we recommend the following steps when troubleshooting CORS issues:\n\n1. Capture a HAR file with the issue described, as well as the JS console log output recorded simultaneously. This is because the HAR file alone will not give full visibility on the reason behind cross-origin issues.\n2. Ensure that the application has set `credentials: 'same-origin'` in all fetch or XHR requests.\n3. If you are using the [cross-origin setting](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) on script tags, these must be set to \"use-credentials\".\n\nCORS is failing on the same domain\n\nCORS checks do not occur on the same domain. If this error occurs, it is likely the request is being sent without the `CF-Authorization` cookie.\n\n</page>\n\n<page>\n---\ntitle: Renew certificates · Cloudflare for Platforms docs\ndescription: The exact method for certificate renewal depends on whether that\n  hostname is active1 and whether it is a wildcard certificate.\nlastUpdated: 2025-08-20T21:45:15.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/renew-certificates/\n  md: https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/renew-certificates/index.md\n---\n\nThe exact method for certificate renewal depends on whether that hostname is active[1](#user-content-fn-1) and whether it is a wildcard certificate.\n\nCustom hostnames certificates have a 90-day validity period and are available for renewal 30 days before their expiration.\n\n## Non-wildcard hostnames\n\nIf you are using a non-wildcard hostname and the hostname is active, Cloudflare will try to perform DCV automatically on the hostname's behalf by serving the [HTTP token](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/http/).\n\nIf the custom hostname is not active, then the custom hostname domain owner will need to add the TXT or HTTP DCV token for the new certificate to validate and issue. As the SaaS provider, you will be responsible for sharing this token with the custom hostname domain owner.\n\n## Wildcard hostnames\n\nWith wildcard hostnames, you cannot use HTTP. In this case, you will have to use TXT DCV tokens.\n\nThese tokens can be fetched through the API or the dashboard when the certificates are in a [pending validation](https://developers.cloudflare.com/ssl/reference/certificate-statuses/#new-certificates) state during custom hostname creation or during certificate renewals.\n\nIf your hostname is using another validation method, you will need to [update](https://developers.cloudflare.com/api/resources/custom_hostnames/methods/edit/) the `\"method\"` field in the SSL object to be `\"txt\"`.\n\nAfter this step, follow the normal steps for [TXT validation](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/txt/).\n\nNote\n\nTo allow Cloudflare to auto-renew all future certificate orders, consider [DCV delegation](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/security/certificate-management/issue-and-validate/validate-certificates/delegated-dcv/).\n\n## Footnotes\n\n1. Meaning Cloudflare could verify your customer's ownership of the hostname and the [hostname status](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/hostname-validation/validation-status/) is active. [↩](#user-content-fnref-1)\n\n</page>\n\n<page>\n---\ntitle: Application token · Cloudflare One docs\ndescription: Learn how Cloudflare Access uses application tokens to secure your\n  origin. Understand JWT structure and payloads.\nlastUpdated: 2025-10-24T20:47:24.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/application-token/\n  md: https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/application-token/index.md\n---\n\nCloudflare Access includes the application token with all authenticated requests to your origin. A typical JWT looks like this:\n\n`eyJhbGciOiJSUzI1NiIsImtpZCI6IjkzMzhhYmUxYmFmMmZlNDkyZjY0.eyJhdWQiOlsiOTdlMmFhZ TEyMDEyMWY5MDJkZjhiYzk5ZmMzNDU5MTNh.zLYsHmLEginAQUXdygQo08gLTExWNXsN4jBc6PKdB`\n\nAs shown above, the JWT contains three Base64-URL values separated by dots:\n\n* [Header](#header)\n* [Payload](#payload)\n* [Signature](#signature)\n\nUnless your application is connected to Access through Cloudflare Tunnel, your application must [validate the token](https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/validating-json/) to ensure the security of your origin. Validation of the header alone is not sufficient — the JWT and signature must be confirmed to avoid identity spoofing.\n\n## Header",
      "language": "unknown"
    },
    {
      "code": "* `alg` identifies the encoding algorithm.\n* `kid` identifies the key used to sign the token.\n* `typ` designates the token format.\n\n## Payload\n\nThe payload contains the actual claim and user information to pass to the application. Payload contents vary depending on whether you authenticated to the application with an identity provider or with a [service token](https://developers.cloudflare.com/cloudflare-one/access-controls/service-credentials/service-tokens/).\n\n### Identity-based authentication",
      "language": "unknown"
    },
    {
      "code": "| Field | Description |\n| - | - |\n| aud | [Application audience (AUD) tag](https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/validating-json/#get-your-aud-tag) of the Access application. |\n| email | The email address of the authenticated user, verified by the identity provider. |\n| exp | The expiration timestamp for the token (Unix time). |\n| iat | The issuance timestamp for the token (Unix time). |\n| nbf | The not-before timestamp for the token (Unix time), used to check if the token was received before it should be used. |\n| iss | The Cloudflare Access domain URL for the application. |\n| type | The type of Access token (`app` for application token or `org` for global session token). |\n| identity\\_nonce | A cache key used to get the [user's identity](#user-identity). |\n| sub | The ID of the user. This value is unique to an email address per account. The user would get a different `sub` if they are [removed](https://developers.cloudflare.com/cloudflare-one/team-and-resources/users/seat-management/#remove-a-user) and re-added to your Zero Trust organization, or if they log into a different organization. |\n| country | The country where the user authenticated from. |\n\n#### Custom SAML attributes and OIDC claims\n\nAccess allows you to add custom SAML attributes and OIDC claims to your JWT for enhanced verification, if supported by your identity provider. This is configured when you setup your [SAML](https://developers.cloudflare.com/cloudflare-one/integrations/identity-providers/generic-saml/) or [OIDC](https://developers.cloudflare.com/cloudflare-one/integrations/identity-providers/generic-oidc/) provider.\n\n#### User identity\n\nUser identity is useful for checking application permissions. For example, your application can validate that a given user is a member of an Okta or Microsoft Entra ID group such as `Finance-Team`.\n\nDue to cookie size limits and bandwidth considerations, the application token only contains a subset of the user's identity. To get the user's full identity, send the `CF_Authorization` cookie to `https://<your-team-name>.cloudflareaccess.com/cdn-cgi/access/get-identity`. Your request should be structured as follows:",
      "language": "unknown"
    },
    {
      "code": "Access will return a JSON structure containing the following data:\n\n| Field | Description |\n| - | - |\n| email | The email address of the user. |\n| idp | Data from your identity provider. |\n| geo | The country where the user authenticated from. |\n| user\\_uuid | The ID of the user. |\n| devicePosture | The device posture attributes. |\n| account\\_id | The account ID for your organization. |\n| iat | The timestamp indicating when the user logged in. |\n| ip | The IP address of the user. |\n| auth\\_status | The status if authenticating with mTLS. |\n| common\\_name | The common name on the mTLS client certificate. |\n| service\\_token\\_id | The Client ID of the service token used for authentication. |\n| service\\_token\\_status | True if authentication was through a service token instead of an IdP. |\n| is\\_warp | True if the user enabled WARP. |\n| is\\_gateway | True if the user enabled WARP and authenticated to a Zero Trust team. |\n| gateway\\_account\\_id | An ID generated by the WARP client when authenticated to a Zero Trust team. |\n| device\\_id | The ID of the device used for authentication. |\n| version | The version of the `get-identity` object. |\n| device\\_sessions | A list of all sessions initiated by the user. |\n\n### Service token authentication",
      "language": "unknown"
    },
    {
      "code": "| Field | Description |\n| - | - |\n| type | The type of Access token (`app` for application token or `org` for global session token). |\n| aud | The [application audience (AUD) tag](https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/validating-json/#get-your-aud-tag) of the Access application. |\n| exp | The expiration timestamp of the JWT (Unix time). |\n| iss | The Cloudflare Access domain URL for the application. |\n| common\\_name | The Client ID of the service token (`CF-Access-Client-Id`). |\n| iat | The issuance timestamp of the JWT (Unix time). |\n| sub | Contains an empty string when authentication was through a service token. |\n\n## Signature\n\nCloudflare generates the signature by signing the encoded header and payload using the SHA-256 algorithm (RS256). In RS256, a private key signs the JWTs and a separate [public key](https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/validating-json/#access-signing-keys) verifies the signature.\n\nFor more information on JWTs, refer to [jwt.io](https://jwt.io/).\n\n</page>\n\n<page>\n---\ntitle: Validate JWTs · Cloudflare One docs\ndescription: When Cloudflare sends a request to your origin, the request will\n  include an application token as a Cf-Access-Jwt-Assertion request header.\n  Requests made through a browser will also pass the token as a CF_Authorization\n  cookie.\nlastUpdated: 2025-12-04T17:03:58.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/validating-json/\n  md: https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/validating-json/index.md\n---\n\nWhen Cloudflare sends a request to your origin, the request will include an [application token](https://developers.cloudflare.com/cloudflare-one/access-controls/applications/http-apps/authorization-cookie/application-token/) as a `Cf-Access-Jwt-Assertion` request header. Requests made through a browser will also pass the token as a `CF_Authorization` cookie.\n\nCloudflare signs the token with a key pair unique to your account. You should validate the token with your public key to ensure that the request came from Access and not a malicious third party. We recommend validating the `Cf-Access-Jwt-Assertion` header instead of the `CF_Authorization` cookie, since the cookie is not guaranteed to be passed.\n\n## Access signing keys\n\nThe public key for the signing key pair is located at `https://<your-team-name>.cloudflareaccess.com/cdn-cgi/access/certs`, where `<your-team-name>` is your Cloudflare One team name.\n\nBy default, Access rotates the signing key every 6 weeks. This means you will need to programmatically or manually update your keys as they rotate. Previous keys remain valid for 7 days after rotation to allow time for you to make the update.\n\nYou can also manually rotate the key using the [API](https://developers.cloudflare.com/api/resources/zero_trust/subresources/access/subresources/keys/methods/rotate/). This can be done for testing or security purposes.\n\nAs shown in the example below, `https://<your-team-name>.cloudflareaccess.com/cdn-cgi/access/certs` contains two public keys: the current key used to sign all new tokens, and the previous key that has been rotated out.\n\n* `keys`: both keys in JWK format\n* `public_cert`: current key in PEM format\n* `public_certs`: both keys in PEM format",
      "language": "unknown"
    },
    {
      "code": "Avoid key rotation issues\n\n* Validate tokens using the external endpoint rather than saving the public key as a hard-coded value.\n* Do not fetch the current key from `public_cert`, since your origin may inadvertently read an expired value from an outdated cache. Instead, match the `kid` value in the JWT to the corresponding certificate in `public_certs`.\n\n## Verify the JWT manually\n\nTo verify the token manually:\n\n1. Copy the JWT from the `Cf-Access-Jwt-Assertion` request header.\n\n2. Go to [jwt.io](https://jwt.io/).\n\n3. Select the RS256 algorithm.\n\n4. Paste the JWT into the **Encoded** box.\n\n5. In the **Payload** box, ensure that the `iss` field points to your team domain (`https://<your-team-name>.cloudflareaccess.com`). `jwt.io` uses the `iss` value to fetch the public key for token validation.\n\n6. Ensure that the page says **Signature Verified**.\n\nYou can now trust that this request was sent by Access.\n\n## Programmatic verification\n\nYou can run an automated script on your origin server to validate incoming requests. The provided sample code gets the application token from a request and checks its signature against your public key. You will need to insert your own team domain and Application Audience (AUD) tag into the sample code.\n\n### Get your AUD tag\n\nCloudflare Access assigns a unique AUD tag to each application. The `aud` claim in the token payload specifies which application the JWT is valid for.\n\nTo get the AUD tag:\n\n1. In [Cloudflare One](https://one.dash.cloudflare.com/), go to **Access controls** > **Applications**.\n2. Select **Configure** for your application.\n3. From the **Basic information** tab, copy the **Application Audience (AUD) Tag**.\n\nYou can now paste the AUD tag into your token validation script. The AUD tag will never change unless you delete or recreate the Access application.\n\n### Cloudflare Workers example\n\nWhen Cloudflare Access is in front of your [Worker](https://developers.cloudflare.com/workers), your Worker still needs to validate the JWT that Cloudflare Access adds to the `Cf-Access-Jwt-Assertion` header on the incoming request.\n\nThe following code will validate the JWT using the [jose NPM package](https://www.npmjs.com/package/jose):\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "#### Required environment variables\n\nAdd these [environment variables](https://developers.cloudflare.com/workers/configuration/environment-variables/) to your Worker:\n\n* `POLICY_AUD`: Your application's [AUD tag](#get-your-aud-tag)\n* `TEAM_DOMAIN`: `https://<your-team-name>.cloudflareaccess.com`, where `<your-team-name>` is replaced with your actual team name.\n\nYou can set these variables by adding them to your Worker's [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/), or via the Cloudflare dashboard under **Workers & Pages** > **your-worker** > **Settings** > **Environment Variables**.\n\n### Golang example",
      "language": "unknown"
    },
    {
      "code": "### Python example\n\n`pip` install the following:\n\n* flask\n* requests\n* PyJWT\n* cryptography",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h3",
      "text": "3. Customer obtains certificate",
      "id": "3.-customer-obtains-certificate"
    },
    {
      "level": "h3",
      "text": "4. Upload the certificate",
      "id": "4.-upload-the-certificate"
    },
    {
      "level": "h2",
      "text": "Other actions",
      "id": "other-actions"
    },
    {
      "level": "h3",
      "text": "List all CSRs",
      "id": "list-all-csrs"
    },
    {
      "level": "h3",
      "text": "Delete a CSR",
      "id": "delete-a-csr"
    },
    {
      "level": "h2",
      "text": "Upload certificates",
      "id": "upload-certificates"
    },
    {
      "level": "h2",
      "text": "Use certificate packs: RSA and ECDSA",
      "id": "use-certificate-packs:-rsa-and-ecdsa"
    },
    {
      "level": "h3",
      "text": "Delete a custom certificate and private key",
      "id": "delete-a-custom-certificate-and-private-key"
    },
    {
      "level": "h3",
      "text": "Replace a custom certificate and private key",
      "id": "replace-a-custom-certificate-and-private-key"
    },
    {
      "level": "h2",
      "text": "Move to a Cloudflare certificate",
      "id": "move-to-a-cloudflare-certificate"
    },
    {
      "level": "h2",
      "text": "Certificate authorities",
      "id": "certificate-authorities"
    },
    {
      "level": "h2",
      "text": "Certificate details and compatibility",
      "id": "certificate-details-and-compatibility"
    },
    {
      "level": "h2",
      "text": "DCV situations",
      "id": "dcv-situations"
    },
    {
      "level": "h3",
      "text": "Non-wildcard certificates",
      "id": "non-wildcard-certificates"
    },
    {
      "level": "h3",
      "text": "Wildcard certificates",
      "id": "wildcard-certificates"
    },
    {
      "level": "h3",
      "text": "Minimize downtime",
      "id": "minimize-downtime"
    },
    {
      "level": "h3",
      "text": "Minimize customer effort",
      "id": "minimize-customer-effort"
    },
    {
      "level": "h2",
      "text": "Potential issues",
      "id": "potential-issues"
    },
    {
      "level": "h2",
      "text": "Before you begin",
      "id": "before-you-begin"
    },
    {
      "level": "h2",
      "text": "Initial setup",
      "id": "initial-setup"
    },
    {
      "level": "h3",
      "text": "1. Get IP range",
      "id": "1.-get-ip-range"
    },
    {
      "level": "h3",
      "text": "2. Create fallback origin",
      "id": "2.-create-fallback-origin"
    },
    {
      "level": "h2",
      "text": "Per-hostname setup",
      "id": "per-hostname-setup"
    },
    {
      "level": "h3",
      "text": "1. Plan for validation",
      "id": "1.-plan-for-validation"
    },
    {
      "level": "h3",
      "text": "2. Create custom hostname",
      "id": "2.-create-custom-hostname"
    },
    {
      "level": "h3",
      "text": "3. Have customer create DNS record",
      "id": "3.-have-customer-create-dns-record"
    },
    {
      "level": "h2",
      "text": "Footnotes",
      "id": "footnotes"
    },
    {
      "level": "h2",
      "text": "Allow simple requests",
      "id": "allow-simple-requests"
    },
    {
      "level": "h3",
      "text": "Authenticate manually",
      "id": "authenticate-manually"
    },
    {
      "level": "h2",
      "text": "Allow preflighted requests",
      "id": "allow-preflighted-requests"
    },
    {
      "level": "h3",
      "text": "Bypass OPTIONS requests to origin",
      "id": "bypass-options-requests-to-origin"
    },
    {
      "level": "h3",
      "text": "Configure response to preflight requests",
      "id": "configure-response-to-preflight-requests"
    },
    {
      "level": "h2",
      "text": "Send authentication token with Cloudflare Worker",
      "id": "send-authentication-token-with-cloudflare-worker"
    },
    {
      "level": "h3",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h3",
      "text": "1. Generate a service token",
      "id": "1.-generate-a-service-token"
    },
    {
      "level": "h3",
      "text": "2. Add a Service Auth policy",
      "id": "2.-add-a-service-auth-policy"
    },
    {
      "level": "h3",
      "text": "3. Create a new Worker",
      "id": "3.-create-a-new-worker"
    },
    {
      "level": "h3",
      "text": "4. Configure the Worker",
      "id": "4.-configure-the-worker"
    },
    {
      "level": "h3",
      "text": "5. Update HTTP request URLs",
      "id": "5.-update-http-request-urls"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h2",
      "text": "Non-wildcard hostnames",
      "id": "non-wildcard-hostnames"
    },
    {
      "level": "h2",
      "text": "Wildcard hostnames",
      "id": "wildcard-hostnames"
    },
    {
      "level": "h2",
      "text": "Footnotes",
      "id": "footnotes"
    },
    {
      "level": "h2",
      "text": "Header",
      "id": "header"
    },
    {
      "level": "h2",
      "text": "Payload",
      "id": "payload"
    },
    {
      "level": "h3",
      "text": "Identity-based authentication",
      "id": "identity-based-authentication"
    },
    {
      "level": "h3",
      "text": "Service token authentication",
      "id": "service-token-authentication"
    },
    {
      "level": "h2",
      "text": "Signature",
      "id": "signature"
    },
    {
      "level": "h2",
      "text": "Access signing keys",
      "id": "access-signing-keys"
    },
    {
      "level": "h2",
      "text": "Verify the JWT manually",
      "id": "verify-the-jwt-manually"
    },
    {
      "level": "h2",
      "text": "Programmatic verification",
      "id": "programmatic-verification"
    },
    {
      "level": "h3",
      "text": "Get your AUD tag",
      "id": "get-your-aud-tag"
    },
    {
      "level": "h3",
      "text": "Cloudflare Workers example",
      "id": "cloudflare-workers-example"
    },
    {
      "level": "h3",
      "text": "Golang example",
      "id": "golang-example"
    },
    {
      "level": "h3",
      "text": "Python example",
      "id": "python-example"
    }
  ],
  "url": "llms-txt#response:",
  "links": []
}