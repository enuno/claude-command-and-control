{
  "title": "This is a comment",
  "content": "/secure/page\n  X-Frame-Options: DENY\n  X-Content-Type-Options: nosniff\n  Referrer-Policy: no-referrer\n\n/static/*\n  Access-Control-Allow-Origin: *\n  X-Robots-Tag: nosnippet\n\nhttps://myworker.mysubdomain.workers.dev/*\n  X-Robots-Tag: noindex\ntxt\n/*\n  Content-Security-Policy: default-src 'self';\n\n/*.jpg\n  ! Content-Security-Policy\ntxt\n/movies/:title\n  x-movie-name: You are watching \":title\"\ntxt\n/*\n  Access-Control-Allow-Origin: *\ntxt\nhttps://:worker.:subdomain.workers.dev/*\n  Access-Control-Allow-Origin: https://*-:worker.:subdomain.workers.dev/\ntxt\nhttps://:version.:subdomain.workers.dev/*\n  X-Robots-Tag: noindex\ntxt\n/static/*\n  Cache-Control: public, max-age=31556952, immutable\ntxt\n/app/*\n  X-Frame-Options: DENY\n  X-Content-Type-Options: nosniff\n  Referrer-Policy: no-referrer\n  Permissions-Policy: document-domain=()\n  Content-Security-Policy: script-src 'self'; frame-ancestors 'none';\ntxt\n[source] [destination] [code?]\ntxt\n/home301 / 301\n/home302 / 302\n/querystrings /?query=string 301\n/twitch https://twitch.tv\n/trailing /trailing/ 301\n/notrailing/ /nottrailing 301\n/page/ /page2/#fragment 301\n/blog/* https://blog.my.domain/:splat\n/products/:code/:name /products?code=:code&name=:name\ntxt\n/movies/:title /media/:title\nplaintext\n/a /b 200\n/b /c 200\ntxt\n/about/faq/*\n  Link: </about/faqs>; rel=\"canonical\"\nts\nimport assert from \"node:assert\";\nimport test, { after, before, describe } from \"node:test\";\nimport { unstable_startWorker } from \"wrangler\";\n\ndescribe(\"worker\", () => {\n  let worker;\n\nbefore(async () => {\n    worker = await unstable_startWorker({ config: \"wrangler.json\" });\n  });\n\ntest(\"hello world\", async () => {\n    assert.strictEqual(\n      await (await worker.fetch(\"http://example.com\")).text(),\n      \"Hello world\",\n    );\n  });\n\nafter(async () => {\n    await worker.dispose();\n  });\n});\njson\n{\n  \"name\": \"cloudflare-vite-get-started\",\n  \"private\": true,\n  \"version\": \"0.0.0\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite dev\",\n    \"build\": \"vite build\",\n    \"preview\": \"npm run build && vite preview\",\n    \"deploy\": \"npm run build && wrangler deploy\"\n  }\n}\nsh\n  npm i -D vite @cloudflare/vite-plugin wrangler\n  sh\n  yarn add -D vite @cloudflare/vite-plugin wrangler\n  sh\n  pnpm add -D vite @cloudflare/vite-plugin wrangler\n  ts\nimport { defineConfig } from \"vite\";\nimport { cloudflare } from \"@cloudflare/vite-plugin\";\n\nexport default defineConfig({\n  plugins: [cloudflare()],\n});\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"cloudflare-vite-get-started\",\n    \"compatibility_date\": \"2025-04-03\",\n    \"main\": \"./src/index.ts\"\n  }\n  toml\n  name = \"cloudflare-vite-get-started\"\n  compatibility_date = \"2025-04-03\"\n  main = \"./src/index.ts\"\n  ts\nexport default {\n  fetch() {\n    return new Response(`Running in ${navigator.userAgent}!`);\n  },\n};\nsh\n  npm create vite@latest -- cloudflare-vite-tutorial --template react-ts\n  sh\n  yarn create vite cloudflare-vite-tutorial --template react-ts\n  sh\n  pnpm create vite@latest cloudflare-vite-tutorial --template react-ts\n  sh\n  npm i -D @cloudflare/vite-plugin wrangler\n  sh\n  yarn add -D @cloudflare/vite-plugin wrangler\n  sh\n  pnpm add -D @cloudflare/vite-plugin wrangler\n  ts\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport { cloudflare } from \"@cloudflare/vite-plugin\";\n\nexport default defineConfig({\n  plugins: [react(), cloudflare()],\n});\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"cloudflare-vite-tutorial\",\n    \"compatibility_date\": \"2025-04-03\",\n    \"assets\": {\n      \"not_found_handling\": \"single-page-application\"\n    }\n  }\n  toml\n  name = \"cloudflare-vite-tutorial\"\n  compatibility_date = \"2025-04-03\"\n  assets = { not_found_handling = \"single-page-application\" }\n  txt\n.wrangler\n.dev.vars*\nsh\n  npm i -D @cloudflare/workers-types\n  sh\n  yarn add -D @cloudflare/workers-types\n  sh\n  pnpm add -D @cloudflare/workers-types\n  jsonc\n{\n  \"extends\": \"./tsconfig.node.json\",\n  \"compilerOptions\": {\n    \"tsBuildInfoFile\": \"./node_modules/.tmp/tsconfig.worker.tsbuildinfo\",\n    \"types\": [\"@cloudflare/workers-types/2023-07-01\", \"vite/client\"],\n  },\n  \"include\": [\"worker\"],\n}\njsonc\n{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./tsconfig.app.json\" },\n    { \"path\": \"./tsconfig.node.json\" },\n    { \"path\": \"./tsconfig.worker.json\" },\n  ],\n}\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"cloudflare-vite-tutorial\",\n    \"compatibility_date\": \"2025-04-03\",\n    \"assets\": {\n      \"not_found_handling\": \"single-page-application\"\n    },\n    \"main\": \"./worker/index.ts\"\n  }\n  toml\n  name = \"cloudflare-vite-tutorial\"\n  compatibility_date = \"2025-04-03\"\n  assets = { not_found_handling = \"single-page-application\" }\n  main = \"./worker/index.ts\"\n  ts\nexport default {\n  fetch(request) {\n    const url = new URL(request.url);\n\nif (url.pathname.startsWith(\"/api/\")) {\n      return Response.json({\n        name: \"Cloudflare\",\n      });\n    }\n\nreturn new Response(null, { status: 404 });\n  },\n} satisfies ExportedHandler;\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"name\": \"cloudflare-vite-tutorial\",\n    \"compatibility_date\": \"2025-04-03\",\n    \"assets\": {\n      \"not_found_handling\": \"single-page-application\",\n      \"run_worker_first\": [\n        \"/api/*\"\n      ]\n    },\n    \"main\": \"./worker/index.ts\"\n  }\n  toml\n  name = \"cloudflare-vite-tutorial\"\n  compatibility_date = \"2025-04-03\"\n  assets = { not_found_handling = \"single-page-application\", run_worker_first = [\"/api/*\"] }\n  main = \"./worker/index.ts\"\n  tsx\nimport { useState } from \"react\";\nimport reactLogo from \"./assets/react.svg\";\nimport viteLogo from \"/vite.svg\";\nimport \"./App.css\";\n\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState(\"unknown\");\n\nreturn (\n    <>\n16 collapsed lines\n      <div>\n        <a href=\"https://vite.dev\" target=\"_blank\">\n          <img src={viteLogo} className=\"logo\" alt=\"Vite logo\" />\n        </a>\n        <a href=\"https://react.dev\" target=\"_blank\">\n          <img src={reactLogo} className=\"logo react\" alt=\"React logo\" />\n        </a>\n      </div>\n      <h1>Vite + React</h1>\n      <div className=\"card\">\n        <button\n          onClick={() => setCount((count) => count + 1)}\n          aria-label=\"increment\"\n        >\n          count is {count}\n        </button>\n        <p>\n          Edit <code>src/App.tsx</code> and save to test HMR\n        </p>\n      </div>\n      <div className=\"card\">\n        <button\n          onClick={() => {\n            fetch(\"/api/\")\n              .then((res) => res.json() as Promise<{ name: string }>)\n              .then((data) => setName(data.name));\n          }}\n          aria-label=\"get name\"\n        >\n          Name from API is: {name}\n        </button>\n        <p>\n          Edit <code>api/index.ts</code> to change the name\n        </p>\n      </div>\n      <p className=\"read-the-docs\">\n        Click on the Vite and React logos to learn more\n      </p>\n    </>\n  );\n}\n\nexport default App;\nsh\nnpm run build\nsh\nnpm run preview\nsh\nnpm exec wrangler deploy\nsh\n  npm create cloudflare@latest -- todos\n  sh\n  yarn create cloudflare todos\n  sh\n  pnpm create cloudflare@latest todos\n  sh\ncd todos\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello World!\");\n  },\n};\nsh\nnpx wrangler kv namespace create \"TODOS\" --preview\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"kv_namespaces\": [\n      {\n        \"binding\": \"TODOS\",\n        \"id\": \"<YOUR_ID>\",\n        \"preview_id\": \"<YOUR_PREVIEW_ID>\"\n      }\n    ]\n  }\n  toml\n  kv_namespaces = [\n    {binding = \"TODOS\", id = \"<YOUR_ID>\", preview_id = \"<YOUR_PREVIEW_ID>\"}\n  ]\n  js\nexport default {\n  async fetch(request, env, ctx) {\n    const defaultData = {\n      todos: [\n        {\n          id: 1,\n          name: \"Finish the Cloudflare Workers blog post\",\n          completed: false,\n        },\n      ],\n    };\n    await env.TODOS.put(\"data\", JSON.stringify(defaultData));\n    return new Response(\"Hello World!\");\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    const defaultData = {\n      todos: [\n        {\n          id: 1,\n          name: \"Finish the Cloudflare Workers blog post\",\n          completed: false,\n        },\n      ],\n    };\n    const setCache = (data) => env.TODOS.put(\"data\", data);\n    const getCache = () => env.TODOS.get(\"data\");\n\nconst cache = await getCache();\n    if (!cache) {\n      await setCache(JSON.stringify(defaultData));\n      data = defaultData;\n    } else {\n      data = JSON.parse(cache);\n    }\n\nreturn new Response(JSON.stringify(data));\n  },\n};\njs\nconst html = `<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <title>Todos</title>\n  </head>\n  <body>\n    <h1>Todos</h1>\n  </body>\n</html>\n`;\n\nasync fetch (request, env, ctx) {\n  // previous code\n  return new Response(html, {\n      headers: {\n        'Content-Type': 'text/html'\n      }\n    });\n}\njs\nconst html = `<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <title>Todos</title>\n  </head>\n  <body>\n    <h1>Todos</h1>\n    <div id=\"todos\"></div>\n  </body>\n</html>\n`;\njs\nconst html = `<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\" />\n    <title>Todos</title>\n  </head>\n  <body>\n    <h1>Todos</h1>\n    <div id=\"todos\"></div>\n  </body>\n  <script>\n    window.todos = []\n    var todoContainer = document.querySelector(\"#todos\")\n    window.todos.forEach(todo => {\n      var el = document.createElement(\"div\")\n      el.textContent = todo.name\n      todoContainer.appendChild(el)\n    })\n  </script>\n</html>\n`;\njs\nconst html = (todos) => `\n<!doctype html>\n<html>\n  <!-- existing content -->\n  <script>\n    window.todos = ${todos}\n    var todoContainer = document.querySelector(\"#todos\")\n    // ...\n  <script>\n</html>\n`;\njs\nasync fetch (request, env, ctx) {\n  const body = html(JSON.stringify(data.todos).replace(/</g, '\\\\u003c'));\n  return new Response(body, {\n    headers: { 'Content-Type': 'text/html' },\n  });\n}\njs\nexport default {\n  async fetch(request, env, ctx) {\n    const setCache = (data) => env.TODOS.put(\"data\", data);\n\nif (request.method === \"PUT\") {\n      const body = await request.text();\n      try {\n        JSON.parse(body);\n        await setCache(body);\n        return new Response(body, { status: 200 });\n      } catch (err) {\n        return new Response(err, { status: 500 });\n      }\n    }\n    // previous code\n  },\n};\njs\nconst html = (todos) => `\n<!doctype html>\n<html>\n  <!-- existing content -->\n  <div>\n    <input type=\"text\" name=\"name\" placeholder=\"A new todo\"></input>\n    <button id=\"create\">Create</button>\n  </div>\n  <!-- existing script -->\n</html>\n`;\njs\nconst html = (todos) => `\n<!doctype html>\n<html>\n  <!-- existing content -->\n  <script>\n    // Existing JavaScript code\n\nvar createTodo = function() {\n      var input = document.querySelector(\"input[name=name]\")\n      if (input.value.length) {\n        todos = [].concat(todos, {\n          id: todos.length + 1,\n          name: input.value,\n          completed: false,\n        })\n        fetch(\"/\", {\n          method: \"PUT\",\n          body: JSON.stringify({ todos: todos }),\n        })\n      }\n    }\n\ndocument.querySelector(\"#create\").addEventListener(\"click\", createTodo)\n  </script>\n</html>\n`;\njs\nconst html = (todos) => `\n<!doctype html>\n<html>\n  <!-- existing content -->\n  <script>\n    var populateTodos = function() {\n      var todoContainer = document.querySelector(\"#todos\")\n      todoContainer.innerHTML = null\n      window.todos.forEach(todo => {\n        var el = document.createElement(\"div\")\n        el.textContent = todo.name\n        todoContainer.appendChild(el)\n      })\n    }\n\nvar createTodo = function() {\n      var input = document.querySelector(\"input[name=name]\")\n      if (input.value.length) {\n        todos = [].concat(todos, {\n          id: todos.length + 1,\n          name: input.value,\n          completed: false,\n        })\n        fetch(\"/\", {\n          method: \"PUT\",\n          body: JSON.stringify({ todos: todos }),\n        })\n        populateTodos()\n        input.value = \"\"\n      }\n    }\n\ndocument.querySelector(\"#create\").addEventListener(\"click\", createTodo)\n  </script>\n`;\njs\nconst html = (todos) => `\n<!doctype html>\n<html>\n  <!-- existing content -->\n  <script>\n    var populateTodos = function() {\n      var todoContainer = document.querySelector(\"#todos\")\n      todoContainer.innerHTML = null\n      window.todos.forEach(todo => {\n        var el = document.createElement(\"div\")\n        var name = document.createElement(\"span\")\n        name.textContent = todo.name\n        el.appendChild(name)\n        todoContainer.appendChild(el)\n      })\n    }\n  </script>\n`;\njs\nconst html = (todos) => `\n<!doctype html>\n<html>\n  <!-- existing content -->\n  <script>\n    var populateTodos = function() {\n      var todoContainer = document.querySelector(\"#todos\")\n      todoContainer.innerHTML = null\n      window.todos.forEach(todo => {\n        var el = document.createElement(\"div\")\n        el.dataset.todo = todo.id\n\nvar name = document.createElement(\"span\")\n        name.textContent = todo.name\n\nel.appendChild(name)\n        todoContainer.appendChild(el)\n      })\n    }\n  </script>\n`;\nhtml\n<div data-todo=\"1\"></div>\n<div data-todo=\"2\"></div>\njs\nconst html = (todos) => `\n<!doctype html>\n<html>\n  <!-- existing content -->\n  <script>\n    window.todos.forEach(todo => {\n      var el = document.createElement(\"div\")\n      el.dataset.todo = todo.id\n\nvar name = document.createElement(\"span\")\n      name.textContent = todo.name\n\nvar checkbox = document.createElement(\"input\")\n      checkbox.type = \"checkbox\"\n      checkbox.checked = todo.completed ? 1 : 0\n\nel.appendChild(checkbox)\n      el.appendChild(name)\n      todoContainer.appendChild(el)\n    })\n  </script>\n`;\njs\nconst html = (todos) => `\n<!doctype html>\n<html>\n  <!-- existing content -->\n  <script>\n    var populateTodos = function() {\n      window.todos.forEach(todo => {\n        // Existing todo element set up code\n        checkbox.addEventListener(\"click\", completeTodo)\n      })\n    }\n\nvar completeTodo = function(evt) {\n      var checkbox = evt.target\n      var todoElement = checkbox.parentNode\n\nvar newTodoSet = [].concat(window.todos)\n      var todo = newTodoSet.find(t => t.id == todoElement.dataset.todo)\n      todo.completed = !todo.completed\n      todos = newTodoSet\n      updateTodos()\n    }\n  </script>\n`;\njs\nexport default {\n  async fetch(request, env, ctx) {\n    const defaultData = {\n      todos: [\n        {\n          id: 1,\n          name: \"Finish the Cloudflare Workers blog post\",\n          completed: false,\n        },\n      ],\n    };\n    const setCache = (key, data) => env.TODOS.put(key, data);\n    const getCache = (key) => env.TODOS.get(key);\n\nconst ip = request.headers.get(\"CF-Connecting-IP\");\n    const myKey = `data-${ip}`;\n\nif (request.method === \"PUT\") {\n      const body = await request.text();\n      try {\n        JSON.parse(body);\n        await setCache(myKey, body);\n        return new Response(body, { status: 200 });\n      } catch (err) {\n        return new Response(err, { status: 500 });\n      }\n    }\n\nconst cache = await getCache();\n    if (!cache) {\n      await setCache(myKey, JSON.stringify(defaultData));\n      data = defaultData;\n    } else {\n      data = JSON.parse(cache);\n    }\n\nconst body = html(JSON.stringify(data.todos).replace(/</g, \"\\\\u003c\"));\n\nreturn new Response(body, {\n      headers: {\n        \"Content-Type\": \"text/html\",\n      },\n    });\n  },\n};\njs\nconst html = (todos) => `\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n    <title>Todos</title>\n    <link href=\"https://cdn.jsdelivr.net/npm/tailwindcss/dist/tailwind.min.css\" rel=\"stylesheet\"></link>\n  </head>\n\n<body class=\"bg-blue-100\">\n    <div class=\"w-full h-full flex content-center justify-center mt-8\">\n      <div class=\"bg-white shadow-md rounded px-8 pt-6 py-8 mb-4\">\n        <h1 class=\"block text-grey-800 text-md font-bold mb-2\">Todos</h1>\n        <div class=\"flex\">\n          <input class=\"shadow appearance-none border rounded w-full py-2 px-3 text-grey-800 leading-tight focus:outline-none focus:shadow-outline\" type=\"text\" name=\"name\" placeholder=\"A new todo\"></input>\n          <button class=\"bg-blue-500 hover:bg-blue-800 text-white font-bold ml-2 py-2 px-4 rounded focus:outline-none focus:shadow-outline\" id=\"create\" type=\"submit\">Create</button>\n        </div>\n        <div class=\"mt-4\" id=\"todos\"></div>\n      </div>\n    </div>\n  </body>\n\n<script>\n    window.todos = ${todos}\n\nvar updateTodos = function() {\n      fetch(\"/\", { method: \"PUT\", body: JSON.stringify({ todos: window.todos }) })\n      populateTodos()\n    }\n\nvar completeTodo = function(evt) {\n      var checkbox = evt.target\n      var todoElement = checkbox.parentNode\n      var newTodoSet = [].concat(window.todos)\n      var todo = newTodoSet.find(t => t.id == todoElement.dataset.todo)\n      todo.completed = !todo.completed\n      window.todos = newTodoSet\n      updateTodos()\n    }\n\nvar populateTodos = function() {\n      var todoContainer = document.querySelector(\"#todos\")\n      todoContainer.innerHTML = null\n\nwindow.todos.forEach(todo => {\n        var el = document.createElement(\"div\")\n        el.className = \"border-t py-4\"\n        el.dataset.todo = todo.id\n\nvar name = document.createElement(\"span\")\n        name.className = todo.completed ? \"line-through\" : \"\"\n        name.textContent = todo.name\n\nvar checkbox = document.createElement(\"input\")\n        checkbox.className = \"mx-4\"\n        checkbox.type = \"checkbox\"\n        checkbox.checked = todo.completed ? 1 : 0\n        checkbox.addEventListener(\"click\", completeTodo)\n\nel.appendChild(checkbox)\n        el.appendChild(name)\n        todoContainer.appendChild(el)\n      })\n    }\n\nvar createTodo = function() {\n      var input = document.querySelector(\"input[name=name]\")\n      if (input.value.length) {\n        window.todos = [].concat(todos, { id: window.todos.length + 1, name: input.value, completed: false })\n        input.value = \"\"\n        updateTodos()\n      }\n    }\n\ndocument.querySelector(\"#create\").addEventListener(\"click\", createTodo)\n  </script>\n</html>\n`;\n\nexport default {\n  async fetch(request, env, ctx) {\n    const defaultData = {\n      todos: [\n        {\n          id: 1,\n          name: \"Finish the Cloudflare Workers blog post\",\n          completed: false,\n        },\n      ],\n    };\n    const setCache = (key, data) => env.TODOS.put(key, data);\n    const getCache = (key) => env.TODOS.get(key);\n\nconst ip = request.headers.get(\"CF-Connecting-IP\");\n    const myKey = `data-${ip}`;\n\nif (request.method === \"PUT\") {\n      const body = await request.text();\n      try {\n        JSON.parse(body);\n        await setCache(myKey, body);\n        return new Response(body, { status: 200 });\n      } catch (err) {\n        return new Response(err, { status: 500 });\n      }\n    }\n\nconst cache = await getCache();\n    if (!cache) {\n      await setCache(myKey, JSON.stringify(defaultData));\n      data = defaultData;\n    } else {\n      data = JSON.parse(cache);\n    }\n\nconst body = html(JSON.stringify(data.todos).replace(/</g, \"\\\\u003c\"));\n\nreturn new Response(body, {\n      headers: {\n        \"Content-Type\": \"text/html\",\n      },\n    });\n  },\n};\nsh\n  npm create cloudflare@latest -- qr-code-generator\n  sh\n  yarn create cloudflare qr-code-generator\n  sh\n  pnpm create cloudflare@latest qr-code-generator\n  sh\ncd qr-code-generator\njs\nexport default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello Worker!\");\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    if (request.method === \"POST\") {\n      return new Response(\"Hello Worker!\");\n    }\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    if (request.method === \"POST\") {\n      return new Response(\"Hello Worker!\");\n    }\n\nreturn new Response(\"Expected POST request\", {\n      status: 405,\n    });\n  },\n};\njs\nexport default {\n  async fetch(request, env, ctx) {\n    if (request.method === \"POST\") {\n    }\n  },\n};\n\nasync function generateQRCode(request) {\n  // TODO: Include QR code generation\n  return new Response(\"Hello worker!\");\n}\njs\nexport default {\n  async fetch(request, env, ctx) {\n    if (request.method === \"POST\") {\n      return generateQRCode(request);\n    }\n  },\n};\nsh\n  npm i qrcode-svg\n  sh\n  yarn add qrcode-svg\n  sh\n  pnpm add qrcode-svg\n  js\nimport QRCode from \"qrcode-svg\";\n\nasync function generateQRCode(request) {\n  const { text } = await request.json();\n  const qr = new QRCode({ content: text || \"https://workers.dev\" });\n  return new Response(qr.svg(), {\n    headers: { \"Content-Type\": \"image/svg+xml\" },\n  });\n}\njs\nexport default {\n  async fetch(request, env, ctx) {\n    if (request.method === \"POST\") {\n      return generateQRCode(request);\n    }\n\nreturn new Response(landing, {\n      headers: {\n        \"Content-Type\": \"text/html\",\n      },\n    });\n  },\n};\n\nasync function generateQRCode(request) {\n  const { text } = await request.json();\n  const qr = new QRCode({ content: text || \"https://workers.dev\" });\n  return new Response(qr.svg(), {\n    headers: { \"Content-Type\": \"image/svg+xml\" },\n  });\n}\n\nconst landing = `\n<h1>QR Generator</h1>\n<p>Click the below button to generate a new QR code. This will make a request to your Worker.</p>\n<input type=\"text\" id=\"text\" value=\"https://workers.dev\"></input>\n<button onclick=\"generate()\">Generate QR Code</button>\n<p>Generated QR Code Image</p>\n<img id=\"qr\" src=\"#\" />\n<script>\n  function generate() {\n    fetch(window.location.pathname, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ text: document.querySelector(\"#text\").value })\n    })\n    .then(response => response.blob())\n    .then(blob => {\n      const reader = new FileReader();\n      reader.onloadend = function () {\n        document.querySelector(\"#qr\").src = reader.result; // Update the image source with the newly generated QR code\n      }\n      reader.readAsDataURL(blob);\n    })\n  }\n</script>\n`;\njs\nconst QRCode = require(\"qrcode-svg\");\n\nexport default {\n  async fetch(request, env, ctx) {\n    if (request.method === \"POST\") {\n      return generateQRCode(request);\n    }\n\nreturn new Response(landing, {\n      headers: {\n        \"Content-Type\": \"text/html\",\n      },\n    });\n  },\n};\n\nasync function generateQRCode(request) {\n  const { text } = await request.json();\n  const qr = new QRCode({ content: text || \"https://workers.dev\" });\n  return new Response(qr.svg(), {\n    headers: { \"Content-Type\": \"image/svg+xml\" },\n  });\n}\n\nconst landing = `\n<h1>QR Generator</h1>\n<p>Click the below button to generate a new QR code. This will make a request to your Worker.</p>\n<input type=\"text\" id=\"text\" value=\"https://workers.dev\"></input>\n<button onclick=\"generate()\">Generate QR Code</button>\n<p>Generated QR Code Image</p>\n<img id=\"qr\" src=\"#\" />\n<script>\n  function generate() {\n    fetch(window.location.pathname, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ text: document.querySelector(\"#text\").value })\n    })\n    .then(response => response.blob())\n    .then(blob => {\n      const reader = new FileReader();\n      reader.onloadend = function () {\n        document.querySelector(\"#qr\").src = reader.result; // Update the image source with the newly generated QR code\n      }\n      reader.readAsDataURL(blob);\n    })\n  }\n</script>\n`;\nsh\nnpx wrangler deploy\nsh\n  npm create cloudflare@latest -- slack-bot\n  sh\n  yarn create cloudflare slack-bot\n  sh\n  pnpm create cloudflare@latest slack-bot\n  sh\ncd slack-bot\nts\nimport { Hono } from \"hono\";\n\ntype Bindings = {\n  [key in keyof CloudflareBindings]: CloudflareBindings[key];\n};\n\nconst app = new Hono<{ Bindings: Bindings }>();\n\napp.get(\"/\", (c) => {\n  return c.text(\"Hello Hono!\");\n});\n\nexport default app;\nsh\n  npm i -- dev\n  sh\n  yarn add dev\n  sh\n  pnpm add dev\n  ts\nimport { Hono } from \"hono\";\n\nconst app = new Hono();\n\napp.get(\"/posts\", (c) => c.text(\"Posts!\"));\napp.post(\"/posts\", (c) => c.text(\"Created!\", 201));\n\nexport default app;\nts\nimport { Hono } from \"hono\";\nimport api from \"./api\";\n\nconst app = new Hono();\n\napp.route(\"/api/v1\", api);\n\nexport default app;\nsh\nmkdir -p src/routes\ntouch src/routes/lookup.ts\ntouch src/routes/webhook.ts\nts\nimport { Hono } from \"hono\";\nimport lookup from \"./routes/lookup\";\nimport webhook from \"./routes/webhook\";\n\nconst app = new Hono();\n\napp.route(\"/lookup\", lookup);\napp.route(\"/webhook\", webhook);\n\nexport default app;\nts\nexport type Bindings = {\n  SLACK_WEBHOOK_URL: string;\n};\n\nexport type Issue = {\n  html_url: string;\n  title: string;\n  body: string;\n  state: string;\n  created_at: string;\n  number: number;\n  user: User;\n};\n\ntype User = {\n  html_url: string;\n  login: string;\n  avatar_url: string;\n};\nts\nimport { Hono } from \"hono\";\n\nconst app = new Hono();\n\nexport default app;\ntxt\ntoken=gIkuvaNzQIHg97ATvDxqgjtO\n&team_id=T0001\n&team_domain=example\n&enterprise_id=E0001\n&enterprise_name=Globular%20Construct%20Inc\n&channel_id=C2147483705\n&channel_name=test\n&user_id=U2147483697\n&user_name=Steve\n&command=/issue\n&text=cloudflare/wrangler#1\n&response_url=https://hooks.slack.com/commands/1234/5678\n&trigger_id=13345224609.738474920.8088930838d88f008e0\nts\nimport { Hono } from \"hono\";\n\nconst app = new Hono();\n\napp.post(\"/\", async (c) => {\n  const { text } = await c.req.parseBody();\n  if (typeof text !== \"string\") {\n    return c.notFound();\n  }\n});\n\nexport default app;\nts\nconst ghIssueRegex =\n  /(?<owner>[\\w.-]*)\\/(?<repo>[\\w.-]*)\\#(?<issue_number>\\d*)/;\n\nexport const parseGhIssueString = (text: string) => {\n  const match = text.match(ghIssueRegex);\n  return match ? (match.groups ?? {}) : {};\n};\nts\nimport { Hono } from \"hono\";\nimport { parseGhIssueString } from \"../utils/github\";\n\nconst app = new Hono();\n\napp.post(\"/\", async (c) => {\n  const { text } = await c.req.parseBody();\n  if (typeof text !== \"string\") {\n    return c.notFound();\n  }\n\nconst { owner, repo, issue_number } = parseGhIssueString(text);\n});\n\nexport default app;\nts\nconst ghIssueRegex =\n  /(?<owner>[\\w.-]*)\\/(?<repo>[\\w.-]*)\\#(?<issue_number>\\d*)/;\n\nexport const parseGhIssueString = (text: string) => {\n  const match = text.match(ghIssueRegex);\n  return match ? (match.groups ?? {}) : {};\n};\n\nexport const fetchGithubIssue = (\n  owner: string,\n  repo: string,\n  issue_number: string,\n) => {\n  const url = `https://api.github.com/repos/${owner}/${repo}/issues/${issue_number}`;\n  const headers = { \"User-Agent\": \"simple-worker-slack-bot\" };\n  return fetch(url, { headers });\n};\nts\nimport { Hono } from \"hono\";\nimport { fetchGithubIssue, parseGhIssueString } from \"../utils/github\";\nimport { Issue } from \"../types\";\n\nconst app = new Hono();\n\napp.post(\"/\", async (c) => {\n  const { text } = await c.req.parseBody();\n  if (typeof text !== \"string\") {\n    return c.notFound();\n  }\n\nconst { owner, repo, issue_number } = parseGhIssueString(text);\n  const response = await fetchGithubIssue(owner, repo, issue_number);\n  const issue = await response.json<Issue>();\n});\n\nexport default app;\nts\nimport { Issue } from \"../types\";\n\nexport const constructGhIssueSlackMessage = (\n  issue: Issue,\n  issue_string: string,\n  prefix_text?: string,\n) => {\n  const issue_link = `<${issue.html_url}|${issue_string}>`;\n  const user_link = `<${issue.user.html_url}|${issue.user.login}>`;\n  const date = new Date(Date.parse(issue.created_at)).toLocaleDateString();\n\nconst text_lines = [\n    prefix_text,\n    `*${issue.title} - ${issue_link}*`,\n    issue.body,\n    `*${issue.state}* - Created by ${user_link} on ${date}`,\n  ];\n};\nts\nimport { Issue } from \"../types\";\n\nexport const constructGhIssueSlackMessage = (\n  issue: Issue,\n  issue_string: string,\n  prefix_text?: string,\n) => {\n  const issue_link = `<${issue.html_url}|${issue_string}>`;\n  const user_link = `<${issue.user.html_url}|${issue.user.login}>`;\n  const date = new Date(Date.parse(issue.created_at)).toLocaleDateString();\n\nconst text_lines = [\n    prefix_text,\n    `*${issue.title} - ${issue_link}*`,\n    issue.body,\n    `*${issue.state}* - Created by ${user_link} on ${date}`,\n  ];\n\nreturn [\n    {\n      type: \"section\",\n      text: {\n        type: \"mrkdwn\",\n        text: text_lines.join(\"\\n\"),\n      },\n      accessory: {\n        type: \"image\",\n        image_url: issue.user.avatar_url,\n        alt_text: issue.user.login,\n      },\n    },\n  ];\n};\nts\nimport { Hono } from \"hono\";\nimport { fetchGithubIssue, parseGhIssueString } from \"../utils/github\";\nimport { constructGhIssueSlackMessage } from \"../utils/slack\";\nimport { Issue } from \"../types\";\n\nconst app = new Hono();\n\napp.post(\"/\", async (c) => {\n  const { text } = await c.req.parseBody();\n  if (typeof text !== \"string\") {\n    return c.notFound();\n  }\n\nconst { owner, repo, issue_number } = parseGhIssueString(text);\n  const response = await fetchGithubIssue(owner, repo, issue_number);\n  const issue = await response.json<Issue>();\n  const blocks = constructGhIssueSlackMessage(issue, text);\n\nreturn c.json({\n    blocks,\n    response_type: \"in_channel\",\n  });\n});\n\nexport default app;\nts\nimport { Hono } from \"hono\";\nimport { fetchGithubIssue, parseGhIssueString } from \"../utils/github\";\nimport { constructGhIssueSlackMessage } from \"../utils/slack\";\nimport { Issue } from \"../types\";\n\nconst app = new Hono();\n\napp.post(\"/\", async (c) => {\n  const { text } = await c.req.parseBody();\n  if (typeof text !== \"string\") {\n    return c.notFound();\n  }\n\nconst { owner, repo, issue_number } = parseGhIssueString(text);\n  const response = await fetchGithubIssue(owner, repo, issue_number);\n  const issue = await response.json<Issue>();\n  const blocks = constructGhIssueSlackMessage(issue, text);\n\nreturn c.json({\n    blocks,\n    response_type: \"in_channel\",\n  });\n});\n\napp.onError((_e, c) => {\n  return c.text(\n    \"Uh-oh! We couldn't find the issue you provided. \" +\n      \"We can only find public issues in the following format: `owner/repo#issue_number`.\",\n  );\n});\n\nexport default app;\nts\nimport { Hono } from \"hono\";\nimport { Bindings } from \"../types\";\n\nconst app = new Hono<{ Bindings: Bindings }>();\n\nexport default app;\nts\nimport { Hono } from \"hono\";\nimport { constructGhIssueSlackMessage } from \"../utils/slack\";\n\nconst app = new Hono();\n\napp.post(\"/\", async (c) => {\n  const { action, issue, repository } = await c.req.json();\n  const prefix_text = `An issue was ${action}:`;\n  const issue_string = `${repository.owner.login}/${repository.name}#${issue.number}`;\n});\n\nexport default app;\nts\nimport { Hono } from \"hono\";\nimport { constructGhIssueSlackMessage } from \"../utils/slack\";\n\nconst app = new Hono();\n\napp.post(\"/\", async (c) => {\n  const { action, issue, repository } = await c.req.json();\n  const prefix_text = `An issue was ${action}:`;\n  const issue_string = `${repository.owner.login}/${repository.name}#${issue.number}`;\n  const blocks = constructGhIssueSlackMessage(issue, issue_string, prefix_text);\n});\n\nexport default app;\nts\nimport { Issue } from \"../types\";\n\nconst compact = (array: unknown[]) => array.filter((el) => el);\n\nexport const constructGhIssueSlackMessage = (\n  issue: Issue,\n  issue_string: string,\n  prefix_text?: string,\n) => {\n  const issue_link = `<${issue.html_url}|${issue_string}>`;\n  const user_link = `<${issue.user.html_url}|${issue.user.login}>`;\n  const date = new Date(Date.parse(issue.created_at)).toLocaleDateString();\n\nconst text_lines = [\n    prefix_text,\n    `*${issue.title} - ${issue_link}*`,\n    issue.body,\n    `*${issue.state}* - Created by ${user_link} on ${date}`,\n  ];\n\nreturn [\n    {\n      type: \"section\",\n      text: {\n        type: \"mrkdwn\",\n        text: compact(text_lines).join(\"\\n\"),\n      },\n      accessory: {\n        type: \"image\",\n        image_url: issue.user.avatar_url,\n        alt_text: issue.user.login,\n      },\n    },\n  ];\n};\nts\nimport { Hono } from \"hono\";\nimport { constructGhIssueSlackMessage } from \"../utils/slack\";\nimport { Bindings } from \"../types\";\n\nconst app = new Hono<{ Bindings: Bindings }>();\n\napp.post(\"/\", async (c) => {\n  const { action, issue, repository } = await c.req.json();\n  const prefix_text = `An issue was ${action}:`;\n  const issue_string = `${repository.owner.login}/${repository.name}#${issue.number}`;\n  const blocks = constructGhIssueSlackMessage(issue, issue_string, prefix_text);\n\nconst fetchResponse = await fetch(c.env.SLACK_WEBHOOK_URL, {\n    body: JSON.stringify({ blocks }),\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n  });\n\nreturn c.text(\"OK\");\n});\n\nexport default app;\nsh\nnpx wrangler secret put SLACK_WEBHOOK_URL\nsh\nEnter a secret value: https://hooks.slack.com/services/abc123\nts\nimport { Hono } from \"hono\";\nimport { constructGhIssueSlackMessage } from \"../utils/slack\";\nimport { Bindings } from \"../types\";\n\nconst app = new Hono<{ Bindings: Bindings }>();\n\napp.post(\"/\", async (c) => {\n  const { action, issue, repository } = await c.req.json();\n  const prefix_text = `An issue was ${action}:`;\n  const issue_string = `${repository.owner.login}/${repository.name}#${issue.number}`;\n  const blocks = constructGhIssueSlackMessage(issue, issue_string, prefix_text);\n\nconst fetchResponse = await fetch(c.env.SLACK_WEBHOOK_URL, {\n    body: JSON.stringify({ blocks }),\n    method: \"POST\",\n    headers: { \"Content-Type\": \"application/json\" },\n  });\n\nif (!fetchResponse.ok) throw new Error();\n\nreturn c.text(\"OK\");\n});\n\napp.onError((_e, c) => {\n  return c.json(\n    {\n      message: \"Unable to handle webhook\",\n    },\n    500,\n  );\n});\n\nexport default app;\nsh\n  npm i -- deploy\n  sh\n  yarn add deploy\n  sh\n  pnpm add deploy\n  sh",
  "code_samples": [
    {
      "code": "An incoming request which matches multiple rules' URL patterns will inherit all rules' headers. Using the previous `_headers` file, the following requests will have the following headers applied:\n\n| Request URL | Headers |\n| - | - |\n| `https://custom.domain/secure/page` | `X-Frame-Options: DENY` `X-Content-Type-Options: nosniff` `Referrer-Policy: no-referrer` |\n| `https://custom.domain/static/image.jpg` | `Access-Control-Allow-Origin: *` `X-Robots-Tag: nosnippet` |\n| `https://myworker.mysubdomain.workers.dev/home` | `X-Robots-Tag: noindex` |\n| `https://myworker.mysubdomain.workers.dev/secure/page` | `X-Frame-Options: DENY` `X-Content-Type-Options: nosniff` `Referrer-Policy: no-referrer` `X-Robots-Tag: noindex` |\n| `https://myworker.mysubdomain.workers.dev/static/styles.css` | `Access-Control-Allow-Origin: *` `X-Robots-Tag: nosnippet, noindex` |\n\nYou may define up to 100 header rules. Each line in the `_headers` file has a 2,000 character limit. The entire line, including spacing, header name, and value, counts towards this limit.\n\nIf a header is applied twice in the `_headers` file, the values are joined with a comma separator.\n\n### Detach a header\n\nYou may wish to remove a default header or a header which has been added by a more pervasive rule. This can be done by prepending the header name with an exclamation mark and space (`! `).",
      "language": "unknown"
    },
    {
      "code": "### Match a path\n\nThe same URL matching features that [`_redirects`](https://developers.cloudflare.com/workers/static-assets/redirects/) offers is also available to the `_headers` file. Note, however, that redirects are applied before headers, so when a request matches both a redirect and a header, the redirect takes priority.\n\n#### Splats\n\nWhen matching, a splat pattern — signified by an asterisk (`*`) — will greedily match all characters. You may only include a single splat in the URL.\n\nThe matched value can be referenced within the header value as the `:splat` placeholder.\n\n#### Placeholders\n\nA placeholder can be defined with `:placeholder_name`. A colon (`:`) followed by a letter indicates the start of a placeholder and the placeholder name that follows must be composed of alphanumeric characters and underscores (`:[A-Za-z]\\w*`). Every named placeholder can only be referenced once. Placeholders match all characters apart from the delimiter, which when part of the host, is a period (`.`) or a forward-slash (`/`) and may only be a forward-slash (`/`) when part of the path.\n\nSimilarly, the matched value can be used in the header values with `:placeholder_name`.",
      "language": "unknown"
    },
    {
      "code": "#### Examples\n\n##### Cross-Origin Resource Sharing (CORS)\n\nTo enable other domains to fetch every static asset from your Worker, the following can be added to the `_headers` file:",
      "language": "unknown"
    },
    {
      "code": "This applies the `Access-Control-Allow-Origin` header to any incoming URL. To be more restrictive, you can define a URL pattern that applies to a `*.*.workers.dev` subdomain, which then only allows access from its [preview URLs](https://developers.cloudflare.com/workers/configuration/previews/):",
      "language": "unknown"
    },
    {
      "code": "##### Prevent your workers.dev URLs showing in search results\n\n[Google](https://developers.google.com/search/docs/advanced/robots/robots_meta_tag#directives) and other search engines often support the `X-Robots-Tag` header to instruct its crawlers how your website should be indexed.\n\nFor example, to prevent your `\\*.\\*.workers.dev` URLs from being indexed, add the following to your `_headers` file:",
      "language": "unknown"
    },
    {
      "code": "##### Configure custom browser cache behavior\n\nIf you have a folder of fingerprinted assets (assets which have a hash in their filename), you can configure more aggressive caching behavior in the browser to improve performance for repeat visitors:",
      "language": "unknown"
    },
    {
      "code": "##### Harden security for an application\n\nWarning\n\nIf you are server-side rendering (SSR) or using a Worker to generate responses in any other way and wish to attach security headers, the headers should be sent from the Worker's `Response` instead of using a `_headers` file. For example, if you have an API endpoint and want to allow cross-origin requests, you should ensure that your Worker code attaches CORS headers to its responses, including to `OPTIONS` requests.\n\nYou can prevent click-jacking by informing browsers not to embed your application inside another (for example, with an `<iframe>`) with a [`X-Frame-Options`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Frame-Options) header.\n\n[`X-Content-Type-Options: nosniff`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Content-Type-Options) prevents browsers from interpreting a response as any other content-type than what is defined with the `Content-Type` header.\n\n[`Referrer-Policy`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Referrer-Policy) allows you to customize how much information visitors give about where they are coming from when they navigate away from your page.\n\nBrowser features can be disabled to varying degrees with the [`Permissions-Policy`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Permissions-Policy) header (recently renamed from `Feature-Policy`).\n\nIf you need fine-grained control over your application's content, the [`Content-Security-Policy`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy) header allows you to configure a number of security settings, including similar controls to the `X-Frame-Options` header.",
      "language": "unknown"
    },
    {
      "code": "## Footnotes\n\n1. Due to a technical limitation that we hope to address in the future, the `CF-Cache-Status` header is not always entirely accurate. It is possible for false-positives and false-negatives to occur. This should be rare. In the meantime, this header should be considered as returning a \"probablistic\" result. [↩](#user-content-fnref-1)\n\n</page>\n\n<page>\n---\ntitle: Migration Guides · Cloudflare Workers docs\ndescription: Learn how to migrate your applications to Cloudflare Workers.\nlastUpdated: 2025-05-01T19:25:08.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/workers/static-assets/migration-guides/\n  md: https://developers.cloudflare.com/workers/static-assets/migration-guides/index.md\n---\n\nMigrate your existing applications to Cloudflare Workers.\n\nTake advantage of Cloudflare's global network and migrate your existing applications to Workers.\n\n* [Migrate from Pages to Workers](https://developers.cloudflare.com/workers/static-assets/migration-guides/migrate-from-pages/)\n* [Migrate from Netlify to Workers](https://developers.cloudflare.com/workers/static-assets/migration-guides/netlify-to-workers/)\n* [Migrate from Vercel to Workers](https://developers.cloudflare.com/workers/static-assets/migration-guides/vercel-to-workers/)\n\n</page>\n\n<page>\n---\ntitle: Redirects · Cloudflare Workers docs\ndescription: To apply custom redirects on a Worker with static assets, declare\n  your redirects in a plain text file called _redirects without a file\n  extension, in the static asset directory of your project. This file will not\n  itself be served as a static asset, but will instead be parsed by Workers and\n  its rules will be applied to static asset responses.\nlastUpdated: 2025-08-22T14:24:45.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/static-assets/redirects/\n  md: https://developers.cloudflare.com/workers/static-assets/redirects/index.md\n---\n\nTo apply custom redirects on a Worker with static assets, declare your redirects in a plain text file called `_redirects` without a file extension, in the static asset directory of your project. This file will not itself be served as a static asset, but will instead be parsed by Workers and its rules will be applied to static asset responses.\n\nIf you are using a framework, you will often have a directory named `public/` or `static/`, and this usually contains deploy-ready assets, such as favicons, `robots.txt` files, and site manifests. These files get copied over to a final output directory during the build, so this is the perfect place to author your `_redirects` file. If you are not using a framework, the `_redirects` file can go directly into your [static assets directory](https://developers.cloudflare.com/workers/static-assets/binding/#directory).\n\nWarning\n\nRedirects defined in the `_redirects` file are not applied to requests served by your Worker code, even if the request URL matches a rule defined in `_redirects`. You may wish to apply redirects manually in your Worker code, or explore other options such as [Bulk Redirects](https://developers.cloudflare.com/rules/url-forwarding/bulk-redirects/create-dashboard/).\n\n## Structure\n\n### Per line\n\nOnly one redirect can be defined per line and must follow this format, otherwise it will be ignored.",
      "language": "unknown"
    },
    {
      "code": "* `source` string required\n\n  * A file path.\n  * Can include [wildcards (`*`)](#splats) and [placeholders](#placeholders).\n  * Because fragments are evaluated by your browser and not Cloudflare's network, any fragments in the source are not evaluated.\n\n* `destination` string required\n\n  * A file path or external link.\n  * Can include fragments, query strings, [splats](#splats), and [placeholders](#placeholders).\n\n* `code` number (default: 302) optional\n\n  * Optional parameter\n\nLines starting with a `#` will be treated as comments.\n\n### Per file\n\nA `_redirects` file is limited to 2,000 static redirects and 100 dynamic redirects, for a combined total of 2,100 redirects. Each redirect declaration has a 1,000-character limit.\n\nIn your `_redirects` file:\n\n* The order of your redirects matter. If there are multiple redirects for the same `source` path, the top-most redirect is applied.\n* Static redirects should appear before dynamic redirects.\n* Redirects are always followed, regardless of whether or not an asset matches the incoming request.\n\nA complete example with multiple redirects may look like the following:",
      "language": "unknown"
    },
    {
      "code": "## Advanced redirects\n\nCloudflare currently offers limited support for advanced redirects.\n\n| Feature | Support | Example | Notes |\n| - | - | - | - |\n| Redirects (301, 302, 303, 307, 308) | ✅ | `/home / 301` | 302 is used as the default status code. |\n| Rewrites (other status codes) | ❌ | `/blog/* /blog/404.html 404` | |\n| Splats | ✅ | `/blog/* /posts/:splat` | Refer to [Splats](#splats). |\n| Placeholders | ✅ | `/blog/:year/:month/:date/:slug /news/:year/:month/:date/:slug` | Refer to [Placeholders](#placeholders). |\n| Query Parameters | ❌ | `/shop id=:id /blog/:id 301` | |\n| Proxying | ✅ | `/blog/* /news/:splat 200` | Refer to [Proxying](#proxying). |\n| Domain-level redirects | ❌ | `workers.example.com/* workers.example.com/blog/:splat 301` | |\n| Redirect by country or language | ❌ | `/ /us 302 Country=us` | |\n| Redirect by cookie | ❌ | `/\\* /preview/:splat 302 Cookie=preview` | |\n\n## Redirects and header matching\n\nRedirects execute before headers, so in the case of a request matching rules in both files, the redirect will win out.\n\n### Splats\n\nOn matching, a splat (asterisk, `*`) will greedily match all characters. You may only include a single splat in the URL.\n\nThe matched value can be used in the redirect location with `:splat`.\n\n### Placeholders\n\nA placeholder can be defined with `:placeholder_name`. A colon (`:`) followed by a letter indicates the start of a placeholder and the placeholder name that follows must be composed of alphanumeric characters and underscores (`:[A-Za-z]\\w*`). Every named placeholder can only be referenced once. Placeholders match all characters apart from the delimiter, which when part of the host, is a period (`.`) or a forward-slash (`/`) and may only be a forward-slash (`/`) when part of the path.\n\nSimilarly, the matched value can be used in the redirect values with `:placeholder_name`.",
      "language": "unknown"
    },
    {
      "code": "### Proxying\n\nProxying will only support relative URLs on your site. You cannot proxy external domains.\n\nOnly the first redirect in your will apply. For example, in the following example, a request to `/a` will render `/b`, and a request to `/b` will render `/c`, but `/a` will not render `/c`.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nBe aware that proxying pages can have an adverse effect on search engine optimization (SEO). Search engines often penalize websites that serve duplicate content. Consider adding a `Link` HTTP header which informs search engines of the canonical source of content.\n\nFor example, if you have added `/about/faq/* /about/faqs 200` to your `_redirects` file, you may want to add the following to your `_headers` file:",
      "language": "unknown"
    },
    {
      "code": "## Surpass `_redirects` limits\n\nA [`_redirects`](https://developers.cloudflare.com/workers/platform/limits/#redirects) file has a maximum of 2,000 static redirects and 100 dynamic redirects, for a combined total of 2,100 redirects. Use [Bulk Redirects](https://developers.cloudflare.com/rules/url-forwarding/bulk-redirects/) to handle redirects that surpasses the 2,100 redirect rules limit of `_redirects`.\n\nNote\n\nThe redirects defined in the `_redirects` file of your build folder can work together with your Bulk Redirects. In case of duplicates, Bulk Redirects will run in front of your Worker, where your other redirects live.\n\nFor example, if you have Bulk Redirects set up to direct `abc.com` to `xyz.com` but also have `_redirects` set up to direct `xyz.com` to `foo.com`, a request for `abc.com` will eventually redirect to `foo.com`.\n\nTo use Bulk Redirects, refer to the [Bulk Redirects dashboard documentation](https://developers.cloudflare.com/rules/url-forwarding/bulk-redirects/create-dashboard/) or the [Bulk Redirects API documentation](https://developers.cloudflare.com/rules/url-forwarding/bulk-redirects/create-api/).\n\n## Related resources\n\n* [Transform Rules](https://developers.cloudflare.com/rules/transform/)\n\n</page>\n\n<page>\n---\ntitle: Routing · Cloudflare Workers docs\ndescription: Learn how to configure different architectures for the static\n  assets of your Worker.\nlastUpdated: 2025-10-30T09:50:40.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/workers/static-assets/routing/\n  md: https://developers.cloudflare.com/workers/static-assets/routing/index.md\n---\n\nLearn how to configure different architectures for the static assets of your Worker.\n\n* [Full-stack application](https://developers.cloudflare.com/workers/static-assets/routing/full-stack-application/)\n* [Single Page Application (SPA)](https://developers.cloudflare.com/workers/static-assets/routing/single-page-application/)\n* [Static Site Generation (SSG) and custom 404 pages](https://developers.cloudflare.com/workers/static-assets/routing/static-site-generation/)\n* [Worker script](https://developers.cloudflare.com/workers/static-assets/routing/worker-script/)\n* [Advanced](https://developers.cloudflare.com/workers/static-assets/routing/advanced/)\n\n</page>\n\n<page>\n---\ntitle: Miniflare · Cloudflare Workers docs\ndescription: >-\n  Miniflare is a simulator for developing and testing\n\n  Cloudflare Workers. It's written in\n\n  TypeScript, and runs your code in a sandbox implementing Workers' runtime\n  APIs.\nlastUpdated: 2025-04-10T20:52:52.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/testing/miniflare/\n  md: https://developers.cloudflare.com/workers/testing/miniflare/index.md\n---\n\nWarning\n\nThis documentation describes the Miniflare API, which is only relevant for advanced use cases. Instead, most users should use [Wrangler](https://developers.cloudflare.com/workers/wrangler) to build, run & deploy their Workers locally\n\n**Miniflare** is a simulator for developing and testing [**Cloudflare Workers**](https://workers.cloudflare.com/). It's written in TypeScript, and runs your code in a sandbox implementing Workers' runtime APIs.\n\n* 🎉 **Fun:** develop Workers easily with detailed logging, file watching and pretty error pages supporting source maps.\n* 🔋 **Full-featured:** supports most Workers features, including KV, Durable Objects, WebSockets, modules and more.\n* ⚡ **Fully-local:** test and develop Workers without an Internet connection. Reload code on change quickly.\n\n[Get Started](https://developers.cloudflare.com/workers/testing/miniflare/get-started)\n\n[GitHub](https://github.com/cloudflare/workers-sdk/tree/main/packages/miniflare)\n\n[NPM](https://npmjs.com/package/miniflare)\n\n***\n\nThese docs primarily cover Miniflare specific things. For more information on runtime APIs, refer to the [Cloudflare Workers docs](https://developers.cloudflare.com/workers).\n\nIf you find something that doesn't behave as it does in the production Workers environment (and this difference isn't documented), or something's wrong in these docs, please [open a GitHub issue](https://github.com/cloudflare/workers-sdk/issues/new/choose).\n\n* [Get Started](https://developers.cloudflare.com/workers/testing/miniflare/get-started/)\n* [Writing tests ](https://developers.cloudflare.com/workers/testing/miniflare/writing-tests/): Write integration tests against Workers using Miniflare.\n* [Core](https://developers.cloudflare.com/workers/testing/miniflare/core/)\n* [Developing](https://developers.cloudflare.com/workers/testing/miniflare/developing/)\n* [Migrations ](https://developers.cloudflare.com/workers/testing/miniflare/migrations/): Review migration guides for specific versions of Miniflare.\n* [Storage](https://developers.cloudflare.com/workers/testing/miniflare/storage/)\n\n</page>\n\n<page>\n---\ntitle: Wrangler's unstable_startWorker() · Cloudflare Workers docs\ndescription: Write integration tests using Wrangler's `unstable_startWorker()` API\nlastUpdated: 2025-04-10T14:17:11.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/testing/unstable_startworker/\n  md: https://developers.cloudflare.com/workers/testing/unstable_startworker/index.md\n---\n\nNote\n\nFor most users, Cloudflare recommends using the Workers Vitest integration. If you have been using `unstable_dev()`, refer to the [Migrate from `unstable_dev()` guide](https://developers.cloudflare.com/workers/testing/vitest-integration/migration-guides/migrate-from-unstable-dev/).\n\nWarning\n\n`unstable_startWorker()` is an experimental API subject to breaking changes.\n\nIf you do not want to use Vitest, consider using [Wrangler's `unstable_startWorker()` API](https://developers.cloudflare.com/workers/wrangler/api/#unstable_startworker). This API exposes the internals of Wrangler's dev server, and allows you to customise how it runs. Compared to using [Miniflare directly for testing](https://developers.cloudflare.com/workers/testing/miniflare/writing-tests/), you can pass in a Wrangler configuration file, and it will automatically load the configuration for you.\n\nThis example uses `node:test`, but should apply to any testing framework:",
      "language": "unknown"
    },
    {
      "code": "</page>\n\n<page>\n---\ntitle: Vitest integration · Cloudflare Workers docs\ndescription: For most users, Cloudflare recommends using the Workers Vitest\n  integration for testing Workers and Pages Functions projects. Vitest is a\n  popular JavaScript testing framework featuring a very fast watch mode, Jest\n  compatibility, and out-of-the-box support for TypeScript. In this integration,\n  Cloudflare provides a custom pool that allows your Vitest tests to run inside\n  the Workers runtime.\nlastUpdated: 2025-04-10T14:17:11.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/testing/vitest-integration/\n  md: https://developers.cloudflare.com/workers/testing/vitest-integration/index.md\n---\n\nFor most users, Cloudflare recommends using the Workers Vitest integration for testing Workers and [Pages Functions](https://developers.cloudflare.com/pages/functions/) projects. [Vitest](https://vitest.dev/) is a popular JavaScript testing framework featuring a very fast watch mode, Jest compatibility, and out-of-the-box support for TypeScript. In this integration, Cloudflare provides a custom pool that allows your Vitest tests to run *inside* the Workers runtime.\n\nThe Workers Vitest integration:\n\n* Supports both **unit tests** and **integration tests**.\n* Provides direct access to Workers runtime APIs and bindings.\n* Implements isolated per-test storage.\n* Runs tests fully-locally using [Miniflare](https://miniflare.dev/).\n* Leverages Vitest's hot-module reloading for near instant reruns.\n* Provides a declarative interface for mocking outbound requests.\n* Supports projects with multiple Workers.\n\n[Write your first test](https://developers.cloudflare.com/workers/testing/vitest-integration/write-your-first-test/)\n\n</page>\n\n<page>\n---\ntitle: Get started · Cloudflare Workers docs\ndescription: Get started with the Vite plugin\nlastUpdated: 2025-10-29T21:32:51.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/vite-plugin/get-started/\n  md: https://developers.cloudflare.com/workers/vite-plugin/get-started/index.md\n---\n\nNote\n\nThis guide demonstrates creating a standalone Worker from scratch. If you would instead like to create a new application from a ready-to-go template, refer to the [TanStack Start](https://developers.cloudflare.com/workers/framework-guides/web-apps/tanstack-start/), [React Router](https://developers.cloudflare.com/workers/framework-guides/web-apps/react-router/), [React](https://developers.cloudflare.com/workers/framework-guides/web-apps/react/) or [Vue](https://developers.cloudflare.com/workers/framework-guides/web-apps/vue/) framework guides.\n\n## Start with a basic `package.json`",
      "language": "unknown"
    },
    {
      "code": "Note\n\nEnsure that you include `\"type\": \"module\"` in order to use ES modules by default.\n\n## Install the dependencies\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "## Create your Vite config file and include the Cloudflare plugin",
      "language": "unknown"
    },
    {
      "code": "The Cloudflare Vite plugin doesn't require any configuration by default and will look for a `wrangler.jsonc`, `wrangler.json` or `wrangler.toml` in the root of your application.\n\nRefer to the [API reference](https://developers.cloudflare.com/workers/vite-plugin/reference/api/) for configuration options.\n\n## Create your Worker config file\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "The `name` field specifies the name of your Worker. By default, this is also used as the name of the Worker's Vite Environment (see [Vite Environments](https://developers.cloudflare.com/workers/vite-plugin/reference/vite-environments/) for more information). The `main` field specifies the entry file for your Worker code.\n\nFor more information about the Worker configuration, see [Configuration](https://developers.cloudflare.com/workers/wrangler/configuration/).\n\n## Create your Worker entry file",
      "language": "unknown"
    },
    {
      "code": "A request to this Worker will return **'Running in Cloudflare-Workers!'**, demonstrating that the code is running inside the Workers runtime.\n\n## Dev, build, preview and deploy\n\nYou can now start the Vite development server (`npm run dev`), build the application (`npm run build`), preview the built application (`npm run preview`), and deploy to Cloudflare (`npm run deploy`).\n\n</page>\n\n<page>\n---\ntitle: Reference · Cloudflare Workers docs\nlastUpdated: 2025-04-04T07:52:43.000Z\nchatbotDeprioritize: true\nsource_url:\n  html: https://developers.cloudflare.com/workers/vite-plugin/reference/\n  md: https://developers.cloudflare.com/workers/vite-plugin/reference/index.md\n---\n\n* [API](https://developers.cloudflare.com/workers/vite-plugin/reference/api/)\n* [Static Assets](https://developers.cloudflare.com/workers/vite-plugin/reference/static-assets/)\n* [Debugging](https://developers.cloudflare.com/workers/vite-plugin/reference/debugging/)\n* [Migrating from wrangler dev](https://developers.cloudflare.com/workers/vite-plugin/reference/migrating-from-wrangler-dev/)\n* [Secrets](https://developers.cloudflare.com/workers/vite-plugin/reference/secrets/)\n* [Vite Environments](https://developers.cloudflare.com/workers/vite-plugin/reference/vite-environments/)\n* [Cloudflare Environments](https://developers.cloudflare.com/workers/vite-plugin/reference/cloudflare-environments/)\n* [Programmatic configuration](https://developers.cloudflare.com/workers/vite-plugin/reference/programmatic-configuration/)\n\n</page>\n\n<page>\n---\ntitle: Tutorial - React SPA with an API · Cloudflare Workers docs\ndescription: Create a React SPA with an API Worker using the Vite plugin\nlastUpdated: 2025-07-01T10:19:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/workers/vite-plugin/tutorial/\n  md: https://developers.cloudflare.com/workers/vite-plugin/tutorial/index.md\n---\n\nThis tutorial takes you through the steps needed to adapt a Vite project to use the Cloudflare Vite plugin. Much of the content can also be applied to adapting existing Vite projects and to front-end frameworks other than React.\n\nNote\n\nIf you want to start a new app with a template already set up with Vite, React and the Cloudflare Vite plugin, refer to the [React framework guide](https://developers.cloudflare.com/workers/framework-guides/web-apps/react/). To create a standalone Worker, refer to [Get started](https://developers.cloudflare.com/workers/vite-plugin/get-started/).\n\n## Introduction\n\nIn this tutorial, you will create a React SPA that can be deployed as a Worker with static assets. You will then add an API Worker that can be accessed from the front-end code. You will develop, build, and preview the application using Vite before finally deploying to Cloudflare.\n\n## Set up and configure the React SPA\n\n### Scaffold a Vite project\n\nStart by creating a React TypeScript project with Vite.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Next, open the `cloudflare-vite-tutorial` directory in your editor of choice.\n\n### Add the Cloudflare dependencies\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "### Add the plugin to your Vite config",
      "language": "unknown"
    },
    {
      "code": "The Cloudflare Vite plugin doesn't require any configuration by default and will look for a `wrangler.jsonc`, `wrangler.json` or `wrangler.toml` in the root of your application.\n\nRefer to the [API reference](https://developers.cloudflare.com/workers/vite-plugin/reference/api/) for configuration options.\n\n### Create your Worker config file\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "The [`not_found_handling`](https://developers.cloudflare.com/workers/static-assets/routing/single-page-application/) value has been set to `single-page-application`. This means that all not found requests will serve the `index.html` file. With the Cloudflare plugin, the `assets` routing configuration is used in place of Vite's default behavior. This ensures that your application's [routing configuration](https://developers.cloudflare.com/workers/static-assets/routing/) works the same way while developing as it does when deployed to production.\n\nNote that the [`directory`](https://developers.cloudflare.com/workers/static-assets/binding/#directory) field is not used when configuring assets with Vite. The `directory` in the output configuration will automatically point to the client build output. See [Static Assets](https://developers.cloudflare.com/workers/vite-plugin/reference/static-assets/) for more information.\n\nNote\n\nWhen using the Cloudflare Vite plugin, the Worker config (for example, `wrangler.jsonc`) that you provide is the input configuration file. A separate output `wrangler.json` file is created when you run `vite build`. This output file is a snapshot of your configuration at the time of the build and is modified to reference your build artifacts. It is the configuration that is used for preview and deployment.\n\n### Update the .gitignore file\n\nWhen developing Workers, additional files are used and/or generated that should not be stored in git. Add the following lines to your `.gitignore` file:",
      "language": "unknown"
    },
    {
      "code": "### Run the development server\n\nRun `npm run dev` to start the Vite development server and verify that your application is working as expected.\n\nFor a purely front-end application, you could now build (`npm run build`), preview (`npm run preview`), and deploy (`npm exec wrangler deploy`) your application. This tutorial, however, will show you how to go a step further and add an API Worker.\n\n## Add an API Worker\n\n### Configure TypeScript for your Worker code\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### Add to your Worker configuration\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "The `main` field specifies the entry file for your Worker code.\n\n### Add your API Worker",
      "language": "unknown"
    },
    {
      "code": "The Worker above will be invoked for any non-navigation request that does not match a static asset. It returns a JSON response if the `pathname` starts with `/api/` and otherwise return a `404` response.\n\nNote\n\nFor top-level navigation requests, browsers send a `Sec-Fetch-Mode: navigate` header. If this is present and the URL does not match a static asset, the `not_found_handling` behavior will be invoked rather than the Worker. This implicit routing is the default behavior.\n\nIf you would instead like to define the routes that invoke your Worker explicitly, you can provide an array of route patterns to [`run_worker_first`](https://developers.cloudflare.com/workers/static-assets/binding/#run_worker_first). This opts out of interpreting the `Sec-Fetch-Mode` header.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "### Call the API from the client\n\nEdit `src/App.tsx` so that it includes an additional button that calls the API and sets some state:",
      "language": "unknown"
    },
    {
      "code": "Now, if you click the button, it will display 'Name from API is: Cloudflare'.\n\nIncrement the counter to update the application state in the browser. Next, edit `api/index.ts` by changing the `name` it returns to `'Cloudflare Workers'`. If you click the button again, it will display the new `name` while preserving the previously set counter value.\n\nWith Vite and the Cloudflare plugin, you can iterate on the client and server parts of your app together, without losing UI state between edits.\n\n### Build your application\n\nRun `npm run build` to build your application.",
      "language": "unknown"
    },
    {
      "code": "If you inspect the `dist` directory, you will see that it contains two subdirectories:\n\n* `client` - the client code that runs in the browser\n* `cloudflare-vite-tutorial` - the Worker code alongside the output `wrangler.json` configuration file\n\n### Preview your application\n\nRun `npm run preview` to validate that your application runs as expected.",
      "language": "unknown"
    },
    {
      "code": "This command will run your build output locally in the Workers runtime, closely matching its behaviour in production.\n\n### Deploy to Cloudflare\n\nRun `npm exec wrangler deploy` to deploy your application to Cloudflare.",
      "language": "unknown"
    },
    {
      "code": "This command will automatically use the output `wrangler.json` that was included in the build output.\n\n## Next steps\n\nIn this tutorial, we created an SPA that could be deployed as a Worker with static assets. We then added an API Worker that could be accessed from the front-end code. Finally, we deployed both the client and server-side parts of the application to Cloudflare.\n\nPossible next steps include:\n\n* Adding a binding to another Cloudflare service such as a [KV namespace](https://developers.cloudflare.com/kv/) or [D1 database](https://developers.cloudflare.com/d1/)\n* Expanding the API to include additional routes\n* Using a library, such as [Hono](https://hono.dev/) or [tRPC](https://trpc.io/), in your API Worker\n\n</page>\n\n<page>\n---\ntitle: Build a todo list Jamstack application · Cloudflare Workers docs\ndescription: This tutorial explains how to build a todo list application using\n  HTML, CSS, and JavaScript.\nlastUpdated: 2025-10-13T13:40:40.000Z\nchatbotDeprioritize: false\ntags: JavaScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/build-a-jamstack-app/\n  md: https://developers.cloudflare.com/workers/tutorials/build-a-jamstack-app/index.md\n---\n\nIn this tutorial, you will build a todo list application using HTML, CSS, and JavaScript. The application data will be stored in [Workers KV](https://developers.cloudflare.com/kv/api/).\n\n![Preview of a finished todo list. Continue reading for instructions on how to set up a todo list.](https://developers.cloudflare.com/_astro/finished.CHDh55j7_Z2s3VLp.webp)\n\nBefore starting this project, you should have some experience with HTML, CSS, and JavaScript. You will learn:\n\n1. How building with Workers makes allows you to focus on writing code and ship finished products.\n2. How the addition of Workers KV makes this tutorial a great introduction to building full, data-driven applications.\n\nIf you would like to see the finished code for this project, find the [project on GitHub](https://github.com/lauragift21/cloudflare-workers-todos) and refer to the [live demo](https://todos.examples.workers.dev/) to review what you will be building.\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## 1. Create a new Workers project\n\nFirst, use the [`create-cloudflare`](https://www.npmjs.com/package/create-cloudflare) CLI tool to create a new Cloudflare Workers project named `todos`. In this tutorial, you will use the default `Hello World` template to create a Workers project.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nMove into your newly created directory:",
      "language": "unknown"
    },
    {
      "code": "Inside of your new `todos` Worker project directory, `index.js` represents the entry point to your Cloudflare Workers application.\n\nAll incoming HTTP requests to a Worker are passed to the [`fetch()` handler](https://developers.cloudflare.com/workers/runtime-apis/handlers/fetch/) as a [request](https://developers.cloudflare.com/workers/runtime-apis/request/) object. After a request is received by the Worker, the response your application constructs will be returned to the user. This tutorial will guide you through understanding how the request/response pattern works and how you can use it to build fully featured applications.",
      "language": "unknown"
    },
    {
      "code": "In your default `index.js` file, you can see that request/response pattern in action. The `fetch` constructs a new `Response` with the body text `'Hello World!'`.\n\nWhen a Worker receives a `request`, the Worker returns the newly constructed response to the client. Your Worker will serve new responses directly from [Cloudflare's global network](https://www.cloudflare.com/network) instead of continuing to your origin server. A standard server would accept requests and return responses. Cloudflare Workers allows you to respond by constructing responses directly on the Cloudflare global network.\n\n## 2. Review project details\n\nAny project you deploy to Cloudflare Workers can make use of modern JavaScript tooling like [ES modules](https://developers.cloudflare.com/workers/reference/migrate-to-module-workers/), `npm` packages, and [`async`/`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) functions to build your application. In addition to writing Workers, you can use Workers to [build full applications](https://developers.cloudflare.com/workers/tutorials/build-a-slackbot/) using the same tooling and process as in this tutorial.\n\nIn this tutorial, you will build a todo list application running on Workers that allows reading data from a [KV](https://developers.cloudflare.com/kv/) store and using the data to populate an HTML response to send to the client.\n\nThe work needed to create this application is split into three tasks:\n\n1. Write data to KV.\n2. Rendering data from KV.\n3. Adding todos from the application UI.\n\nFor the remainder of this tutorial you will complete each task, iterating on your application, and then publish it to your own domain.\n\n## 3. Write data to KV\n\nTo begin, you need to understand how to populate your todo list with actual data. To do this, use [Cloudflare Workers KV](https://developers.cloudflare.com/kv/) — a key-value store that you can access inside of your Worker to read and write data.\n\nTo get started with KV, set up a namespace. All of your cached data will be stored inside that namespace and, with configuration, you can access that namespace inside the Worker with a predefined variable. Use Wrangler to create a new namespace called `TODOS` with the [`kv namespace create` command](https://developers.cloudflare.com/workers/wrangler/commands/#kv-namespace-create) and get the associated namespace ID by running the following command in your terminal:",
      "language": "unknown"
    },
    {
      "code": "The associated namespace can be combined with a `--preview` flag to interact with a preview namespace instead of a production namespace. Namespaces can be added to your application by defining them inside your Wrangler configuration. Copy your newly created namespace ID, and in your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/), define a `kv_namespaces` key to set up your namespace:\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "The defined namespace, `TODOS`, will now be available inside of your codebase. With that, it is time to understand the [KV API](https://developers.cloudflare.com/kv/api/). A KV namespace has three primary methods you can use to interface with your cache: `get`, `put`, and `delete`.\n\nStart storing data by defining an initial set of data, which you will put inside of the cache using the `put` method. The following example defines a `defaultData` object instead of an array of todo items. You may want to store metadata and other information inside of this cache object later on. Given that data object, use `JSON.stringify` to add a string into the cache:",
      "language": "unknown"
    },
    {
      "code": "Workers KV is an eventually consistent, global datastore. Any writes within a region are immediately reflected within that same region but will not be immediately available in other regions. However, those writes will eventually be available everywhere and, at that point, Workers KV guarantees that data within each region will be consistent.\n\nGiven the presence of data in the cache and the assumption that your cache is eventually consistent, this code needs a slight adjustment: the application should check the cache and use its value, if the key exists. If it does not, you will use `defaultData` as the data source for now (it should be set in the future) and write it to the cache for future use. After breaking out the code into a few functions for simplicity, the result looks like this:",
      "language": "unknown"
    },
    {
      "code": "## Render data from KV\n\nGiven the presence of data in your code, which is the cached data object for your application, you should take this data and render it in a user interface.\n\nTo do this, make a new `html` variable in your Workers script and use it to build up a static HTML template that you can serve to the client. In `fetch`, construct a new `Response` with a `Content-Type: text/html` header and serve it to the client:",
      "language": "unknown"
    },
    {
      "code": "You have a static HTML site being rendered and you can begin populating it with data. In the body, add a `div` tag with an `id` of `todos`:",
      "language": "unknown"
    },
    {
      "code": "Add a `<script>` element at the end of the body content that takes a `todos` array. For each `todo` in the array, create a `div` element and appends it to the `todos` HTML element:",
      "language": "unknown"
    },
    {
      "code": "Your static page can take in `window.todos` and render HTML based on it, but you have not actually passed in any data from KV. To do this, you will need to make a few changes.\n\nFirst, your `html` variable will change to a function. The function will take in a `todos` argument, which will populate the `window.todos` variable in the above code sample:",
      "language": "unknown"
    },
    {
      "code": "In `fetch`, use the retrieved KV data to call the `html` function and generate a `Response` based on it:",
      "language": "unknown"
    },
    {
      "code": "## 4. Add todos from the user interface (UI)\n\nAt this point, you have built a Cloudflare Worker that takes data from Cloudflare KV and renders a static page based on that Worker. That static page reads data and generates a todo list based on that data. The remaining task is creating todos from inside the application UI. You can add todos using the KV API — update the cache by running `env.TODOS.put(newData)`.\n\nTo update a todo item, you will add a second handler in your Workers script, designed to watch for `PUT` requests to `/`. When a request body is received at that URL, the Worker will send the new todo data to your KV store.\n\nAdd this new functionality in `fetch`: if the request method is a PUT, it will take the request body and update the cache.",
      "language": "unknown"
    },
    {
      "code": "Check that the request is a `PUT` and wrap the remainder of the code in a `try/catch` block. First, parse the body of the request coming in, ensuring that it is JSON, before you update the cache with the new data and return it to the user. If anything goes wrong, return a `500` status code. If the route is hit with an HTTP method other than `PUT` — for example, `POST` or `DELETE` — return a `404` error.\n\nWith this script, you can now add some dynamic functionality to your HTML page to actually hit this route. First, create an input for your todo name and a button for submitting the todo.",
      "language": "unknown"
    },
    {
      "code": "Given that input and button, add a corresponding JavaScript function to watch for clicks on the button — once the button is clicked, the browser will `PUT` to `/` and submit the todo.",
      "language": "unknown"
    },
    {
      "code": "This code updates the cache. Remember that the KV cache is eventually consistent — even if you were to update your Worker to read from the cache and return it, you have no guarantees it will actually be up to date. Instead, update the list of todos locally, by taking your original code for rendering the todo list, making it a reusable function called `populateTodos`, and calling it when the page loads and when the cache request has finished:",
      "language": "unknown"
    },
    {
      "code": "With the client-side code in place, deploying the new version of the function should put all these pieces together. The result is an actual dynamic todo list.\n\n## 5. Update todos from the application UI\n\nFor the final piece of your todo list, you need to be able to update todos — specifically, marking them as completed.\n\nLuckily, a great deal of the infrastructure for this work is already in place. You can update the todo list data in the cache, as evidenced by your `createTodo` function. Performing updates on a todo is more of a client-side task than a Worker-side one.\n\nTo start, the `populateTodos` function can be updated to generate a `div` for each todo. In addition, move the name of the todo into a child element of that `div`:",
      "language": "unknown"
    },
    {
      "code": "You have designed the client-side part of this code to handle an array of todos and render a list of HTML elements. There is a number of things that you have been doing that you have not quite had a use for yet – specifically, the inclusion of IDs and updating the todo's completed state. These things work well together to actually support updating todos in the application UI.\n\nTo start, it would be useful to attach the ID of each todo in the HTML. By doing this, you can then refer to the element later in order to correspond it to the todo in the JavaScript part of your code. Data attributes and the corresponding `dataset` method in JavaScript are a perfect way to implement this. When you generate your `div` element for each todo, you can attach a data attribute called todo to each `div`:",
      "language": "unknown"
    },
    {
      "code": "Inside your HTML, each `div` for a todo now has an attached data attribute, which looks like:",
      "language": "unknown"
    },
    {
      "code": "You can now generate a checkbox for each todo element. This checkbox will default to unchecked for new todos but you can mark it as checked as the element is rendered in the window:",
      "language": "unknown"
    },
    {
      "code": "The checkbox is set up to correctly reflect the value of completed on each todo but it does not yet update when you actually check the box. To do this, attach the `completeTodo` function as an event listener on the `click` event. Inside the function, inspect the checkbox element, find its parent (the todo `div`), and use its `todo` data attribute to find the corresponding todo in the data array. You can toggle the completed status, update its properties, and rerender the UI:",
      "language": "unknown"
    },
    {
      "code": "The final result of your code is a system that checks the `todos` variable, updates your Cloudflare KV cache with that value, and then does a re-render of the UI based on the data it has locally.\n\n## 6. Conclusion and next steps\n\nBy completing this tutorial, you have built a static HTML, CSS, and JavaScript application that is transparently powered by Workers and Workers KV, which take full advantage of Cloudflare's global network.\n\nIf you would like to keep improving on your project, you can implement a better design (you can refer to a live version available at [todos.signalnerve.workers.dev](https://todos.signalnerve.workers.dev/)), or make additional improvements to security and speed.\n\nYou may also want to add user-specific caching. Right now, the cache key is always `data` – this means that any visitor to the site will share the same todo list with other visitors. Within your Worker, you could use values from the client request to create and maintain user-specific lists. For example, you may generate a cache key based on the requesting IP:",
      "language": "unknown"
    },
    {
      "code": "After making these changes and deploying the Worker one more time, your todo list application now includes per-user functionality while still taking full advantage of Cloudflare's global network.\n\nThe final version of your Worker script should look like this:",
      "language": "unknown"
    },
    {
      "code": "You can find the source code for this project, as well as a README with deployment instructions, [on GitHub](https://github.com/lauragift21/cloudflare-workers-todos).\n\n</page>\n\n<page>\n---\ntitle: Build a QR code generator · Cloudflare Workers docs\ndescription: This tutorial shows you how to build and publish a Worker\n  application that generates QR codes. The final version of the codebase is\n  available on GitHub.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\ntags: JavaScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/build-a-qr-code-generator/\n  md: https://developers.cloudflare.com/workers/tutorials/build-a-qr-code-generator/index.md\n---\n\nIn this tutorial, you will build and publish a Worker application that generates QR codes.\n\nIf you would like to review the code for this tutorial, the final version of the codebase is [available on GitHub](https://github.com/kristianfreeman/workers-qr-code-generator). You can take the code provided in the example repository, customize it, and deploy it for use in your own projects.\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## 1. Create a new Workers project\n\nFirst, use the [`create-cloudflare` CLI](https://developers.cloudflare.com/pages/get-started/c3) to create a new Cloudflare Workers project. To do this, open a terminal window and run the following command:\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "For setup, select the following options:\n\n* For *What would you like to start with?*, choose `Hello World example`.\n* For *Which template would you like to use?*, choose `Worker only`.\n* For *Which language do you want to use?*, choose `JavaScript`.\n* For *Do you want to use git for version control?*, choose `Yes`.\n* For *Do you want to deploy your application?*, choose `No` (we will be making some changes before deploying).\n\nThen, move into your newly created directory:",
      "language": "unknown"
    },
    {
      "code": "Inside of your new `qr-code-generator` Worker project directory, `index.js` represents the entry point to your Cloudflare Workers application.\n\nAll Cloudflare Workers applications start by listening for `fetch` events, which are triggered when a client makes a request to a Workers route. After a request is received by the Worker, the response your application constructs will be returned to the user. This tutorial will guide you through understanding how the request/response pattern works and how you can use it to build fully featured applications.",
      "language": "unknown"
    },
    {
      "code": "In your default `index.js` file, you can see that request/response pattern in action. The `fetch` constructs a new `Response` with the body text `'Hello Worker!'`.\n\nWhen a Worker receives a `fetch` event, the Worker returns the newly constructed response to the client. Your Worker will serve new responses directly from [Cloudflare's global network](https://www.cloudflare.com/network) instead of continuing to your origin server. A standard server would accept requests and return responses. Cloudflare Workers allows you to respond quickly by constructing responses directly on the Cloudflare global network.\n\n## 2. Handle Incoming Request\n\nAny project you publish to Cloudflare Workers can make use of modern JavaScript tooling like ES modules, `npm` packages, and [`async`/`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) functions to build your application. In addition to writing Workers, you can use Workers to [build full applications](https://developers.cloudflare.com/workers/tutorials/build-a-slackbot/) using the same tooling and process as in this tutorial.\n\nThe QR code generator you will build in this tutorial will be a Worker that runs on a single route and receives requests. Each request will contain a text message (a URL, for example), which the function will encode into a QR code. The function will then respond with the QR code in PNG image format.\n\nAt this point in the tutorial, your Worker function can receive requests and return a simple response with the text `\"Hello Worker!\"`. To handle data coming into your Worker, check if the incoming request is a `POST` request:",
      "language": "unknown"
    },
    {
      "code": "Currently, if an incoming request is not a `POST`, the function will return `undefined`. However, a Worker always needs to return a `Response`. Since the function should only accept incoming `POST` requests, return a new `Response` with a [`405` status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status/405) if the incoming request is not a `POST`:",
      "language": "unknown"
    },
    {
      "code": "You have established the basic flow of the request. You will now set up a response to incoming valid requests. If a `POST` request comes in, the function should generate a QR code. To start, move the `\"Hello Worker!\"` response into a new function, `generateQRCode`, which will ultimately contain the bulk of your function’s logic:",
      "language": "unknown"
    },
    {
      "code": "With the `generateQRCode` function filled out, call it within `fetch` function and return its result directly to the client:",
      "language": "unknown"
    },
    {
      "code": "## 3. Build a QR code generator\n\nAll projects deployed to Cloudflare Workers support npm packages. This support makes it easy to rapidly build out functionality in your Workers. The ['qrcode-svg'](https://github.com/papnkukn/qrcode-svg) package is a great way to take text and encode it into a QR code. In the command line, install and save 'qrcode-svg' to your project’s 'package.json':\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "In `index.js`, import the `qrcode-svg` package as the variable `QRCode`. In the `generateQRCode` function, parse the incoming request as JSON using `request.json`, and generate a new QR code using the `qrcode-svg` package. The QR code is generated as an SVG. Construct a new instance of `Response`, passing in the SVG data as the body, and a `Content-Type` header of `image/svg+xml`. This will allow browsers to properly parse the data coming back from your Worker as an image:",
      "language": "unknown"
    },
    {
      "code": "## 4. Test in an application UI\n\nThe Worker will execute when a user sends a `POST` request to a route, but it is best practice to also provide a proper interface for testing the function. At this point in the tutorial, if any request is received by your function that is not a `POST`, a `405` response is returned. The new version of `fetch` should return a new `Response` with a static HTML document instead of the `405` error:",
      "language": "unknown"
    },
    {
      "code": "The `landing` variable, which is a static HTML string, sets up an `input` tag and a corresponding `button`, which calls the `generateQRCode` function. This function will make an HTTP `POST` request back to your Worker, allowing you to see the corresponding QR code image returned on the page.\n\nWith the above steps complete, your Worker is ready. The full version of the code looks like this:",
      "language": "unknown"
    },
    {
      "code": "## 5. Deploy your Worker\n\nWith all the above steps complete, you have written the code for a QR code generator on Cloudflare Workers.\n\nWrangler has built-in support for bundling, uploading, and releasing your Cloudflare Workers application. To do this, run `npx wrangler deploy`, which will build and deploy your code.",
      "language": "unknown"
    },
    {
      "code": "## Related resources\n\nIn this tutorial, you built and deployed a Worker application for generating QR codes. If you would like to see the full source code for this application, you can find it [on GitHub](https://github.com/kristianfreeman/workers-qr-code-generator).\n\nIf you want to get started building your own projects, review the existing list of [Quickstart templates](https://developers.cloudflare.com/workers/get-started/quickstarts/).\n\n</page>\n\n<page>\n---\ntitle: Build a Slackbot · Cloudflare Workers docs\ndescription: Learn how to build a Slackbot with Hono and TypeScript in Cloudflare Workerss\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\ntags: Hono,TypeScript\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/build-a-slackbot/\n  md: https://developers.cloudflare.com/workers/tutorials/build-a-slackbot/index.md\n---\n\nIn this tutorial, you will build a [Slack](https://slack.com) bot using [Cloudflare Workers](https://developers.cloudflare.com/workers/). Your bot will make use of GitHub webhooks to send messages to a Slack channel when issues are updated or created, and allow users to write a command to look up GitHub issues from inside Slack.\n\n![After following this tutorial, you will be able to create a Slackbot like the one in this example. Continue reading to build your Slackbot.](https://developers.cloudflare.com/_astro/issue-command.BJRwbx5d_2fTOgN.webp)\n\nThis tutorial is recommended for people who are familiar with writing web applications. You will use TypeScript as the programming language and [Hono](https://hono.dev/) as the web framework. If you have built an application with tools like [Node](https://nodejs.org) and [Express](https://expressjs.com), this project will feel very familiar to you. If you are new to writing web applications or have wanted to build something like a Slack bot in the past, but were intimidated by deployment or configuration, Workers will be a way for you to focus on writing code and shipping projects.\n\nIf you would like to review the code or how the bot works in an actual Slack channel before proceeding with this tutorial, you can access the final version of the codebase [on GitHub](https://github.com/yusukebe/workers-slack-bot). From GitHub, you can add your own Slack API keys and deploy it to your own Slack channels for testing.\n\n***\n\n## Before you start\n\nAll of the tutorials assume you have already completed the [Get started guide](https://developers.cloudflare.com/workers/get-started/guide/), which gets you set up with a Cloudflare Workers account, [C3](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare), and [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/).\n\n## Set up Slack\n\nThis tutorial assumes that you already have a Slack account, and the ability to create and manage Slack applications.\n\n### Configure a Slack application\n\nTo post messages from your Cloudflare Worker into a Slack channel, you will need to create an application in Slack’s UI. To do this, go to Slack’s API section, at [api.slack.com/apps](https://api.slack.com/apps), and select **Create New App**.\n\n![To create a Slackbot, first create a Slack App](https://developers.cloudflare.com/_astro/create-a-slack-app.D5_bKo4M_Z2vXaWG.webp)\n\nSlack applications have many features. You will make use of two of them, Incoming Webhooks and Slash Commands, to build your Worker-powered Slack bot.\n\n#### Incoming Webhook\n\nIncoming Webhooks are URLs that you can use to send messages to your Slack channels. Your incoming webhook will be paired with GitHub’s webhook support to send messages to a Slack channel whenever there are updates to issues in a given repository. You will see the code in more detail as you build your application. First, create a Slack webhook:\n\n1. On the sidebar of Slack's UI, select **Incoming Webhooks**.\n2. In **Webhook URLs for your Workspace**, select **Add New Webhook to Workspace**.\n3. On the following screen, select the channel that you want your webhook to send messages to (you can select a room, like #general or #code, or be messaged directly by your Slack bot when the webhook is called.)\n4. Authorize the new webhook URL.\n\nAfter authorizing your webhook URL, you will be returned to the **Incoming Webhooks** page and can view your new webhook URL. You will add this into your Workers code later. Next, you will add the second component to your Slack bot: a Slash Command.\n\n![Select Add New Webhook to Workspace to add a new Webhook URL in Slack's dashboard](https://developers.cloudflare.com/_astro/slack-incoming-webhook.DWpFxzq__Z5d6ks.webp)\n\n#### Slash Command\n\nA Slash Command in Slack is a custom-configured command that can be attached to a URL request. For example, if you configured `/weather <zip>`, Slack would make an HTTP POST request to a configured URL, passing the text `<zip>` to get the weather for a specified zip code. In your application, you will use the `/issue` command to look up GitHub issues using the [GitHub API](https://developer.github.com). Typing `/issue cloudflare/wrangler#1` will send the text `cloudflare/wrangler#1` in a HTTP POST request to your application, which the application will use to find the [relevant GitHub issue](https://github.com/cloudflare/wrangler-legacy/issues/1).\n\n1. On the Slack sidebar, select **Slash Commands**.\n2. Create your first slash command.\n\nFor this tutorial, you will use the command `/issue`. The request URL should be the `/lookup` path on your application URL: for example, if your application will be hosted at `https://myworkerurl.com`, the Request URL should be `https://myworkerurl.com/lookup`.\n\n![You must create a Slash Command in Slack's dashboard and attach it to a Request URL](https://developers.cloudflare.com/_astro/create-slack-command.CBy2ieO7_Z1SByGn.webp)\n\n### Configure your GitHub Webhooks\n\nYour Cloudflare Workers application will be able to handle incoming requests from Slack. It should also be able to receive events directly from GitHub. If a GitHub issue is created or updated, you can make use of GitHub webhooks to send that event to your Workers application and post a corresponding message in Slack.\n\nTo configure a webhook:\n\n1. Go to your GitHub repository's **Settings** > **Webhooks** > **Add webhook**.\n\nIf you have a repository like `https://github.com/user/repo`, you can access the **Webhooks** page directly at `https://github.com/user/repo/settings/hooks`.\n\n1. Set the Payload URL to the `/webhook` path on your Worker URL.\n\nFor example, if your Worker will be hosted at `https://myworkerurl.com`, the Payload URL should be `https://myworkerurl.com/webhook`.\n\n1. In the **Content type** dropdown, select **application/json**.\n\nThe **Content type** for your payload can either be a URL-encoded payload (`application/x-www-form-urlencoded`) or JSON (`application/json`). For the purpose of this tutorial and to make parsing the payload sent to your application, select JSON.\n\n1. In **Which events would you like to trigger this webhook?**, select **Let me select individual events**.\n\nGitHub webhooks allow you to specify which events you would like to have sent to your webhook. By default, the webhook will send `push` events from your repository. For the purpose of this tutorial, you will choose **Let me select individual events**.\n\n1. Select the **Issues** event type.\n\nThere are many different event types that can be enabled for your webhook. Selecting **Issues** will send every issue-related event to your webhook, including when issues are opened, edited, deleted, and more. If you would like to expand your Slack bot application in the future, you can select more of these events after the tutorial.\n\n1. Select **Add webhook**.\n\n![Create a GitHub Webhook in the GitHub dashboard](https://developers.cloudflare.com/_astro/new-github-webhook.DtHDy8MC_1YzvLr.webp)\n\nWhen your webhook is created, it will attempt to send a test payload to your application. Since your application is not actually deployed yet, leave the configuration as it is. You will later return to your repository to create, edit, and close some issues to ensure that the webhook is working once your application is deployed.\n\n## Init\n\nTo initiate the project, use the command line interface [C3 (create-cloudflare-cli)](https://github.com/cloudflare/workers-sdk/tree/main/packages/create-cloudflare).\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Follow these steps to create a Hono project.\n\n* For *What would you like to start with*?, select `Framework Starter`.\n* For *Which development framework do you want to use?*, select `Hono`.\n* For, *Do you want to deploy your application?*, select `No`.\n\nGo to the `slack-bot` directory:",
      "language": "unknown"
    },
    {
      "code": "Open `src/index.ts` in an editor to find the following code.",
      "language": "unknown"
    },
    {
      "code": "This is a minimal application using Hono. If a GET access comes in on the path `/`, it will return a response with the text `Hello Hono!`. It also returns a message `404 Not Found` with status code 404 if any other path or method is accessed.\n\nTo run the application on your local machine, execute the following command.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Access to `http://localhost:8787` in your browser after the server has been started, and you can see the message.\n\nHono helps you to create your Workers application easily and quickly.\n\n## Build\n\nNow, let's create a Slack bot on Cloudflare Workers.\n\n### Separating files\n\nYou can create your application in several files instead of writing all endpoints and functions in one file. With Hono, it is able to add routing of child applications to the parent application using the function `app.route()`.\n\nFor example, imagine the following Web API application.",
      "language": "unknown"
    },
    {
      "code": "You can add the routes under `/api/v1`.",
      "language": "unknown"
    },
    {
      "code": "It will return `Posts!` when accessing `GET /api/v1/posts`.\n\nThe Slack bot will have two child applications called \"route\" each.\n\n1. `lookup` route will take requests from Slack (sent when a user uses the `/issue` command), and look up the corresponding issue using the GitHub API. This application will be added to `/lookup` in the main application.\n\n2. `webhook` route will be called when an issue changes on GitHub, via a configured webhook. This application will be add to `/webhook` in the main application.\n\nCreate the route files in a directory named `routes`.",
      "language": "unknown"
    },
    {
      "code": "Then update the main application.",
      "language": "unknown"
    },
    {
      "code": "### Defining TypeScript types\n\nBefore implementing the actual functions, you need to define the TypeScript types you will use in this project. Create a new file in the application at `src/types.ts` and write the code. `Bindings` is a type that describes the Cloudflare Workers environment variables. `Issue` is a type for a GitHub issue and `User` is a type for a GitHub user. You will need these later.",
      "language": "unknown"
    },
    {
      "code": "### Creating the lookup route\n\nStart creating the lookup route in `src/routes/lookup.ts`.",
      "language": "unknown"
    },
    {
      "code": "To understand how you should design this function, you need to understand how Slack slash commands send data to URLs.\n\nAccording to the [documentation for Slack slash commands](https://api.slack.com/interactivity/slash-commands), Slack sends an HTTP POST request to your specified URL, with a `application/x-www-form-urlencoded` content type. For example, if someone were to type `/issue cloudflare/wrangler#1`, you could expect a data payload in the format:",
      "language": "unknown"
    },
    {
      "code": "Given this payload body, you need to parse it, and get the value of the `text` key. With that `text`, for example, `cloudflare/wrangler#1`, you can parse that string into known piece of data (`owner`, `repo`, and `issue_number`), and use it to make a request to GitHub’s API, to retrieve the issue data.\n\nWith Slack slash commands, you can respond to a slash command by returning structured data as the response to the incoming slash command. In this case, you should use the response from GitHub’s API to present a formatted version of the GitHub issue, including pieces of data like the title of the issue, who created it, and the date it was created. Slack’s new [Block Kit](https://api.slack.com/block-kit) framework will allow you to return a detailed message response, by constructing text and image blocks with the data from GitHub’s API.\n\n#### Parsing slash commands\n\nTo begin, the `lookup` route should parse the messages coming from Slack. As previously mentioned, the Slack API sends an HTTP POST in URL Encoded format. You can get the variable `text` by parsing it with `c.req.json()`.",
      "language": "unknown"
    },
    {
      "code": "Given a `text` variable, that contains text like `cloudflare/wrangler#1`, you should parse that text, and get the individual parts from it for use with GitHub’s API: `owner`, `repo`, and `issue_number`.\n\nTo do this, create a new file in your application, at `src/utils/github.ts`. This file will contain a number of “utility” functions for working with GitHub’s API. The first of these will be a string parser, called `parseGhIssueString`:",
      "language": "unknown"
    },
    {
      "code": "`parseGhIssueString` takes in a `text` input, matches it against `ghIssueRegex`, and if a match is found, returns the `groups` object from that match, making use of the `owner`, `repo`, and `issue_number` capture groups defined in the regex. By exporting this function from `src/utils/github.ts`, you can make use of it back in `src/handlers/lookup.ts`:",
      "language": "unknown"
    },
    {
      "code": "#### Making requests to GitHub’s API\n\nWith this data, you can make your first API lookup to GitHub. Again, make a new function in `src/utils/github.ts`, to make a `fetch` request to the GitHub API for the issue data:",
      "language": "unknown"
    },
    {
      "code": "Back in `src/handlers/lookup.ts`, use `fetchGitHubIssue` to make a request to GitHub’s API, and parse the response:",
      "language": "unknown"
    },
    {
      "code": "#### Constructing a Slack message\n\nAfter you have received a response back from GitHub’s API, the final step is to construct a Slack message with the issue data, and return it to the user. The final result will look something like this:\n\n![A successful Slack Message will have the components listed below](https://developers.cloudflare.com/_astro/issue-slack-message.8mahQ-Ir_3k8DB.webp)\n\nYou can see four different pieces in the above screenshot:\n\n1. The first line (bolded) links to the issue, and shows the issue title\n2. The following lines (including code snippets) are the issue body\n3. The last line of text shows the issue status, the issue creator (with a link to the user’s GitHub profile), and the creation date for the issue\n4. The profile picture of the issue creator, on the right-hand side\n\nThe previously mentioned [Block Kit](https://api.slack.com/block-kit) framework will help take the issue data (in the structure lined out in [GitHub’s REST API documentation](https://developer.github.com/v3/issues/)) and format it into something like the above screenshot.\n\nCreate another file, `src/utils/slack.ts`, to contain the function `constructGhIssueSlackMessage`, a function for taking issue data, and turning it into a collection of blocks. Blocks are JavaScript objects that Slack will use to format the message:",
      "language": "unknown"
    },
    {
      "code": "Slack messages accept a variant of Markdown, which supports bold text via asterisks (`*bolded text*`), and links in the format `<https://yoururl.com|Display Text>`.\n\nGiven that format, construct `issue_link`, which takes the `html_url` property from the GitHub API `issue` data (in format `https://github.com/cloudflare/wrangler-legacy/issues/1`), and the `issue_string` sent from the Slack slash command, and combines them into a clickable link in the Slack message.\n\n`user_link` is similar, using `issue.user.html_url` (in the format `https://github.com/signalnerve`, a GitHub user) and the user’s GitHub username (`issue.user.login`), to construct a clickable link to the GitHub user.\n\nFinally, parse `issue.created_at`, an ISO 8601 string, convert it into an instance of a JavaScript `Date`, and turn it into a formatted string, in the format `MM/DD/YY`.\n\nWith those variables in place, `text_lines` is an array of each line of text for the Slack message. The first line is the **issue title** and the **issue link**, the second is the **issue body**, and the final line is the **issue state** (for example, open or closed), the **user link**, and the **creation date**.\n\nWith the text constructed, you can finally construct your Slack message, returning an array of blocks for Slack’s [Block Kit](https://api.slack.com/block-kit). In this case, there is only have one block: a [section](https://api.slack.com/reference/messaging/blocks#section) block with Markdown text, and an accessory image of the user who created the issue. Return that single block inside of an array, to complete the `constructGhIssueSlackMessage` function:",
      "language": "unknown"
    },
    {
      "code": "#### Finishing the lookup route\n\nIn `src/handlers/lookup.ts`, use `constructGhIssueSlackMessage` to construct `blocks`, and return them as a new response with `c.json()` when the slash command is called:",
      "language": "unknown"
    },
    {
      "code": "One additional parameter passed into the response is `response_type`. By default, responses to slash commands are ephemeral, meaning that they are only seen by the user who writes the slash command. Passing a `response_type` of `in_channel`, as seen above, will cause the response to appear for all users in the channel.\n\nIf you would like the messages to remain private, remove the `response_type` line. This will cause `response_type` to default to `ephemeral`.\n\n#### Handling errors\n\nThe `lookup` route is almost complete, but there are a number of errors that can occur in the route, such as parsing the body from Slack, getting the issue from GitHub, or constructing the Slack message itself. Although Hono applications can handle errors without having to do anything, you can customize the response returned in the following way.",
      "language": "unknown"
    },
    {
      "code": "### Creating the webhook route\n\nYou are now halfway through implementing the routes for your Workers application. In implementing the next route, `src/routes/webhook.ts`, you will re-use a lot of the code that you have already written for the lookup route.\n\nAt the beginning of this tutorial, you configured a GitHub webhook to track any events related to issues in your repository. When an issue is opened, for example, the function corresponding to the path `/webhook` on your Workers application should take the data sent to it from GitHub, and post a new message in the configured Slack channel.\n\nIn `src/routes/webhook.ts`, define a blank Hono application. The difference from the `lookup` route is that the `Bindings` is passed as a generics for the `new Hono()`. This is necessary to give the appropriate TypeScript type to `SLACK_WEBHOOK_URL` which will be used later.",
      "language": "unknown"
    },
    {
      "code": "Much like with the `lookup` route, you will need to parse the incoming payload inside of `request`, get the relevant issue data from it (refer to [the GitHub API documentation on `IssueEvent`](https://developer.github.com/v3/activity/events/types/#issuesevent) for the full payload schema), and send a formatted message to Slack to indicate what has changed. The final version will look something like this:\n\n![A successful Webhook Message example](https://developers.cloudflare.com/_astro/webhook_example.EQJW9q2u_16BLje.webp)\n\nCompare this message format to the format returned when a user uses the `/issue` slash command. You will see that there is only one actual difference between the two: the addition of an action text on the first line, in the format `An issue was $action:`. This action, which is sent as part of the `IssueEvent` from GitHub, will be used as you construct a very familiar looking collection of blocks using Slack’s Block Kit.\n\n#### Parsing event data\n\nTo start filling out the route, parse the request body formatted JSON into an object and construct some helper variables:",
      "language": "unknown"
    },
    {
      "code": "An `IssueEvent`, the payload sent from GitHub as part of your webhook configuration, includes an `action` (what happened to the issue: for example, it was opened, closed, locked, etc.), the `issue` itself, and the `repository`, among other things.\n\nUse `c.req.json()` to convert the payload body of the request from JSON into a plain JS object. Use ES6 destructuring to set `action`, `issue` and `repository` as variables you can use in your code. `prefix_text` is a string indicating what happened to the issue, and `issue_string` is the familiar string `owner/repo#issue_number` that you have seen before: while the `lookup` route directly used the text sent from Slack to fill in `issue_string`, you will construct it directly based on the data passed in the JSON payload.\n\n#### Constructing and sending a Slack message\n\nThe messages your Slack bot sends back to your Slack channel from the `lookup` and `webhook` routes are incredibly similar. Because of this, you can re-use the existing `constructGhIssueSlackMessage` to continue populating `src/handlers/webhook.ts`. Import the function from `src/utils/slack.ts`, and pass the issue data into it:",
      "language": "unknown"
    },
    {
      "code": "Importantly, the usage of `constructGhIssueSlackMessage` in this handler adds one additional argument to the function, `prefix_text`. Update the corresponding function inside of `src/utils/slack.ts`, adding `prefix_text` to the collection of `text_lines` in the message block, if it has been passed in to the function.\n\nAdd a utility function, `compact`, which takes an array, and filters out any `null` or `undefined` values from it. This function will be used to remove `prefix_text` from `text_lines` if it has not actually been passed in to the function, such as when called from `src/handlers/lookup.ts`. The full (and final) version of the `src/utils/slack.ts` looks like this:",
      "language": "unknown"
    },
    {
      "code": "Back in `src/handlers/webhook.ts`, the `blocks` that are returned from `constructGhIssueSlackMessage` become the body in a new `fetch` request, an HTTP POST request to a Slack webhook URL. Once that request completes, return a response with status code `200`, and the body text `\"OK\"`:",
      "language": "unknown"
    },
    {
      "code": "The constant `SLACK_WEBHOOK_URL` represents the Slack Webhook URL that you created all the way back in the [Incoming Webhook](https://developers.cloudflare.com/workers/tutorials/build-a-slackbot/#incoming-webhook) section of this tutorial.\n\nWarning\n\nSince this webhook allows developers to post directly to your Slack channel, keep it secret.\n\nTo use this constant inside of your codebase, use the [`wrangler secret`](https://developers.cloudflare.com/workers/wrangler/commands/#secret) command:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "#### Handling errors\n\nSimilarly to the `lookup` route, the `webhook` route should include some basic error handling. Unlike `lookup`, which sends responses directly back into Slack, if something goes wrong with your webhook, it may be useful to actually generate an erroneous response, and return it to GitHub.\n\nTo do this, write the custom error handler with `app.onError()` and return a new response with a status code of `500`. The final version of `src/routes/webhook.ts` looks like this:",
      "language": "unknown"
    },
    {
      "code": "## Deploy\n\nBy completing the preceding steps, you have finished writing the code for your Slack bot. You can now deploy your application.\n\nWrangler has built-in support for bundling, uploading, and releasing your Cloudflare Workers application. To do this, run the following command which will build and deploy your code.\n\n* npm",
      "language": "unknown"
    },
    {
      "code": "* yarn",
      "language": "unknown"
    },
    {
      "code": "* pnpm",
      "language": "unknown"
    },
    {
      "code": "Deploying your Workers application should now cause issue updates to start appearing in your Slack channel, as the GitHub webhook can now successfully reach your Workers webhook route:\n\n![When you create new issue, a Slackbot will now appear in your Slack channel](https://developers.cloudflare.com/images/workers/tutorials/slackbot/create-new-issue.gif)\n\n## Related resources\n\nIn this tutorial, you built and deployed a Cloudflare Workers application that can respond to GitHub webhook events, and allow GitHub API lookups within Slack. If you would like to review the full source code for this application, you can find the repository [on GitHub](https://github.com/yusukebe/workers-slack-bot).\n\nIf you want to get started building your own projects, review the existing list of [Quickstart templates](https://developers.cloudflare.com/workers/get-started/quickstarts/).\n\n</page>\n\n<page>\n---\ntitle: Connect to and query your Turso database using Workers · Cloudflare\n  Workers docs\ndescription: This tutorial will guide you on how to build globally distributed\n  applications with Cloudflare Workers, and Turso, an edge-hosted distributed\n  database based on libSQL.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\ntags: TypeScript,SQL\nsource_url:\n  html: https://developers.cloudflare.com/workers/tutorials/connect-to-turso-using-workers/\n  md: https://developers.cloudflare.com/workers/tutorials/connect-to-turso-using-workers/index.md\n---\n\nThis tutorial will guide you on how to build globally distributed applications with Cloudflare Workers, and [Turso](https://chiselstrike.com/), an edge-hosted distributed database based on libSQL. By using Workers and Turso, you can create applications that are close to your end users without having to maintain or operate infrastructure in tens or hundreds of regions.\n\nNote\n\nFor a more seamless experience, refer to the [Turso Database Integration guide](https://developers.cloudflare.com/workers/databases/third-party-integrations/turso/). The Turso Database Integration will guide you through connecting your Worker to a Turso database by securely configuring your database credentials as [secrets](https://developers.cloudflare.com/workers/configuration/secrets/) in your Worker.\n\n## Prerequisites\n\nBefore continuing with this tutorial, you should have:\n\n* Successfully [created up your first Cloudflare Worker](https://developers.cloudflare.com/workers/get-started/guide/) and/or have deployed a Cloudflare Worker before.\n* Installed [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), a command-line tool for building Cloudflare Workers.\n* A [GitHub account](https://github.com/), required for authenticating to Turso.\n* A basic familiarity with installing and using command-line interface (CLI) applications.\n\n## Install the Turso CLI\n\nYou will need the Turso CLI to create and populate a database. Run either of the following two commands in your terminal to install the Turso CLI:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h3",
      "text": "Detach a header",
      "id": "detach-a-header"
    },
    {
      "level": "h3",
      "text": "Match a path",
      "id": "match-a-path"
    },
    {
      "level": "h2",
      "text": "Footnotes",
      "id": "footnotes"
    },
    {
      "level": "h2",
      "text": "Structure",
      "id": "structure"
    },
    {
      "level": "h3",
      "text": "Per line",
      "id": "per-line"
    },
    {
      "level": "h3",
      "text": "Per file",
      "id": "per-file"
    },
    {
      "level": "h2",
      "text": "Advanced redirects",
      "id": "advanced-redirects"
    },
    {
      "level": "h2",
      "text": "Redirects and header matching",
      "id": "redirects-and-header-matching"
    },
    {
      "level": "h3",
      "text": "Splats",
      "id": "splats"
    },
    {
      "level": "h3",
      "text": "Placeholders",
      "id": "placeholders"
    },
    {
      "level": "h3",
      "text": "Proxying",
      "id": "proxying"
    },
    {
      "level": "h2",
      "text": "Surpass `_redirects` limits",
      "id": "surpass-`_redirects`-limits"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Start with a basic `package.json`",
      "id": "start-with-a-basic-`package.json`"
    },
    {
      "level": "h2",
      "text": "Install the dependencies",
      "id": "install-the-dependencies"
    },
    {
      "level": "h2",
      "text": "Create your Vite config file and include the Cloudflare plugin",
      "id": "create-your-vite-config-file-and-include-the-cloudflare-plugin"
    },
    {
      "level": "h2",
      "text": "Create your Worker config file",
      "id": "create-your-worker-config-file"
    },
    {
      "level": "h2",
      "text": "Create your Worker entry file",
      "id": "create-your-worker-entry-file"
    },
    {
      "level": "h2",
      "text": "Dev, build, preview and deploy",
      "id": "dev,-build,-preview-and-deploy"
    },
    {
      "level": "h2",
      "text": "Introduction",
      "id": "introduction"
    },
    {
      "level": "h2",
      "text": "Set up and configure the React SPA",
      "id": "set-up-and-configure-the-react-spa"
    },
    {
      "level": "h3",
      "text": "Scaffold a Vite project",
      "id": "scaffold-a-vite-project"
    },
    {
      "level": "h3",
      "text": "Add the Cloudflare dependencies",
      "id": "add-the-cloudflare-dependencies"
    },
    {
      "level": "h3",
      "text": "Add the plugin to your Vite config",
      "id": "add-the-plugin-to-your-vite-config"
    },
    {
      "level": "h3",
      "text": "Create your Worker config file",
      "id": "create-your-worker-config-file"
    },
    {
      "level": "h3",
      "text": "Update the .gitignore file",
      "id": "update-the-.gitignore-file"
    },
    {
      "level": "h3",
      "text": "Run the development server",
      "id": "run-the-development-server"
    },
    {
      "level": "h2",
      "text": "Add an API Worker",
      "id": "add-an-api-worker"
    },
    {
      "level": "h3",
      "text": "Configure TypeScript for your Worker code",
      "id": "configure-typescript-for-your-worker-code"
    },
    {
      "level": "h3",
      "text": "Add to your Worker configuration",
      "id": "add-to-your-worker-configuration"
    },
    {
      "level": "h3",
      "text": "Add your API Worker",
      "id": "add-your-api-worker"
    },
    {
      "level": "h3",
      "text": "Call the API from the client",
      "id": "call-the-api-from-the-client"
    },
    {
      "level": "h3",
      "text": "Build your application",
      "id": "build-your-application"
    },
    {
      "level": "h3",
      "text": "Preview your application",
      "id": "preview-your-application"
    },
    {
      "level": "h3",
      "text": "Deploy to Cloudflare",
      "id": "deploy-to-cloudflare"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "1. Create a new Workers project",
      "id": "1.-create-a-new-workers-project"
    },
    {
      "level": "h2",
      "text": "2. Review project details",
      "id": "2.-review-project-details"
    },
    {
      "level": "h2",
      "text": "3. Write data to KV",
      "id": "3.-write-data-to-kv"
    },
    {
      "level": "h2",
      "text": "Render data from KV",
      "id": "render-data-from-kv"
    },
    {
      "level": "h2",
      "text": "4. Add todos from the user interface (UI)",
      "id": "4.-add-todos-from-the-user-interface-(ui)"
    },
    {
      "level": "h2",
      "text": "5. Update todos from the application UI",
      "id": "5.-update-todos-from-the-application-ui"
    },
    {
      "level": "h2",
      "text": "6. Conclusion and next steps",
      "id": "6.-conclusion-and-next-steps"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "1. Create a new Workers project",
      "id": "1.-create-a-new-workers-project"
    },
    {
      "level": "h2",
      "text": "2. Handle Incoming Request",
      "id": "2.-handle-incoming-request"
    },
    {
      "level": "h2",
      "text": "3. Build a QR code generator",
      "id": "3.-build-a-qr-code-generator"
    },
    {
      "level": "h2",
      "text": "4. Test in an application UI",
      "id": "4.-test-in-an-application-ui"
    },
    {
      "level": "h2",
      "text": "5. Deploy your Worker",
      "id": "5.-deploy-your-worker"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "Set up Slack",
      "id": "set-up-slack"
    },
    {
      "level": "h3",
      "text": "Configure a Slack application",
      "id": "configure-a-slack-application"
    },
    {
      "level": "h3",
      "text": "Configure your GitHub Webhooks",
      "id": "configure-your-github-webhooks"
    },
    {
      "level": "h2",
      "text": "Init",
      "id": "init"
    },
    {
      "level": "h2",
      "text": "Build",
      "id": "build"
    },
    {
      "level": "h3",
      "text": "Separating files",
      "id": "separating-files"
    },
    {
      "level": "h3",
      "text": "Defining TypeScript types",
      "id": "defining-typescript-types"
    },
    {
      "level": "h3",
      "text": "Creating the lookup route",
      "id": "creating-the-lookup-route"
    },
    {
      "level": "h3",
      "text": "Creating the webhook route",
      "id": "creating-the-webhook-route"
    },
    {
      "level": "h2",
      "text": "Deploy",
      "id": "deploy"
    },
    {
      "level": "h2",
      "text": "Related resources",
      "id": "related-resources"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "Install the Turso CLI",
      "id": "install-the-turso-cli"
    }
  ],
  "url": "llms-txt#this-is-a-comment",
  "links": []
}