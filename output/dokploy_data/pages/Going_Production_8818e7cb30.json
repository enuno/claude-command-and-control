{
  "title": "Going Production",
  "content": "import { Callout } from 'fumadocs-ui/components/callout';\n\nBy default, dokploy offer multiple [Builds Types](/docs/core/applications/build-type) to deploy your application, the most common is `nixpacks` and `heroku buildpacks`\nhowever this also comes with problems, first is the resources that are required to build your application which some times can lead to timeout on your server or even freezeing your server\nand all your application will be down for this reasson, this is mainly problem from `Docker` since the comsumption of resources such as RAM, CPU is very high to build an application.\n\nYou have two options to solve this problem:\n\n1. Increase the resources of your server CPU, RAM, Disk (Probably is not a good idea and cheapest solution)\n2. Build & Publish the application in a CI/CD pipeline eg. Github Actions, Gitlab CI, Gitea Actions, etc. (Recommended)\n\n### Build & Publish the application in a CI/CD pipeline\n\nWe will use Github Actions as an example, but you can use any CI/CD pipeline that you want.\n\nWe will use the following configuration:\n\n1. **Use Git Provider in Your Application**:\n   * Repository: `https://github.com/Dokploy/production-example`\n   * Branch: `main`\n   * Build path: `/`\n\n<Callout type=\"info\">\n  The repo have everything you need, however you can follow the same idea for your own applications.\n</Callout>\n\n3. The repository already have a Dockerfile, so we will use that, in the case your application is different create your own Dockerfile is required for this guide.\n4. We will use `Dockerhub` as an example, but you can use any container registry that you want.\n5. Make sure to create the repository in the `Dockerhub` , `namespace` is your username and `repository` is `example`.\n6. Create a new Github Actions workflow in `.github/workflows/deploy.yml`\n7. Add the following code to the workflow:\n\n8. Create your own Dockerfile, in this case we will use the `Dockerfile` from the repository.\n\n```properties\nFROM node:18-alpine AS base\nENV PNPM_HOME=\"/pnpm\"\nENV PATH=\"$PNPM_HOME:$PATH\"\nRUN corepack enable\n\nFROM base AS build\nWORKDIR /app\nCOPY . .\nCOPY package.json pnpm-lock.yaml ./\nRUN --mount=type=cache,id=pnpm,target=/pnpm/store pnpm install --frozen-lockfile\nENV NODE_ENV=production\nRUN pnpm run build\n\nFROM base AS dokploy\nWORKDIR /app\nENV NODE_ENV=production",
  "code_samples": [
    {
      "code": "name: Build Docker images\n\non:\n  push:\n    branches: [\"main\"]\n\njobs:\n  build-and-push-dockerfile-image:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@v2\n        with:\n          username: ${{ secrets.DOCKERHUB_USERNAME }} # Make sure to add the secrets in your repository in -> Settings -> Secrets (Actions) -> New repository secret\n          password: ${{ secrets.DOCKERHUB_TOKEN }}   # Make sure to add the secrets in your repository in -> Settings -> Secrets (Actions) -> New repository secret\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v4\n        with:\n          context: .\n          file: ./Dockerfile\n          push: true\n          # Make sure to replace with your own namespace and repository\n          tags: |\n            namespace/example:latest \n          platforms: linux/amd64",
      "language": "yaml"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Solution",
      "id": "solution"
    },
    {
      "level": "h3",
      "text": "Build & Publish the application in a CI/CD pipeline",
      "id": "build-&-publish-the-application-in-a-ci/cd-pipeline"
    }
  ],
  "url": "llms-txt#going-production",
  "links": []
}