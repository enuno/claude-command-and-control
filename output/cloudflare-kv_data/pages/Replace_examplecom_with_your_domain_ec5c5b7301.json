{
  "title": "Replace example.com with your domain",
  "content": "pulumi env set $E --plaintext pulumiConfig.domain example.com\nsh\n  npm install @pulumi/cloudflare\n  sh\n  added 1 package ...\n  sh\n  npm install @pulumi/cloudflare\n  sh\n  added 1 package ...\n  sh\n  echo \"pulumi_cloudflare>=5.38,<6.0.0\" >> requirements.txt\n  source venv/bin/activate\n  pip install -r requirements.txt\n  sh\n  ...Collecting pulumi-cloudflare...\n  sh\n  go get github.com/pulumi/pulumi-cloudflare/sdk/v3/go/cloudflare\n  sh\n  go: downloading github.com/pulumi/pulumi-cloudflare ...\n  xml\n  <dependency>\n      <groupId>com.pulumi</groupId>\n      <artifactId>cloudflare</artifactId>\n      <version>5.38.0</version>\n  </dependency>\n  sh\n  mvn clean install\n  sh\n  ...[INFO] BUILD SUCCESS...\n  sh\n  dotnet add package Pulumi.Cloudflare\n  sh\n  ...\n  info : Adding PackageReference for package 'Pulumi.Cloudflare' into project\n  ...\n  javascript\n  \"use strict\";\n  const pulumi = require(\"@pulumi/pulumi\");\n  const cloudflare = require(\"@pulumi/cloudflare\");\n\nconst config = new pulumi.Config();\n  const accountId = config.require(\"accountId\");\n  const domain = config.require(\"domain\");\n\nconst content = `export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };`;\n\nconst worker = new cloudflare.WorkersScript(\"hello-world-worker\", {\n    accountId: accountId,\n    name: \"hello-world-worker\",\n    content: content,\n    module: true, // ES6 module\n  });\n  typescript\n  import * as pulumi from \"@pulumi/pulumi\";\n  import * as cloudflare from \"@pulumi/cloudflare\";\n\nconst config = new pulumi.Config();\n  const accountId = config.require(\"accountId\");\n  const domain = config.require(\"domain\");\n\nconst content = `export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };`;\n\nconst worker = new cloudflare.WorkersScript(\"hello-world-worker\", {\n    accountId: accountId,\n    name: \"hello-world-worker\",\n    content: content,\n    module: true, // ES6 module\n  });\n  python\n  \"\"\"Pulumi program \"\"\"\n  import pulumi\n  import pulumi_cloudflare as cloudflare\n\nCONFIG = pulumi.Config()\n  ACCOUNT_ID = CONFIG.get(\"accountId\")\n  DOMAIN = CONFIG.require(\"domain\")\n  CONTENT = \"\"\"\n  export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };\n  \"\"\"\n\nworker = cloudflare.WorkersScript(\"hello-world-worker\",\n      account_id=ACCOUNT_ID,\n      name=\"hello-world-worker\",\n      content=CONTENT,\n      module=True  # ES6 module\n  )\n  go\n  package main\n\nimport (\n    \"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n    \"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n    \"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n  )\n\nfunc main() {\n    pulumi.Run(func(ctx *pulumi.Context) error {\n      conf := config.New(ctx, \"\")\n      accountID := conf.Get(\"accountId\")\n      domain := conf.Get(\"domain\")\n      content := `\n      export default {\n        async fetch(request) {\n          const options = { headers: { 'content-type': 'text/plain' } };\n          return new Response(\"Hello World!\", options);\n        },\n      };\n      `\n      worker, err := cloudflare.NewWorkersScript(ctx, \"hello-world-worker\", &cloudflare.WorkersScriptArgs{\n        AccountId: pulumi.String(accountID),\n        Name:      pulumi.String(\"hello-world-worker\"),\n        Content:   pulumi.String(content),\n        Module:    pulumi.Bool(true), // ES6 module\n      })\n      if err != nil {\n        return err\n      }\n\nreturn nil\n    })\n  }\n  java\n  package myproject;\n\nimport com.pulumi.Pulumi;\n  import com.pulumi.cloudflare.WorkersScript;\n  import com.pulumi.cloudflare.WorkersScriptArgs;\n  import com.pulumi.core.Output;\n\npublic class App {\n      public static void main(String[] args) {\n          Pulumi.run(ctx -> {\n              var content = \"\"\"\n                export default {\n                  async fetch(request) {\n                    const options = { headers: { 'content-type': 'text/plain' } };\n                    return new Response(\"Hello World!\", options);\n                  },\n                };\n              \"\"\";\n\nvar accountId = ctx.config().require(\"accountId\");\n              var domain = ctx.config().require(\"domain\");\n              var worker = new WorkersScript(\"hello-world-worker\", WorkersScriptArgs.builder()\n                  .accountId(accountId)\n                  .name(\"hello-world-worker\")\n                  .content(content)\n                  .module(true)\n                  .build());\n\nreturn;\n          });\n      }\n  }\n  csharp\n  using Pulumi;\n  using Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =>\n  {\n      var config = new Config();\n      var accountId = config.Require(\"accountId\");\n      var domain = config.Require(\"domain\");\n      var content = @\"\n              export default {\n                  async fetch(request) {\n                      const options = { headers: { 'content-type': 'text/plain' } };\n                      return new Response(\"\"Hello World!\"\", options);\n                  },\n              };\n          \";\n\nvar worker = new Cloudflare.WorkersScript(\"hello-world-worker\", new()\n      {\n          AccountId = accountId,\n          Name = \"hello-world-worker\",\n          Content = content,\n          Module = true\n      });\n      return;\n  });\n  yaml\n  name: serverless-cloudflare\n  runtime: yaml\n  resources:\n    worker:\n      type: cloudflare:WorkersScript\n      properties:\n        accountId: \"${accountId}\"\n        name: \"hello-world-worker\"\n        content: |\n          export default {\n              async fetch(request) {\n                  const options = { headers: { 'content-type': 'text/plain' } };\n                  return new Response(\"Hello World!\", options);\n              },\n          };\n        module: true\n  javascript\n  const zone = cloudflare.getZone({\n    accountId: accountId,\n    name: domain,\n  });\n\nconst zoneId = zone.then((z) => z.zoneId);\n\nconst route = new cloudflare.WorkersRoute(\"hello-world-route\", {\n    zoneId: zoneId,\n    pattern: \"hello-world.\" + domain,\n    scriptName: worker.name,\n  });\n  typescript\n  const zone = cloudflare.getZone({\n    accountId: accountId,\n    name: domain,\n  });\n\nconst zoneId = zone.then((z) => z.zoneId);\n\nconst route = new cloudflare.WorkersRoute(\"hello-world-route\", {\n    zoneId: zoneId,\n    pattern: \"hello-world.\" + domain,\n    scriptName: worker.name,\n  });\n  python\n  zone = cloudflare.get_zone(account_id=ACCOUNT_ID, name=DOMAIN)\n  zone_id = zone.zone_id\n  route = cloudflare.WorkersRoute(\"hello-world-route\",\n      zone_id=zone_id,\n      pattern=\"hello-world.\" + DOMAIN,\n      script_name=worker.name\n  )\n  go\n  zone, err := cloudflare.LookupZone(ctx, &cloudflare.LookupZoneArgs{\n    AccountId: &accountID,\n    Name:      &domain,\n  }, nil)\n  if err != nil {\n    return err\n  }\n\nroute, err := cloudflare.NewWorkersRoute(ctx, \"hello-world-route\", &cloudflare.WorkersRouteArgs{\n    ZoneId:     pulumi.String(zone.Id),\n    Pattern:    pulumi.String(\"hello-world.\" + domain),\n    ScriptName: worker.Name,\n  })\n  if err != nil {\n    return err\n  }\n  java\n  final var zone = CloudflareFunctions.getZone(GetZoneArgs.builder()\n    .accountId(accountId)\n    .name(domain)\n    .build());\n  var route = new WorkersRoute(\"hello-world-route\", WorkersRouteArgs.builder()\n    .zoneId(zone.applyValue(getZoneResult -> getZoneResult.id()))\n    .pattern(\"hello-world.\" + domain)\n    .scriptName(worker.name())\n    .build());\n  csharp\n  var zone = Output.Create(Cloudflare.GetZone.InvokeAsync(new()\n  {\n      AccountId = accountId,\n      Name = domain,\n  }));\n  var route = new Cloudflare.WorkersRoute(\"hello-world-route\", new()\n  {\n      ZoneId = zone.Apply(z => z.Id),\n      Pattern = \"hello-world.\" + domain,\n      ScriptName = worker.Name,\n  });\n  yaml\n  # new top-level section\n  variables:\n    zone:\n      fn::invoke:\n        function: cloudflare:getZone\n        arguments:\n          accountId: ${accountId}\n          name: ${domain}\n  yaml\n  route:\n    type: cloudflare:WorkersRoute\n    properties:\n      zoneId: ${zone.id}\n      pattern: \"hello-world.${domain}\"\n      scriptName: ${worker.name}\n  javascript\n  const record = new cloudflare.Record(\"hello-world-record\", {\n    name: route.pattern,\n    type: \"A\",\n    content: \"192.0.2.1\",\n    zoneId: zoneId,\n    proxied: true,\n  });\n\nexports.url = pulumi.interpolate`https://${record.hostname}`;\n  typescript\n  const record = new cloudflare.Record(\"hello-world-record\", {\n    name: route.pattern,\n    type: \"A\",\n    content: \"192.0.2.1\",\n    zoneId: zoneId,\n    proxied: true,\n  });\n\nexport const url = pulumi.interpolate`https://${record.hostname}`;\n  python\n  record = cloudflare.Record(\"hello-world-record\",\n      name=route.pattern,\n      type=\"A\",\n      content=\"192.0.2.1\",\n      zone_id=zone_id,\n      proxied=True\n  )\n\nurl = pulumi.Output.concat(\"https://\", record.hostname)\n  pulumi.export('url', url)\n  go\n  record, err := cloudflare.NewRecord(ctx, \"hello-world-record\", &cloudflare.RecordArgs{\n    Name:    route.Pattern,\n    Type:    pulumi.String(\"A\"),\n    Content: pulumi.String(\"192.0.2.1\"),\n    ZoneId:  pulumi.String(zone.Id),\n    Proxied: pulumi.Bool(true),\n  })\n  if err != nil {\n    return err\n  }\n\nctx.Export(\"url\", pulumi.Sprintf(\"https://%s\", record.Hostname))\n  java\n  var record = new Record(\"hello-world-record\", RecordArgs.builder()\n      .name(route.pattern())\n      .type(\"A\")\n      .content(\"192.0.2.1\")\n      .zoneId(zone.applyValue(getZoneResult -> getZoneResult.id()))\n      .proxied(true)\n      .build());\n\nctx.export(\"url\", Output.format(\"https://%s\", record.hostname()));\n  csharp\n  var record = new Cloudflare.Record(\"hello-world-record\", new()\n  {\n      Name = route.Pattern,\n      Type = \"A\",\n      Content = \"192.0.2.1\",\n      ZoneId = zone.Apply(z => z.Id),\n      Proxied = true\n  });\n\nreturn new Dictionary<string, object?>\n  {\n      [\"url\"] = Output.Format($\"https://{record.Hostname}\")\n  };\n  yaml\n    record:\n      type: cloudflare:Record\n      properties:\n        name: ${route.pattern}\n        type: A\n        content: \"192.0.2.1\"\n        zoneId: ${zone.id}\n        proxied: true\n\noutputs:\n    url: \"https://${record.hostname}\"\n  javascript\n  \"use strict\";\n  const pulumi = require(\"@pulumi/pulumi\");\n  const cloudflare = require(\"@pulumi/cloudflare\");\n\nconst config = new pulumi.Config();\n  const accountId = config.require(\"accountId\");\n  const domain = config.require(\"domain\");\n\nconst content = `export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };`;\n\nconst worker = new cloudflare.WorkersScript(\"hello-world-worker\", {\n    accountId: accountId,\n    name: \"hello-world-worker\",\n    content: content,\n    module: true, // ES6 module\n  });\n\nconst zone = cloudflare.getZone({\n    accountId: accountId,\n    name: domain,\n  });\n\nconst zoneId = zone.then((z) => z.zoneId);\n\nconst route = new cloudflare.WorkersRoute(\"hello-world-route\", {\n    zoneId: zoneId,\n    pattern: \"hello-world.\" + domain,\n    scriptName: worker.name,\n  });\n\nconst record = new cloudflare.Record(\"hello-world-record\", {\n    name: route.pattern,\n    type: \"A\",\n    content: \"192.0.2.1\",\n    zoneId: zoneId,\n    proxied: true,\n  });\n\nexports.url = pulumi.interpolate`https://${record.hostname}`;\n  typescript\n  import * as pulumi from \"@pulumi/pulumi\";\n  import * as cloudflare from \"@pulumi/cloudflare\";\n\nconst config = new pulumi.Config();\n  const accountId = config.require(\"accountId\");\n  const domain = config.require(\"domain\");\n\nconst content = `export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };`;\n\nconst worker = new cloudflare.WorkersScript(\"hello-world-worker\", {\n    accountId: accountId,\n    name: \"hello-world-worker\",\n    content: content,\n    module: true, // ES6 module\n  });\n\nconst zone = cloudflare.getZone({\n    accountId: accountId,\n    name: domain,\n  });\n\nconst zoneId = zone.then((z) => z.zoneId);\n\nconst route = new cloudflare.WorkersRoute(\"hello-world-route\", {\n    zoneId: zoneId,\n    pattern: \"hello-world.\" + domain,\n    scriptName: worker.name,\n  });\n\nconst record = new cloudflare.Record(\"hello-world-record\", {\n    name: route.pattern,\n    type: \"A\",\n    content: \"192.0.2.1\",\n    zoneId: zoneId,\n    proxied: true,\n  });\n\nexport const url = pulumi.interpolate`https://${record.hostname}`;\n  python\n  \"\"\"Pulumi program \"\"\"\n  import pulumi\n  import pulumi_cloudflare as cloudflare\n\nCONFIG = pulumi.Config()\n  ACCOUNT_ID = CONFIG.get(\"accountId\")\n  DOMAIN = CONFIG.require(\"domain\")\n  CONTENT = \"\"\"\n  export default {\n    async fetch(request) {\n      const options = { headers: { 'content-type': 'text/plain' } };\n      return new Response(\"Hello World!\", options);\n    },\n  };\n  \"\"\"\n\nworker = cloudflare.WorkersScript(\"hello-world-worker\",\n      account_id=ACCOUNT_ID,\n      name=\"hello-world-worker\",\n      content=CONTENT,\n      module=True  # ES6 module\n  )\n\nzone = cloudflare.get_zone(account_id=ACCOUNT_ID, name=DOMAIN)\n  zone_id = zone.zone_id\n  route = cloudflare.WorkersRoute(\"hello-world-route\",\n      zone_id=zone_id,\n      pattern=\"hello-world.\" + DOMAIN,\n      script_name=worker.name\n  )\n\nrecord = cloudflare.Record(\"hello-world-record\",\n      name=route.pattern,\n      type=\"A\",\n      content=\"192.0.2.1\",\n      zone_id=zone_id,\n      proxied=True\n  )\n\nurl = pulumi.Output.concat(\"https://\", record.hostname)\n  pulumi.export('url', url)\n  go\n  package main\n\nimport (\n    \"github.com/pulumi/pulumi-cloudflare/sdk/v5/go/cloudflare\"\n    \"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n    \"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config\"\n  )\n\nfunc main() {\n    pulumi.Run(func(ctx *pulumi.Context) error {\n      conf := config.New(ctx, \"\")\n      accountID := conf.Get(\"accountId\")\n      domain := conf.Get(\"domain\")\n      content := `\n      export default {\n        async fetch(request) {\n          const options = { headers: { 'content-type': 'text/plain' } };\n          return new Response(\"Hello World!\", options);\n        },\n      };\n      `\n      worker, err := cloudflare.NewWorkersScript(ctx, \"hello-world-worker\", &cloudflare.WorkersScriptArgs{\n        AccountId: pulumi.String(accountID),\n        Name:      pulumi.String(\"hello-world-worker\"),\n        Content:   pulumi.String(content),\n        Module:    pulumi.Bool(true), // ES6 module\n      })\n      if err != nil {\n        return err\n      }\n      zone, err := cloudflare.LookupZone(ctx, &cloudflare.LookupZoneArgs{\n        AccountId: &accountID,\n        Name:      &domain,\n      }, nil)\n      if err != nil {\n        return err\n      }\n\nroute, err := cloudflare.NewWorkersRoute(ctx, \"hello-world-route\", &cloudflare.WorkersRouteArgs{\n        ZoneId:     pulumi.String(zone.Id),\n        Pattern:    pulumi.String(\"hello-world.\" + domain),\n        ScriptName: worker.Name,\n      })\n      if err != nil {\n        return err\n      }\n\nrecord, err := cloudflare.NewRecord(ctx, \"hello-world-record\", &cloudflare.RecordArgs{\n        Name:    route.Pattern,\n        Type:    pulumi.String(\"A\"),\n        Content: pulumi.String(\"192.0.2.1\"),\n        ZoneId:  pulumi.String(zone.Id),\n        Proxied: pulumi.Bool(true),\n      })\n      if err != nil {\n        return err\n      }\n\nctx.Export(\"url\", pulumi.Sprintf(\"https://%s\", record.Hostname))\n\nreturn nil\n    })\n  }\n  java\n  package myproject;\n\nimport com.pulumi.Pulumi;\n  import com.pulumi.core.Output;\n  import com.pulumi.cloudflare.WorkersScript;\n  import com.pulumi.cloudflare.WorkersScriptArgs;\n  import com.pulumi.cloudflare.CloudflareFunctions;\n  import com.pulumi.cloudflare.inputs.GetZoneArgs;\n  import com.pulumi.cloudflare.WorkersRoute;\n  import com.pulumi.cloudflare.WorkersRouteArgs;\n  import com.pulumi.cloudflare.Record;\n  import com.pulumi.cloudflare.RecordArgs;\n\npublic class App {\n      public static void main(String[] args) {\n          Pulumi.run(ctx -> {\n              var content = \"\"\"\n          export default {\n            async fetch(request) {\n              const options = { headers: { 'content-type': 'text/plain' } };\n              return new Response(\"Hello World!\", options);\n            },\n          };\n        \"\"\";\n\nvar accountId = ctx.config().require(\"accountId\");\n              var domain = ctx.config().require(\"domain\");\n\nvar worker = new WorkersScript(\"hello-world-worker\", WorkersScriptArgs.builder()\n                  .accountId(accountId)\n                  .name(\"hello-world-worker\")\n                  .content(content)\n                  .module(true)\n                  .build());\n              final var zone = CloudflareFunctions.getZone(GetZoneArgs.builder()\n                  .accountId(accountId)\n                  .name(domain)\n                  .build());\n              var route = new WorkersRoute(\"hello-world-route\", WorkersRouteArgs.builder()\n                  .zoneId(zone.applyValue(getZoneResult -> getZoneResult.id()))\n                  .pattern(\"hello-world.\" + domain)\n                  .scriptName(worker.name())\n                  .build());\n              var record = new Record(\"hello-world-record\", RecordArgs.builder()\n                  .name(route.pattern())\n                  .type(\"A\")\n                  .content(\"192.0.2.1\")\n                  .zoneId(zone.applyValue(getZoneResult -> getZoneResult.id()))\n                  .proxied(true)\n                  .build());\n\nctx.export(\"url\", Output.format(\"https://%s\", record.hostname()));\n              return;\n          });\n      }\n  }\n  csharp\n  using System.Collections.Generic;\n  using Pulumi;\n  using Cloudflare = Pulumi.Cloudflare;\n\nreturn await Deployment.RunAsync(() =>\n  {\n      var config = new Config();\n      var accountId = config.Require(\"accountId\");\n      var domain = config.Require(\"domain\");\n      var content = @\"\n              export default {\n                  async fetch(request) {\n                      const options = { headers: { 'content-type': 'text/plain' } };\n                      return new Response(\"\"Hello World!\"\", options);\n                  },\n              };\n          \";\n\nvar worker = new Cloudflare.WorkersScript(\"hello-world-worker\", new()\n      {\n          AccountId = accountId,\n          Name = \"hello-world-worker\",\n          Content = content,\n          Module = true\n      });\n      var zone = Output.Create(Cloudflare.GetZone.InvokeAsync(new()\n      {\n          AccountId = accountId,\n          Name = domain,\n      }));\n      var route = new Cloudflare.WorkersRoute(\"hello-world-route\", new()\n      {\n          ZoneId = zone.Apply(z => z.Id),\n          Pattern = \"hello-world.\" + domain,\n          ScriptName = worker.Name,\n      });\n\nvar record = new Cloudflare.Record(\"hello-world-record\", new()\n      {\n          Name = route.Pattern,\n          Type = \"A\",\n          Content = \"192.0.2.1\",\n          ZoneId = zone.Apply(z => z.Id),\n          Proxied = true\n      });\n\nreturn new Dictionary<string, object?>\n      {\n          [\"url\"] = Output.Format($\"https://{record.Hostname}\")\n      };\n  });\n  yaml\n  name: serverless-cloudflare\n  runtime: yaml\n  variables:\n    zone:\n      fn::invoke:\n        function: cloudflare:getZone\n        arguments:\n          accountId: ${accountId}\n          name: ${domain}\n\nresources:\n    worker:\n      type: cloudflare:WorkersScript\n      properties:\n        accountId: \"${accountId}\"\n        name: \"hello-world-worker\"\n        content: |\n          export default {\n              async fetch(request) {\n                  const options = { headers: { 'content-type': 'text/plain' } };\n                  return new Response(\"Hello World!\", options);\n              },\n          };\n        module: true\n    route:\n      type: cloudflare:WorkersRoute\n      properties:\n        zoneId: ${zone.id}\n        pattern: \"hello-world.${domain}\"\n        scriptName: ${worker.name}\n    record:\n      type: cloudflare:Record\n      properties:\n        name: ${route.pattern}\n        type: A\n        content: \"192.0.2.1\"\n        zoneId: ${zone.id}\n        proxied: true\n\noutputs:\n    url: \"https://${record.hostname}\"\n  sh\npulumi up --yes\nsh\nwait for the dev stack to become ready\nsh\ncurl $(pulumi stack output url)\nsh\nHello, World!\nsh\npulumi destroy\nsh\npulumi stack rm dev\nsh\nesc login\nsh\nLogged in to pulumi.com as  ....\nsh\nESC_ENV=wrangler/my-dev-environment\nesc env init $ESC_ENV\nsh\nEnvironment created.\nsh\nesc env set $ESC_ENV environmentVariables.CLOUDFLARE_ACCOUNT_ID 123abc\nesc env set $ESC_ENV environmentVariables.CLOUDFLARE_API_TOKEN  123abc --secret\nsh\nnpx wrangler logout\nsh\nNot logged in, exiting...\nsh\nesc run ${ESC_ENV} npx wrangler whoami\nsh\nGetting User settings...\nðŸ‘‹ You are logged in with an API Token.\nsh\nesc env set ${ESC_ENV} environementVariables.TOP_SECRET \"aliens are real\" --secret\nsh\nesc run -i ${ESC_ENV} -- sh -c 'echo \"$TOP_SECRET\" | npx wrangler secret put TOP_SECRET'\nsh\nE=wrangler/my-devvars\nesc env init $E\nsh\nEnvironment created.\nsh\nesc env set $E environmentVariables.TOP_SECRET  \"the moon is made of cheese\" --secret\nsh\nesc env open ${E} --format dotenv > .dev.vars\nsh\nnpx wrangler queues update <QUEUE-NAME> --delivery-delay-secs 60 --message-retention-period-secs 3000\njsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"queues\": {\n      \"producers\": [\n        {\n          \"queue\": \"my-queue\",\n          \"binding\": \"MY_QUEUE\"\n        }\n      ]\n    }\n  }\n  toml\n  [[queues.producers]]\n    queue = \"my-queue\"\n    binding = \"MY_QUEUE\"\n  jsonc\n  {\n    \"$schema\": \"./node_modules/wrangler/config-schema.json\",\n    \"queues\": {\n      \"consumers\": [\n        {\n          \"queue\": \"my-queue\",\n          \"max_batch_size\": 10,\n          \"max_batch_timeout\": 30,\n          \"max_retries\": 10,\n          \"dead_letter_queue\": \"my-queue-dlq\"\n        }\n      ]\n    }\n  }\n  toml\n  [[queues.consumers]]\n    queue = \"my-queue\"\n    max_batch_size = 10\n    max_batch_timeout = 30\n    max_retries = 10\n    dead_letter_queue = \"my-queue-dlq\"\n  js\n  export default {\n    async queue(batch, env, ctx) {\n      for (const msg of batch.messages) {\n        // TODO: do something with the message\n        // Explicitly acknowledge the message as delivered\n        msg.ack();\n      }\n    },\n  };\n  ts\n  export default {\n    async queue(batch: MessageBatch, env: Env, ctx: ExecutionContext) {\n      for (const msg of batch.messages) {\n        // TODO: do something with the message\n        // Explicitly acknowledge the message as delivered\n        msg.ack();\n      }\n    },\n  };\n  python\n  from workers import WorkerEntrypoint\n\nclass Default(WorkerEntrypoint):\n      async def queue(self, batch):\n          for msg in batch.messages:\n              # TODO: do something with the message\n              # Explicitly acknowledge the message as delivered\n              msg.ack()\n  js\n  export default {\n    async queue(batch, env, ctx) {\n      for (const msg of batch.messages) {\n        // TODO: do something with the message that fails\n        msg.retry();\n      }\n    },\n  };\n  ts\n  export default {\n    async queue(batch: MessageBatch, env: Env, ctx: ExecutionContext) {\n      for (const msg of batch.messages) {\n        // TODO: do something with the message that fails\n        msg.retry();\n      }\n    },\n  };\n  python\n  from workers import WorkerEntrypoint\n\nclass Default(WorkerEntrypoint):\n      async def queue(self, batch):\n          for msg in batch.messages:\n              # TODO: do something with the message that fails\n              msg.retry()\n  js\n  // Delay a singular message by 600 seconds (10 minutes)\n  await env.YOUR_QUEUE.send(message, { delaySeconds: 600 });\n\n// Delay a batch of messages by 300 seconds (5 minutes)\n  await env.YOUR_QUEUE.sendBatch(messages, { delaySeconds: 300 });\n\n// Do not delay this message.\n  // If there is a global delay configured on the queue, ignore it.\n  await env.YOUR_QUEUE.sendBatch(messages, { delaySeconds: 0 });\n  ts\n  // Delay a singular message by 600 seconds (10 minutes)\n  await env.YOUR_QUEUE.send(message, { delaySeconds: 600 });\n\n// Delay a batch of messages by 300 seconds (5 minutes)\n  await env.YOUR_QUEUE.sendBatch(messages, { delaySeconds: 300 });\n\n// Do not delay this message.\n  // If there is a global delay configured on the queue, ignore it.\n  await env.YOUR_QUEUE.sendBatch(messages, { delaySeconds: 0 });\n  python\n  # Delay a singular message by 600 seconds (10 minutes)\n  await env.YOUR_QUEUE.send(message, delaySeconds=600)\n\n# Delay a batch of messages by 300 seconds (5 minutes)\n  await env.YOUR_QUEUE.sendBatch(messages, delaySeconds=300)\n\n# Do not delay this message.\n  # If there is a global delay configured on the queue, ignore it.\n  await env.YOUR_QUEUE.sendBatch(messages, delaySeconds=0)\n  sh",
  "code_samples": [
    {
      "code": "### f. Install the Cloudflare package\n\nYou need to install the Cloudflare package for your language of choice in order to define Cloudflare resources in your Pulumi program.\n\nInstall the Cloudflare package by running the following command:\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* go",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* Java\n\n  Below are Apache Maven instructions. For other Java project managers such as Gradle, see the official [Maven repository](https://central.sonatype.com/artifact/com.pulumi/cloudflare/overview)\n\n  1. Open your `pom.xml` file.\n  2. Add the Pulumi Cloudflare dependency inside the `<dependencies>` section.",
      "language": "unknown"
    },
    {
      "code": "1. Run:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* .NET",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "* YAML\n\n  There are no dependencies to download for YAML. Skip ahead.\n\n## 2. Define Cloudflare resources in code\n\nWith the Cloudflare package installed, you can now define any [supported Cloudflare resource](https://www.pulumi.com/registry/packages/cloudflare/) in your Pulumi program. Next, define a Worker, a Route, and a DNS Record.\n\n### a. Add a Workers script\n\nThe [Workers Script resource](https://www.pulumi.com/registry/packages/cloudflare/api-docs/workersscript/) represents a Cloudflare Worker that can be deployed to the Cloudflare network.\n\nReplace the contents of your entrypoint file with the following:\n\n* JavaScript\n\n  **Filename: `index.js`**",
      "language": "unknown"
    },
    {
      "code": "* TypeScript\n\n  **Filename: `index.ts`**",
      "language": "unknown"
    },
    {
      "code": "* Python\n\n  **Filename: `__main__.py`**",
      "language": "unknown"
    },
    {
      "code": "* go\n\n  **Filename: `main.go`**",
      "language": "unknown"
    },
    {
      "code": "* Java\n\n  **Filename: `src/main/java/myproject/App.java`**",
      "language": "unknown"
    },
    {
      "code": "* .NET\n\n  **Filename: `Program.cs`**",
      "language": "unknown"
    },
    {
      "code": "* YAML\n\n  **Filename: `Pulumi.yaml`**",
      "language": "unknown"
    },
    {
      "code": "### b. Add a Route\n\nYou will now add a [Workers Route resource](https://www.pulumi.com/registry/packages/cloudflare/api-docs/workersroute/) to your Pulumi program so the Workers script can have an endpoint and be active. To properly configure the Route, you will also look up the zone ID for your domain.\n\nAdd the following code snippet to your entrypoint file **after** the Worker script resource:\n\n* JavaScript\n\n  **Filename: `index.js`**",
      "language": "unknown"
    },
    {
      "code": "* TypeScript\n\n  **Filename: `index.ts`**",
      "language": "unknown"
    },
    {
      "code": "* Python\n\n  **Filename: `__main__.py`**",
      "language": "unknown"
    },
    {
      "code": "* go\n\n  **Filename: `main.go`**",
      "language": "unknown"
    },
    {
      "code": "* Java\n\n  **Filename: `src/main/java/myproject/App.java`**",
      "language": "unknown"
    },
    {
      "code": "* .NET\n\n  **Filename: `Program.cs`**",
      "language": "unknown"
    },
    {
      "code": "* YAML\n\n  **Filename: `Pulumi.yaml`**\n\n  Below the `runtime` key, add the following code:",
      "language": "unknown"
    },
    {
      "code": "Below the `worker` resource, add the following code:",
      "language": "unknown"
    },
    {
      "code": "### c. Add a DNS Record\n\nYou will now add a DNS [Record resource](https://www.pulumi.com/registry/packages/cloudflare/api-docs/record/) to resolve the previously configured Route. In the next step, you'll also output the Route URL so it can be easily accessed.\n\nAdd the following code snippet to your entrypoint file **after** the Route resource:\n\n* JavaScript\n\n  **Filename: `index.js`**",
      "language": "unknown"
    },
    {
      "code": "* TypeScript\n\n  **Filename: `index.ts`**",
      "language": "unknown"
    },
    {
      "code": "* Python\n\n  **Filename: `__main__.py`**",
      "language": "unknown"
    },
    {
      "code": "* go\n\n  **Filename: `main.go`**",
      "language": "unknown"
    },
    {
      "code": "* Java\n\n  **Filename: `src/main/java/myproject/App.java`**",
      "language": "unknown"
    },
    {
      "code": "* .NET\n\n  **Filename: `Program.cs`**\n\n  Notice the updated ' return ' statement because you're now exporting a value. Ensure that you also include `using System.Collections.Generic;` in your imports.",
      "language": "unknown"
    },
    {
      "code": "* YAML\n\n  Notice the new top-level `outputs` section.",
      "language": "unknown"
    },
    {
      "code": "Note\n\nYou may need to use `http` instead depending on your domain settings.\n\n### d. (Optional) Verify your code\n\nConfirm all your changes match the full solution below:\n\n* JavaScript\n\n  **Filename: `index.js`**",
      "language": "unknown"
    },
    {
      "code": "* TypeScript\n\n  **Filename: `index.ts`**",
      "language": "unknown"
    },
    {
      "code": "* Python\n\n  **Filename: `__main__.py`**",
      "language": "unknown"
    },
    {
      "code": "* go\n\n  **Filename: `main.go`**",
      "language": "unknown"
    },
    {
      "code": "* Java\n\n  **Filename: `src/main/java/myproject/App.java`**",
      "language": "unknown"
    },
    {
      "code": "* .NET\n\n  **Filename: `Program.cs`**",
      "language": "unknown"
    },
    {
      "code": "* YAML\n\n  **Filename: `Pulumi.yaml`**",
      "language": "unknown"
    },
    {
      "code": "## 3. Deploy your application\n\nNow that you have defined all the Cloudflare resources, you can deploy the Hello World application to your Cloudflare account using the Pulumi CLI.\n\nTo deploy the changes, run:",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## 4. Test the Worker\n\nYou incrementally added Cloudflare resources to run and access your Hello World application. You can test your application by curling the `url` output from the Pulumi stack.",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## 5. Clean up\n\nIn this last step, you will clean up the resources and stack used throughout the tutorial.\n\n### a. Delete the Cloudflare resources",
      "language": "unknown"
    },
    {
      "code": "### b. Remove the Pulumi stack",
      "language": "unknown"
    },
    {
      "code": "## Next steps\n\nVisit the [Cloudflare package documentation](https://www.pulumi.com/docs/reference/pkg/cloudflare/) to explore other resources you can define with Pulumi and Cloudflare.\n\n</page>\n\n<page>\n---\ntitle: Manage secrets with Pulumi ESC Â· Pulumi docs\ndescription: Pulumi ESC (Environments, Secrets, and Configuration) is a secure\n  and robust secrets management solution. The tutorial will walk you through how\n  to develop with Wrangler while following security best practices.\nlastUpdated: 2025-10-09T15:47:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/pulumi/tutorial/manage-secrets/\n  md: https://developers.cloudflare.com/pulumi/tutorial/manage-secrets/index.md\n---\n\nIn this tutorial, you will receive step-by-step instructions on using Pulumi ESC (Environments, Secrets, and Configuration), which is a secure and robust secrets management solution.\n\nThe tutorial will walk you through how to develop with Wrangler while following security best practices.\n\nSpecifically, you will learn how to manage your `CLOUDFLARE_API_TOKEN` for logging in to your Cloudflare account, pass ESC-stored secrets to Workers, and programmatically load your `.dev.vars` file.\n\nNote\n\nYou will provision resources that qualify under free tier offerings for both Pulumi Cloud and Cloudflare.\n\n## Before you begin\n\nEnsure you have:\n\n* A Cloudflare account. [Sign up for a Cloudflare account](https://www.cloudflare.com/sign-up).\n* A Pulumi Cloud account. [Sign up for a Pulumi Cloud](https://app.pulumi.com/signup).\n* The [Pulumi ESC CLI](https://www.pulumi.com/docs/install/esc/) installed.\n* A Wrangler project. To create one, follow the [Create a New Worker project step](https://developers.cloudflare.com/workers/get-started/guide/#1-create-a-new-worker-project).\n\n## 1. Set up a new Environment\n\nA [Pulumi ESC Environment](https://www.pulumi.com/docs/esc/environments/), or Environment, is a YAML file containing configurations and secrets for your application and infrastructure. These can be accessed in several ways, including shell commands. All ESC Environments reside in your Pulumi Cloud account.\n\n### a. Log in to Pulumi Cloud\n\nUse the Pulumi ESC CLI to log into your Pulumi Cloud account.",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### b. Create a new Environment\n\nNote\n\nEnvironment names must be unique within a Pulumi organization and may only contain alphanumeric characters, hyphens, underscores, and periods.",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "## 2. Log into Cloudflare\n\nNow that the Pulumi ESC Environment has been created, it can be consumed in various ways. For instance, to log into your Cloudflare account without needing to predefine credentials in your shell.\n\n### a. Add your credentials\n\nBy externally and securely storing your `CLOUDFLARE_API_TOKEN`, you can control access and rotate the token value. We will run `wrangler` in non-interactive mode, which requires:\n\n* Your Cloudflare [account ID](https://developers.cloudflare.com/fundamentals/account/find-account-and-zone-ids/)\n* A valid Cloudflare API [token](https://developers.cloudflare.com/fundamentals/api/get-started/create-token/)\n\nReplace the placeholder `123abc` with your corresponding values:",
      "language": "unknown"
    },
    {
      "code": "Note\n\nThe API token is declared as a `secret`. Once the Environment is saved, Pulumi will encrypt its value and replace it with ciphertext.\n\n### b. Log out\n\nEnsure you're not currently logged in to your Cloudflare account.",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### c. Log in\n\nPass ESC-stored Cloudflare credentials to Wrangler.",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "When you use the `esc run` command, it opens the Environment and sets the specified Environment variables into a temporary environment. After that, it uses those variables in the context of the `wrangler` command. This is especially helpful when running `wrangler` commands in a CI/CD environment but wanting to avoid storing credentials directly in your pipeline.\n\n## 3. Add Worker secrets\n\nPulumi ESC centralizes secrets, and Wrangler can be used to pass them on to Workers and other Cloudflare resources. You will use the `wrangler secret put` command for this purpose.\n\n### a. Add a secret",
      "language": "unknown"
    },
    {
      "code": "### b. Pass the secret to your Worker",
      "language": "unknown"
    },
    {
      "code": "By using an external secrets management solution, commonly used Worker secrets can be stored in a single shared Environment that is accessed by the relevant Workers. You can use shell commands with `esc` to incorporate scripting and integrate them into deployment pipelines or `make` commands. Use `esc [command] --help` for more information about the various commands available in the CLI.\n\n## 4. Load `.dev.vars`\n\nIn this step, you will configure an Environment to load your `.dev.vars` file programmatically.\n\nNote\n\nThe `.dev.vars` file is located in the root of your Wrangler project to define secrets used when running `wrangler dev`. For more information, refer to [Local Development with Secrets](https://developers.cloudflare.com/workers/configuration/secrets/#local-development-with-secrets).\n\nWith a dedicated ESC Environment to store all the `.dev.vars` secrets, you can use a `dotenv` export flag.\n\n### a. Create an Environment",
      "language": "unknown"
    },
    {
      "code": "",
      "language": "unknown"
    },
    {
      "code": "### b. Add a secret",
      "language": "unknown"
    },
    {
      "code": "### c. Generate the `.dev.vars` file",
      "language": "unknown"
    },
    {
      "code": "As `.dev.vars` files may often contain secrets, they should not be committed to source control. Keeping these secrets externally ensures you can load them to a new development environment without any loss.\n\n## Next steps\n\nYou have configured Pulumi ESC Environments to load secrets for Wrangler commands, enhancing security during development with Wrangler. The externalized secrets are now reusable across Workers. [Learn more about Pulumi ESC features and integrations](https://www.pulumi.com/docs/esc/) or follow the [Deploy a Worker with Pulumi](https://developers.cloudflare.com/pulumi/tutorial/hello-world/) tutorial.\n\n</page>\n\n<page>\n---\ntitle: Legal Â· Cloudflare Privacy Gateway docs\ndescription: Privacy Gateway is a managed gateway service deployed on\n  Cloudflareâ€™s global network that implements the Oblivious HTTP IETF standard\n  to improve client privacy when connecting to an application backend.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/privacy-gateway/reference/legal/\n  md: https://developers.cloudflare.com/privacy-gateway/reference/legal/index.md\n---\n\nPrivacy Gateway is a managed gateway service deployed on Cloudflareâ€™s global network that implements the Oblivious HTTP IETF standard to improve client privacy when connecting to an application backend.\n\nOHTTP introduces a trusted third party (Cloudflare in this case), called a relay, between client and server. The relayâ€™s purpose is to forward requests from client to server, and likewise to forward responses from server to client. These messages are encrypted between client and server such that the relay learns nothing of the application data, beyond the server the client is interacting with.\n\nThe Privacy Gateway service follows [Cloudflareâ€™s privacy policy](https://www.cloudflare.com/privacypolicy/).\n\n## What Cloudflare sees\n\nWhile Cloudflare will never see the contents of the encrypted application HTTP request proxied through the Privacy Gateway service â€“ because the client will first connect to the OHTTP relay server operated in Cloudflareâ€™s global networkâ€“ Cloudflare will see the following information: the connecting deviceâ€™s IP address, the application service they are using, including its DNS name and IP address, and metadata associated with the request, including the type of browser, device operating system, hardware configuration, and timestamp of the request (\"Privacy Gateway Logs\").\n\n## What Cloudflare stores\n\nCloudflare retains the Privacy Gateway Logs information for the most recent quarter plus one month (approximately 124 days).\n\n## What Privacy Gateway customers see\n\n* The application content of requests.\n* The IP address and associated metadata of the Cloudflare Privacy Gateway server the request came from.\n\n</page>\n\n<page>\n---\ntitle: Limitations Â· Cloudflare Privacy Gateway docs\ndescription: End users should be aware that Cloudflare cannot ensure that\n  websites and services will not send identifying user data from requests\n  forwarded through the Privacy Gateway. This includes information such as\n  names, email addresses, and phone numbers.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/privacy-gateway/reference/limitations/\n  md: https://developers.cloudflare.com/privacy-gateway/reference/limitations/index.md\n---\n\nEnd users should be aware that Cloudflare cannot ensure that websites and services will not send identifying user data from requests forwarded through the Privacy Gateway. This includes information such as names, email addresses, and phone numbers.\n\n</page>\n\n<page>\n---\ntitle: Privacy Gateway Metrics Â· Cloudflare Privacy Gateway docs\ndescription: \"Privacy Gateway now supports enhanced monitoring through our\n  GraphQL API, providing detailed insights into your gateway traffic and\n  performance. To access these metrics, ensure you have:\"\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/privacy-gateway/reference/metrics/\n  md: https://developers.cloudflare.com/privacy-gateway/reference/metrics/index.md\n---\n\nPrivacy Gateway now supports enhanced monitoring through our GraphQL API, providing detailed insights into your gateway traffic and performance. To access these metrics, ensure you have:\n\n* A relay gateway proxy implementation where Cloudflare acts as the oblivious relay party.\n* An API token with Analytics Read permissions. We offer two GraphQL nodes to retrieve metrics: `ohttpMetricsAdaptive` and `ohttpMetricsAdaptiveGroups`. The first node provides comprehensive request data, while the second facilitates grouped analytics.\n\n## ohttpMetricsAdaptive\n\nThe `ohttpMetricsAdaptive` node is designed for detailed insights into individual OHTTP requests with adaptive sampling. This node can help in understanding the performance and load on your server and client setup.\n\n### Key Arguments\n\n* `filter` required\n  * Apply filters to narrow down your data set. `accountTag` is a required filter.\n* `limit` optional\n  * Specify the maximum number of records to return.\n* `orderBy` optional\n  * Choose how to sort your data, with options for various dimensions and metrics.\n\n### Available Fields\n\n* `bytesToClient` int optional\n  * The number of bytes returned to the client.\n* `bytesToGateway` int optional\n  * Total bytes received from the client.\n* `colo` string optional\n  * Airport code of the Cloudflare data center that served the request.\n* `datetime` Time optional\n  * The date and time when the event was recorded.\n* `gatewayStatusCode` int optional\n  * Status code returned by the gateway.\n* `relayStatusCode` int optional\n  * Status code returned by the relay.\n\nThis node is useful for a granular view of traffic, helping you identify patterns, performance issues, or anomalies in your data flow.\n\n## ohttpMetricsAdaptiveGroups\n\nThe `ohttpMetricsAdaptiveGroups` node allows for aggregated analysis of OHTTP request metrics with adaptive sampling. This node is particularly useful for identifying trends and patterns across different dimensions of your traffic and operations.\n\n### Key Arguments\n\n* `filter` required\n  * Apply filters to narrow down your data set. `accountTag` is a required filter.\n* `limit` optional\n  * Specify the maximum number of records to return.\n* `orderBy` optional\n  * Choose how to sort your data, with options for various dimensions and metrics.\n\n### Available Fields\n\n* `count` int optional\n  * The number of records that meet the criteria.\n* `dimensions` optional\n  * Specifies the grouping dimensions for your data.\n* `sum` optional\n  * Aggregated totals for various metrics, per dimension.\n\n**Dimensions**\n\nYou can group your metrics by various dimensions to get a more segmented view of your data:\n\n* `colo` string optional\n  * The airport code of the Cloudflare data center.\n* `date` Date optional\n  * The date of OHTTP request metrics.\n* `datetimeFifteenMinutes` Time optional\n  * Timestamp truncated to fifteen minutes.\n* `datetimeFiveMinutes` Time optional\n  * Timestamp truncated to five minutes.\n* `datetimeHour` Time optional\n  * Timestamp truncated to the hour.\n* `datetimeMinute` Time optional\n  * Timestamp truncated to the minute.\n* `endpoint` string optional\n  * The appId that generated traffic.\n* `gatewayStatusCode` int optional\n  * Status code returned by the gateway.\n* `relayStatusCode` int optional\n  * Status code returned by the relay.\n\n**Sum Fields**\n\nSum fields offer a cumulative view of various metrics over your selected time period:\n\n* `bytesToClient` int optional\n  * Total bytes sent from the gateway to the client.\n* `bytesToGateway` int optional\n  * Total bytes from the client to the gateway.\n* `clientRequestErrors` int optional\n  * Total number of client request errors.\n* `gatewayResponseErrors` int optional\n  * Total number of gateway response errors.\n\nUtilize the ohttpMetricsAdaptiveGroups node to gain comprehensive, aggregated insights into your traffic patterns, helping you optimize performance and user experience.\n\n</page>\n\n<page>\n---\ntitle: Product compatibility Â· Cloudflare Privacy Gateway docs\ndescription: When using Privacy Gateway, the majority of Cloudflare products\n  will be compatible with your application.\nlastUpdated: 2024-08-13T19:56:56.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/privacy-gateway/reference/product-compatibility/\n  md: https://developers.cloudflare.com/privacy-gateway/reference/product-compatibility/index.md\n---\n\nWhen [using Privacy Gateway](https://developers.cloudflare.com/privacy-gateway/get-started/), the majority of Cloudflare products will be compatible with your application.\n\nHowever, the following products are not compatible:\n\n* [API Shield](https://developers.cloudflare.com/api-shield/): [Schema Validation](https://developers.cloudflare.com/api-shield/security/schema-validation/) and [API discovery](https://developers.cloudflare.com/api-shield/security/api-discovery/) are not possible since Cloudflare cannot see the request URLs.\n* [Cache](https://developers.cloudflare.com/cache/): Caching of application content is no longer possible since each between client and gateway is end-to-end encrypted.\n* [WAF](https://developers.cloudflare.com/waf/): Rules implemented based on request content are not supported since Cloudflare cannot see the request or response content.\n\n</page>\n\n<page>\n---\ntitle: Cloudflare Queues - Configuration Â· Cloudflare Queues docs\ndescription: Cloudflare Queues can be configured using Wrangler, the\n  command-line interface for Cloudflare's Developer Platform, which includes\n  Workers, R2, and other developer products.\nlastUpdated: 2025-08-11T15:14:33.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/configure-queues/\n  md: https://developers.cloudflare.com/queues/configuration/configure-queues/index.md\n---\n\nCloudflare Queues can be configured using [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), the command-line interface for Cloudflare's Developer Platform, which includes [Workers](https://developers.cloudflare.com/workers/), [R2](https://developers.cloudflare.com/r2/), and other developer products.\n\nEach Producer and Consumer Worker has a [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/) that specifies environment variables, triggers, and resources, such as a queue. To enable Worker-to-resource communication, you must set up a [binding](https://developers.cloudflare.com/workers/runtime-apis/bindings/) in your Worker project's Wrangler file.\n\nUse the options below to configure your queue.\n\nNote\n\nBelow are options for queues, refer to the Wrangler documentation for a full reference of the [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/).\n\n## Queue configuration\n\nThe following queue level settings can be configured using Wrangler:",
      "language": "unknown"
    },
    {
      "code": "* `--delivery-delay-secs` number optional\n\n  * How long a published message is delayed for, before it is delivered to consumers.\n  * Must be between 0 and 43200 (12 hours).\n  * Defaults to 0.\n\n* `--message-retention-period-secs` number optional\n\n  * How long messages are retained on the Queue.\n  * Defaults to 345600 (4 days).\n  * Must be between 60 and 1209600 (14 days)\n\n## Producer Worker configuration\n\nA producer is a [Cloudflare Worker](https://developers.cloudflare.com/workers/) that writes to one or more queues. A producer can accept messages over HTTP, asynchronously write messages when handling requests, and/or write to a queue from within a [Durable Object](https://developers.cloudflare.com/durable-objects/). Any Worker can write to a queue.\n\nTo produce to a queue, set up a binding in your Wrangler file. These options should be used when a Worker wants to send messages to a queue.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "- `queue` string\n  * The name of the queue.\n- `binding` string\n  * The name of the binding, which is a JavaScript variable.\n\n## Consumer Worker Configuration\n\nTo consume messages from one or more queues, set up a binding in your Wrangler file. These options should be used when a Worker wants to receive messages from a queue.\n\n* wrangler.jsonc",
      "language": "unknown"
    },
    {
      "code": "* wrangler.toml",
      "language": "unknown"
    },
    {
      "code": "Refer to [Limits](https://developers.cloudflare.com/queues/platform/limits) to review the maximum values for each of these options.\n\n* `queue` string\n  * The name of the queue.\n\n* `max_batch_size` number optional\n\n  * The maximum number of messages allowed in each batch.\n  * Defaults to `10` messages.\n\n* `max_batch_timeout` number optional\n\n  * The maximum number of seconds to wait until a batch is full.\n  * Defaults to `5` seconds.\n\n* `max_retries` number optional\n\n  * The maximum number of retries for a message, if it fails or [`retryAll()`](https://developers.cloudflare.com/queues/configuration/javascript-apis/#messagebatch) is invoked.\n  * Defaults to `3` retries.\n\n* `dead_letter_queue` string optional\n\n  * The name of another queue to send a message if it fails processing at least `max_retries` times.\n  * If a `dead_letter_queue` is not defined, messages that repeatedly fail processing will eventually be discarded.\n  * If there is no queue with the specified name, it will be created automatically.\n\n* `max_concurrency` number optional\n\n  * The maximum number of concurrent consumers allowed to run at once. Leaving this unset will mean that the number of invocations will scale to the [currently supported maximum](https://developers.cloudflare.com/queues/platform/limits/).\n  * Refer to [Consumer concurrency](https://developers.cloudflare.com/queues/configuration/consumer-concurrency/) for more information on how consumers autoscale, particularly when messages are retried.\n\n## Pull-based\n\nA queue can have a HTTP-based consumer that pulls from the queue. This consumer can be any HTTP-speaking service that can communicate over the Internet. Review [Pull consumers](https://developers.cloudflare.com/queues/configuration/pull-consumers/) to learn how to configure a pull-based consumer.\n\n</page>\n\n<page>\n---\ntitle: Batching, Retries and Delays Â· Cloudflare Queues docs\ndescription: When configuring a consumer Worker for a queue, you can also define\n  how messages are batched as they are delivered.\nlastUpdated: 2025-12-09T12:49:27.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/queues/configuration/batching-retries/\n  md: https://developers.cloudflare.com/queues/configuration/batching-retries/index.md\n---\n\n## Batching\n\nWhen configuring a [consumer Worker](https://developers.cloudflare.com/queues/reference/how-queues-works#consumers) for a queue, you can also define how messages are batched as they are delivered.\n\nBatching can:\n\n1. Reduce the total number of times your consumer Worker needs to be invoked (which can reduce costs).\n2. Allow you to batch messages when writing to an external API or service (reducing writes).\n3. Disperse load over time, especially if your producer Workers are associated with user-facing activity.\n\nThere are two ways to configure how messages are batched. You configure batching when connecting your consumer Worker to a queue.\n\n* `max_batch_size` - The maximum size of a batch delivered to a consumer (defaults to 10 messages).\n* `max_batch_timeout` - the *maximum* amount of time the queue will wait before delivering a batch to a consumer (defaults to 5 seconds)\n\nBatch size configuration\n\nBoth `max_batch_size` and `max_batch_timeout` work together. Whichever limit is reached first will trigger the delivery of a batch.\n\nFor example, a `max_batch_size = 30` and a `max_batch_timeout = 10` means that if 30 messages are written to the queue, the consumer will receive a batch of 30 messages. However, if it takes longer than 10 seconds for those 30 messages to be written to the queue, then the consumer will get a batch of messages that contains however many messages were on the queue at the time (somewhere between 1 and 29, in this case).\n\nEmpty queues\n\nWhen a queue is empty, a push-based (Worker) consumer's `queue` handler will not be invoked until there are messages to deliver. A queue does not attempt to push empty batches to a consumer and thus does not invoke unnecessary reads.\n\n[Pull-based consumers](https://developers.cloudflare.com/queues/configuration/pull-consumers/) that attempt to pull from a queue, even when empty, will incur a read operation.\n\nWhen determining what size and timeout settings to configure, you will want to consider latency (how long can you wait to receive messages?), overall batch size (when writing to external systems), and cost (fewer-but-larger batches).\n\n### Batch settings\n\nThe following batch-level settings can be configured to adjust how Queues delivers batches to your configured consumer.\n\n## Explicit acknowledgement and retries\n\nYou can acknowledge individual messages within a batch by explicitly acknowledging each message as it is processed. Messages that are explicitly acknowledged will not be re-delivered, even if your queue consumer fails on a subsequent message and/or fails to return successfully when processing a batch.\n\n* Each message can be acknowledged as you process it within a batch, and avoids the entire batch from being re-delivered if your consumer throws an error during batch processing.\n* Acknowledging individual messages is useful when you are calling external APIs, writing messages to a database, or otherwise performing non-idempotent (state changing) actions on individual messages.\n\nTo explicitly acknowledge a message as delivered, call the `ack()` method on the message.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "You can also call `retry()` to explicitly force a message to be redelivered in a subsequent batch. This is referred to as \"negative acknowledgement\". This can be particularly useful when you want to process the rest of the messages in that batch without throwing an error that would force the entire batch to be redelivered.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "You can also acknowledge or negatively acknowledge messages at a batch level with `ackAll()` and `retryAll()`. Calling `ackAll()` on the batch of messages (`MessageBatch`) delivered to your consumer Worker has the same behaviour as a consumer Worker that successfully returns (does not throw an error).\n\nNote that calls to `ack()`, `retry()` and their `ackAll()` / `retryAll()` equivalents follow the below precedence rules:\n\n* If you call `ack()` on a message, subsequent calls to `ack()` or `retry()` are silently ignored.\n* If you call `retry()` on a message and then call `ack()`: the `ack()` is ignored. The first method call wins in all cases.\n* If you call either `ack()` or `retry()` on a single message, and then either/any of `ackAll()` or `retryAll()` on the batch, the call on the single message takes precedence. That is, the batch-level call does not apply to that message (or messages, if multiple calls were made).\n\n## Delivery failure\n\nWhen a message is failed to be delivered, the default behaviour is to retry delivery three times before marking the delivery as failed. You can set `max_retries` (defaults to 3) when configuring your consumer, but in most cases we recommend leaving this as the default.\n\nMessages that reach the configured maximum retries will be deleted from the queue, or if a [dead-letter queue](https://developers.cloudflare.com/queues/configuration/dead-letter-queues/) (DLQ) is configured, written to the DLQ instead.\n\nNote\n\nEach retry counts as an additional read operation per [Queues pricing](https://developers.cloudflare.com/queues/platform/pricing/).\n\nWhen a single message within a batch fails to be delivered, the entire batch is retried, unless you have [explicitly acknowledged](#explicit-acknowledgement-and-retries) a message (or messages) within that batch. For example, if a batch of 10 messages is delivered, but the 8th message fails to be delivered, all 10 messages will be retried and thus redelivered to your consumer in full.\n\nRetried messages and consumer concurrency\n\nRetrying messages with `retry()` or calling `retryAll()` on a batch will **not** cause the consumer to autoscale down if consumer concurrency is enabled. Refer to [Consumer concurrency](https://developers.cloudflare.com/queues/configuration/consumer-concurrency/) to learn more.\n\n## Delay messages\n\nWhen publishing messages to a queue, or when [marking a message or batch for retry](#explicit-acknowledgement-and-retries), you can choose to delay messages from being processed for a period of time.\n\nDelaying messages allows you to defer tasks until later, and/or respond to backpressure when consuming from a queue. For example, if an upstream API you are calling to returns a `HTTP 429: Too Many Requests`, you can delay messages to slow down how quickly you are consuming them before they are re-processed.\n\nMessages can be delayed by up to 12 hours.\n\nNote\n\nConfiguring delivery and retry delays via the `wrangler` CLI or when [developing locally](https://developers.cloudflare.com/queues/configuration/local-development/) requires `wrangler` version `3.38.0` or greater. Use `npx wrangler@latest` to always use the latest version of `wrangler`.\n\n### Delay on send\n\nTo delay a message or batch of messages when sending to a queue, you can provide a `delaySeconds` parameter when sending a message.\n\n* JavaScript",
      "language": "unknown"
    },
    {
      "code": "* TypeScript",
      "language": "unknown"
    },
    {
      "code": "* Python",
      "language": "unknown"
    },
    {
      "code": "You can also configure a default, global delay on a per-queue basis by passing `--delivery-delay-secs` when creating a queue via the `wrangler` CLI:",
      "language": "unknown"
    }
  ],
  "headings": [
    {
      "level": "h3",
      "text": "f. Install the Cloudflare package",
      "id": "f.-install-the-cloudflare-package"
    },
    {
      "level": "h2",
      "text": "2. Define Cloudflare resources in code",
      "id": "2.-define-cloudflare-resources-in-code"
    },
    {
      "level": "h3",
      "text": "a. Add a Workers script",
      "id": "a.-add-a-workers-script"
    },
    {
      "level": "h3",
      "text": "b. Add a Route",
      "id": "b.-add-a-route"
    },
    {
      "level": "h3",
      "text": "c. Add a DNS Record",
      "id": "c.-add-a-dns-record"
    },
    {
      "level": "h3",
      "text": "d. (Optional) Verify your code",
      "id": "d.-(optional)-verify-your-code"
    },
    {
      "level": "h2",
      "text": "3. Deploy your application",
      "id": "3.-deploy-your-application"
    },
    {
      "level": "h2",
      "text": "4. Test the Worker",
      "id": "4.-test-the-worker"
    },
    {
      "level": "h2",
      "text": "5. Clean up",
      "id": "5.-clean-up"
    },
    {
      "level": "h3",
      "text": "a. Delete the Cloudflare resources",
      "id": "a.-delete-the-cloudflare-resources"
    },
    {
      "level": "h3",
      "text": "b. Remove the Pulumi stack",
      "id": "b.-remove-the-pulumi-stack"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "Before you begin",
      "id": "before-you-begin"
    },
    {
      "level": "h2",
      "text": "1. Set up a new Environment",
      "id": "1.-set-up-a-new-environment"
    },
    {
      "level": "h3",
      "text": "a. Log in to Pulumi Cloud",
      "id": "a.-log-in-to-pulumi-cloud"
    },
    {
      "level": "h3",
      "text": "b. Create a new Environment",
      "id": "b.-create-a-new-environment"
    },
    {
      "level": "h2",
      "text": "2. Log into Cloudflare",
      "id": "2.-log-into-cloudflare"
    },
    {
      "level": "h3",
      "text": "a. Add your credentials",
      "id": "a.-add-your-credentials"
    },
    {
      "level": "h3",
      "text": "b. Log out",
      "id": "b.-log-out"
    },
    {
      "level": "h3",
      "text": "c. Log in",
      "id": "c.-log-in"
    },
    {
      "level": "h2",
      "text": "3. Add Worker secrets",
      "id": "3.-add-worker-secrets"
    },
    {
      "level": "h3",
      "text": "a. Add a secret",
      "id": "a.-add-a-secret"
    },
    {
      "level": "h3",
      "text": "b. Pass the secret to your Worker",
      "id": "b.-pass-the-secret-to-your-worker"
    },
    {
      "level": "h2",
      "text": "4. Load `.dev.vars`",
      "id": "4.-load-`.dev.vars`"
    },
    {
      "level": "h3",
      "text": "a. Create an Environment",
      "id": "a.-create-an-environment"
    },
    {
      "level": "h3",
      "text": "b. Add a secret",
      "id": "b.-add-a-secret"
    },
    {
      "level": "h3",
      "text": "c. Generate the `.dev.vars` file",
      "id": "c.-generate-the-`.dev.vars`-file"
    },
    {
      "level": "h2",
      "text": "Next steps",
      "id": "next-steps"
    },
    {
      "level": "h2",
      "text": "What Cloudflare sees",
      "id": "what-cloudflare-sees"
    },
    {
      "level": "h2",
      "text": "What Cloudflare stores",
      "id": "what-cloudflare-stores"
    },
    {
      "level": "h2",
      "text": "What Privacy Gateway customers see",
      "id": "what-privacy-gateway-customers-see"
    },
    {
      "level": "h2",
      "text": "ohttpMetricsAdaptive",
      "id": "ohttpmetricsadaptive"
    },
    {
      "level": "h3",
      "text": "Key Arguments",
      "id": "key-arguments"
    },
    {
      "level": "h3",
      "text": "Available Fields",
      "id": "available-fields"
    },
    {
      "level": "h2",
      "text": "ohttpMetricsAdaptiveGroups",
      "id": "ohttpmetricsadaptivegroups"
    },
    {
      "level": "h3",
      "text": "Key Arguments",
      "id": "key-arguments"
    },
    {
      "level": "h3",
      "text": "Available Fields",
      "id": "available-fields"
    },
    {
      "level": "h2",
      "text": "Queue configuration",
      "id": "queue-configuration"
    },
    {
      "level": "h2",
      "text": "Producer Worker configuration",
      "id": "producer-worker-configuration"
    },
    {
      "level": "h2",
      "text": "Consumer Worker Configuration",
      "id": "consumer-worker-configuration"
    },
    {
      "level": "h2",
      "text": "Pull-based",
      "id": "pull-based"
    },
    {
      "level": "h2",
      "text": "Batching",
      "id": "batching"
    },
    {
      "level": "h3",
      "text": "Batch settings",
      "id": "batch-settings"
    },
    {
      "level": "h2",
      "text": "Explicit acknowledgement and retries",
      "id": "explicit-acknowledgement-and-retries"
    },
    {
      "level": "h2",
      "text": "Delivery failure",
      "id": "delivery-failure"
    },
    {
      "level": "h2",
      "text": "Delay messages",
      "id": "delay-messages"
    },
    {
      "level": "h3",
      "text": "Delay on send",
      "id": "delay-on-send"
    }
  ],
  "url": "llms-txt#replace-example.com-with-your-domain",
  "links": []
}