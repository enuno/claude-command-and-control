{
  "title": "Use Cloudflare Tunnels with Kubernetes client-go credential plugins",
  "content": "This tutorial explains how to use Cloudflare Tunnels with Kubernetes client-go credential plugins for authentication. By following these steps, you can securely access your Kubernetes cluster through a Cloudflare Tunnel using the `kubectl` command-line tool.\n\n* A Cloudflare account\n* The Cloudflare Tunnel client (`cloudflared`) installed on your machine\n* Access to a Kubernetes cluster\n* `kubectl` installed on your machine\n\n## 1. Set up a Cloudflare Tunnel\n\n1. Authenticate `cloudflared` with your Cloudflare account:\n\n2. Create a new tunnel:\n\n3. Configure your tunnel by creating a configuration file named `config.yml`:\n\nReplace `<TUNNEL_ID>` with your tunnel ID and adjust the hostname as needed.\n\n## 2. Configure the Kubernetes API server\n\nEnsure your Kubernetes API server is configured to accept authentication from Cloudflare Tunnels. This may involve setting up an authentication webhook or configuring the API server to trust the Cloudflare Tunnel's client certificates.\n\n## 3. Set up client-go credential plugin\n\n1. Create a script named `cloudflare-k8s-auth.sh` with the following content:\n\nMake the script executable:\n\n2. Update your `~/.kube/config` file to use the credential plugin:\n\n## 4. Use kubectl with Cloudflare Tunnel\n\nNow you can use `kubectl` commands as usual. The client-go credential plugin will automatically handle authentication through the Cloudflare Tunnel:\n\nIf you encounter issues:\n\n* Ensure `cloudflared` is running and the tunnel is active\n* Check that your `~/.kube/config` file is correctly configured\n* Verify that the Kubernetes API server is properly set up to accept authentication from Cloudflare Tunnels\n* Review the Cloudflare Tunnel logs for any error messages\n\nFor more information, refer to the [Cloudflare Tunnels documentation](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/) and the [Kubernetes client-go credential plugins documentation](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#client-go-credential-plugins).\n\n<page>\n---\ntitle: Use virtual networks to change user egress IPs · Cloudflare One docs\ndescription: This tutorial gives administrators an easy way to allow their users\n  to change their egress IP address between any of your assigned dedicated\n  egress IP addresses.\nlastUpdated: 2025-11-20T23:13:05.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-one/tutorials/user-selectable-egress-ips/\n  md: https://developers.cloudflare.com/cloudflare-one/tutorials/user-selectable-egress-ips/index.md\n---\n\nOnly available on Enterprise plans.\n\nThis tutorial gives administrators an easy way to allow their users to change their egress IP address between any of your assigned dedicated egress IP addresses. Your users can choose which egress IP to use by switching virtual networks directly from in the WARP client.\n\nChanging egress IPs can be useful in quality assurance (QA) and other similar scenarios in which users both use their local egress location and either switch to or simulate other remote locations.\n\n* [Deployed the WARP client](https://developers.cloudflare.com/cloudflare-one/team-and-resources/devices/warp/deployment/) on your users' devices.\n\n* [Configured tunnels](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/private-net/cloudflared/) to connect your private network to Cloudflare. This tutorial assumes you have:\n\n* Created two tunnels [through the dashboard](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/get-started/create-remote-tunnel/).\n  * Routed `10.0.0.0/8` through one tunnel.\n  * Routed `192.168.88.0/24` through the other tunnel.\n\n* Received multiple [dedicated egress IP addresses](https://developers.cloudflare.com/cloudflare-one/traffic-policies/egress-policies/dedicated-egress-ips/).\n\n## Create a virtual network for each egress route\n\nFirst, create [virtual networks](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/private-net/cloudflared/tunnel-virtual-networks/) corresponding to your dedicated egress IPs.\n\n1. In [Cloudflare One](https://one.dash.cloudflare.com/), go to **Networks** > **Routes**.\n  2. In **Virtual networks**, select **Create virtual network**.\n  3. Name your virtual network. We recommend using a name related to the location of the corresponding dedicated egress IP. For example, if your users will egress from the Americas, you can name the virtual network `vnet-AMER`.\n  4. Select **Save**.\n  5. Repeat Steps 2-4 for each dedicated egress IP you want users to switch between. For example, you can create another virtual network called `vnet-EMEA` for egress from Europe, the Middle East, and Africa.\n\n1. Create a [virtual network](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/private-net/cloudflared/tunnel-virtual-networks/) corresponding to one of your dedicated egress IPs. We recommend using a name related to the location of the corresponding dedicated egress IP. For example, if your users will egress from the Americas, you can name the virtual network `vnet-AMER`.\n\nRequired API token permissions\n\nAt least one of the following [token permissions](https://developers.cloudflare.com/fundamentals/api/reference/permissions/) is required:\n\n* `Cloudflare One Networks Write`\n     * `Cloudflare Tunnel Write`\n\nFor more information, refer to [Create a virtual network](https://developers.cloudflare.com/api/resources/zero_trust/subresources/networks/subresources/virtual_networks/methods/create/).\n\n2. Repeat Step 1 for each dedicated egress IP you want users to switch between. For example, you can create another virtual network called `vnet-EMEA` for egress from Europe, the Middle East, and Africa.\n\n## Assign each virtual network to each tunnel\n\nAfter creating your virtual networks, route your private network CIDRs over each virtual network. This ensures that users can reach all services on your network regardless of which egress IP they use.\n\n1. Go to **Networks** > **Connectors** > **Cloudflare Tunnels**.\n  2. Select your tunnel routing `10.0.0.0/8`, then select **Configure**.\n  3. Go to **Private Networks**. Select the `10.0.0.0/8` route.\n  4. In **Additional settings**, choose your first virtual network. For example, `vnet-AMER`.\n  5. Select **Save private network**.\n  6. To route `10.0.0.0/8` over another virtual network, select **Add a private network**.\n  7. In **CIDR**, enter `10.0.0.0/8`. In **Additional settings**, choose your second virtual network. For example, `vnet-EMEA`.\n  8. Select **Save private network**.\n  9. Repeat Steps 6-8 for each virtual network you created.\n  10. Return to **Networks** > **Tunnels**. Repeat Steps 2-9 for each private network tunnel route.\n\n1. Assign your first virtual network to your private network route. For example, assign `vnet-AMER` to your tunnel that routes `10.0.0.0/8`:\n\nRequired API token permissions\n\nAt least one of the following [token permissions](https://developers.cloudflare.com/fundamentals/api/reference/permissions/) is required:\n\n* `Cloudflare One Networks Write`\n     * `Cloudflare Tunnel Write`\n\nFor more information, refer to [Update a tunnel route](https://developers.cloudflare.com/api/resources/zero_trust/subresources/networks/subresources/routes/methods/edit/).\n\n2. Repeat this process for each virtual network you created. For example:\n\nRequired API token permissions\n\nAt least one of the following [token permissions](https://developers.cloudflare.com/fundamentals/api/reference/permissions/) is required:\n\n* `Cloudflare One Networks Write`\n     * `Cloudflare Tunnel Write`\n\n3. Repeat Steps 1-2 for each private network tunnel route.\n\nEach tunnel connected to your private network should have each of your virtual networks assigned to it. For example, if you have tunnels routing `10.0.0.0/8` and `192.168.88.0/24`, both tunnels should have the `vnet-AMER` and `vnet-EMEA` virtual networks assigned.\n\n| Tunnel | CIDR | Virtual network |\n| - | - | - |\n| **Tunnel 1** | `10.0.0.0/8` | `vnet-AMER` |\n| | `10.0.0.0/8` | `vnet-EMEA` |\n| **Tunnel 2** | `192.168.88.0/24` | `vnet-AMER` |\n| | `192.168.88.0/24` | `vnet-EMEA` |\n\n## Create virtual network egress policies\n\nNext, assign your dedicated egress IPs to each virtual network using Gateway egress policies.\n\n1. In [Cloudflare One](https://one.dash.cloudflare.com/), go to **Traffic policies** > **Egress policies**.\n\n2. Select **Add a policy**.\n\n3. Name your policy. We recommend including the country or region traffic will egress from.\n\n4. Add the virtual network with the *Virtual Network* selector. For example:\n\n| Selector | Operator | Value |\n     | - | - | - |\n     | Virtual Network | is | *vnet-AMER* |\n\n5. In **Select an egress IP**, choose **Use dedicated Cloudflare egress IPs**. Choose the dedicated IPv4 and IPv6 addresses you want traffic to egress with.\n\n6. Select **Create policy**.\n\n7. Repeat Steps 1-6 to create a separate egress policy for each virtual network you created.\n\n1. Add a Gateway egress policy that matches the corresponding virtual network. For example:\n\nFor more information, refer to [Create a Zero Trust Gateway rule](https://developers.cloudflare.com/api/resources/zero_trust/subresources/gateway/subresources/rules/methods/create/).\n\n2. Repeat Step 1 to create an egress policy for each virtual network you created.\n\nEach policy you create should correspond to a different primary dedicated egress IP.\n\n## Test virtual network egress\n\nWindows, macOS, and Linux\n\n1. On your user's device, log in to your Zero Trust organization in the WARP client.\n\n2. In a terminal, run the following command to check the default egress IP address.\n\nThe command should output your organization's default egress IP.\n\n3. In the WARP client, select the gear icon > **Virtual Networks**. Choose a virtual network you created.\n\n4. Check the egress IP address by running `curl ifconfig.me -4` again. The command should output the IP address specified in your egress policy.\n\n1. On your user's device, log in to your Zero Trust organization in the Cloudflare One Agent app.\n2. In a browser, go to [ifconfig.me](https://ifconfig.me/). Your organization's default egress IP should appear in **IP Address**.\n3. In Cloudflare One Agent, go to **Advanced** > **Connection options** > **Virtual networks**. Choose a virtual network you created.\n4. Check the egress IP address by reloading the browser page from Step 1. The IP address specified in your egress policy should appear in **IP Address**.\n\nWhile your users are connected to a virtual network, their traffic will route via the dedicated egress IP specified. You can repeat these steps to test that each virtual network is egressing from the correct IP.\n\n<page>\n---\ntitle: Deploy WARP on headless Linux machines · Cloudflare One docs\ndescription: This tutorial explains how to deploy the Cloudflare WARP client on\n  headless Linux devices using a service token and an installation script.\nlastUpdated: 2025-11-20T23:13:05.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-one/tutorials/warp-on-headless-linux/\n  md: https://developers.cloudflare.com/cloudflare-one/tutorials/warp-on-headless-linux/index.md\n---\n\nThis tutorial explains how to deploy the [Cloudflare WARP client](https://developers.cloudflare.com/cloudflare-one/team-and-resources/devices/warp/) on Linux devices using a service token and an installation script. This deployment workflow is designed for headless servers - that is, servers which do not have access to a browser for identity provider logins - and for situations where you want to fully automate the onboarding process. Because devices will not register through an identity provider, [identity-based policies](https://developers.cloudflare.com/cloudflare-one/traffic-policies/identity-selectors/) and logging will be unavailable.\n\nThis tutorial focuses on deploying WARP as an endpoint device agent. If you are looking to deploy WARP as a gateway to a private network, refer to the [WARP Connector documentation](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/private-net/warp-connector/).\n\n* [Cloudflare Zero Trust account](https://developers.cloudflare.com/cloudflare-one/setup/#create-a-zero-trust-organization)\n\n## 1. Create a service token\n\nFully automated deployments rely on a service token to enroll the WARP client in your Zero Trust organization. You can use the same token to enroll multiple devices, or generate a unique token per device if they require different [device profile settings](https://developers.cloudflare.com/cloudflare-one/team-and-resources/devices/warp/configure-warp/device-profiles/).\n\nTo create a service token:\n\n1. In [Cloudflare One](https://one.dash.cloudflare.com), go to **Access controls** > **Service credentials** > **Service Tokens**.\n\n2. Select **Create Service Token**.\n\n3. Name the service token. The name allows you to easily identify events related to the token in the logs and to revoke the token individually.\n\n4. Choose a **Service Token Duration**. This sets the expiration date for the token.\n\n5. Select **Generate token**. You will see the generated Client ID and Client Secret for the service token, as well as their respective request headers.\n\n6. Copy the Client Secret.\n\nThis is the only time Cloudflare Access will display the Client Secret. If you lose the Client Secret, you must generate a new service token.\n\n1. Make a `POST` request to the [Access Service Tokens](https://developers.cloudflare.com/api/resources/zero_trust/subresources/access/subresources/service_tokens/methods/create/) endpoint:\n\nRequired API token permissions\n\nAt least one of the following [token permissions](https://developers.cloudflare.com/fundamentals/api/reference/permissions/) is required:\n\n* `Access: Service Tokens Write`\n\n2. Copy the `client_id` and `client_secret` values returned in the response.\n\nThis is the only time Cloudflare Access will display the Client Secret. If you lose the Client Secret, you must generate a new service token.\n\n1. Add the following permission to your [`cloudflare_api_token`](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/api_token):\n\n* `Access: Service Tokens Write`\n\n2. Configure the [`cloudflare_zero_trust_access_service_token`](https://registry.terraform.io/providers/cloudflare/cloudflare/latest/docs/resources/zero_trust_access_service_token) resource:\n\n3. Get the Client ID and Client Secret of the service token:\n\nExample: Output to CLI\n\n1. Output the Client ID and Client Secret to the Terraform state file:\n\n2. Apply the configuration:\n\n3. Read the Client ID and Client Secret:\n\nExample: Store in HashiCorp Vault\n\n## 2. Configure device enrollment permissions\n\nDevice enrollment permissions determine the users and devices that can register WARP with your Zero Trust organization.\n\nTo allow devices to enroll using a service token:\n\n1. In [Cloudflare One](https://one.dash.cloudflare.com), go to **Team & Resources** > **Devices**. Select the **Management** tab.\n\n2. In **Device enrollment permissions**, select **Manage**.\n\n3. In the **Policies** tab, select **Create new policy**. A new tab will open with the policy creation page.\n\n4. For **Action**, select *Service Auth*.\n\n5. For the **Selector** field, you have two options: you can either allow all service tokens (`Any Access Service Token`) or specific service tokens (`Service Token`). For example:\n\n| Rule Action | Rule type | Selector | Value |\n   | - | - | - | - |\n   | Service Auth | Include | Service Token | `<TOKEN-NAME>` |\n\n7. Go back to **Device enrollment permissions** and add the newly created policy to your permissions.\n\n## 3. Create an installation script\n\nYou can use a shell script to automate WARP installation and registration. The following example shows how to deploy WARP on Ubuntu 24.04.\n\n1. In a terminal, create a new `.sh` file using a text editor. For example:\n\n2. Press `i` to enter insert mode and add the following lines:\n\n3. If you are using Debian or RHEL / CentOS, modify the `warp()` function so that it installs the correct [WARP package](https://pkg.cloudflareclient.com/) for your OS.\n\n4. Modify the values in the `mdm()` function:\n\n1. For `auth_client_id` and `auth_client_secret`, replace the string values with the Client ID and Client Secret of your [service token](https://developers.cloudflare.com/cloudflare-one/tutorials/warp-on-headless-linux/#1-create-a-service-token).\n   2. For `organization`, replace `your-team-name` with your Zero Trust team name.\n   3. (Optional) Add or modify other [WARP deployment parameters](https://developers.cloudflare.com/cloudflare-one/team-and-resources/devices/warp/deployment/mdm-deployment/parameters/) according to your preferences.\n\n5. Press `esc`, then type `:x` and press `Enter` to save and exit.\n\nTo install WARP using the example script:\n\n1. Make the script executable:\n\nWARP is now deployed with the configuration parameters stored in `/var/lib/cloudflare-warp/mdm.xml`. Assuming [`auto_connect`](https://developers.cloudflare.com/cloudflare-one/team-and-resources/devices/warp/deployment/mdm-deployment/parameters/#auto_connect) is configured, WARP will automatically connect to your Zero Trust organization. Once connected, the device will appear in [Cloudflare One](https://one.dash.cloudflare.com) under **Team & Resources** > **Devices** with the email `non_identity@<team-name>.cloudflareaccess.com`.\n\n<page>\n---\ntitle: Render a VNC client in browser · Cloudflare One docs\ndescription: Cloudflare can render a Virtual Network Computer (VNC) terminal in\n  your browser without any client software or configuration required.\n  Administrators can use Cloudflare Tunnel to connect a VNC host to Cloudflare's\n  network. This tutorial focuses on configuring a Tight VNC server.\nlastUpdated: 2025-11-20T23:13:05.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/cloudflare-one/tutorials/vnc-client-in-browser/\n  md: https://developers.cloudflare.com/cloudflare-one/tutorials/vnc-client-in-browser/index.md\n---\n\nCloudflare can render a Virtual Network Computer (VNC) terminal in your browser without any client software or configuration required.\n\nAdministrators can use Cloudflare Tunnel to connect a VNC host to Cloudflare's network. Using Cloudflare Access, you can apply Zero Trust policies to determine who can access your VNC server. Cloudflare's network will then enforce the Zero Trust policies and, when a user is allowed, render the client in the browser.\n\n**This walkthrough covers how to:**\n\n* Install and run a Cloudflare Tunnel on a Linux virtual machine\n* Install and configure VNC on a Linux virtual machine\n* Build a Zero Trust policy to determine who can reach the host\n* Render the VNC server in your browser\n\n**Time to complete:**\n\nThere are a number of VNC versions, deployments, and instances. This tutorial focuses on configuring a Tight VNC server on an Azure hosted Linux virtual machine (VM). For help with other configurations, post your questions in our [community](https://community.cloudflare.com/t/feedback-for-browser-vnc/280619/3).\n\n1. [Add a website to Cloudflare.](https://developers.cloudflare.com/fundamentals/manage-domains/add-site/)\n2. [Enable Cloudflare Zero Trust on your account.](https://developers.cloudflare.com/cloudflare-one/setup/)\n3. [Connect your identity provider to Cloudflare Zero Trust.](https://developers.cloudflare.com/cloudflare-one/integrations/identity-providers/)\n\n## Configure VNC on your virtual machine\n\nThis section covers how to install a VNC server with TightVNC and the GNOME desktop environment. If you already have a VNC server installed, you can skip this step.\n\n1. Open a terminal window for your VM.\n\n2. To install the VNC software, run the following commands:\n\n3. Once installed, you can create the VNC server instance with the following command:\n\n4. Select a password for the VNC server. This password will be used during login for your browser VNC server.\n\n5. Run the following command, which will take you to your VNC server configuration directory.\n\n6. Open your `xstartup` file.\n\n7. Update the file to the following configuration (this is for demonstration purposes — browser-based VNC will work with most configurations):\n\n8. To create your VNC server, run the following command:\n\nAt this point, you have a VNC server ready to test with browser-based VNC. We recommend performing a brief test with an existing VNC browser to verify any missing packages or configuration changes that might need to be made before continuing. Once your VNC server appears as desired, continue with your setup.\n\n## Configure Cloudflare Tunnel on your machine\n\n1. Follow [these instructions](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/downloads/) to install `cloudflared`.\n\n2. Authenticate `cloudflared` with the command:\n\n3. Create a Tunnel with the command:\n\n4. Create a Tunnel configuration file with the command:\n\n5. Add the following configuration to your configuration file.\n\nAs you do that, replace `<HOSTNAME>` with the domain you wish to use to expose your VNC server in the browser. Also, replace `5901` with the port your VNC server is running on. To get a list of ports, run `sudo ss -lnpt` and look for `VNC` to get the value that should be specified in your configuration file.\n\n6. [Route your Tunnel](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/routing-to-tunnel/dns/) to your website.\n\n8. Follow [this guide](https://developers.cloudflare.com/cloudflare-one/networks/connectors/cloudflare-tunnel/configure-tunnels/tunnel-with-firewall/) to open outbound connections for Cloudflare Tunnel if you have a firewall enabled.\n\nAt this point you have a running VNC server and a Cloudflare Tunnel on your machine ready to accept inbound VNC requests.\n\n## Create a Cloudflare Access VNC application\n\nThe last step is to create a Cloudflare Access application to run your VNC server in the Browser.\n\n1. In [Cloudflare One](https://one.dash.cloudflare.com), go to **Access controls** > **Applications**.\n\n2. Select **Add an application**.\n\n3. Select **Self-hosted**.\n\n4. Enter any name for the application.\n\n5. Select **Add public hostname** and set the domain to which you would like to expose the VNC server.\n\n6. In **Access policies**, add an Allow or Block policy. For example policies, refer to the [Access policies documentation](https://developers.cloudflare.com/cloudflare-one/access-controls/policies/#allow).\n\nService Auth and Bypass policies are not supported for browser-based VNC applications.\n\n1. In **Advanced settings**, set **Browser rendering** to *VNC*.\n\nUsers will see a login screen with your configured identity providers. After successful authentication, they may be prompted to enter the VNC server's password.\n\nYou can define granular access controls across each individual VNC instance.\n\n<page>\n---\ntitle: Cron Container · Cloudflare Containers docs\ndescription: Running a container on a schedule using Cron Triggers\nlastUpdated: 2025-11-24T12:16:10.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/containers/examples/cron/\n  md: https://developers.cloudflare.com/containers/examples/cron/index.md\n---\n\nTo launch a container on a schedule, you can use a Workers [Cron Trigger](https://developers.cloudflare.com/workers/configuration/cron-triggers/).\n\nFor a full example, see the [Cron Container Template](https://github.com/mikenomitch/cron-container/tree/main).\n\nUse a cron expression in your Wrangler config to specify the schedule:\n\nThen in your Worker, call your Container from the \"scheduled\" handler:\n\n<page>\n---\ntitle: Static Frontend, Container Backend · Cloudflare Containers docs\ndescription: A simple frontend app with a containerized backend\nlastUpdated: 2025-09-22T15:52:17.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/containers/examples/container-backend/\n  md: https://developers.cloudflare.com/containers/examples/container-backend/index.md\n---\n\nA common pattern is to serve a static frontend application (e.g., React, Vue, Svelte) using Static Assets, then pass backend requests to a containerized backend application.\n\nIn this example, we'll show an example using a simple `index.html` file served as a static asset, but you can select from one of many frontend frameworks. See our [Workers framework examples](https://developers.cloudflare.com/workers/framework-guides/web-apps/) for more information.\n\nFor a full example, see the [Static Frontend + Container Backend Template](https://github.com/mikenomitch/static-frontend-container-backend).\n\n## Configure Static Assets and a Container\n\n## Add a simple index.html file to serve\n\nCreate a simple `index.html` file in the `./dist` directory.\n\nIn this example, we are using [Alpine.js](https://alpinejs.dev/) to fetch a list of widgets from `/api/widgets`.\n\nThis is meant to be a very simple example, but you can get significantly more complex. See [examples of Workers integrating with frontend frameworks](https://developers.cloudflare.com/workers/framework-guides/web-apps/) for more information.\n\nYour Worker needs to be able to both serve static assets and route requests to the containerized backend.\n\nIn this case, we will pass requests to one of three container instances if the route starts with `/api`, and all other requests will be served as static assets.\n\nThis example uses the `getRandom` function, which is a temporary helper that will randomly select of of N instances of a Container to route requests to.\n\nIn the future, we will provide improved latency-aware load balancing and autoscaling.\n\nThis will make scaling stateless instances simple and routing more efficient. See the [autoscaling documentation](https://developers.cloudflare.com/containers/platform-details/scaling-and-routing) for more details.\n\n## Define a backend container\n\nYour container should be able to handle requests to `/api/widgets`.\n\nIn this case, we'll use a simple Golang backend that returns a hard-coded list of widgets.\n\n<page>\n---\ntitle: Using Durable Objects Directly · Cloudflare Containers docs\ndescription: Various examples calling Containers directly from Durable Objects\nlastUpdated: 2025-08-18T14:27:42.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/containers/examples/durable-object-interface/\n  md: https://developers.cloudflare.com/containers/examples/durable-object-interface/index.md\n---\n\n<page>\n---\ntitle: Env Vars and Secrets · Cloudflare Containers docs\ndescription: Pass in environment variables and secrets to your container\nlastUpdated: 2025-09-24T21:18:25.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/containers/examples/env-vars-and-secrets/\n  md: https://developers.cloudflare.com/containers/examples/env-vars-and-secrets/index.md\n---\n\nEnvironment variables can be passed into a Container using the `envVars` field in the [`Container`](https://developers.cloudflare.com/containers/container-package) class, or by setting manually when the Container starts.\n\nSecrets can be passed into a Container by using [Worker Secrets](https://developers.cloudflare.com/workers/configuration/secrets/) or the [Secret Store](https://developers.cloudflare.com/secrets-store/integrations/workers/), then passing them into the Container as environment variables.\n\nKV values can be passed into a Container by using [Workers KV](https://developers.cloudflare.com/kv/), then reading the values and passing them into the Container as environment variables.\n\nThese examples show the various ways to pass in secrets, KV values, and environment variables. In each, we will be passing in:\n\n* the variable `\"ENV_VAR\"` as a hard-coded environment variable\n* the secret `\"WORKER_SECRET\"` as a secret from Worker Secrets\n* the secret `\"SECRET_STORE_SECRET\"` as a secret from the Secret Store\n* the value `\"KV_VALUE\"` as a value from Workers KV\n\nIn practice, you may just use one of the methods for storing secrets and data, but we will show all methods for completeness.\n\n## Creating secrets and KV data\n\nFirst, let's create the `\"WORKER_SECRET\"` secret in Worker Secrets:\n\nThen, let's create a store called \"demo\" in the Secret Store, and add the `\"SECRET_STORE_SECRET\"` secret to it:\n\nNext, let's create a KV namespace called `DEMO_KV` and add a key-value pair:\n\nFor full details on how to create secrets, see the [Workers Secrets documentation](https://developers.cloudflare.com/workers/configuration/secrets/) and the [Secret Store documentation](https://developers.cloudflare.com/secrets-store/integrations/workers/). For KV setup, see the [Workers KV documentation](https://developers.cloudflare.com/kv/).\n\nNext, we need to add bindings to access our secrets, KV values, and environment variables in Wrangler configuration.\n\nNote that `\"WORKER_SECRET\"` does not need to be specified in the Wrangler config file, as it is automatically added to `env`.\n\nAlso note that we did not configure anything specific for environment variables, secrets, or KV values in the *container-related* portion of the Wrangler configuration file.\n\n## Using `envVars` on the Container class\n\nNow, let's pass the env vars and secrets to our container using the `envVars` field in the `Container` class:\n\nEvery instance of this `Container` will now have these variables and secrets set as environment variables when it launches.\n\n## Setting environment variables per-instance\n\nBut what if you want to set environment variables on a per-instance basis?\n\nIn this case, use the `startAndWaitForPorts()` method to pass in environment variables for each instance.\n\n## Reading KV values in containers\n\nKV values are particularly useful for configuration data that changes infrequently but needs to be accessible to your containers. Since KV operations are asynchronous, you must read the values at runtime when starting containers.\n\nHere are common patterns for using KV with containers:\n\n### Configuration data\n\n## Build-time environment variables\n\nFinally, you can also set build-time environment variables that are only available when building the container image via the `image_vars` field in the Wrangler configuration.\n\n<page>\n---\ntitle: Mount R2 buckets with FUSE · Cloudflare Containers docs\ndescription: Mount R2 buckets as filesystems using FUSE in Containers\nlastUpdated: 2025-12-10T16:39:46.000Z\nchatbotDeprioritize: false\nsource_url:\n  html: https://developers.cloudflare.com/containers/examples/r2-fuse-mount/\n  md: https://developers.cloudflare.com/containers/examples/r2-fuse-mount/index.md\n---\n\nFUSE (Filesystem in Userspace) allows you to mount [R2 buckets](https://developers.cloudflare.com/r2/) as filesystems within Containers. Applications can then interact with R2 using standard filesystem operations rather than object storage APIs.\n\nCommon use cases include:\n\n* **Bootstrapping containers with assets** - Mount datasets, models, or dependencies for sandboxes and agent environments\n* **Persisting user state** - Store and access user configuration or application state without managing downloads\n* **Large static files** - Avoid bloating container images or downloading files at startup\n* **Editing files** - Make code or config available within the container and save edits across instances.\n\nPerformance considerations\n\nObject storage is not a POSIX-compatible filesystem, nor is it local storage. While FUSE mounts provide a familiar interface, you should not expect native SSD-like performance.\n\nCommon use cases where this tradeoff is acceptable include reading shared assets, bootstrapping [agents](https://developers.cloudflare.com/agents/) or [sandboxes](https://developers.cloudflare.com/sandbox/) with initial data, persisting user state, and applications that require filesystem APIs but don't need high-performance I/O.\n\nTo mount an R2 bucket, install a FUSE adapter in your Dockerfile and configure it to run at container startup.\n\nThis example uses [tigrisfs](https://github.com/tigrisdata/tigrisfs), which supports S3-compatible storage including R2:\n\n```dockerfile\nFROM alpine:3.20",
  "code_samples": [
    {
      "code": "cloudflared tunnel login",
      "language": "sh"
    },
    {
      "code": "cloudflared tunnel create k8s-tunnel",
      "language": "sh"
    },
    {
      "code": "tunnel: <TUNNEL_ID>\n   credentials-file: /path/to/credentials.json\n   ingress:\n     - hostname: k8s.example.com\n       service: tcp://kubernetes.default.svc.cluster.local:443\n     - service: http_status:404",
      "language": "yaml"
    },
    {
      "code": "cloudflared tunnel run k8s-tunnel",
      "language": "sh"
    },
    {
      "code": "#!/bin/bash\n\n\n   echo '{\n     \"apiVersion\": \"client.authentication.k8s.io/v1beta1\",\n     \"kind\": \"ExecCredential\",\n     \"status\": {\n       \"token\": \"'\"$(cloudflared access token -app=https://k8s.example.com)\"'\"\n     }\n   }'",
      "language": "bash"
    },
    {
      "code": "chmod +x cloudflare-k8s-auth.sh",
      "language": "sh"
    },
    {
      "code": "apiVersion: v1\n   kind: Config\n   clusters:\n     - cluster:\n         server: https://k8s.example.com\n       name: cloudflare-k8s\n   users:\n     - name: cloudflare-user\n       user:\n         exec:\n           apiVersion: client.authentication.k8s.io/v1beta1\n           command: /path/to/cloudflare-k8s-auth.sh\n           interactiveMode: Never\n   contexts:\n     - context:\n         cluster: cloudflare-k8s\n         user: cloudflare-user\n       name: cloudflare-k8s-context\n   current-context: cloudflare-k8s-context",
      "language": "yaml"
    },
    {
      "code": "kubectl get pods",
      "language": "sh"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/teamnet/virtual_networks\" \\\n       --request POST \\\n       --header \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\" \\\n       --json '{\n         \"comment\": \"Virtual network to egress from the Americas\",\n         \"is_default\": false,\n         \"name\": \"vnet-AMER\"\n       }'",
      "language": "bash"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/teamnet/routes/$ROUTE_ID\" \\\n       --request PATCH \\\n       --header \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\" \\\n       --json '{\n         \"network\": \"10.0.0.0/8\",\n         \"tunnel_id\": \"<TUNNEL_UUID>\",\n         \"virtual_network_id\": \"<VNET_AMER_UUID>\"\n       }'",
      "language": "bash"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/teamnet/routes/$ROUTE_ID\" \\\n       --request PATCH \\\n       --header \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\" \\\n       --json '{\n         \"network\": \"10.0.0.0/8\",\n         \"tunnel_id\": \"<TUNNEL_UUID>\",\n         \"virtual_network_id\": \"<VNET_EMEA_UUID>\"\n       }'",
      "language": "bash"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/gateway/rules\" \\\n       --request POST \\\n       --header \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\" \\\n       --json '{\n         \"action\": \"egress\",\n         \"description\": \"Egress via North America by connecting to vnet-AMER\",\n         \"enabled\": true,\n         \"filters\": [\n             \"egress\"\n         ],\n         \"name\": \"Egress AMER vnet\",\n         \"precedence\": 0,\n         \"traffic\": \"net.vnet_id == <VNET_AMER_UUID>\",\n         \"rule_settings\": {\n             \"egress\": {\n                 \"ipv4\": \"<DEDICATED_IPV4_ADDRESS>\",\n                 \"ipv4_fallback\": \"<SECONDARY_DEDICATED_IPV6_ADDRESS>\",\n                 \"ipv6\": \"<DEDICATED_IPV6_ADDRESS>\"\n             }\n         }\n       }'",
      "language": "bash"
    },
    {
      "code": "curl ifconfig.me -4",
      "language": "sh"
    },
    {
      "code": "curl \"https://api.cloudflare.com/client/v4/accounts/$ACCOUNT_ID/access/service_tokens\" \\\n       --request POST \\\n       --header \"Authorization: Bearer $CLOUDFLARE_API_TOKEN\" \\\n       --json '{\n         \"name\": \"CI/CD token\",\n         \"duration\": \"8760h\"\n       }'",
      "language": "bash"
    },
    {
      "code": "\"result\": {\n       \"client_id\": \"88bf3b6d86161464f6509f7219099e57.access\",\n       \"client_secret\": \"bdd31cbc4dec990953e39163fbbb194c93313ca9f0a6e420346af9d326b1d2a5\",\n       \"created_at\": \"2025-09-25T22:26:26Z\",\n       \"expires_at\": \"2026-09-25T22:26:26Z\",\n       \"id\": \"3537a672-e4d8-4d89-aab9-26cb622918a1\",\n       \"name\": \"CI/CD token\",\n       \"updated_at\": \"2025-09-25T22:26:26Z\",\n       \"duration\": \"8760h\",\n       \"client_secret_version\": 1\n     }",
      "language": "json"
    },
    {
      "code": "resource \"cloudflare_zero_trust_access_service_token\" \"example_service_token\" {\n       account_id = var.cloudflare_account_id\n       name       = \"Example service token\"\n       duration  = \"8760h\"\n\n\n       lifecycle {\n         create_before_destroy = true\n       }\n     }",
      "language": "tf"
    },
    {
      "code": "output \"example_service_token_client_id\" {\n          value     = cloudflare_zero_trust_access_service_token.example_service_token.client_id\n        }\n\n\n        output \"example_service_token_client_secret\" {\n          value     = cloudflare_zero_trust_access_service_token.example_service_token.client_secret\n          sensitive = true\n        }",
      "language": "tf"
    },
    {
      "code": "terraform apply",
      "language": "sh"
    },
    {
      "code": "terraform output -raw example_service_token_client_id",
      "language": "sh"
    },
    {
      "code": "terraform output -raw example_service_token_client_secret",
      "language": "sh"
    },
    {
      "code": "resource \"vault_generic_secret\" \"example_service_token\" {\n         path         = \"kv/cloudflare/example_service_token\"\n\n\n         data_json = jsonencode({\n           \"CLIENT_ID\"     = cloudflare_access_service_token.example_service_token.client_id\n           \"CLIENT_SECRET\" = cloudflare_access_service_token.example_service_token.client_secret\n         })\n       }",
      "language": "tf"
    },
    {
      "code": "vim install_warp.sh",
      "language": "sh"
    },
    {
      "code": "#!/bin/bash\n   set -e\n\n\n   # Download and install the WARP client\n   function warp() {\n       curl -fsSL https://pkg.cloudflareclient.com/pubkey.gpg | sudo gpg --yes --dearmor --output /usr/share/keyrings/cloudflare-warp-archive-keyring.gpg\n       echo \"deb [signed-by=/usr/share/keyrings/cloudflare-warp-archive-keyring.gpg] https://pkg.cloudflareclient.com/ $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/cloudflare-client.list\n       sudo apt-get update --assume-yes\n       sudo apt-get install --assume-yes cloudflare-warp\n   }\n\n\n   # Create an MDM file with your WARP deployment parameters\n   function mdm() {\n     sudo touch /var/lib/cloudflare-warp/mdm.xml\n     cat > /var/lib/cloudflare-warp/mdm.xml << \"EOF\"\n   <dict>\n       <key>auth_client_id</key>\n       <string>88bf3b6d86161464f6509f7219099e57.access</string>\n       <key>auth_client_secret</key>\n       <string>bdd31cbc4dec990953e39163fbbb194c93313ca9f0a6e420346af9d326b1d2a5</string>\n       <key>auto_connect</key>\n       <integer>1</integer>\n       <key>onboarding</key>\n       <false/>\n       <key>organization</key>\n       <string>your-team-name</string>\n       <key>service_mode</key>\n       <string>warp</string>\n   </dict>\n   EOF\n   }\n\n\n   #main program\n   warp\n   mdm",
      "language": "bash"
    },
    {
      "code": "chmod +x install_warp.sh",
      "language": "sh"
    },
    {
      "code": "sudo ./install_warp.sh",
      "language": "sh"
    },
    {
      "code": "sudo apt-get update\n\n\n   sudo apt-get install gnome-core gnome-panel ubuntu-gnome-desktop tightvncserver",
      "language": "sh"
    },
    {
      "code": "sudo tightvncserver",
      "language": "sh"
    },
    {
      "code": "cd .vnc",
      "language": "sh"
    },
    {
      "code": "vim xstartup",
      "language": "sh"
    },
    {
      "code": "xsetroot -solid grey\n   x-terminal-emulator -geometry 80x24+10+10 -ls -title \"$VNCDESKTOP Desktop\" &\n   #x-window-manager &\n\n\n   # Fix to make GNOME work\n   export XKL_XMODMAP_DISABLE=1\n   /etc/X11/Xsession\n\n\n   #gnome-session &\n   gnome-panel &\n   nautilus &",
      "language": "txt"
    },
    {
      "code": "vncserver",
      "language": "sh"
    },
    {
      "code": "cloudflared tunnel login",
      "language": "sh"
    },
    {
      "code": "cloudflared tunnel create <NAME>",
      "language": "sh"
    },
    {
      "code": "vim config.yml",
      "language": "sh"
    },
    {
      "code": "tunnel: <NAME>\n   ingress:\n   - hostname: vnc.kennyatx.com\n     service: tcp://localhost:5901\n   - service: http_status:404",
      "language": "txt"
    },
    {
      "code": "cloudflared tunnel --config path/config.yaml run <NAME>",
      "language": "sh"
    },
    {
      "code": "{\n    \"name\": \"cron-container\",\n    \"main\": \"src/index.ts\",\n    \"triggers\": {\n      \"crons\": [\n        \"*/2 * * * *\" // Run every 2 minutes\n      ]\n    },\n    \"containers\": [\n      {\n        \"class_name\": \"CronContainer\",\n        \"image\": \"./Dockerfile\"\n      }\n    ],\n    \"durable_objects\": {\n      \"bindings\": [\n        {\n          \"class_name\": \"CronContainer\",\n          \"name\": \"CRON_CONTAINER\"\n        }\n      ]\n    },\n    \"migrations\": [\n      {\n        \"new_sqlite_classes\": [\"CronContainer\"],\n        \"tag\": \"v1\"\n      }\n    ]\n  }",
      "language": "jsonc"
    },
    {
      "code": "name = \"cron-container\"\n  main = \"src/index.ts\"\n\n\n  [triggers]\n  crons = [ \"*/2 * * * *\" ]\n\n\n  [[containers]]\n  class_name = \"CronContainer\"\n  image = \"./Dockerfile\"\n\n\n  [[durable_objects.bindings]]\n  class_name = \"CronContainer\"\n  name = \"CRON_CONTAINER\"\n\n\n  [[migrations]]\n  new_sqlite_classes = [ \"CronContainer\" ]\n  tag = \"v1\"",
      "language": "toml"
    },
    {
      "code": "import { Container, getContainer } from '@cloudflare/containers';\n\n\nexport class CronContainer extends Container {\n  sleepAfter = '10s';\n\n\n  override onStart() {\n    console.log('Starting container');\n  }\n\n\n  override onStop() {\n    console.log('Container stopped');\n  }\n}\n\n\nexport default {\n  async fetch(): Promise<Response> {\n    return new Response(\"This Worker runs a cron job to execute a container on a schedule.\");\n  },\n\n\n  async scheduled(_controller: any, env: { CRON_CONTAINER: DurableObjectNamespace<CronContainer> }) {\n    let container = getContainer(env.CRON_CONTAINER);\n    await container.start({\n      envVars: {\n        MESSAGE: \"Start Time: \" + new Date().toISOString(),\n      }\n    })\n  },\n};",
      "language": "ts"
    },
    {
      "code": "{\n    \"name\": \"cron-container\",\n    \"main\": \"src/index.ts\",\n    \"assets\": {\n      \"directory\": \"./dist\",\n      \"binding\": \"ASSETS\"\n    },\n    \"containers\": [\n      {\n        \"class_name\": \"Backend\",\n        \"image\": \"./Dockerfile\",\n        \"max_instances\": 3\n      }\n    ],\n    \"durable_objects\": {\n      \"bindings\": [\n        {\n          \"class_name\": \"Backend\",\n          \"name\": \"BACKEND\"\n        }\n      ]\n    },\n    \"migrations\": [\n      {\n        \"new_sqlite_classes\": [\n          \"Backend\"\n        ],\n        \"tag\": \"v1\"\n      }\n    ]\n  }",
      "language": "jsonc"
    },
    {
      "code": "name = \"cron-container\"\n  main = \"src/index.ts\"\n\n\n  [assets]\n  directory = \"./dist\"\n  binding = \"ASSETS\"\n\n\n  [[containers]]\n  class_name = \"Backend\"\n  image = \"./Dockerfile\"\n  max_instances = 3\n\n\n  [[durable_objects.bindings]]\n  class_name = \"Backend\"\n  name = \"BACKEND\"\n\n\n  [[migrations]]\n  new_sqlite_classes = [ \"Backend\" ]\n  tag = \"v1\"",
      "language": "toml"
    },
    {
      "code": "<!DOCTYPE html>\n<html lang=\"en\">\n\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Widgets</title>\n  <script defer src=\"https://cdnjs.cloudflare.com/ajax/libs/alpinejs/3.13.3/cdn.min.js\"></script>\n</head>\n\n\n<body>\n  <div x-data=\"widgets()\" x-init=\"fetchWidgets()\">\n    <h1>Widgets</h1>\n    <div x-show=\"loading\">Loading...</div>\n    <div x-show=\"error\" x-text=\"error\" style=\"color: red;\"></div>\n    <ul x-show=\"!loading && !error\">\n      <template x-for=\"widget in widgets\" :key=\"widget.id\">\n        <li>\n          <span x-text=\"widget.name\"></span> - (ID: <span x-text=\"widget.id\"></span>)\n        </li>\n      </template>\n    </ul>\n\n\n    <div x-show=\"!loading && !error && widgets.length === 0\">\n      No widgets found.\n    </div>\n\n\n  </div>\n\n\n  <script>\n    function widgets() {\n      return {\n        widgets: [],\n        loading: false,\n        error: null,\n\n\n        async fetchWidgets() {\n          this.loading = true;\n          this.error = null;\n\n\n          try {\n            const response = await fetch('/api/widgets');\n            if (!response.ok) {\n              throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n            }\n            this.widgets = await response.json();\n          } catch (err) {\n            this.error = err.message;\n          } finally {\n            this.loading = false;\n          }\n        }\n      }\n    }\n  </script>\n\n\n</body>\n\n\n</html>",
      "language": "html"
    },
    {
      "code": "import { Container, getRandom } from \"@cloudflare/containers\";\n\n\nconst INSTANCE_COUNT = 3;\n\n\nclass Backend extends Container {\n  defaultPort = 8080; // pass requests to port 8080 in the container\n  sleepAfter = \"2h\"; // only sleep a container if it hasn't gotten requests in 2 hours\n}\n\n\nexport default {\n  async fetch(request, env) {\n    const url = new URL(request.url);\n    if (url.pathname.startsWith(\"/api\")) {\n      // note: \"getRandom\" to be replaced with latency-aware routing in the near future\n      const containerInstance = await getRandom(env.BACKEND, INSTANCE_COUNT);\n      return containerInstance.fetch(request);\n    }\n\n\n    return env.ASSETS.fetch(request);\n  },\n};",
      "language": "javascript"
    },
    {
      "code": "package main\n\n\nimport (\n  \"encoding/json\"\n  \"log\"\n  \"net/http\"\n)\n\n\nfunc handler(w http.ResponseWriter, r \\*http.Request) {\n  widgets := []map[string]interface{}{\n    {\"id\": 1, \"name\": \"Widget A\"},\n    {\"id\": 2, \"name\": \"Sprocket B\"},\n    {\"id\": 3, \"name\": \"Gear C\"},\n  }\n\n\n  w.Header().Set(\"Content-Type\", \"application/json\")\n  w.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n  json.NewEncoder(w).Encode(widgets)\n\n\n}\n\n\nfunc main() {\n  http.HandleFunc(\"/api/widgets\", handler)\n  log.Fatal(http.ListenAndServe(\":8080\", nil))\n}",
      "language": "go"
    },
    {
      "code": "npx wrangler secret put WORKER_SECRET",
      "language": "sh"
    },
    {
      "code": "yarn wrangler secret put WORKER_SECRET",
      "language": "sh"
    },
    {
      "code": "pnpm wrangler secret put WORKER_SECRET",
      "language": "sh"
    },
    {
      "code": "npx wrangler secrets-store store create demo --remote",
      "language": "sh"
    },
    {
      "code": "yarn wrangler secrets-store store create demo --remote",
      "language": "sh"
    },
    {
      "code": "pnpm wrangler secrets-store store create demo --remote",
      "language": "sh"
    },
    {
      "code": "npx wrangler secrets-store secret create demo --name SECRET_STORE_SECRET --scopes workers --remote",
      "language": "sh"
    },
    {
      "code": "yarn wrangler secrets-store secret create demo --name SECRET_STORE_SECRET --scopes workers --remote",
      "language": "sh"
    },
    {
      "code": "pnpm wrangler secrets-store secret create demo --name SECRET_STORE_SECRET --scopes workers --remote",
      "language": "sh"
    },
    {
      "code": "npx wrangler kv namespace create DEMO_KV",
      "language": "sh"
    },
    {
      "code": "yarn wrangler kv namespace create DEMO_KV",
      "language": "sh"
    },
    {
      "code": "pnpm wrangler kv namespace create DEMO_KV",
      "language": "sh"
    },
    {
      "code": "npx wrangler kv key put --binding DEMO_KV KV_VALUE 'Hello from KV!'",
      "language": "sh"
    },
    {
      "code": "yarn wrangler kv key put --binding DEMO_KV KV_VALUE 'Hello from KV!'",
      "language": "sh"
    },
    {
      "code": "pnpm wrangler kv key put --binding DEMO_KV KV_VALUE 'Hello from KV!'",
      "language": "sh"
    },
    {
      "code": "{\n    \"name\": \"my-container-worker\",\n    \"vars\": {\n      \"ENV_VAR\": \"my-env-var\"\n    },\n    \"secrets_store_secrets\": [\n      {\n        \"binding\": \"SECRET_STORE\",\n        \"store_id\": \"demo\",\n        \"secret_name\": \"SECRET_STORE_SECRET\"\n      }\n    ],\n    \"kv_namespaces\": [\n      {\n        \"binding\": \"DEMO_KV\",\n        \"id\": \"<your-kv-namespace-id>\"\n      }\n    ]\n    // rest of the configuration...\n  }",
      "language": "jsonc"
    },
    {
      "code": "name = \"my-container-worker\"\n\n\n  [vars]\n  ENV_VAR = \"my-env-var\"\n\n\n  [[secrets_store_secrets]]\n  binding = \"SECRET_STORE\"\n  store_id = \"demo\"\n  secret_name = \"SECRET_STORE_SECRET\"\n\n\n  [[kv_namespaces]]\n  binding = \"DEMO_KV\"\n  id = \"<your-kv-namespace-id>\"",
      "language": "toml"
    },
    {
      "code": "// https://developers.cloudflare.com/workers/runtime-apis/bindings/#importing-env-as-a-global\nimport { env } from \"cloudflare:workers\";\nexport class MyContainer extends Container {\n  defaultPort = 8080;\n  sleepAfter = \"10s\";\n  envVars = {\n    WORKER_SECRET: env.WORKER_SECRET,\n    ENV_VAR: env.ENV_VAR,\n    // we can't set the secret store binding or KV values as defaults here, as getting their values is asynchronous\n  };\n}",
      "language": "js"
    },
    {
      "code": "export class MyContainer extends Container {\n  defaultPort = 8080;\n  sleepAfter = \"10s\";\n}\n\n\nexport default {\n  async fetch(request, env) {\n    if (new URL(request.url).pathname === \"/launch-instances\") {\n      let instanceOne = env.MY_CONTAINER.getByName(\"foo\");\n      let instanceTwo = env.MY_CONTAINER.getByName(\"bar\");\n\n\n      // Each instance gets a different set of environment variables\n\n\n      await instanceOne.startAndWaitForPorts({\n        startOptions: {\n          envVars: {\n            ENV_VAR: env.ENV_VAR + \"foo\",\n            WORKER_SECRET: env.WORKER_SECRET,\n            SECRET_STORE_SECRET: await env.SECRET_STORE.get(),\n            KV_VALUE: await env.DEMO_KV.get(\"KV_VALUE\"),\n          },\n        },\n      });\n\n\n      await instanceTwo.startAndWaitForPorts({\n        startOptions: {\n          envVars: {\n            ENV_VAR: env.ENV_VAR + \"bar\",\n            WORKER_SECRET: env.WORKER_SECRET,\n            SECRET_STORE_SECRET: await env.SECRET_STORE.get(),\n            KV_VALUE: await env.DEMO_KV.get(\"KV_VALUE\"),\n            // You can also read different KV keys for different instances\n            INSTANCE_CONFIG: await env.DEMO_KV.get(\"instance-bar-config\"),\n          },\n        },\n      });\n      return new Response(\"Container instances launched\");\n    }\n\n\n    // ... etc ...\n  },\n};",
      "language": "js"
    },
    {
      "code": "export default {\n  async fetch(request, env) {\n    if (new URL(request.url).pathname === \"/configure-container\") {\n      // Read configuration from KV\n      const config = await env.DEMO_KV.get(\"container-config\", \"json\");\n      const apiUrl = await env.DEMO_KV.get(\"api-endpoint\");\n\n\n      let container = env.MY_CONTAINER.getByName(\"configured\");\n\n\n      await container.startAndWaitForPorts({\n        startOptions: {\n          envVars: {\n            CONFIG_JSON: JSON.stringify(config),\n            API_ENDPOINT: apiUrl,\n            DEPLOYMENT_ENV: await env.DEMO_KV.get(\"deployment-env\"),\n          },\n        },\n      });\n\n\n      return new Response(\"Container configured and launched\");\n    }\n  },\n};",
      "language": "js"
    },
    {
      "code": "export default {\n  async fetch(request, env) {\n    if (new URL(request.url).pathname === \"/launch-with-features\") {\n      // Read feature flags from KV\n      const featureFlags = {\n        ENABLE_FEATURE_A: await env.DEMO_KV.get(\"feature-a-enabled\"),\n        ENABLE_FEATURE_B: await env.DEMO_KV.get(\"feature-b-enabled\"),\n        DEBUG_MODE: await env.DEMO_KV.get(\"debug-enabled\"),\n      };\n\n\n      let container = env.MY_CONTAINER.getByName(\"features\");\n\n\n      await container.startAndWaitForPorts({\n        startOptions: {\n          envVars: {\n            ...featureFlags,\n            CONTAINER_VERSION: \"1.2.3\",\n          },\n        },\n      });\n\n\n      return new Response(\"Container launched with feature flags\");\n    }\n  },\n};",
      "language": "js"
    }
  ],
  "headings": [
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Set up a Cloudflare Tunnel",
      "id": "1.-set-up-a-cloudflare-tunnel"
    },
    {
      "level": "h2",
      "text": "2. Configure the Kubernetes API server",
      "id": "2.-configure-the-kubernetes-api-server"
    },
    {
      "level": "h2",
      "text": "3. Set up client-go credential plugin",
      "id": "3.-set-up-client-go-credential-plugin"
    },
    {
      "level": "h2",
      "text": "4. Use kubectl with Cloudflare Tunnel",
      "id": "4.-use-kubectl-with-cloudflare-tunnel"
    },
    {
      "level": "h2",
      "text": "Troubleshooting",
      "id": "troubleshooting"
    },
    {
      "level": "h2",
      "text": "Before you begin",
      "id": "before-you-begin"
    },
    {
      "level": "h2",
      "text": "Create a virtual network for each egress route",
      "id": "create-a-virtual-network-for-each-egress-route"
    },
    {
      "level": "h2",
      "text": "Assign each virtual network to each tunnel",
      "id": "assign-each-virtual-network-to-each-tunnel"
    },
    {
      "level": "h2",
      "text": "Create virtual network egress policies",
      "id": "create-virtual-network-egress-policies"
    },
    {
      "level": "h2",
      "text": "Test virtual network egress",
      "id": "test-virtual-network-egress"
    },
    {
      "level": "h2",
      "text": "Prerequisites",
      "id": "prerequisites"
    },
    {
      "level": "h2",
      "text": "1. Create a service token",
      "id": "1.-create-a-service-token"
    },
    {
      "level": "h2",
      "text": "2. Configure device enrollment permissions",
      "id": "2.-configure-device-enrollment-permissions"
    },
    {
      "level": "h2",
      "text": "3. Create an installation script",
      "id": "3.-create-an-installation-script"
    },
    {
      "level": "h2",
      "text": "4. Install WARP",
      "id": "4.-install-warp"
    },
    {
      "level": "h2",
      "text": "Before you start",
      "id": "before-you-start"
    },
    {
      "level": "h2",
      "text": "Configure VNC on your virtual machine",
      "id": "configure-vnc-on-your-virtual-machine"
    },
    {
      "level": "h2",
      "text": "Configure Cloudflare Tunnel on your machine",
      "id": "configure-cloudflare-tunnel-on-your-machine"
    },
    {
      "level": "h2",
      "text": "Create a Cloudflare Access VNC application",
      "id": "create-a-cloudflare-access-vnc-application"
    },
    {
      "level": "h2",
      "text": "Configure Static Assets and a Container",
      "id": "configure-static-assets-and-a-container"
    },
    {
      "level": "h2",
      "text": "Add a simple index.html file to serve",
      "id": "add-a-simple-index.html-file-to-serve"
    },
    {
      "level": "h2",
      "text": "Define a Worker",
      "id": "define-a-worker"
    },
    {
      "level": "h2",
      "text": "Define a backend container",
      "id": "define-a-backend-container"
    },
    {
      "level": "h2",
      "text": "Creating secrets and KV data",
      "id": "creating-secrets-and-kv-data"
    },
    {
      "level": "h2",
      "text": "Adding bindings",
      "id": "adding-bindings"
    },
    {
      "level": "h2",
      "text": "Using `envVars` on the Container class",
      "id": "using-`envvars`-on-the-container-class"
    },
    {
      "level": "h2",
      "text": "Setting environment variables per-instance",
      "id": "setting-environment-variables-per-instance"
    },
    {
      "level": "h2",
      "text": "Reading KV values in containers",
      "id": "reading-kv-values-in-containers"
    },
    {
      "level": "h3",
      "text": "Configuration data",
      "id": "configuration-data"
    },
    {
      "level": "h3",
      "text": "Feature flags",
      "id": "feature-flags"
    },
    {
      "level": "h2",
      "text": "Build-time environment variables",
      "id": "build-time-environment-variables"
    },
    {
      "level": "h2",
      "text": "Mounting buckets",
      "id": "mounting-buckets"
    }
  ],
  "url": "llms-txt#use-cloudflare-tunnels-with-kubernetes-client-go-credential-plugins",
  "links": []
}